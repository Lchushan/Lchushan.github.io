(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var r,i,s=e[0],l=e[1],c=e[2],d=0,h=[];d<s.length;d++)i=s[d],Object.prototype.hasOwnProperty.call(a,i)&&a[i]&&h.push(a[i][0]),a[i]=0;for(r in l)Object.prototype.hasOwnProperty.call(l,r)&&(n[r]=l[r]);for(m&&m(e);h.length;)h.shift()();return o.push.apply(o,c||[]),t()}function t(){for(var n,e=0;e<o.length;e++){for(var t=o[e],r=!0,s=1;s<t.length;s++){var l=t[s];0!==a[l]&&(r=!1)}r&&(o.splice(e--,1),n=i(i.s=t[0]))}return n}var r={},a={1:0},o=[];function i(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,i),t.l=!0,t.exports}i.e=function(n){var e=[],t=a[n];if(0!==t)if(t)e.push(t[2]);else{var r=new Promise((function(e,r){t=a[n]=[e,r]}));e.push(t[2]=r);var o,s=document.createElement("script");s.charset="utf-8",s.timeout=120,i.nc&&s.setAttribute("nonce",i.nc),s.src=function(n){return i.p+"assets/js/"+({}[n]||n)+"."+{2:"f7dde802",3:"7f8ab6bd",4:"591798d0",5:"ae5a8b30",6:"c6d5d1da",7:"39a2feef",8:"6aa44381",9:"ab9a5c08",10:"12b4bf37",11:"986ec194",12:"127689ae",13:"528417d2",14:"ccd1b44f",15:"df2ae387",16:"7bbe874c",17:"4b65eca3",18:"b4f5604c",19:"ada119ee",20:"d063279a",21:"d15b3ac7",22:"5185a1a5",23:"91b5f7c4",24:"545bc1fb",25:"ce0688e9",26:"14f7ddb2",27:"1d380883",28:"84fd7342",29:"977a10c6",30:"e27d5c6c",31:"fef44b40",32:"3cde5ab7",33:"2fd0f2f0",34:"6174b407",35:"3457d0d3",36:"c672256a",37:"c5336199",38:"f878aa15",39:"7272608e",40:"1f5087ab",41:"d8defd1f",42:"4decf61e",43:"1f54a9fb",44:"05628c46",45:"b64569a4",46:"3e758616",47:"754e4534",48:"d7707287",49:"c62b8419",50:"60fbaa68",51:"812c8fc9",52:"bae4e31b",53:"bdcc492b",54:"c9eece36",55:"bec15e04",56:"3e4a4b07",57:"300f3929",58:"9b3bc2f8",59:"b4f2f65a",60:"6da1c705",61:"0f431e1e",62:"ca980bdb",63:"b1d0e0d0",64:"a5dc88b1",65:"2134e59f",66:"2ce26325",67:"be6c5ba6",68:"5ee46489",69:"817ef5b5",70:"bd026d5e",71:"94cd51c9",72:"2852256c",73:"ff13867e",74:"d43a4484",75:"8a138783",76:"75869419",77:"85ccf9b3",78:"d1f93c97",79:"476c7345",80:"75df788e",81:"8dabfdfb",82:"b373d124",83:"543e5130",84:"551d04d7",85:"21a99aad"}[n]+".js"}(n);var l=new Error;o=function(e){s.onerror=s.onload=null,clearTimeout(c);var t=a[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),o=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+r+": "+o+")",l.name="ChunkLoadError",l.type=r,l.request=o,t[1](l)}a[n]=void 0}};var c=setTimeout((function(){o({type:"timeout",target:s})}),12e4);s.onerror=s.onload=o,document.head.appendChild(s)}return Promise.all(e)},i.m=n,i.c=r,i.d=function(n,e,t){i.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},i.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},i.t=function(n,e){if(1&e&&(n=i(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(i.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)i.d(t,r,function(e){return n[e]}.bind(null,r));return t},i.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return i.d(e,"a",e),e},i.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},i.p="/",i.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var c=0;c<s.length;c++)e(s[c]);var m=l;o.push([100,0]),t()}([function(n,e,t){var r=t(52),a=r.all;n.exports=r.IS_HTMLDDA?function(n){return"function"==typeof n||n===a}:function(n){return"function"==typeof n}},function(n,e,t){var r=t(25),a=Function.prototype,o=a.call,i=r&&a.bind.bind(o,o);n.exports=r?i:function(n){return function(){return o.apply(n,arguments)}}},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||this||Function("return this")()},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){var r=t(3);n.exports=!r((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var r=t(66),a="object"==typeof self&&self&&self.Object===Object&&self,o=r||a||Function("return this")();n.exports=o},function(n,e,t){var r=t(1),a=t(30),o=r({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return o(a(n),e)}},function(n,e,t){var r=t(0),a=t(52),o=a.all;n.exports=a.IS_HTMLDDA?function(n){return"object"==typeof n?null!==n:r(n)||n===o}:function(n){return"object"==typeof n?null!==n:r(n)}},function(n,e,t){var r=t(158),a=t(161);n.exports=function(n,e){var t=a(n,e);return r(t)?t:void 0}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var r=t(13),a=t(143),o=t(144),i=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":i&&i in Object(n)?a(n):o(n)}},function(n,e,t){var r=t(4),a=t(15),o=t(33);n.exports=r?function(n,e,t){return a.f(n,e,o(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var r=t(6).Symbol;n.exports=r},function(n,e,t){"use strict";function r(n,e,t,r,a,o,i,s){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),r&&(c.functional=!0),o&&(c._scopeId="data-v-"+o),i?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),a&&a.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(i)},c._ssrRegister=l):a&&(l=s?function(){a.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:a),l)if(c.functional){c._injectStyles=l;var m=c.render;c.render=function(n,e){return l.call(e),m(n,e)}}else{var d=c.beforeCreate;c.beforeCreate=d?[].concat(d,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return r}))},function(n,e,t){var r=t(4),a=t(61),o=t(95),i=t(23),s=t(51),l=TypeError,c=Object.defineProperty,m=Object.getOwnPropertyDescriptor;e.f=r?o?function(n,e,t){if(i(n),e=s(e),i(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var r=m(n,e);r&&r.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:r.configurable,enumerable:"enumerable"in t?t.enumerable:r.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(i(n),e=s(e),i(t),a)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var r=t(1),a=r({}.toString),o=r("".slice);n.exports=function(n){return o(a(n),8,-1)}},function(n,e,t){var r=t(148),a=t(149),o=t(150),i=t(151),s=t(152);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=o,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(68);n.exports=function(n,e){for(var t=n.length;t--;)if(r(n[t][0],e))return t;return-1}},function(n,e,t){var r=t(9)(Object,"create");n.exports=r},function(n,e,t){var r=t(170);n.exports=function(n,e){var t=n.__data__;return r(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var r=t(43);n.exports=function(n){if("string"==typeof n||r(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var r,a;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(a="function"==typeof(r=function(){var n,e,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function a(n,e,t){return n<e?e:n>t?t:n}function o(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(r[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=a(n,r.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(r.barSelector),m=r.speed,d=r.easing;return l.offsetWidth,i((function(e){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),s(c,function(n,e,t){var a;return(a="translate3d"===r.positionUsing?{transform:"translate3d("+o(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+o(n)+"%,0)"}:{"margin-left":o(n)+"%"}).transition="all "+e+"ms "+t,a}(n,m,d)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+m+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),m)}),m)):setTimeout(e,m)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*a(Math.random()*e,.1,.95)),e=a(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},n=0,e=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===e&&t.start(),n++,e++,r.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=r.template;var a,i=e.querySelector(r.barSelector),l=n?"-100":o(t.status||0),m=document.querySelector(r.parent);return s(i,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),r.showSpinner||(a=e.querySelector(r.spinnerSelector))&&h(a),m!=document.body&&c(m,"nprogress-custom-parent"),m.appendChild(e),e},t.remove=function(){m(document.documentElement,"nprogress-busy"),m(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&h(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var i=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var r,a=n.length,o=e.charAt(0).toUpperCase()+e.slice(1);a--;)if((r=n[a]+o)in t)return r;return e}(t))}function r(n,e,r){e=t(e),n.style[e]=r}return function(n,e){var t,a,o=arguments;if(2==o.length)for(t in e)void 0!==(a=e[t])&&e.hasOwnProperty(t)&&r(n,t,a);else r(n,o[1],o[2])}}();function l(n,e){return("string"==typeof n?n:d(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=d(n),r=t+e;l(t,e)||(n.className=r.substring(1))}function m(n,e){var t,r=d(n);l(n,e)&&(t=r.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function d(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function h(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?r.call(e,t,e,n):r)||(n.exports=a)},function(n,e,t){var r=t(8),a=String,o=TypeError;n.exports=function(n){if(r(n))return n;throw o(a(n)+" is not an object")}},function(n,e,t){var r=t(2),a=t(48).f,o=t(12),i=t(91),s=t(35),l=t(62),c=t(119);n.exports=function(n,e){var t,m,d,h,p,u=n.target,f=n.global,y=n.stat;if(t=f?r:y?r[u]||s(u,{}):(r[u]||{}).prototype)for(m in e){if(h=e[m],d=n.dontCallGetSet?(p=a(t,m))&&p.value:t[m],!c(f?m:u+(y?".":"#")+m,n.forced)&&void 0!==d){if(typeof h==typeof d)continue;l(h,d)}(n.sham||d&&d.sham)&&o(h,"sham",!0),i(t,m,h,n)}}},function(n,e,t){var r=t(3);n.exports=!r((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var r=t(45),a=t(49);n.exports=function(n){return r(a(n))}},function(n,e,t){var r=t(2),a=t(0),o=function(n){return a(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?o(r[n]):r[n]&&r[n][e]}},function(n,e,t){var r=t(0),a=t(106),o=TypeError;n.exports=function(n){if(r(n))return n;throw o(a(n)+" is not a function")}},function(n,e,t){var r=t(2),a=t(58),o=t(7),i=t(60),s=t(56),l=t(55),c=r.Symbol,m=a("wks"),d=l?c.for||c:c&&c.withoutSetter||i;n.exports=function(n){return o(m,n)||(m[n]=s&&o(c,n)?c[n]:d("Symbol."+n)),m[n]}},function(n,e,t){var r=t(49),a=Object;n.exports=function(n){return a(r(n))}},function(n,e,t){var r=t(117);n.exports=function(n){return r(n.length)}},function(n,e,t){var r=t(25),a=Function.prototype.call;n.exports=r?a.bind(a):function(){return a.apply(a,arguments)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var r=t(2),a=t(35),o=r["__core-js_shared__"]||a("__core-js_shared__",{});n.exports=o},function(n,e,t){var r=t(2),a=Object.defineProperty;n.exports=function(n,e){try{a(r,n,{value:e,configurable:!0,writable:!0})}catch(t){r[n]=e}return e}},function(n,e,t){var r=t(142),a=t(10),o=Object.prototype,i=o.hasOwnProperty,s=o.propertyIsEnumerable,l=r(function(){return arguments}())?r:function(n){return a(n)&&i.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var r=t(9)(t(6),"Map");n.exports=r},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var r=t(162),a=t(169),o=t(171),i=t(172),s=t(173);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=o,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var r=t(5),a=t(43),o=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,i=/^\w*$/;n.exports=function(n,e){if(r(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!a(n))||(i.test(n)||!o.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var r=t(11),a=t(10);n.exports=function(n){return"symbol"==typeof n||a(n)&&"[object Symbol]"==r(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){var r=t(1),a=t(3),o=t(16),i=Object,s=r("".split);n.exports=a((function(){return!i("z").propertyIsEnumerable(0)}))?function(n){return"String"==o(n)?s(n,""):i(n)}:i},function(n,e){n.exports={}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e,t){var r=t(4),a=t(32),o=t(102),i=t(33),s=t(26),l=t(51),c=t(7),m=t(61),d=Object.getOwnPropertyDescriptor;e.f=r?d:function(n,e){if(n=s(n),e=l(e),m)try{return d(n,e)}catch(n){}if(c(n,e))return i(!a(o.f,n,e),n[e])}},function(n,e,t){var r=t(50),a=TypeError;n.exports=function(n){if(r(n))throw a("Can't call method on "+n);return n}},function(n,e){n.exports=function(n){return null==n}},function(n,e,t){var r=t(103),a=t(53);n.exports=function(n){var e=r(n,"string");return a(e)?e:e+""}},function(n,e){var t="object"==typeof document&&document.all,r=void 0===t&&void 0!==t;n.exports={all:t,IS_HTMLDDA:r}},function(n,e,t){var r=t(27),a=t(0),o=t(54),i=t(55),s=Object;n.exports=i?function(n){return"symbol"==typeof n}:function(n){var e=r("Symbol");return a(e)&&o(e.prototype,s(n))}},function(n,e,t){var r=t(1);n.exports=r({}.isPrototypeOf)},function(n,e,t){var r=t(56);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var r=t(57),a=t(3),o=t(2).String;n.exports=!!Object.getOwnPropertySymbols&&!a((function(){var n=Symbol();return!o(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(n,e,t){var r,a,o=t(2),i=t(104),s=o.process,l=o.Deno,c=s&&s.versions||l&&l.version,m=c&&c.v8;m&&(a=(r=m.split("."))[0]>0&&r[0]<4?1:+(r[0]+r[1])),!a&&i&&(!(r=i.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=i.match(/Chrome\/(\d+)/))&&(a=+r[1]),n.exports=a},function(n,e,t){var r=t(59),a=t(34);(n.exports=function(n,e){return a[n]||(a[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.31.1",mode:r?"pure":"global",copyright:"© 2014-2023 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.31.1/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e){n.exports=!1},function(n,e,t){var r=t(1),a=0,o=Math.random(),i=r(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+i(++a+o,36)}},function(n,e,t){var r=t(4),a=t(3),o=t(94);n.exports=!r&&!a((function(){return 7!=Object.defineProperty(o("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var r=t(7),a=t(112),o=t(48),i=t(15);n.exports=function(n,e,t){for(var s=a(e),l=i.f,c=o.f,m=0;m<s.length;m++){var d=s[m];r(n,d)||t&&r(t,d)||l(n,d,c(e,d))}}},function(n,e,t){var r=t(116);n.exports=function(n){var e=+n;return e!=e||0===e?0:r(e)}},function(n,e,t){var r=t(129),a=t(23),o=t(130);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=r(Object.prototype,"__proto__","set"))(t,[]),e=t instanceof Array}catch(n){}return function(t,r){return a(t),o(r),e?n(t,r):t.__proto__=r,t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,r=e.length,a=n.length;++t<r;)n[a+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var r=t(17),a=t(153),o=t(154),i=t(155),s=t(156),l=t(157);function c(n){var e=this.__data__=new r(n);this.size=e.size}c.prototype.clear=a,c.prototype.delete=o,c.prototype.get=i,c.prototype.has=s,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var r=t(11),a=t(38);n.exports=function(n){if(!a(n))return!1;var e=r(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var r=t(174),a=t(10);n.exports=function n(e,t,o,i,s){return e===t||(null==e||null==t||!a(e)&&!a(t)?e!=e&&t!=t:r(e,t,o,i,n,s))}},function(n,e,t){var r=t(73),a=t(177),o=t(74);n.exports=function(n,e,t,i,s,l){var c=1&t,m=n.length,d=e.length;if(m!=d&&!(c&&d>m))return!1;var h=l.get(n),p=l.get(e);if(h&&p)return h==e&&p==n;var u=-1,f=!0,y=2&t?new r:void 0;for(l.set(n,e),l.set(e,n);++u<m;){var g=n[u],v=e[u];if(i)var b=c?i(v,g,u,e,n,l):i(g,v,u,n,e,l);if(void 0!==b){if(b)continue;f=!1;break}if(y){if(!a(e,(function(n,e){if(!o(y,e)&&(g===n||s(g,n,t,i,l)))return y.push(e)}))){f=!1;break}}else if(g!==v&&!s(g,v,t,i,l)){f=!1;break}}return l.delete(n),l.delete(e),f}},function(n,e,t){var r=t(39),a=t(175),o=t(176);function i(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new r;++e<t;)this.add(n[e])}i.prototype.add=i.prototype.push=a,i.prototype.has=o,n.exports=i},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var r=t(187),a=t(193),o=t(79);n.exports=function(n){return o(n)?r(n):a(n)}},function(n,e,t){(function(n){var r=t(6),a=t(189),o=e&&!e.nodeType&&e,i=o&&"object"==typeof n&&n&&!n.nodeType&&n,s=i&&i.exports===o?r.Buffer:void 0,l=(s?s.isBuffer:void 0)||a;n.exports=l}).call(this,t(47)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var r=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==r||"symbol"!=r&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var r=t(190),a=t(191),o=t(192),i=o&&o.isTypedArray,s=i?a(i):r;n.exports=s},function(n,e,t){var r=t(69),a=t(41);n.exports=function(n){return null!=n&&a(n.length)&&!r(n)}},function(n,e,t){var r=t(9)(t(6),"Set");n.exports=r},function(n,e,t){var r=t(38);n.exports=function(n){return n==n&&!r(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var r=t(84),a=t(21);n.exports=function(n,e){for(var t=0,o=(e=r(e,n)).length;null!=n&&t<o;)n=n[a(e[t++])];return t&&t==o?n:void 0}},function(n,e,t){var r=t(5),a=t(42),o=t(204),i=t(207);n.exports=function(n,e){return r(n)?n:a(n,e)?[n]:o(i(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(140),a=t(145),o=t(216),i=t(224),s=t(233),l=t(99),c=o((function(n){var e=l(n);return s(e)&&(e=void 0),i(r(n,1,s,!0),a(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var r=/["'&<>]/;n.exports=function(n){var e,t=""+n,a=r.exec(t);if(!a)return t;var o="",i=0,s=0;for(i=a.index;i<t.length;i++){switch(t.charCodeAt(i)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}s!==i&&(o+=t.substring(s,i)),s=i+1,o+=e}return s!==i?o+t.substring(s,i):o}},function(n,e){var t=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,a=/^0b[01]+$/i,o=/^0o[0-7]+$/i,i=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=s||l||Function("return this")(),m=Object.prototype.toString,d=Math.max,h=Math.min,p=function(){return c.Date.now()};function u(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function f(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==m.call(n)}(n))return NaN;if(u(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=u(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=a.test(n);return s||o.test(n)?i(n.slice(2),s?2:8):r.test(n)?NaN:+n}n.exports=function(n,e,t){var r,a,o,i,s,l,c=0,m=!1,y=!1,g=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function v(e){var t=r,o=a;return r=a=void 0,c=e,i=n.apply(o,t)}function b(n){return c=n,s=setTimeout(x,e),m?v(n):i}function w(n){var t=n-l;return void 0===l||t>=e||t<0||y&&n-c>=o}function x(){var n=p();if(w(n))return E(n);s=setTimeout(x,function(n){var t=e-(n-l);return y?h(t,o-(n-c)):t}(n))}function E(n){return s=void 0,g&&r?v(n):(r=a=void 0,i)}function k(){var n=p(),t=w(n);if(r=arguments,a=this,l=n,t){if(void 0===s)return b(l);if(y)return s=setTimeout(x,e),v(l)}return void 0===s&&(s=setTimeout(x,e)),i}return e=f(e)||0,u(t)&&(m=!!t.leading,o=(y="maxWait"in t)?d(f(t.maxWait)||0,e):o,g="trailing"in t?!!t.trailing:g),k.cancel=function(){void 0!==s&&clearTimeout(s),c=0,r=l=a=s=void 0},k.flush=function(){return void 0===s?i:E(p())},k}},function(n,e,t){"use strict";var r=t(24),a=t(30),o=t(31),i=t(123),s=t(125);r({target:"Array",proto:!0,arity:1,forced:t(3)((function(){return 4294967297!==[].push.call({length:4294967296},1)}))||!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}()},{push:function(n){var e=a(this),t=o(e),r=arguments.length;s(t+r);for(var l=0;l<r;l++)e[t]=arguments[l],t++;return i(e,t),t}})},function(n,e,t){var r=t(0),a=t(15),o=t(96),i=t(35);n.exports=function(n,e,t,s){s||(s={});var l=s.enumerable,c=void 0!==s.name?s.name:e;if(r(t)&&o(t,c,s),s.global)l?n[e]=t:i(e,t);else{try{s.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:a.f(n,e,{value:t,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return n}},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var r=t(134),a=String;n.exports=function(n){if("Symbol"===r(n))throw TypeError("Cannot convert a Symbol value to a string");return a(n)}},function(n,e,t){var r=t(2),a=t(8),o=r.document,i=a(o)&&a(o.createElement);n.exports=function(n){return i?o.createElement(n):{}}},function(n,e,t){var r=t(4),a=t(3);n.exports=r&&a((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var r=t(1),a=t(3),o=t(0),i=t(7),s=t(4),l=t(108).CONFIGURABLE,c=t(109),m=t(110),d=m.enforce,h=m.get,p=String,u=Object.defineProperty,f=r("".slice),y=r("".replace),g=r([].join),v=s&&!a((function(){return 8!==u((function(){}),"length",{value:8}).length})),b=String(String).split("String"),w=n.exports=function(n,e,t){"Symbol("===f(p(e),0,7)&&(e="["+y(p(e),/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!i(n,"name")||l&&n.name!==e)&&(s?u(n,"name",{value:e,configurable:!0}):n.name=e),v&&t&&i(t,"arity")&&n.length!==t.arity&&u(n,"length",{value:t.arity});try{t&&i(t,"constructor")&&t.constructor?s&&u(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var r=d(n);return i(r,"source")||(r.source=g(b,"string"==typeof e?e:"")),n};Function.prototype.toString=w((function(){return o(this)&&h(this).source||c(this)}),"toString")},function(n,e,t){var r=t(58),a=t(60),o=r("keys");n.exports=function(n){return o[n]||(o[n]=a(n))}},function(n,e,t){var r=t(1),a=t(7),o=t(26),i=t(114).indexOf,s=t(46),l=r([].push);n.exports=function(n,e){var t,r=o(n),c=0,m=[];for(t in r)!a(s,t)&&a(r,t)&&l(m,t);for(;e.length>c;)a(r,t=e[c++])&&(~i(m,t)||l(m,t));return m}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(238)},function(n,e,t){"use strict";var r=t(24),a=t(120).left,o=t(121),i=t(57);r({target:"Array",proto:!0,forced:!t(122)&&i>79&&i<83||!o("reduce")},{reduce:function(n){var e=arguments.length;return a(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r={}.propertyIsEnumerable,a=Object.getOwnPropertyDescriptor,o=a&&!r.call({1:2},1);e.f=o?function(n){var e=a(this,n);return!!e&&e.enumerable}:r},function(n,e,t){var r=t(32),a=t(8),o=t(53),i=t(105),s=t(107),l=t(29),c=TypeError,m=l("toPrimitive");n.exports=function(n,e){if(!a(n)||o(n))return n;var t,l=i(n,m);if(l){if(void 0===e&&(e="default"),t=r(l,n,e),!a(t)||o(t))return t;throw c("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e){n.exports="undefined"!=typeof navigator&&String(navigator.userAgent)||""},function(n,e,t){var r=t(28),a=t(50);n.exports=function(n,e){var t=n[e];return a(t)?void 0:r(t)}},function(n,e){var t=String;n.exports=function(n){try{return t(n)}catch(n){return"Object"}}},function(n,e,t){var r=t(32),a=t(0),o=t(8),i=TypeError;n.exports=function(n,e){var t,s;if("string"===e&&a(t=n.toString)&&!o(s=r(t,n)))return s;if(a(t=n.valueOf)&&!o(s=r(t,n)))return s;if("string"!==e&&a(t=n.toString)&&!o(s=r(t,n)))return s;throw i("Can't convert object to primitive value")}},function(n,e,t){var r=t(4),a=t(7),o=Function.prototype,i=r&&Object.getOwnPropertyDescriptor,s=a(o,"name"),l=s&&"something"===function(){}.name,c=s&&(!r||r&&i(o,"name").configurable);n.exports={EXISTS:s,PROPER:l,CONFIGURABLE:c}},function(n,e,t){var r=t(1),a=t(0),o=t(34),i=r(Function.toString);a(o.inspectSource)||(o.inspectSource=function(n){return i(n)}),n.exports=o.inspectSource},function(n,e,t){var r,a,o,i=t(111),s=t(2),l=t(8),c=t(12),m=t(7),d=t(34),h=t(97),p=t(46),u=s.TypeError,f=s.WeakMap;if(i||d.state){var y=d.state||(d.state=new f);y.get=y.get,y.has=y.has,y.set=y.set,r=function(n,e){if(y.has(n))throw u("Object already initialized");return e.facade=n,y.set(n,e),e},a=function(n){return y.get(n)||{}},o=function(n){return y.has(n)}}else{var g=h("state");p[g]=!0,r=function(n,e){if(m(n,g))throw u("Object already initialized");return e.facade=n,c(n,g,e),e},a=function(n){return m(n,g)?n[g]:{}},o=function(n){return m(n,g)}}n.exports={set:r,get:a,has:o,enforce:function(n){return o(n)?a(n):r(n,{})},getterFor:function(n){return function(e){var t;if(!l(e)||(t=a(e)).type!==n)throw u("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var r=t(2),a=t(0),o=r.WeakMap;n.exports=a(o)&&/native code/.test(String(o))},function(n,e,t){var r=t(27),a=t(1),o=t(113),i=t(118),s=t(23),l=a([].concat);n.exports=r("Reflect","ownKeys")||function(n){var e=o.f(s(n)),t=i.f;return t?l(e,t(n)):e}},function(n,e,t){var r=t(98),a=t(92).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return r(n,a)}},function(n,e,t){var r=t(26),a=t(115),o=t(31),i=function(n){return function(e,t,i){var s,l=r(e),c=o(l),m=a(i,c);if(n&&t!=t){for(;c>m;)if((s=l[m++])!=s)return!0}else for(;c>m;m++)if((n||m in l)&&l[m]===t)return n||m||0;return!n&&-1}};n.exports={includes:i(!0),indexOf:i(!1)}},function(n,e,t){var r=t(63),a=Math.max,o=Math.min;n.exports=function(n,e){var t=r(n);return t<0?a(t+e,0):o(t,e)}},function(n,e){var t=Math.ceil,r=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?r:t)(e)}},function(n,e,t){var r=t(63),a=Math.min;n.exports=function(n){return n>0?a(r(n),9007199254740991):0}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var r=t(3),a=t(0),o=/#|\.prototype\./,i=function(n,e){var t=l[s(n)];return t==m||t!=c&&(a(e)?r(e):!!e)},s=i.normalize=function(n){return String(n).replace(o,".").toLowerCase()},l=i.data={},c=i.NATIVE="N",m=i.POLYFILL="P";n.exports=i},function(n,e,t){var r=t(28),a=t(30),o=t(45),i=t(31),s=TypeError,l=function(n){return function(e,t,l,c){r(t);var m=a(e),d=o(m),h=i(m),p=n?h-1:0,u=n?-1:1;if(l<2)for(;;){if(p in d){c=d[p],p+=u;break}if(p+=u,n?p<0:h<=p)throw s("Reduce of empty array with no initial value")}for(;n?p>=0:h>p;p+=u)p in d&&(c=t(c,d[p],p,m));return c}};n.exports={left:l(!1),right:l(!0)}},function(n,e,t){"use strict";var r=t(3);n.exports=function(n,e){var t=[][n];return!!t&&r((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var r=t(16);n.exports="undefined"!=typeof process&&"process"==r(process)},function(n,e,t){"use strict";var r=t(4),a=t(124),o=TypeError,i=Object.getOwnPropertyDescriptor,s=r&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=s?function(n,e){if(a(n)&&!i(n,"length").writable)throw o("Cannot set read only .length");return n.length=e}:function(n,e){return n.length=e}},function(n,e,t){var r=t(16);n.exports=Array.isArray||function(n){return"Array"==r(n)}},function(n,e){var t=TypeError;n.exports=function(n){if(n>9007199254740991)throw t("Maximum allowed index exceeded");return n}},function(n,e,t){var r=t(24),a=t(2),o=t(127),i=t(128),s=a.WebAssembly,l=7!==Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=i(n,e,l),r({global:!0,constructor:!0,arity:1,forced:l},t)},m=function(n,e){if(s&&s[n]){var t={};t[n]=i("WebAssembly."+n,e,l),r({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};c("Error",(function(n){return function(e){return o(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return o(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return o(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return o(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return o(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return o(n,this,arguments)}})),c("URIError",(function(n){return function(e){return o(n,this,arguments)}})),m("CompileError",(function(n){return function(e){return o(n,this,arguments)}})),m("LinkError",(function(n){return function(e){return o(n,this,arguments)}})),m("RuntimeError",(function(n){return function(e){return o(n,this,arguments)}}))},function(n,e,t){var r=t(25),a=Function.prototype,o=a.apply,i=a.call;n.exports="object"==typeof Reflect&&Reflect.apply||(r?i.bind(o):function(){return i.apply(o,arguments)})},function(n,e,t){"use strict";var r=t(27),a=t(7),o=t(12),i=t(54),s=t(64),l=t(62),c=t(131),m=t(132),d=t(133),h=t(136),p=t(137),u=t(4),f=t(59);n.exports=function(n,e,t,y){var g=y?2:1,v=n.split("."),b=v[v.length-1],w=r.apply(null,v);if(w){var x=w.prototype;if(!f&&a(x,"cause")&&delete x.cause,!t)return w;var E=r("Error"),k=e((function(n,e){var t=d(y?e:n,void 0),r=y?new w(n):new w;return void 0!==t&&o(r,"message",t),p(r,k,r.stack,2),this&&i(x,this)&&m(r,this,k),arguments.length>g&&h(r,arguments[g]),r}));if(k.prototype=x,"Error"!==b?s?s(k,E):l(k,E,{name:!0}):u&&"stackTraceLimit"in w&&(c(k,w,"stackTraceLimit"),c(k,w,"prepareStackTrace")),l(k,w),!f)try{x.name!==b&&o(x,"name",b),x.constructor=k}catch(n){}return k}}},function(n,e,t){var r=t(1),a=t(28);n.exports=function(n,e,t){try{return r(a(Object.getOwnPropertyDescriptor(n,e)[t]))}catch(n){}}},function(n,e,t){var r=t(0),a=String,o=TypeError;n.exports=function(n){if("object"==typeof n||r(n))return n;throw o("Can't set "+a(n)+" as a prototype")}},function(n,e,t){var r=t(15).f;n.exports=function(n,e,t){t in n||r(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){var r=t(0),a=t(8),o=t(64);n.exports=function(n,e,t){var i,s;return o&&r(i=e.constructor)&&i!==t&&a(s=i.prototype)&&s!==t.prototype&&o(n,s),n}},function(n,e,t){var r=t(93);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:r(n)}},function(n,e,t){var r=t(135),a=t(0),o=t(16),i=t(29)("toStringTag"),s=Object,l="Arguments"==o(function(){return arguments}());n.exports=r?o:function(n){var e,t,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),i))?t:l?o(e):"Object"==(r=o(e))&&a(e.callee)?"Arguments":r}},function(n,e,t){var r={};r[t(29)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,e,t){var r=t(8),a=t(12);n.exports=function(n,e){r(e)&&"cause"in e&&a(n,"cause",e.cause)}},function(n,e,t){var r=t(12),a=t(138),o=t(139),i=Error.captureStackTrace;n.exports=function(n,e,t,s){o&&(i?i(n,e):r(n,"stack",a(t,s)))}},function(n,e,t){var r=t(1),a=Error,o=r("".replace),i=String(a("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,l=s.test(i);n.exports=function(n,e){if(l&&"string"==typeof n&&!a.prepareStackTrace)for(;e--;)n=o(n,s,"");return n}},function(n,e,t){var r=t(3),a=t(33);n.exports=!r((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",a(1,7)),7!==n.stack)}))},function(n,e,t){var r=t(65),a=t(141);n.exports=function n(e,t,o,i,s){var l=-1,c=e.length;for(o||(o=a),s||(s=[]);++l<c;){var m=e[l];t>0&&o(m)?t>1?n(m,t-1,o,i,s):r(s,m):i||(s[s.length]=m)}return s}},function(n,e,t){var r=t(13),a=t(36),o=t(5),i=r?r.isConcatSpreadable:void 0;n.exports=function(n){return o(n)||a(n)||!!(i&&n&&n[i])}},function(n,e,t){var r=t(11),a=t(10);n.exports=function(n){return a(n)&&"[object Arguments]"==r(n)}},function(n,e,t){var r=t(13),a=Object.prototype,o=a.hasOwnProperty,i=a.toString,s=r?r.toStringTag:void 0;n.exports=function(n){var e=o.call(n,s),t=n[s];try{n[s]=void 0;var r=!0}catch(n){}var a=i.call(n);return r&&(e?n[s]=t:delete n[s]),a}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var r=t(146),a=t(202),o=t(44),i=t(5),s=t(213);n.exports=function(n){return"function"==typeof n?n:null==n?o:"object"==typeof n?i(n)?a(n[0],n[1]):r(n):s(n)}},function(n,e,t){var r=t(147),a=t(201),o=t(82);n.exports=function(n){var e=a(n);return 1==e.length&&e[0][2]?o(e[0][0],e[0][1]):function(t){return t===n||r(t,n,e)}}},function(n,e,t){var r=t(67),a=t(71);n.exports=function(n,e,t,o){var i=t.length,s=i,l=!o;if(null==n)return!s;for(n=Object(n);i--;){var c=t[i];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++i<s;){var m=(c=t[i])[0],d=n[m],h=c[1];if(l&&c[2]){if(void 0===d&&!(m in n))return!1}else{var p=new r;if(o)var u=o(d,h,m,n,e,p);if(!(void 0===u?a(h,d,3,o,p):u))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var r=t(18),a=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=r(e,n);return!(t<0)&&(t==e.length-1?e.pop():a.call(e,t,1),--this.size,!0)}},function(n,e,t){var r=t(18);n.exports=function(n){var e=this.__data__,t=r(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var r=t(18);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,e,t){var r=t(18);n.exports=function(n,e){var t=this.__data__,a=r(t,n);return a<0?(++this.size,t.push([n,e])):t[a][1]=e,this}},function(n,e,t){var r=t(17);n.exports=function(){this.__data__=new r,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var r=t(17),a=t(37),o=t(39);n.exports=function(n,e){var t=this.__data__;if(t instanceof r){var i=t.__data__;if(!a||i.length<199)return i.push([n,e]),this.size=++t.size,this;t=this.__data__=new o(i)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var r=t(69),a=t(159),o=t(38),i=t(70),s=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,m=l.toString,d=c.hasOwnProperty,h=RegExp("^"+m.call(d).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!o(n)||a(n))&&(r(n)?h:s).test(i(n))}},function(n,e,t){var r,a=t(160),o=(r=/[^.]+$/.exec(a&&a.keys&&a.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!o&&o in n}},function(n,e,t){var r=t(6)["__core-js_shared__"];n.exports=r},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var r=t(163),a=t(17),o=t(37);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(o||a),string:new r}}},function(n,e,t){var r=t(164),a=t(165),o=t(166),i=t(167),s=t(168);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=o,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(19);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var r=t(19),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(r){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return a.call(e,n)?e[n]:void 0}},function(n,e,t){var r=t(19),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return r?void 0!==e[n]:a.call(e,n)}},function(n,e,t){var r=t(19);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=r&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var r=t(20);n.exports=function(n){var e=r(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var r=t(20);n.exports=function(n){return r(this,n).get(n)}},function(n,e,t){var r=t(20);n.exports=function(n){return r(this,n).has(n)}},function(n,e,t){var r=t(20);n.exports=function(n,e){var t=r(this,n),a=t.size;return t.set(n,e),this.size+=t.size==a?0:1,this}},function(n,e,t){var r=t(67),a=t(72),o=t(178),i=t(181),s=t(197),l=t(5),c=t(76),m=t(78),d="[object Object]",h=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,p,u,f){var y=l(n),g=l(e),v=y?"[object Array]":s(n),b=g?"[object Array]":s(e),w=(v="[object Arguments]"==v?d:v)==d,x=(b="[object Arguments]"==b?d:b)==d,E=v==b;if(E&&c(n)){if(!c(e))return!1;y=!0,w=!1}if(E&&!w)return f||(f=new r),y||m(n)?a(n,e,t,p,u,f):o(n,e,v,t,p,u,f);if(!(1&t)){var k=w&&h.call(n,"__wrapped__"),S=x&&h.call(e,"__wrapped__");if(k||S){var T=k?n.value():n,j=S?e.value():e;return f||(f=new r),u(T,j,t,p,f)}}return!!E&&(f||(f=new r),i(n,e,t,p,u,f))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var r=t(13),a=t(179),o=t(68),i=t(72),s=t(180),l=t(40),c=r?r.prototype:void 0,m=c?c.valueOf:void 0;n.exports=function(n,e,t,r,c,d,h){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!d(new a(n),new a(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return o(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var p=s;case"[object Set]":var u=1&r;if(p||(p=l),n.size!=e.size&&!u)return!1;var f=h.get(n);if(f)return f==e;r|=2,h.set(n,e);var y=i(p(n),p(e),r,c,d,h);return h.delete(n),y;case"[object Symbol]":if(m)return m.call(n)==m.call(e)}return!1}},function(n,e,t){var r=t(6).Uint8Array;n.exports=r},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,r){t[++e]=[r,n]})),t}},function(n,e,t){var r=t(182),a=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,o,i,s){var l=1&t,c=r(n),m=c.length;if(m!=r(e).length&&!l)return!1;for(var d=m;d--;){var h=c[d];if(!(l?h in e:a.call(e,h)))return!1}var p=s.get(n),u=s.get(e);if(p&&u)return p==e&&u==n;var f=!0;s.set(n,e),s.set(e,n);for(var y=l;++d<m;){var g=n[h=c[d]],v=e[h];if(o)var b=l?o(v,g,h,e,n,s):o(g,v,h,n,e,s);if(!(void 0===b?g===v||i(g,v,t,o,s):b)){f=!1;break}y||(y="constructor"==h)}if(f&&!y){var w=n.constructor,x=e.constructor;w==x||!("constructor"in n)||!("constructor"in e)||"function"==typeof w&&w instanceof w&&"function"==typeof x&&x instanceof x||(f=!1)}return s.delete(n),s.delete(e),f}},function(n,e,t){var r=t(183),a=t(184),o=t(75);n.exports=function(n){return r(n,o,a)}},function(n,e,t){var r=t(65),a=t(5);n.exports=function(n,e,t){var o=e(n);return a(n)?o:r(o,t(n))}},function(n,e,t){var r=t(185),a=t(186),o=Object.prototype.propertyIsEnumerable,i=Object.getOwnPropertySymbols,s=i?function(n){return null==n?[]:(n=Object(n),r(i(n),(function(e){return o.call(n,e)})))}:a;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,a=0,o=[];++t<r;){var i=n[t];e(i,t,n)&&(o[a++]=i)}return o}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var r=t(188),a=t(36),o=t(5),i=t(76),s=t(77),l=t(78),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=o(n),m=!t&&a(n),d=!t&&!m&&i(n),h=!t&&!m&&!d&&l(n),p=t||m||d||h,u=p?r(n.length,String):[],f=u.length;for(var y in n)!e&&!c.call(n,y)||p&&("length"==y||d&&("offset"==y||"parent"==y)||h&&("buffer"==y||"byteLength"==y||"byteOffset"==y)||s(y,f))||u.push(y);return u}},function(n,e){n.exports=function(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var r=t(11),a=t(41),o=t(10),i={};i["[object Float32Array]"]=i["[object Float64Array]"]=i["[object Int8Array]"]=i["[object Int16Array]"]=i["[object Int32Array]"]=i["[object Uint8Array]"]=i["[object Uint8ClampedArray]"]=i["[object Uint16Array]"]=i["[object Uint32Array]"]=!0,i["[object Arguments]"]=i["[object Array]"]=i["[object ArrayBuffer]"]=i["[object Boolean]"]=i["[object DataView]"]=i["[object Date]"]=i["[object Error]"]=i["[object Function]"]=i["[object Map]"]=i["[object Number]"]=i["[object Object]"]=i["[object RegExp]"]=i["[object Set]"]=i["[object String]"]=i["[object WeakMap]"]=!1,n.exports=function(n){return o(n)&&a(n.length)&&!!i[r(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var r=t(66),a=e&&!e.nodeType&&e,o=a&&"object"==typeof n&&n&&!n.nodeType&&n,i=o&&o.exports===a&&r.process,s=function(){try{var n=o&&o.require&&o.require("util").types;return n||i&&i.binding&&i.binding("util")}catch(n){}}();n.exports=s}).call(this,t(47)(n))},function(n,e,t){var r=t(194),a=t(195),o=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return a(n);var e=[];for(var t in Object(n))o.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var r=t(196)(Object.keys,Object);n.exports=r},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var r=t(198),a=t(37),o=t(199),i=t(80),s=t(200),l=t(11),c=t(70),m=c(r),d=c(a),h=c(o),p=c(i),u=c(s),f=l;(r&&"[object DataView]"!=f(new r(new ArrayBuffer(1)))||a&&"[object Map]"!=f(new a)||o&&"[object Promise]"!=f(o.resolve())||i&&"[object Set]"!=f(new i)||s&&"[object WeakMap]"!=f(new s))&&(f=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,r=t?c(t):"";if(r)switch(r){case m:return"[object DataView]";case d:return"[object Map]";case h:return"[object Promise]";case p:return"[object Set]";case u:return"[object WeakMap]"}return e}),n.exports=f},function(n,e,t){var r=t(9)(t(6),"DataView");n.exports=r},function(n,e,t){var r=t(9)(t(6),"Promise");n.exports=r},function(n,e,t){var r=t(9)(t(6),"WeakMap");n.exports=r},function(n,e,t){var r=t(81),a=t(75);n.exports=function(n){for(var e=a(n),t=e.length;t--;){var o=e[t],i=n[o];e[t]=[o,i,r(i)]}return e}},function(n,e,t){var r=t(71),a=t(203),o=t(210),i=t(42),s=t(81),l=t(82),c=t(21);n.exports=function(n,e){return i(n)&&s(e)?l(c(n),e):function(t){var i=a(t,n);return void 0===i&&i===e?o(t,n):r(e,i,3)}}},function(n,e,t){var r=t(83);n.exports=function(n,e,t){var a=null==n?void 0:r(n,e);return void 0===a?t:a}},function(n,e,t){var r=t(205),a=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,o=/\\(\\)?/g,i=r((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(a,(function(n,t,r,a){e.push(r?a.replace(o,"$1"):t||n)})),e}));n.exports=i},function(n,e,t){var r=t(206);n.exports=function(n){var e=r(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var r=t(39);function a(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var r=arguments,a=e?e.apply(this,r):r[0],o=t.cache;if(o.has(a))return o.get(a);var i=n.apply(this,r);return t.cache=o.set(a,i)||o,i};return t.cache=new(a.Cache||r),t}a.Cache=r,n.exports=a},function(n,e,t){var r=t(208);n.exports=function(n){return null==n?"":r(n)}},function(n,e,t){var r=t(13),a=t(209),o=t(5),i=t(43),s=r?r.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(o(e))return a(e,n)+"";if(i(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,a=Array(r);++t<r;)a[t]=e(n[t],t,n);return a}},function(n,e,t){var r=t(211),a=t(212);n.exports=function(n,e){return null!=n&&a(n,e,r)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var r=t(84),a=t(36),o=t(5),i=t(77),s=t(41),l=t(21);n.exports=function(n,e,t){for(var c=-1,m=(e=r(e,n)).length,d=!1;++c<m;){var h=l(e[c]);if(!(d=null!=n&&t(n,h)))break;n=n[h]}return d||++c!=m?d:!!(m=null==n?0:n.length)&&s(m)&&i(h,m)&&(o(n)||a(n))}},function(n,e,t){var r=t(214),a=t(215),o=t(42),i=t(21);n.exports=function(n){return o(n)?r(i(n)):a(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var r=t(83);n.exports=function(n){return function(e){return r(e,n)}}},function(n,e,t){var r=t(44),a=t(217),o=t(219);n.exports=function(n,e){return o(a(n,e,r),n+"")}},function(n,e,t){var r=t(218),a=Math.max;n.exports=function(n,e,t){return e=a(void 0===e?n.length-1:e,0),function(){for(var o=arguments,i=-1,s=a(o.length-e,0),l=Array(s);++i<s;)l[i]=o[e+i];i=-1;for(var c=Array(e+1);++i<e;)c[i]=o[i];return c[e]=t(l),r(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var r=t(220),a=t(223)(r);n.exports=a},function(n,e,t){var r=t(221),a=t(222),o=t(44),i=a?function(n,e){return a(n,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:o;n.exports=i},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var r=t(9),a=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=a},function(n,e){var t=Date.now;n.exports=function(n){var e=0,r=0;return function(){var a=t(),o=16-(a-r);if(r=a,o>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var r=t(73),a=t(225),o=t(230),i=t(74),s=t(231),l=t(40);n.exports=function(n,e,t){var c=-1,m=a,d=n.length,h=!0,p=[],u=p;if(t)h=!1,m=o;else if(d>=200){var f=e?null:s(n);if(f)return l(f);h=!1,m=i,u=new r}else u=e?[]:p;n:for(;++c<d;){var y=n[c],g=e?e(y):y;if(y=t||0!==y?y:0,h&&g==g){for(var v=u.length;v--;)if(u[v]===g)continue n;e&&u.push(g),p.push(y)}else m(u,g,t)||(u!==p&&u.push(g),p.push(y))}return p}},function(n,e,t){var r=t(226);n.exports=function(n,e){return!!(null==n?0:n.length)&&r(n,e,0)>-1}},function(n,e,t){var r=t(227),a=t(228),o=t(229);n.exports=function(n,e,t){return e==e?o(n,e,t):r(n,a,t)}},function(n,e){n.exports=function(n,e,t,r){for(var a=n.length,o=t+(r?1:-1);r?o--:++o<a;)if(e(n[o],o,n))return o;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var r=t-1,a=n.length;++r<a;)if(n[r]===e)return r;return-1}},function(n,e){n.exports=function(n,e,t){for(var r=-1,a=null==n?0:n.length;++r<a;)if(t(e,n[r]))return!0;return!1}},function(n,e,t){var r=t(80),a=t(232),o=t(40),i=r&&1/o(new r([,-0]))[1]==1/0?function(n){return new r(n)}:a;n.exports=i},function(n,e){n.exports=function(){}},function(n,e,t){var r=t(79),a=t(10);n.exports=function(n){return a(n)&&r(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(85)},function(n,e,t){"use strict";t(86)},function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.7.14
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
var r=Object.freeze({}),a=Array.isArray;function o(n){return null==n}function i(n){return null!=n}function s(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return"function"==typeof n}function m(n){return null!==n&&"object"==typeof n}var d=Object.prototype.toString;function h(n){return"[object Object]"===d.call(n)}function p(n){return"[object RegExp]"===d.call(n)}function u(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function f(n){return i(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function y(n){return null==n?"":Array.isArray(n)||h(n)&&n.toString===d?JSON.stringify(n,null,2):String(n)}function g(n){var e=parseFloat(n);return isNaN(e)?n:e}function v(n,e){for(var t=Object.create(null),r=n.split(","),a=0;a<r.length;a++)t[r[a]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}v("slot,component",!0);var b=v("key,ref,slot,slot-scope,is");function w(n,e){var t=n.length;if(t){if(e===n[t-1])return void(n.length=t-1);var r=n.indexOf(e);if(r>-1)return n.splice(r,1)}}var x=Object.prototype.hasOwnProperty;function E(n,e){return x.call(n,e)}function k(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var S=/-(\w)/g,T=k((function(n){return n.replace(S,(function(n,e){return e?e.toUpperCase():""}))})),j=k((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),C=/\B([A-Z])/g,R=k((function(n){return n.replace(C,"-$1").toLowerCase()}));var M=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var r=arguments.length;return r?r>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function A(n,e){e=e||0;for(var t=n.length-e,r=new Array(t);t--;)r[t]=n[t+e];return r}function z(n,e){for(var t in e)n[t]=e[t];return n}function _(n){for(var e={},t=0;t<n.length;t++)n[t]&&z(e,n[t]);return e}function I(n,e,t){}var P=function(n,e,t){return!1},H=function(n){return n};function D(n,e){if(n===e)return!0;var t=m(n),r=m(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var a=Array.isArray(n),o=Array.isArray(e);if(a&&o)return n.length===e.length&&n.every((function(n,t){return D(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(a||o)return!1;var i=Object.keys(n),s=Object.keys(e);return i.length===s.length&&i.every((function(t){return D(n[t],e[t])}))}catch(n){return!1}}function B(n,e){for(var t=0;t<n.length;t++)if(D(n[t],e))return t;return-1}function $(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function L(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var F=["component","directive","filter"],O=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],q={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:P,isReservedAttr:P,isUnknownElement:P,getTagNamespace:I,parsePlatformTagName:H,mustUseProp:P,async:!0,_lifecycleHooks:O},N=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function G(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function V(n,e,t,r){Object.defineProperty(n,e,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var W=new RegExp("[^".concat(N.source,".$_\\d]"));var U="__proto__"in{},X="undefined"!=typeof window,J=X&&window.navigator.userAgent.toLowerCase(),Y=J&&/msie|trident/.test(J),K=J&&J.indexOf("msie 9.0")>0,Z=J&&J.indexOf("edge/")>0;J&&J.indexOf("android");var Q=J&&/iphone|ipad|ipod|ios/.test(J);J&&/chrome\/\d+/.test(J),J&&/phantomjs/.test(J);var nn,en=J&&J.match(/firefox\/(\d+)/),tn={}.watch,rn=!1;if(X)try{var an={};Object.defineProperty(an,"passive",{get:function(){rn=!0}}),window.addEventListener("test-passive",null,an)}catch(n){}var on=function(){return void 0===nn&&(nn=!X&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),nn},sn=X&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ln(n){return"function"==typeof n&&/native code/.test(n.toString())}var cn,mn="undefined"!=typeof Symbol&&ln(Symbol)&&"undefined"!=typeof Reflect&&ln(Reflect.ownKeys);cn="undefined"!=typeof Set&&ln(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var dn=null;function hn(n){void 0===n&&(n=null),n||dn&&dn._scope.off(),dn=n,n&&n._scope.on()}var pn=function(){function n(n,e,t,r,a,o,i,s){this.tag=n,this.data=e,this.children=t,this.text=r,this.elm=a,this.ns=void 0,this.context=o,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=i,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),un=function(n){void 0===n&&(n="");var e=new pn;return e.text=n,e.isComment=!0,e};function fn(n){return new pn(void 0,void 0,void 0,String(n))}function yn(n){var e=new pn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var gn=0,vn=[],bn=function(){function n(){this._pending=!1,this.id=gn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){this.subs[this.subs.indexOf(n)]=null,this._pending||(this._pending=!0,vn.push(this))},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.filter((function(n){return n}));for(var t=0,r=e.length;t<r;t++){0,e[t].update()}},n}();bn.target=null;var wn=[];function xn(n){wn.push(n),bn.target=n}function En(){wn.pop(),bn.target=wn[wn.length-1]}var kn=Array.prototype,Sn=Object.create(kn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=kn[n];V(Sn,n,(function(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];var a,o=e.apply(this,t),i=this.__ob__;switch(n){case"push":case"unshift":a=t;break;case"splice":a=t.slice(2)}return a&&i.observeArray(a),i.dep.notify(),o}))}));var Tn=Object.getOwnPropertyNames(Sn),jn={},Cn=!0;function Rn(n){Cn=n}var Mn={notify:I,depend:I,addSub:I,removeSub:I},An=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?Mn:new bn,this.vmCount=0,V(n,"__ob__",this),a(n)){if(!t)if(U)n.__proto__=Sn;else for(var r=0,o=Tn.length;r<o;r++){V(n,s=Tn[r],Sn[s])}e||this.observeArray(n)}else{var i=Object.keys(n);for(r=0;r<i.length;r++){var s;_n(n,s=i[r],jn,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)zn(n[e],!1,this.mock)},n}();function zn(n,e,t){return n&&E(n,"__ob__")&&n.__ob__ instanceof An?n.__ob__:!Cn||!t&&on()||!a(n)&&!h(n)||!Object.isExtensible(n)||n.__v_skip||Ln(n)||n instanceof pn?void 0:new An(n,e,t)}function _n(n,e,t,r,o,i){var s=new bn,l=Object.getOwnPropertyDescriptor(n,e);if(!l||!1!==l.configurable){var c=l&&l.get,m=l&&l.set;c&&!m||t!==jn&&2!==arguments.length||(t=n[e]);var d=!o&&zn(t,!1,i);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=c?c.call(n):t;return bn.target&&(s.depend(),d&&(d.dep.depend(),a(e)&&Hn(e))),Ln(e)&&!o?e.value:e},set:function(e){var r=c?c.call(n):t;if(L(r,e)){if(m)m.call(n,e);else{if(c)return;if(!o&&Ln(r)&&!Ln(e))return void(r.value=e);t=e}d=!o&&zn(e,!1,i),s.notify()}}}),s}}function In(n,e,t){if(!$n(n)){var r=n.__ob__;return a(n)&&u(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),r&&!r.shallow&&r.mock&&zn(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||r&&r.vmCount?t:r?(_n(r.value,e,t,void 0,r.shallow,r.mock),r.dep.notify(),t):(n[e]=t,t)}}function Pn(n,e){if(a(n)&&u(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||$n(n)||E(n,e)&&(delete n[e],t&&t.dep.notify())}}function Hn(n){for(var e=void 0,t=0,r=n.length;t<r;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),a(e)&&Hn(e)}function Dn(n){return Bn(n,!0),V(n,"__v_isShallow",!0),n}function Bn(n,e){if(!$n(n)){zn(n,e,on());0}}function $n(n){return!(!n||!n.__v_isReadonly)}function Ln(n){return!(!n||!0!==n.__v_isRef)}function Fn(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(Ln(n))return n.value;var r=n&&n.__ob__;return r&&r.dep.depend(),n},set:function(n){var r=e[t];Ln(r)&&!Ln(n)?r.value=n:e[t]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var On;var qn=function(){function n(n){void 0===n&&(n=!1),this.detached=n,this.active=!0,this.effects=[],this.cleanups=[],this.parent=On,!n&&On&&(this.index=(On.scopes||(On.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=On;try{return On=this,n()}finally{On=e}}else 0},n.prototype.on=function(){On=this},n.prototype.off=function(){On=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!n){var r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.parent=void 0,this.active=!1}},n}();function Nn(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var Gn=k((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),r="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:t,capture:r,passive:e}}));function Vn(n,e){function t(){var n=t.fns;if(!a(n))return Ce(n,null,arguments,e,"v-on handler");for(var r=n.slice(),o=0;o<r.length;o++)Ce(r[o],null,arguments,e,"v-on handler")}return t.fns=n,t}function Wn(n,e,t,r,a,i){var l,c,m,d;for(l in n)c=n[l],m=e[l],d=Gn(l),o(c)||(o(m)?(o(c.fns)&&(c=n[l]=Vn(c,i)),s(d.once)&&(c=n[l]=a(d.name,c,d.capture)),t(d.name,c,d.capture,d.passive,d.params)):c!==m&&(m.fns=c,n[l]=m));for(l in e)o(n[l])&&r((d=Gn(l)).name,e[l],d.capture)}function Un(n,e,t){var r;n instanceof pn&&(n=n.data.hook||(n.data.hook={}));var a=n[e];function l(){t.apply(this,arguments),w(r.fns,l)}o(a)?r=Vn([l]):i(a.fns)&&s(a.merged)?(r=a).fns.push(l):r=Vn([a,l]),r.merged=!0,n[e]=r}function Xn(n,e,t,r,a){if(i(e)){if(E(e,t))return n[t]=e[t],a||delete e[t],!0;if(E(e,r))return n[t]=e[r],a||delete e[r],!0}return!1}function Jn(n){return l(n)?[fn(n)]:a(n)?function n(e,t){var r,c,m,d,h=[];for(r=0;r<e.length;r++)o(c=e[r])||"boolean"==typeof c||(m=h.length-1,d=h[m],a(c)?c.length>0&&(Yn((c=n(c,"".concat(t||"","_").concat(r)))[0])&&Yn(d)&&(h[m]=fn(d.text+c[0].text),c.shift()),h.push.apply(h,c)):l(c)?Yn(d)?h[m]=fn(d.text+c):""!==c&&h.push(fn(c)):Yn(c)&&Yn(d)?h[m]=fn(d.text+c.text):(s(e._isVList)&&i(c.tag)&&o(c.key)&&i(t)&&(c.key="__vlist".concat(t,"_").concat(r,"__")),h.push(c)));return h}(n):void 0}function Yn(n){return i(n)&&i(n.text)&&!1===n.isComment}function Kn(n,e){var t,r,o,s,l=null;if(a(n)||"string"==typeof n)for(l=new Array(n.length),t=0,r=n.length;t<r;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(m(n))if(mn&&n[Symbol.iterator]){l=[];for(var c=n[Symbol.iterator](),d=c.next();!d.done;)l.push(e(d.value,l.length)),d=c.next()}else for(o=Object.keys(n),l=new Array(o.length),t=0,r=o.length;t<r;t++)s=o[t],l[t]=e(n[s],s,t);return i(l)||(l=[]),l._isVList=!0,l}function Zn(n,e,t,r){var a,o=this.$scopedSlots[n];o?(t=t||{},r&&(t=z(z({},r),t)),a=o(t)||(c(e)?e():e)):a=this.$slots[n]||(c(e)?e():e);var i=t&&t.slot;return i?this.$createElement("template",{slot:i},a):a}function Qn(n){return At(this.$options,"filters",n,!0)||H}function ne(n,e){return a(n)?-1===n.indexOf(e):n!==e}function ee(n,e,t,r,a){var o=q.keyCodes[e]||t;return a&&r&&!q.keyCodes[e]?ne(a,r):o?ne(o,n):r?R(r)!==e:void 0===n}function te(n,e,t,r,o){if(t)if(m(t)){a(t)&&(t=_(t));var i=void 0,s=function(a){if("class"===a||"style"===a||b(a))i=n;else{var s=n.attrs&&n.attrs.type;i=r||q.mustUseProp(e,s,a)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=T(a),c=R(a);l in i||c in i||(i[a]=t[a],o&&((n.on||(n.on={}))["update:".concat(a)]=function(n){t[a]=n}))};for(var l in t)s(l)}else;return n}function re(n,e){var t=this._staticTrees||(this._staticTrees=[]),r=t[n];return r&&!e||oe(r=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),r}function ae(n,e,t){return oe(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function oe(n,e,t){if(a(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&ie(n[r],"".concat(e,"_").concat(r),t);else ie(n,e,t)}function ie(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function se(n,e){if(e)if(h(e)){var t=n.on=n.on?z({},n.on):{};for(var r in e){var a=t[r],o=e[r];t[r]=a?[].concat(a,o):o}}else;return n}function le(n,e,t,r){e=e||{$stable:!t};for(var o=0;o<n.length;o++){var i=n[o];a(i)?le(i,e,t):i&&(i.proxy&&(i.fn.proxy=!0),e[i.key]=i.fn)}return r&&(e.$key=r),e}function ce(n,e){for(var t=0;t<e.length;t+=2){var r=e[t];"string"==typeof r&&r&&(n[e[t]]=e[t+1])}return n}function me(n,e){return"string"==typeof n?e+n:n}function de(n){n._o=ae,n._n=g,n._s=y,n._l=Kn,n._t=Zn,n._q=D,n._i=B,n._m=re,n._f=Qn,n._k=ee,n._b=te,n._v=fn,n._e=un,n._u=le,n._g=se,n._d=ce,n._p=me}function he(n,e){if(!n||!n.length)return{};for(var t={},r=0,a=n.length;r<a;r++){var o=n[r],i=o.data;if(i&&i.attrs&&i.attrs.slot&&delete i.attrs.slot,o.context!==e&&o.fnContext!==e||!i||null==i.slot)(t.default||(t.default=[])).push(o);else{var s=i.slot,l=t[s]||(t[s]=[]);"template"===o.tag?l.push.apply(l,o.children||[]):l.push(o)}}for(var c in t)t[c].every(pe)&&delete t[c];return t}function pe(n){return n.isComment&&!n.asyncFactory||" "===n.text}function ue(n){return n.isComment&&n.asyncFactory}function fe(n,e,t,a){var o,i=Object.keys(t).length>0,s=e?!!e.$stable:!i,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(s&&a&&a!==r&&l===a.$key&&!i&&!a.$hasNormal)return a;for(var c in o={},e)e[c]&&"$"!==c[0]&&(o[c]=ye(n,t,c,e[c]))}else o={};for(var m in t)m in o||(o[m]=ge(t,m));return e&&Object.isExtensible(e)&&(e._normalized=o),V(o,"$stable",s),V(o,"$key",l),V(o,"$hasNormal",i),o}function ye(n,e,t,r){var o=function(){var e=dn;hn(n);var t=arguments.length?r.apply(null,arguments):r({}),o=(t=t&&"object"==typeof t&&!a(t)?[t]:Jn(t))&&t[0];return hn(e),t&&(!o||1===t.length&&o.isComment&&!ue(o))?void 0:t};return r.proxy&&Object.defineProperty(e,t,{get:o,enumerable:!0,configurable:!0}),o}function ge(n,e){return function(){return n[e]}}function ve(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};V(e,"_v_attr_proxy",!0),be(e,n.$attrs,r,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||be(n._listenersProxy={},n.$listeners,r,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||xe(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:M(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return Fn(n,e,t)}))}}}function be(n,e,t,r,a){var o=!1;for(var i in e)i in n?e[i]!==t[i]&&(o=!0):(o=!0,we(n,i,r,a));for(var i in n)i in e||(o=!0,delete n[i]);return o}function we(n,e,t,r){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[r][e]}})}function xe(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var Ee=null;function ke(n,e){return(n.__esModule||mn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),m(n)?e.extend(n):n}function Se(n){if(a(n))for(var e=0;e<n.length;e++){var t=n[e];if(i(t)&&(i(t.componentOptions)||ue(t)))return t}}function Te(n,e,t,r,d,h){return(a(t)||l(t))&&(d=r,r=t,t=void 0),s(h)&&(d=2),function(n,e,t,r,l){if(i(t)&&i(t.__ob__))return un();i(t)&&i(t.is)&&(e=t.is);if(!e)return un();0;a(r)&&c(r[0])&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===l?r=Jn(r):1===l&&(r=function(n){for(var e=0;e<n.length;e++)if(a(n[e]))return Array.prototype.concat.apply([],n);return n}(r));var d,h;if("string"==typeof e){var p=void 0;h=n.$vnode&&n.$vnode.ns||q.getTagNamespace(e),d=q.isReservedTag(e)?new pn(q.parsePlatformTagName(e),t,r,void 0,void 0,n):t&&t.pre||!i(p=At(n.$options,"components",e))?new pn(e,t,r,void 0,void 0,n):wt(p,t,n,r,e)}else d=wt(e,t,n,r);return a(d)?d:i(d)?(i(h)&&function n(e,t,r){e.ns=t,"foreignObject"===e.tag&&(t=void 0,r=!0);if(i(e.children))for(var a=0,l=e.children.length;a<l;a++){var c=e.children[a];i(c.tag)&&(o(c.ns)||s(r)&&"svg"!==c.tag)&&n(c,t,r)}}(d,h),i(t)&&function(n){m(n.style)&&qe(n.style);m(n.class)&&qe(n.class)}(t),d):un()}(n,e,t,r,d)}function je(n,e,t){xn();try{if(e)for(var r=e;r=r.$parent;){var a=r.$options.errorCaptured;if(a)for(var o=0;o<a.length;o++)try{if(!1===a[o].call(r,n,e,t))return}catch(n){Re(n,r,"errorCaptured hook")}}Re(n,e,t)}finally{En()}}function Ce(n,e,t,r,a){var o;try{(o=t?n.apply(e,t):n.call(e))&&!o._isVue&&f(o)&&!o._handled&&(o.catch((function(n){return je(n,r,a+" (Promise/async)")})),o._handled=!0)}catch(n){je(n,r,a)}return o}function Re(n,e,t){if(q.errorHandler)try{return q.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Me(e,null,"config.errorHandler")}Me(n,e,t)}function Me(n,e,t){if(!X||"undefined"==typeof console)throw n;console.error(n)}var Ae,ze=!1,_e=[],Ie=!1;function Pe(){Ie=!1;var n=_e.slice(0);_e.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&ln(Promise)){var He=Promise.resolve();Ae=function(){He.then(Pe),Q&&setTimeout(I)},ze=!0}else if(Y||"undefined"==typeof MutationObserver||!ln(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Ae="undefined"!=typeof setImmediate&&ln(setImmediate)?function(){setImmediate(Pe)}:function(){setTimeout(Pe,0)};else{var De=1,Be=new MutationObserver(Pe),$e=document.createTextNode(String(De));Be.observe($e,{characterData:!0}),Ae=function(){De=(De+1)%2,$e.data=String(De)},ze=!0}function Le(n,e){var t;if(_e.push((function(){if(n)try{n.call(e)}catch(n){je(n,e,"nextTick")}else t&&t(e)})),Ie||(Ie=!0,Ae()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function Fe(n){return function(e,t){if(void 0===t&&(t=dn),t)return function(n,e,t){var r=n.$options;r[e]=jt(r[e],t)}(t,n,e)}}Fe("beforeMount"),Fe("mounted"),Fe("beforeUpdate"),Fe("updated"),Fe("beforeDestroy"),Fe("destroyed"),Fe("activated"),Fe("deactivated"),Fe("serverPrefetch"),Fe("renderTracked"),Fe("renderTriggered"),Fe("errorCaptured");var Oe=new cn;function qe(n){return function n(e,t){var r,o,i=a(e);if(!i&&!m(e)||e.__v_skip||Object.isFrozen(e)||e instanceof pn)return;if(e.__ob__){var s=e.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(i)for(r=e.length;r--;)n(e[r],t);else if(Ln(e))n(e.value,t);else for(o=Object.keys(e),r=o.length;r--;)n(e[o[r]],t)}(n,Oe),Oe.clear(),n}var Ne,Ge=0,Ve=function(){function n(n,e,t,r,a){var o,i;o=this,void 0===(i=On&&!On._vm?On:n?n._scope:void 0)&&(i=On),i&&i.active&&i.effects.push(o),(this.vm=n)&&a&&(n._watcher=this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++Ge,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new cn,this.newDepIds=new cn,this.expression="",c(e)?this.getter=e:(this.getter=function(n){if(!W.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=I)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;xn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;je(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&qe(n),En(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():ht(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||m(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');Ce(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&w(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function We(n,e){Ne.$on(n,e)}function Ue(n,e){Ne.$off(n,e)}function Xe(n,e){var t=Ne;return function r(){var a=e.apply(null,arguments);null!==a&&t.$off(n,r)}}function Je(n,e,t){Ne=n,Wn(e,t||{},We,Ue,Xe,n),Ne=void 0}var Ye=null;function Ke(n){var e=Ye;return Ye=n,function(){Ye=e}}function Ze(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function Qe(n,e){if(e){if(n._directInactive=!1,Ze(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)Qe(n.$children[t]);nt(n,"activated")}}function nt(n,e,t,r){void 0===r&&(r=!0),xn();var a=dn;r&&hn(n);var o=n.$options[e],i="".concat(e," hook");if(o)for(var s=0,l=o.length;s<l;s++)Ce(o[s],n,t||null,n,i);n._hasHookEvent&&n.$emit("hook:"+e),r&&hn(a),En()}var et=[],tt=[],rt={},at=!1,ot=!1,it=0;var st=0,lt=Date.now;if(X&&!Y){var ct=window.performance;ct&&"function"==typeof ct.now&&lt()>document.createEvent("Event").timeStamp&&(lt=function(){return ct.now()})}var mt=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function dt(){var n,e;for(st=lt(),ot=!0,et.sort(mt),it=0;it<et.length;it++)(n=et[it]).before&&n.before(),e=n.id,rt[e]=null,n.run();var t=tt.slice(),r=et.slice();it=et.length=tt.length=0,rt={},at=ot=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,Qe(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],r=t.vm;r&&r._watcher===t&&r._isMounted&&!r._isDestroyed&&nt(r,"updated")}}(r),function(){for(var n=0;n<vn.length;n++){var e=vn[n];e.subs=e.subs.filter((function(n){return n})),e._pending=!1}vn.length=0}(),sn&&q.devtools&&sn.emit("flush")}function ht(n){var e=n.id;if(null==rt[e]&&(n!==bn.target||!n.noRecurse)){if(rt[e]=!0,ot){for(var t=et.length-1;t>it&&et[t].id>n.id;)t--;et.splice(t+1,0,n)}else et.push(n);at||(at=!0,Le(dt))}}function pt(n,e){if(n){for(var t=Object.create(null),r=mn?Reflect.ownKeys(n):Object.keys(n),a=0;a<r.length;a++){var o=r[a];if("__ob__"!==o){var i=n[o].from;if(i in e._provided)t[o]=e._provided[i];else if("default"in n[o]){var s=n[o].default;t[o]=c(s)?s.call(e):s}else 0}}return t}}function ut(n,e,t,o,i){var l,c=this,m=i.options;E(o,"_uid")?(l=Object.create(o))._original=o:(l=o,o=o._original);var d=s(m._compiled),h=!d;this.data=n,this.props=e,this.children=t,this.parent=o,this.listeners=n.on||r,this.injections=pt(m.inject,o),this.slots=function(){return c.$slots||fe(o,n.scopedSlots,c.$slots=he(t,o)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return fe(o,n.scopedSlots,this.slots())}}),d&&(this.$options=m,this.$slots=this.slots(),this.$scopedSlots=fe(o,n.scopedSlots,this.$slots)),m._scopeId?this._c=function(n,e,t,r){var i=Te(l,n,e,t,r,h);return i&&!a(i)&&(i.fnScopeId=m._scopeId,i.fnContext=o),i}:this._c=function(n,e,t,r){return Te(l,n,e,t,r,h)}}function ft(n,e,t,r,a){var o=yn(n);return o.fnContext=t,o.fnOptions=r,e.slot&&((o.data||(o.data={})).slot=e.slot),o}function yt(n,e){for(var t in e)n[T(t)]=e[t]}function gt(n){return n.name||n.__name||n._componentTag}de(ut.prototype);var vt={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;vt.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},r=n.data.inlineTemplate;i(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ye)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,a,o){var i=a.data.scopedSlots,s=n.$scopedSlots,l=!!(i&&!i.$stable||s!==r&&!s.$stable||i&&n.$scopedSlots.$key!==i.$key||!i&&n.$scopedSlots.$key),c=!!(o||n.$options._renderChildren||l),m=n.$vnode;n.$options._parentVnode=a,n.$vnode=a,n._vnode&&(n._vnode.parent=a),n.$options._renderChildren=o;var d=a.data.attrs||r;n._attrsProxy&&be(n._attrsProxy,d,m.data&&m.data.attrs||r,n,"$attrs")&&(c=!0),n.$attrs=d,t=t||r;var h=n.$options._parentListeners;if(n._listenersProxy&&be(n._listenersProxy,t,h||r,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,Je(n,t,h),e&&n.$options.props){Rn(!1);for(var p=n._props,u=n.$options._propKeys||[],f=0;f<u.length;f++){var y=u[f],g=n.$options.props;p[y]=zt(y,g,e,n)}Rn(!0),n.$options.propsData=e}c&&(n.$slots=he(o,a.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,nt(r,"mounted")),n.data.keepAlive&&(t._isMounted?((e=r)._inactive=!1,tt.push(e)):Qe(r,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,Ze(e))||e._inactive)){e._inactive=!0;for(var r=0;r<e.$children.length;r++)n(e.$children[r]);nt(e,"deactivated")}}(e,!0):e.$destroy())}},bt=Object.keys(vt);function wt(n,e,t,l,c){if(!o(n)){var d=t.$options._base;if(m(n)&&(n=d.extend(n)),"function"==typeof n){var h;if(o(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&i(n.errorComp))return n.errorComp;if(i(n.resolved))return n.resolved;var t=Ee;if(t&&i(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),s(n.loading)&&i(n.loadingComp))return n.loadingComp;if(t&&!i(n.owners)){var r=n.owners=[t],a=!0,l=null,c=null;t.$on("hook:destroyed",(function(){return w(r,t)}));var d=function(n){for(var e=0,t=r.length;e<t;e++)r[e].$forceUpdate();n&&(r.length=0,null!==l&&(clearTimeout(l),l=null),null!==c&&(clearTimeout(c),c=null))},h=$((function(t){n.resolved=ke(t,e),a?r.length=0:d(!0)})),p=$((function(e){i(n.errorComp)&&(n.error=!0,d(!0))})),u=n(h,p);return m(u)&&(f(u)?o(n.resolved)&&u.then(h,p):f(u.component)&&(u.component.then(h,p),i(u.error)&&(n.errorComp=ke(u.error,e)),i(u.loading)&&(n.loadingComp=ke(u.loading,e),0===u.delay?n.loading=!0:l=setTimeout((function(){l=null,o(n.resolved)&&o(n.error)&&(n.loading=!0,d(!1))}),u.delay||200)),i(u.timeout)&&(c=setTimeout((function(){c=null,o(n.resolved)&&p(null)}),u.timeout)))),a=!1,n.loading?n.loadingComp:n.resolved}}(h=n,d)))return function(n,e,t,r,a){var o=un();return o.asyncFactory=n,o.asyncMeta={data:e,context:t,children:r,tag:a},o}(h,e,t,l,c);e=e||{},Vt(n),i(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var o=e.on||(e.on={}),s=o[r],l=e.model.callback;i(s)?(a(s)?-1===s.indexOf(l):s!==l)&&(o[r]=[l].concat(s)):o[r]=l}(n.options,e);var p=function(n,e,t){var r=e.options.props;if(!o(r)){var a={},s=n.attrs,l=n.props;if(i(s)||i(l))for(var c in r){var m=R(c);Xn(a,l,c,m,!0)||Xn(a,s,c,m,!1)}return a}}(e,n);if(s(n.options.functional))return function(n,e,t,o,s){var l=n.options,c={},m=l.props;if(i(m))for(var d in m)c[d]=zt(d,m,e||r);else i(t.attrs)&&yt(c,t.attrs),i(t.props)&&yt(c,t.props);var h=new ut(t,c,s,o,n),p=l.render.call(null,h._c,h);if(p instanceof pn)return ft(p,t,h.parent,l,h);if(a(p)){for(var u=Jn(p)||[],f=new Array(u.length),y=0;y<u.length;y++)f[y]=ft(u[y],t,h.parent,l,h);return f}}(n,p,e,t,l);var u=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var y=e.slot;e={},y&&(e.slot=y)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<bt.length;t++){var r=bt[t],a=e[r],o=vt[r];a===o||a&&a._merged||(e[r]=a?xt(o,a):o)}}(e);var g=gt(n.options)||c;return new pn("vue-component-".concat(n.cid).concat(g?"-".concat(g):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:p,listeners:u,tag:c,children:l},h)}}}function xt(n,e){var t=function(t,r){n(t,r),e(t,r)};return t._merged=!0,t}var Et=I,kt=q.optionMergeStrategies;function St(n,e,t){if(void 0===t&&(t=!0),!e)return n;for(var r,a,o,i=mn?Reflect.ownKeys(e):Object.keys(e),s=0;s<i.length;s++)"__ob__"!==(r=i[s])&&(a=n[r],o=e[r],t&&E(n,r)?a!==o&&h(a)&&h(o)&&St(a,o):In(n,r,o));return n}function Tt(n,e,t){return t?function(){var r=c(e)?e.call(t,t):e,a=c(n)?n.call(t,t):n;return r?St(r,a):a}:e?n?function(){return St(c(e)?e.call(this,this):e,c(n)?n.call(this,this):n)}:e:n}function jt(n,e){var t=e?n?n.concat(e):a(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Ct(n,e,t,r){var a=Object.create(n||null);return e?z(a,e):a}kt.data=function(n,e,t){return t?Tt(n,e,t):e&&"function"!=typeof e?n:Tt(n,e)},O.forEach((function(n){kt[n]=jt})),F.forEach((function(n){kt[n+"s"]=Ct})),kt.watch=function(n,e,t,r){if(n===tn&&(n=void 0),e===tn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var o={};for(var i in z(o,n),e){var s=o[i],l=e[i];s&&!a(s)&&(s=[s]),o[i]=s?s.concat(l):a(l)?l:[l]}return o},kt.props=kt.methods=kt.inject=kt.computed=function(n,e,t,r){if(!n)return e;var a=Object.create(null);return z(a,n),e&&z(a,e),a},kt.provide=function(n,e){return n?function(){var t=Object.create(null);return St(t,c(n)?n.call(this):n),e&&St(t,c(e)?e.call(this):e,!1),t}:e};var Rt=function(n,e){return void 0===e?n:e};function Mt(n,e,t){if(c(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var r,o,i={};if(a(t))for(r=t.length;r--;)"string"==typeof(o=t[r])&&(i[T(o)]={type:null});else if(h(t))for(var s in t)o=t[s],i[T(s)]=h(o)?o:{type:o};else 0;n.props=i}}(e),function(n,e){var t=n.inject;if(t){var r=n.inject={};if(a(t))for(var o=0;o<t.length;o++)r[t[o]]={from:t[o]};else if(h(t))for(var i in t){var s=t[i];r[i]=h(s)?z({from:i},s):{from:s}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var r=e[t];c(r)&&(e[t]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(n=Mt(n,e.extends,t)),e.mixins))for(var r=0,o=e.mixins.length;r<o;r++)n=Mt(n,e.mixins[r],t);var i,s={};for(i in n)l(i);for(i in e)E(n,i)||l(i);function l(r){var a=kt[r]||Rt;s[r]=a(n[r],e[r],t,r)}return s}function At(n,e,t,r){if("string"==typeof t){var a=n[e];if(E(a,t))return a[t];var o=T(t);if(E(a,o))return a[o];var i=j(o);return E(a,i)?a[i]:a[t]||a[o]||a[i]}}function zt(n,e,t,r){var a=e[n],o=!E(t,n),i=t[n],s=Ht(Boolean,a.type);if(s>-1)if(o&&!E(a,"default"))i=!1;else if(""===i||i===R(n)){var l=Ht(String,a.type);(l<0||s<l)&&(i=!0)}if(void 0===i){i=function(n,e,t){if(!E(e,"default"))return;var r=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return c(r)&&"Function"!==It(e.type)?r.call(n):r}(r,a,n);var m=Cn;Rn(!0),zn(i),Rn(m)}return i}var _t=/^\s*function (\w+)/;function It(n){var e=n&&n.toString().match(_t);return e?e[1]:""}function Pt(n,e){return It(n)===It(e)}function Ht(n,e){if(!a(e))return Pt(e,n)?0:-1;for(var t=0,r=e.length;t<r;t++)if(Pt(e[t],n))return t;return-1}var Dt={enumerable:!0,configurable:!0,get:I,set:I};function Bt(n,e,t){Dt.get=function(){return this[e][t]},Dt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Dt)}function $t(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},r=n._props=Dn({}),a=n.$options._propKeys=[];n.$parent&&Rn(!1);var o=function(o){a.push(o);var i=zt(o,e,t,n);_n(r,o,i),o in n||Bt(n,"_props",o)};for(var i in e)o(i);Rn(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var r=n._setupContext=ve(n);hn(n),xn();var a=Ce(t,null,[n._props||Dn({}),r],n,"setup");if(En(),hn(),c(a))e.render=a;else if(m(a))if(n._setupState=a,a.__sfc){var o=n._setupProxy={};for(var i in a)"__sfc"!==i&&Fn(o,a,i)}else for(var i in a)G(i)||Fn(n,a,i);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?I:M(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;h(e=n._data=c(e)?function(n,e){xn();try{return n.call(e,e)}catch(n){return je(n,e,"data()"),{}}finally{En()}}(e,n):e||{})||(e={});var t=Object.keys(e),r=n.$options.props,a=(n.$options.methods,t.length);for(;a--;){var o=t[a];0,r&&E(r,o)||G(o)||Bt(n,"_data",o)}var i=zn(e);i&&i.vmCount++}(n);else{var t=zn(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),r=on();for(var a in e){var o=e[a],i=c(o)?o:o.get;0,r||(t[a]=new Ve(n,i||I,I,Lt)),a in n||Ft(n,a,o)}}(n,e.computed),e.watch&&e.watch!==tn&&function(n,e){for(var t in e){var r=e[t];if(a(r))for(var o=0;o<r.length;o++)Nt(n,t,r[o]);else Nt(n,t,r)}}(n,e.watch)}var Lt={lazy:!0};function Ft(n,e,t){var r=!on();c(t)?(Dt.get=r?Ot(e):qt(t),Dt.set=I):(Dt.get=t.get?r&&!1!==t.cache?Ot(e):qt(t.get):I,Dt.set=t.set||I),Object.defineProperty(n,e,Dt)}function Ot(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),bn.target&&e.depend(),e.value}}function qt(n){return function(){return n.call(this,this)}}function Nt(n,e,t,r){return h(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,r)}var Gt=0;function Vt(n){var e=n.options;if(n.super){var t=Vt(n.super);if(t!==n.superOptions){n.superOptions=t;var r=function(n){var e,t=n.options,r=n.sealedOptions;for(var a in t)t[a]!==r[a]&&(e||(e={}),e[a]=t[a]);return e}(n);r&&z(n.extendOptions,r),(e=n.options=Mt(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Wt(n){this._init(n)}function Ut(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,r=t.cid,a=n._Ctor||(n._Ctor={});if(a[r])return a[r];var o=gt(n)||gt(t.options);var i=function(n){this._init(n)};return(i.prototype=Object.create(t.prototype)).constructor=i,i.cid=e++,i.options=Mt(t.options,n),i.super=t,i.options.props&&function(n){var e=n.options.props;for(var t in e)Bt(n.prototype,"_props",t)}(i),i.options.computed&&function(n){var e=n.options.computed;for(var t in e)Ft(n.prototype,t,e[t])}(i),i.extend=t.extend,i.mixin=t.mixin,i.use=t.use,F.forEach((function(n){i[n]=t[n]})),o&&(i.options.components[o]=i),i.superOptions=t.options,i.extendOptions=n,i.sealedOptions=z({},i.options),a[r]=i,i}}function Xt(n){return n&&(gt(n.Ctor.options)||n.tag)}function Jt(n,e){return a(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!p(n)&&n.test(e)}function Yt(n,e){var t=n.cache,r=n.keys,a=n._vnode;for(var o in t){var i=t[o];if(i){var s=i.name;s&&!e(s)&&Kt(t,o,r,a)}}}function Kt(n,e,t,r){var a=n[e];!a||r&&a.tag===r.tag||a.componentInstance.$destroy(),n[e]=null,w(t,e)}Wt.prototype._init=function(n){var e=this;e._uid=Gt++,e._isVue=!0,e.__v_skip=!0,e._scope=new qn(!0),e._scope._vm=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),r=e._parentVnode;t.parent=e.parent,t._parentVnode=r;var a=r.componentOptions;t.propsData=a.propsData,t._parentListeners=a.listeners,t._renderChildren=a.children,t._componentTag=a.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=Mt(Vt(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Je(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,a=t&&t.context;n.$slots=he(e._renderChildren,a),n.$scopedSlots=t?fe(n.$parent,t.data.scopedSlots,n.$slots):r,n._c=function(e,t,r,a){return Te(n,e,t,r,a,!1)},n.$createElement=function(e,t,r,a){return Te(n,e,t,r,a,!0)};var o=t&&t.data;_n(n,"$attrs",o&&o.attrs||r,null,!0),_n(n,"$listeners",e._parentListeners||r,null,!0)}(e),nt(e,"beforeCreate",void 0,!1),function(n){var e=pt(n.$options.inject,n);e&&(Rn(!1),Object.keys(e).forEach((function(t){_n(n,t,e[t])})),Rn(!0))}(e),$t(e),function(n){var e=n.$options.provide;if(e){var t=c(e)?e.call(n):e;if(!m(t))return;for(var r=Nn(n),a=mn?Reflect.ownKeys(t):Object.keys(t),o=0;o<a.length;o++){var i=a[o];Object.defineProperty(r,i,Object.getOwnPropertyDescriptor(t,i))}}}(e),nt(e,"created"),e.$options.el&&e.$mount(e.$options.el)},function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=In,n.prototype.$delete=Pn,n.prototype.$watch=function(n,e,t){if(h(e))return Nt(this,n,e,t);(t=t||{}).user=!0;var r=new Ve(this,n,e,t);if(t.immediate){var a='callback for immediate watcher "'.concat(r.expression,'"');xn(),Ce(e,this,[r.value],this,a),En()}return function(){r.teardown()}}}(Wt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var r=this;if(a(n))for(var o=0,i=n.length;o<i;o++)r.$on(n[o],t);else(r._events[n]||(r._events[n]=[])).push(t),e.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,e){var t=this;function r(){t.$off(n,r),e.apply(t,arguments)}return r.fn=e,t.$on(n,r),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(a(n)){for(var r=0,o=n.length;r<o;r++)t.$off(n[r],e);return t}var i,s=t._events[n];if(!s)return t;if(!e)return t._events[n]=null,t;for(var l=s.length;l--;)if((i=s[l])===e||i.fn===e){s.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?A(t):t;for(var r=A(arguments,1),a='event handler for "'.concat(n,'"'),o=0,i=t.length;o<i;o++)Ce(t[o],e,r,e,a)}return e}}(Wt),function(n){n.prototype._update=function(n,e){var t=this,r=t.$el,a=t._vnode,o=Ke(t);t._vnode=n,t.$el=a?t.__patch__(a,n):t.__patch__(t.$el,n,e,!1),o(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var i=t;i&&i.$vnode&&i.$parent&&i.$vnode===i.$parent._vnode;)i.$parent.$el=i.$el,i=i.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){nt(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||w(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),nt(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Wt),function(n){de(n.prototype),n.prototype.$nextTick=function(n){return Le(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,r=t.render,o=t._parentVnode;o&&e._isMounted&&(e.$scopedSlots=fe(e.$parent,o.data.scopedSlots,e.$slots,e.$scopedSlots),e._slotsProxy&&xe(e._slotsProxy,e.$scopedSlots)),e.$vnode=o;try{hn(e),Ee=e,n=r.call(e._renderProxy,e.$createElement)}catch(t){je(t,e,"render"),n=e._vnode}finally{Ee=null,hn()}return a(n)&&1===n.length&&(n=n[0]),n instanceof pn||(n=un()),n.parent=o,n}}(Wt);var Zt=[String,RegExp,Array],Qt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Zt,exclude:Zt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,r=this.keyToCache;if(t){var a=t.tag,o=t.componentInstance,i=t.componentOptions;n[r]={name:Xt(i),tag:a,componentInstance:o},e.push(r),this.max&&e.length>parseInt(this.max)&&Kt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Kt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Yt(n,(function(n){return Jt(e,n)}))})),this.$watch("exclude",(function(e){Yt(n,(function(n){return!Jt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Se(n),t=e&&e.componentOptions;if(t){var r=Xt(t),a=this.include,o=this.exclude;if(a&&(!r||!Jt(a,r))||o&&r&&Jt(o,r))return e;var i=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;i[l]?(e.componentInstance=i[l].componentInstance,w(s,l),s.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return q}};Object.defineProperty(n,"config",e),n.util={warn:Et,extend:z,mergeOptions:Mt,defineReactive:_n},n.set=In,n.delete=Pn,n.nextTick=Le,n.observable=function(n){return zn(n),n},n.options=Object.create(null),F.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,z(n.options.components,Qt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=A(arguments,1);return t.unshift(this),c(n.install)?n.install.apply(n,t):c(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Mt(this.options,n),this}}(n),Ut(n),function(n){F.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&h(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&c(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Wt),Object.defineProperty(Wt.prototype,"$isServer",{get:on}),Object.defineProperty(Wt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Wt,"FunctionalRenderContext",{value:ut}),Wt.version="2.7.14";var nr=v("style,class"),er=v("input,textarea,option,select,progress"),tr=v("contenteditable,draggable,spellcheck"),rr=v("events,caret,typing,plaintext-only"),ar=v("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),or="http://www.w3.org/1999/xlink",ir=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},sr=function(n){return ir(n)?n.slice(6,n.length):""},lr=function(n){return null==n||!1===n};function cr(n){for(var e=n.data,t=n,r=n;i(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(e=mr(r.data,e));for(;i(t=t.parent);)t&&t.data&&(e=mr(e,t.data));return function(n,e){if(i(n)||i(e))return dr(n,hr(e));return""}(e.staticClass,e.class)}function mr(n,e){return{staticClass:dr(n.staticClass,e.staticClass),class:i(n.class)?[n.class,e.class]:e.class}}function dr(n,e){return n?e?n+" "+e:n:e||""}function hr(n){return Array.isArray(n)?function(n){for(var e,t="",r=0,a=n.length;r<a;r++)i(e=hr(n[r]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):m(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var pr={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},ur=v("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),fr=v("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),yr=function(n){return ur(n)||fr(n)};var gr=Object.create(null);var vr=v("text,number,password,search,email,tel,url");var br=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(pr[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),wr={create:function(n,e){xr(e)},update:function(n,e){n.data.ref!==e.data.ref&&(xr(n,!0),xr(e))},destroy:function(n){xr(n,!0)}};function xr(n,e){var t=n.data.ref;if(i(t)){var r=n.context,o=n.componentInstance||n.elm,s=e?null:o,l=e?void 0:o;if(c(t))Ce(t,r,[s],r,"template ref function");else{var m=n.data.refInFor,d="string"==typeof t||"number"==typeof t,h=Ln(t),p=r.$refs;if(d||h)if(m){var u=d?p[t]:t.value;e?a(u)&&w(u,o):a(u)?u.includes(o)||u.push(o):d?(p[t]=[o],Er(r,t,p[t])):t.value=[o]}else if(d){if(e&&p[t]!==o)return;p[t]=l,Er(r,t,s)}else if(h){if(e&&t.value!==o)return;t.value=s}else 0}}}function Er(n,e,t){var r=n._setupState;r&&E(r,e)&&(Ln(r[e])?r[e].value=t:r[e]=t)}var kr=new pn("",{},[]),Sr=["create","activate","update","remove","destroy"];function Tr(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&i(n.data)===i(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,r=i(t=n.data)&&i(t=t.attrs)&&t.type,a=i(t=e.data)&&i(t=t.attrs)&&t.type;return r===a||vr(r)&&vr(a)}(n,e)||s(n.isAsyncPlaceholder)&&o(e.asyncFactory.error))}function jr(n,e,t){var r,a,o={};for(r=e;r<=t;++r)i(a=n[r].key)&&(o[a]=r);return o}var Cr={create:Rr,update:Rr,destroy:function(n){Rr(n,kr)}};function Rr(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,r,a,o=n===kr,i=e===kr,s=Ar(n.data.directives,n.context),l=Ar(e.data.directives,e.context),c=[],m=[];for(t in l)r=s[t],a=l[t],r?(a.oldValue=r.value,a.oldArg=r.arg,_r(a,"update",e,n),a.def&&a.def.componentUpdated&&m.push(a)):(_r(a,"bind",e,n),a.def&&a.def.inserted&&c.push(a));if(c.length){var d=function(){for(var t=0;t<c.length;t++)_r(c[t],"inserted",e,n)};o?Un(e,"insert",d):d()}m.length&&Un(e,"postpatch",(function(){for(var t=0;t<m.length;t++)_r(m[t],"componentUpdated",e,n)}));if(!o)for(t in s)l[t]||_r(s[t],"unbind",n,n,i)}(n,e)}var Mr=Object.create(null);function Ar(n,e){var t,r,a=Object.create(null);if(!n)return a;for(t=0;t<n.length;t++){if((r=n[t]).modifiers||(r.modifiers=Mr),a[zr(r)]=r,e._setupState&&e._setupState.__sfc){var o=r.def||At(e,"_setupState","v-"+r.name);r.def="function"==typeof o?{bind:o,update:o}:o}r.def=r.def||At(e.$options,"directives",r.name)}return a}function zr(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function _r(n,e,t,r,a){var o=n.def&&n.def[e];if(o)try{o(t.elm,n,t,r,a)}catch(r){je(r,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var Ir=[wr,Cr];function Pr(n,e){var t=e.componentOptions;if(!(i(t)&&!1===t.Ctor.options.inheritAttrs||o(n.data.attrs)&&o(e.data.attrs))){var r,a,l=e.elm,c=n.data.attrs||{},m=e.data.attrs||{};for(r in(i(m.__ob__)||s(m._v_attr_proxy))&&(m=e.data.attrs=z({},m)),m)a=m[r],c[r]!==a&&Hr(l,r,a,e.data.pre);for(r in(Y||Z)&&m.value!==c.value&&Hr(l,"value",m.value),c)o(m[r])&&(ir(r)?l.removeAttributeNS(or,sr(r)):tr(r)||l.removeAttribute(r))}}function Hr(n,e,t,r){r||n.tagName.indexOf("-")>-1?Dr(n,e,t):ar(e)?lr(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):tr(e)?n.setAttribute(e,function(n,e){return lr(e)||"false"===e?"false":"contenteditable"===n&&rr(e)?e:"true"}(e,t)):ir(e)?lr(t)?n.removeAttributeNS(or,sr(e)):n.setAttributeNS(or,e,t):Dr(n,e,t)}function Dr(n,e,t){if(lr(t))n.removeAttribute(e);else{if(Y&&!K&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var r=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(e,t)}}var Br={create:Pr,update:Pr};function $r(n,e){var t=e.elm,r=e.data,a=n.data;if(!(o(r.staticClass)&&o(r.class)&&(o(a)||o(a.staticClass)&&o(a.class)))){var s=cr(e),l=t._transitionClasses;i(l)&&(s=dr(s,hr(l))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var Lr,Fr={create:$r,update:$r};function Or(n,e,t){var r=Lr;return function a(){var o=e.apply(null,arguments);null!==o&&Gr(n,a,t,r)}}var qr=ze&&!(en&&Number(en[1])<=53);function Nr(n,e,t,r){if(qr){var a=st,o=e;e=o._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=a||n.timeStamp<=0||n.target.ownerDocument!==document)return o.apply(this,arguments)}}Lr.addEventListener(n,e,rn?{capture:t,passive:r}:t)}function Gr(n,e,t,r){(r||Lr).removeEventListener(n,e._wrapper||e,t)}function Vr(n,e){if(!o(n.data.on)||!o(e.data.on)){var t=e.data.on||{},r=n.data.on||{};Lr=e.elm||n.elm,function(n){if(i(n.__r)){var e=Y?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}i(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Wn(t,r,Nr,Gr,Or,e.context),Lr=void 0}}var Wr,Ur={create:Vr,update:Vr,destroy:function(n){return Vr(n,kr)}};function Xr(n,e){if(!o(n.data.domProps)||!o(e.data.domProps)){var t,r,a=e.elm,l=n.data.domProps||{},c=e.data.domProps||{};for(t in(i(c.__ob__)||s(c._v_attr_proxy))&&(c=e.data.domProps=z({},c)),l)t in c||(a[t]="");for(t in c){if(r=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),r===l[t])continue;1===a.childNodes.length&&a.removeChild(a.childNodes[0])}if("value"===t&&"PROGRESS"!==a.tagName){a._value=r;var m=o(r)?"":String(r);Jr(a,m)&&(a.value=m)}else if("innerHTML"===t&&fr(a.tagName)&&o(a.innerHTML)){(Wr=Wr||document.createElement("div")).innerHTML="<svg>".concat(r,"</svg>");for(var d=Wr.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;d.firstChild;)a.appendChild(d.firstChild)}else if(r!==l[t])try{a[t]=r}catch(n){}}}}function Jr(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,r=n._vModifiers;if(i(r)){if(r.number)return g(t)!==g(e);if(r.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Yr={create:Xr,update:Xr},Kr=k((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(t);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function Zr(n){var e=Qr(n.style);return n.staticStyle?z(n.staticStyle,e):e}function Qr(n){return Array.isArray(n)?_(n):"string"==typeof n?Kr(n):n}var na,ea=/^--/,ta=/\s*!important$/,ra=function(n,e,t){if(ea.test(e))n.style.setProperty(e,t);else if(ta.test(t))n.style.setProperty(R(e),t.replace(ta,""),"important");else{var r=oa(e);if(Array.isArray(t))for(var a=0,o=t.length;a<o;a++)n.style[r]=t[a];else n.style[r]=t}},aa=["Webkit","Moz","ms"],oa=k((function(n){if(na=na||document.createElement("div").style,"filter"!==(n=T(n))&&n in na)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<aa.length;t++){var r=aa[t]+e;if(r in na)return r}}));function ia(n,e){var t=e.data,r=n.data;if(!(o(t.staticStyle)&&o(t.style)&&o(r.staticStyle)&&o(r.style))){var a,s,l=e.elm,c=r.staticStyle,m=r.normalizedStyle||r.style||{},d=c||m,h=Qr(e.data.style)||{};e.data.normalizedStyle=i(h.__ob__)?z({},h):h;var p=function(n,e){var t,r={};if(e)for(var a=n;a.componentInstance;)(a=a.componentInstance._vnode)&&a.data&&(t=Zr(a.data))&&z(r,t);(t=Zr(n.data))&&z(r,t);for(var o=n;o=o.parent;)o.data&&(t=Zr(o.data))&&z(r,t);return r}(e,!0);for(s in d)o(p[s])&&ra(l,s,"");for(s in p)(a=p[s])!==d[s]&&ra(l,s,null==a?"":a)}}var sa={create:ia,update:ia},la=/\s+/;function ca(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(la).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function ma(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(la).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),r=" "+e+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function da(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&z(e,ha(n.name||"v")),z(e,n),e}return"string"==typeof n?ha(n):void 0}}var ha=k((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),pa=X&&!K,ua="transition",fa="transitionend",ya="animation",ga="animationend";pa&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(ua="WebkitTransition",fa="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(ya="WebkitAnimation",ga="webkitAnimationEnd"));var va=X?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function ba(n){va((function(){va(n)}))}function wa(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),ca(n,e))}function xa(n,e){n._transitionClasses&&w(n._transitionClasses,e),ma(n,e)}function Ea(n,e,t){var r=Sa(n,e),a=r.type,o=r.timeout,i=r.propCount;if(!a)return t();var s="transition"===a?fa:ga,l=0,c=function(){n.removeEventListener(s,m),t()},m=function(e){e.target===n&&++l>=i&&c()};setTimeout((function(){l<i&&c()}),o+1),n.addEventListener(s,m)}var ka=/\b(transform|all)(,|$)/;function Sa(n,e){var t,r=window.getComputedStyle(n),a=(r[ua+"Delay"]||"").split(", "),o=(r[ua+"Duration"]||"").split(", "),i=Ta(a,o),s=(r[ya+"Delay"]||"").split(", "),l=(r[ya+"Duration"]||"").split(", "),c=Ta(s,l),m=0,d=0;return"transition"===e?i>0&&(t="transition",m=i,d=o.length):"animation"===e?c>0&&(t="animation",m=c,d=l.length):d=(t=(m=Math.max(i,c))>0?i>c?"transition":"animation":null)?"transition"===t?o.length:l.length:0,{type:t,timeout:m,propCount:d,hasTransform:"transition"===t&&ka.test(r[ua+"Property"])}}function Ta(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return ja(e)+ja(n[t])})))}function ja(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function Ca(n,e){var t=n.elm;i(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=da(n.data.transition);if(!o(r)&&!i(t._enterCb)&&1===t.nodeType){for(var a=r.css,s=r.type,l=r.enterClass,d=r.enterToClass,h=r.enterActiveClass,p=r.appearClass,u=r.appearToClass,f=r.appearActiveClass,y=r.beforeEnter,v=r.enter,b=r.afterEnter,w=r.enterCancelled,x=r.beforeAppear,E=r.appear,k=r.afterAppear,S=r.appearCancelled,T=r.duration,j=Ye,C=Ye.$vnode;C&&C.parent;)j=C.context,C=C.parent;var R=!j._isMounted||!n.isRootInsert;if(!R||E||""===E){var M=R&&p?p:l,A=R&&f?f:h,z=R&&u?u:d,_=R&&x||y,I=R&&c(E)?E:v,P=R&&k||b,H=R&&S||w,D=g(m(T)?T.enter:T);0;var B=!1!==a&&!K,L=Aa(I),F=t._enterCb=$((function(){B&&(xa(t,z),xa(t,A)),F.cancelled?(B&&xa(t,M),H&&H(t)):P&&P(t),t._enterCb=null}));n.data.show||Un(n,"insert",(function(){var e=t.parentNode,r=e&&e._pending&&e._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),I&&I(t,F)})),_&&_(t),B&&(wa(t,M),wa(t,A),ba((function(){xa(t,M),F.cancelled||(wa(t,z),L||(Ma(D)?setTimeout(F,D):Ea(t,s,F)))}))),n.data.show&&(e&&e(),I&&I(t,F)),B||L||F()}}}function Ra(n,e){var t=n.elm;i(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=da(n.data.transition);if(o(r)||1!==t.nodeType)return e();if(!i(t._leaveCb)){var a=r.css,s=r.type,l=r.leaveClass,c=r.leaveToClass,d=r.leaveActiveClass,h=r.beforeLeave,p=r.leave,u=r.afterLeave,f=r.leaveCancelled,y=r.delayLeave,v=r.duration,b=!1!==a&&!K,w=Aa(p),x=g(m(v)?v.leave:v);0;var E=t._leaveCb=$((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),b&&(xa(t,c),xa(t,d)),E.cancelled?(b&&xa(t,l),f&&f(t)):(e(),u&&u(t)),t._leaveCb=null}));y?y(k):k()}function k(){E.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),h&&h(t),b&&(wa(t,l),wa(t,d),ba((function(){xa(t,l),E.cancelled||(wa(t,c),w||(Ma(x)?setTimeout(E,x):Ea(t,s,E)))}))),p&&p(t,E),b||w||E())}}function Ma(n){return"number"==typeof n&&!isNaN(n)}function Aa(n){if(o(n))return!1;var e=n.fns;return i(e)?Aa(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function za(n,e){!0!==e.data.show&&Ca(e)}var _a=function(n){var e,t,r={},c=n.modules,m=n.nodeOps;for(e=0;e<Sr.length;++e)for(r[Sr[e]]=[],t=0;t<c.length;++t)i(c[t][Sr[e]])&&r[Sr[e]].push(c[t][Sr[e]]);function d(n){var e=m.parentNode(n);i(e)&&m.removeChild(e,n)}function h(n,e,t,a,o,l,c){if(i(n.elm)&&i(l)&&(n=l[c]=yn(n)),n.isRootInsert=!o,!function(n,e,t,a){var o=n.data;if(i(o)){var l=i(n.componentInstance)&&o.keepAlive;if(i(o=o.hook)&&i(o=o.init)&&o(n,!1),i(n.componentInstance))return p(n,e),u(t,n.elm,a),s(l)&&function(n,e,t,a){var o,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,i(o=s.data)&&i(o=o.transition)){for(o=0;o<r.activate.length;++o)r.activate[o](kr,s);e.push(s);break}u(t,n.elm,a)}(n,e,t,a),!0}}(n,e,t,a)){var d=n.data,h=n.children,y=n.tag;i(y)?(n.elm=n.ns?m.createElementNS(n.ns,y):m.createElement(y,n),b(n),f(n,h,e),i(d)&&g(n,e),u(t,n.elm,a)):s(n.isComment)?(n.elm=m.createComment(n.text),u(t,n.elm,a)):(n.elm=m.createTextNode(n.text),u(t,n.elm,a))}}function p(n,e){i(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,y(n)?(g(n,e),b(n)):(xr(n),e.push(n))}function u(n,e,t){i(n)&&(i(t)?m.parentNode(t)===n&&m.insertBefore(n,e,t):m.appendChild(n,e))}function f(n,e,t){if(a(e)){0;for(var r=0;r<e.length;++r)h(e[r],t,n.elm,null,!0,e,r)}else l(n.text)&&m.appendChild(n.elm,m.createTextNode(String(n.text)))}function y(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return i(n.tag)}function g(n,t){for(var a=0;a<r.create.length;++a)r.create[a](kr,n);i(e=n.data.hook)&&(i(e.create)&&e.create(kr,n),i(e.insert)&&t.push(n))}function b(n){var e;if(i(e=n.fnScopeId))m.setStyleScope(n.elm,e);else for(var t=n;t;)i(e=t.context)&&i(e=e.$options._scopeId)&&m.setStyleScope(n.elm,e),t=t.parent;i(e=Ye)&&e!==n.context&&e!==n.fnContext&&i(e=e.$options._scopeId)&&m.setStyleScope(n.elm,e)}function w(n,e,t,r,a,o){for(;r<=a;++r)h(t[r],o,n,e,!1,t,r)}function x(n){var e,t,a=n.data;if(i(a))for(i(e=a.hook)&&i(e=e.destroy)&&e(n),e=0;e<r.destroy.length;++e)r.destroy[e](n);if(i(e=n.children))for(t=0;t<n.children.length;++t)x(n.children[t])}function E(n,e,t){for(;e<=t;++e){var r=n[e];i(r)&&(i(r.tag)?(k(r),x(r)):d(r.elm))}}function k(n,e){if(i(e)||i(n.data)){var t,a=r.remove.length+1;for(i(e)?e.listeners+=a:e=function(n,e){function t(){0==--t.listeners&&d(n)}return t.listeners=e,t}(n.elm,a),i(t=n.componentInstance)&&i(t=t._vnode)&&i(t.data)&&k(t,e),t=0;t<r.remove.length;++t)r.remove[t](n,e);i(t=n.data.hook)&&i(t=t.remove)?t(n,e):e()}else d(n.elm)}function S(n,e,t,r){for(var a=t;a<r;a++){var o=e[a];if(i(o)&&Tr(n,o))return a}}function T(n,e,t,a,l,c){if(n!==e){i(e.elm)&&i(a)&&(e=a[l]=yn(e));var d=e.elm=n.elm;if(s(n.isAsyncPlaceholder))i(e.asyncFactory.resolved)?R(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var p,u=e.data;i(u)&&i(p=u.hook)&&i(p=p.prepatch)&&p(n,e);var f=n.children,g=e.children;if(i(u)&&y(e)){for(p=0;p<r.update.length;++p)r.update[p](n,e);i(p=u.hook)&&i(p=p.update)&&p(n,e)}o(e.text)?i(f)&&i(g)?f!==g&&function(n,e,t,r,a){var s,l,c,d=0,p=0,u=e.length-1,f=e[0],y=e[u],g=t.length-1,v=t[0],b=t[g],x=!a;for(0;d<=u&&p<=g;)o(f)?f=e[++d]:o(y)?y=e[--u]:Tr(f,v)?(T(f,v,r,t,p),f=e[++d],v=t[++p]):Tr(y,b)?(T(y,b,r,t,g),y=e[--u],b=t[--g]):Tr(f,b)?(T(f,b,r,t,g),x&&m.insertBefore(n,f.elm,m.nextSibling(y.elm)),f=e[++d],b=t[--g]):Tr(y,v)?(T(y,v,r,t,p),x&&m.insertBefore(n,y.elm,f.elm),y=e[--u],v=t[++p]):(o(s)&&(s=jr(e,d,u)),o(l=i(v.key)?s[v.key]:S(v,e,d,u))?h(v,r,n,f.elm,!1,t,p):Tr(c=e[l],v)?(T(c,v,r,t,p),e[l]=void 0,x&&m.insertBefore(n,c.elm,f.elm)):h(v,r,n,f.elm,!1,t,p),v=t[++p]);d>u?w(n,o(t[g+1])?null:t[g+1].elm,t,p,g,r):p>g&&E(e,d,u)}(d,f,g,t,c):i(g)?(i(n.text)&&m.setTextContent(d,""),w(d,null,g,0,g.length-1,t)):i(f)?E(f,0,f.length-1):i(n.text)&&m.setTextContent(d,""):n.text!==e.text&&m.setTextContent(d,e.text),i(u)&&i(p=u.hook)&&i(p=p.postpatch)&&p(n,e)}}}function j(n,e,t){if(s(t)&&i(n.parent))n.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}var C=v("attrs,class,staticClass,staticStyle,key");function R(n,e,t,r){var a,o=e.tag,l=e.data,c=e.children;if(r=r||l&&l.pre,e.elm=n,s(e.isComment)&&i(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(i(l)&&(i(a=l.hook)&&i(a=a.init)&&a(e,!0),i(a=e.componentInstance)))return p(e,t),!0;if(i(o)){if(i(c))if(n.hasChildNodes())if(i(a=l)&&i(a=a.domProps)&&i(a=a.innerHTML)){if(a!==n.innerHTML)return!1}else{for(var m=!0,d=n.firstChild,h=0;h<c.length;h++){if(!d||!R(d,c[h],t,r)){m=!1;break}d=d.nextSibling}if(!m||d)return!1}else f(e,c,t);if(i(l)){var u=!1;for(var y in l)if(!C(y)){u=!0,g(e,t);break}!u&&l.class&&qe(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,a){if(!o(e)){var l,c=!1,d=[];if(o(n))c=!0,h(e,d);else{var p=i(n.nodeType);if(!p&&Tr(n,e))T(n,e,d,null,null,a);else{if(p){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&R(n,e,d))return j(e,d,!0),n;l=n,n=new pn(m.tagName(l).toLowerCase(),{},[],void 0,l)}var u=n.elm,f=m.parentNode(u);if(h(e,d,u._leaveCb?null:f,m.nextSibling(u)),i(e.parent))for(var g=e.parent,v=y(e);g;){for(var b=0;b<r.destroy.length;++b)r.destroy[b](g);if(g.elm=e.elm,v){for(var w=0;w<r.create.length;++w)r.create[w](kr,g);var k=g.data.hook.insert;if(k.merged)for(var S=1;S<k.fns.length;S++)k.fns[S]()}else xr(g);g=g.parent}i(f)?E([n],0,0):i(n.tag)&&x(n)}}return j(e,d,c),e.elm}i(n)&&x(n)}}({nodeOps:br,modules:[Br,Fr,Ur,Yr,sa,X?{create:za,activate:za,remove:function(n,e){!0!==n.data.show?Ra(n,e):e()}}:{}].concat(Ir)});K&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&Fa(n,"input")}));var Ia={inserted:function(n,e,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?Un(t,"postpatch",(function(){Ia.componentUpdated(n,e,t)})):Pa(n,e,t.context),n._vOptions=[].map.call(n.options,Ba)):("textarea"===t.tag||vr(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",$a),n.addEventListener("compositionend",La),n.addEventListener("change",La),K&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Pa(n,e,t.context);var r=n._vOptions,a=n._vOptions=[].map.call(n.options,Ba);if(a.some((function(n,e){return!D(n,r[e])})))(n.multiple?e.value.some((function(n){return Da(n,a)})):e.value!==e.oldValue&&Da(e.value,a))&&Fa(n,"change")}}};function Pa(n,e,t){Ha(n,e,t),(Y||Z)&&setTimeout((function(){Ha(n,e,t)}),0)}function Ha(n,e,t){var r=e.value,a=n.multiple;if(!a||Array.isArray(r)){for(var o,i,s=0,l=n.options.length;s<l;s++)if(i=n.options[s],a)o=B(r,Ba(i))>-1,i.selected!==o&&(i.selected=o);else if(D(Ba(i),r))return void(n.selectedIndex!==s&&(n.selectedIndex=s));a||(n.selectedIndex=-1)}}function Da(n,e){return e.every((function(e){return!D(e,n)}))}function Ba(n){return"_value"in n?n._value:n.value}function $a(n){n.target.composing=!0}function La(n){n.target.composing&&(n.target.composing=!1,Fa(n.target,"input"))}function Fa(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function Oa(n){return!n.componentInstance||n.data&&n.data.transition?n:Oa(n.componentInstance._vnode)}var qa={model:Ia,show:{bind:function(n,e,t){var r=e.value,a=(t=Oa(t)).data&&t.data.transition,o=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&a?(t.data.show=!0,Ca(t,(function(){n.style.display=o}))):n.style.display=r?o:"none"},update:function(n,e,t){var r=e.value;!r!=!e.oldValue&&((t=Oa(t)).data&&t.data.transition?(t.data.show=!0,r?Ca(t,(function(){n.style.display=n.__vOriginalDisplay})):Ra(t,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,r,a){a||(n.style.display=n.__vOriginalDisplay)}}},Na={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Ga(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Ga(Se(e.children)):n}function Va(n){var e={},t=n.$options;for(var r in t.propsData)e[r]=n[r];var a=t._parentListeners;for(var r in a)e[T(r)]=a[r];return e}function Wa(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Ua=function(n){return n.tag||ue(n)},Xa=function(n){return"show"===n.name},Ja={name:"transition",props:Na,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Ua)).length){0;var r=this.mode;0;var a=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return a;var o=Ga(a);if(!o)return a;if(this._leaving)return Wa(n,a);var i="__transition-".concat(this._uid,"-");o.key=null==o.key?o.isComment?i+"comment":i+o.tag:l(o.key)?0===String(o.key).indexOf(i)?o.key:i+o.key:o.key;var s=(o.data||(o.data={})).transition=Va(this),c=this._vnode,m=Ga(c);if(o.data.directives&&o.data.directives.some(Xa)&&(o.data.show=!0),m&&m.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(o,m)&&!ue(m)&&(!m.componentInstance||!m.componentInstance._vnode.isComment)){var d=m.data.transition=z({},s);if("out-in"===r)return this._leaving=!0,Un(d,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Wa(n,a);if("in-out"===r){if(ue(o))return c;var h,p=function(){h()};Un(s,"afterEnter",p),Un(s,"enterCancelled",p),Un(d,"delayLeave",(function(n){h=n}))}}return a}}},Ya=z({tag:String,moveClass:String},Na);function Ka(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Za(n){n.data.newPos=n.elm.getBoundingClientRect()}function Qa(n){var e=n.data.pos,t=n.data.newPos,r=e.left-t.left,a=e.top-t.top;if(r||a){n.data.moved=!0;var o=n.elm.style;o.transform=o.WebkitTransform="translate(".concat(r,"px,").concat(a,"px)"),o.transitionDuration="0s"}}delete Ya.mode;var no={Transition:Ja,TransitionGroup:{props:Ya,beforeMount:function(){var n=this,e=this._update;this._update=function(t,r){var a=Ke(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,a(),e.call(n,t,r)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,a=this.$slots.default||[],o=this.children=[],i=Va(this),s=0;s<a.length;s++){if((m=a[s]).tag)if(null!=m.key&&0!==String(m.key).indexOf("__vlist"))o.push(m),t[m.key]=m,(m.data||(m.data={})).transition=i;else;}if(r){var l=[],c=[];for(s=0;s<r.length;s++){var m;(m=r[s]).data.transition=i,m.data.pos=m.elm.getBoundingClientRect(),t[m.key]?l.push(m):c.push(m)}this.kept=n(e,null,l),this.removed=c}return n(e,null,o)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Ka),n.forEach(Za),n.forEach(Qa),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,r=t.style;wa(t,e),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(fa,t._moveCb=function n(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(fa,n),t._moveCb=null,xa(t,e))})}})))},methods:{hasMove:function(n,e){if(!pa)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){ma(t,n)})),ca(t,e),t.style.display="none",this.$el.appendChild(t);var r=Sa(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};function eo(n,e){for(var t in e)n[t]=e[t];return n}Wt.config.mustUseProp=function(n,e,t){return"value"===t&&er(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Wt.config.isReservedTag=yr,Wt.config.isReservedAttr=nr,Wt.config.getTagNamespace=function(n){return fr(n)?"svg":"math"===n?"math":void 0},Wt.config.isUnknownElement=function(n){if(!X)return!0;if(yr(n))return!1;if(n=n.toLowerCase(),null!=gr[n])return gr[n];var e=document.createElement(n);return n.indexOf("-")>-1?gr[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:gr[n]=/HTMLUnknownElement/.test(e.toString())},z(Wt.options.directives,qa),z(Wt.options.components,no),Wt.prototype.__patch__=X?_a:I,Wt.prototype.$mount=function(n,e){return function(n,e,t){var r;n.$el=e,n.$options.render||(n.$options.render=un),nt(n,"beforeMount"),r=function(){n._update(n._render(),t)},new Ve(n,r,I,{before:function(){n._isMounted&&!n._isDestroyed&&nt(n,"beforeUpdate")}},!0),t=!1;var a=n._preWatchers;if(a)for(var o=0;o<a.length;o++)a[o].run();return null==n.$vnode&&(n._isMounted=!0,nt(n,"mounted")),n}(this,n=n&&X?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},X&&setTimeout((function(){q.devtools&&sn&&sn.emit("init",Wt)}),0);var to=/[!'()*]/g,ro=function(n){return"%"+n.charCodeAt(0).toString(16)},ao=/%2C/g,oo=function(n){return encodeURIComponent(n).replace(to,ro).replace(ao,",")};function io(n){try{return decodeURIComponent(n)}catch(n){0}return n}var so=function(n){return null==n||"object"==typeof n?n:String(n)};function lo(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),r=io(t.shift()),a=t.length>0?io(t.join("=")):null;void 0===e[r]?e[r]=a:Array.isArray(e[r])?e[r].push(a):e[r]=[e[r],a]})),e):e}function co(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return oo(e);if(Array.isArray(t)){var r=[];return t.forEach((function(n){void 0!==n&&(null===n?r.push(oo(e)):r.push(oo(e)+"="+oo(n)))})),r.join("&")}return oo(e)+"="+oo(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var mo=/\/?$/;function ho(n,e,t,r){var a=r&&r.options.stringifyQuery,o=e.query||{};try{o=po(o)}catch(n){}var i={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:o,params:e.params||{},fullPath:yo(e,a),matched:n?fo(n):[]};return t&&(i.redirectedFrom=yo(t,a)),Object.freeze(i)}function po(n){if(Array.isArray(n))return n.map(po);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=po(n[t]);return e}return n}var uo=ho(null,{path:"/"});function fo(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function yo(n,e){var t=n.path,r=n.query;void 0===r&&(r={});var a=n.hash;return void 0===a&&(a=""),(t||"/")+(e||co)(r)+a}function go(n,e,t){return e===uo?n===e:!!e&&(n.path&&e.path?n.path.replace(mo,"")===e.path.replace(mo,"")&&(t||n.hash===e.hash&&vo(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&vo(n.query,e.query)&&vo(n.params,e.params))))}function vo(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),r=Object.keys(e).sort();return t.length===r.length&&t.every((function(t,a){var o=n[t];if(r[a]!==t)return!1;var i=e[t];return null==o||null==i?o===i:"object"==typeof o&&"object"==typeof i?vo(o,i):String(o)===String(i)}))}function bo(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var r in t.instances){var a=t.instances[r],o=t.enteredCbs[r];if(a&&o){delete t.enteredCbs[r];for(var i=0;i<o.length;i++)a._isBeingDestroyed||o[i](a)}}}}var wo={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,r=e.children,a=e.parent,o=e.data;o.routerView=!0;for(var i=a.$createElement,s=t.name,l=a.$route,c=a._routerViewCache||(a._routerViewCache={}),m=0,d=!1;a&&a._routerRoot!==a;){var h=a.$vnode?a.$vnode.data:{};h.routerView&&m++,h.keepAlive&&a._directInactive&&a._inactive&&(d=!0),a=a.$parent}if(o.routerViewDepth=m,d){var p=c[s],u=p&&p.component;return u?(p.configProps&&xo(u,o,p.route,p.configProps),i(u,o,r)):i()}var f=l.matched[m],y=f&&f.components[s];if(!f||!y)return c[s]=null,i();c[s]={component:y},o.registerRouteInstance=function(n,e){var t=f.instances[s];(e&&t!==n||!e&&t===n)&&(f.instances[s]=e)},(o.hook||(o.hook={})).prepatch=function(n,e){f.instances[s]=e.componentInstance},o.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==f.instances[s]&&(f.instances[s]=n.componentInstance),bo(l)};var g=f.props&&f.props[s];return g&&(eo(c[s],{route:l,configProps:g}),xo(y,o,l,g)),i(y,o,r)}};function xo(n,e,t,r){var a=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,r);if(a){a=e.props=eo({},a);var o=e.attrs=e.attrs||{};for(var i in a)n.props&&i in n.props||(o[i]=a[i],delete a[i])}}function Eo(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var a=e.split("/");t&&a[a.length-1]||a.pop();for(var o=n.replace(/^\//,"").split("/"),i=0;i<o.length;i++){var s=o[i];".."===s?a.pop():"."!==s&&a.push(s)}return""!==a[0]&&a.unshift(""),a.join("/")}function ko(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var So=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},To=Lo,jo=zo,Co=function(n,e){return Io(zo(n,e),e)},Ro=Io,Mo=$o,Ao=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function zo(n,e){for(var t,r=[],a=0,o=0,i="",s=e&&e.delimiter||"/";null!=(t=Ao.exec(n));){var l=t[0],c=t[1],m=t.index;if(i+=n.slice(o,m),o=m+l.length,c)i+=c[1];else{var d=n[o],h=t[2],p=t[3],u=t[4],f=t[5],y=t[6],g=t[7];i&&(r.push(i),i="");var v=null!=h&&null!=d&&d!==h,b="+"===y||"*"===y,w="?"===y||"*"===y,x=t[2]||s,E=u||f;r.push({name:p||a++,prefix:h||"",delimiter:x,optional:w,repeat:b,partial:v,asterisk:!!g,pattern:E?Ho(E):g?".*":"[^"+Po(x)+"]+?"})}}return o<n.length&&(i+=n.substr(o)),i&&r.push(i),r}function _o(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function Io(n,e){for(var t=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(t[r]=new RegExp("^(?:"+n[r].pattern+")$",Bo(e)));return function(e,r){for(var a="",o=e||{},i=(r||{}).pretty?_o:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var c,m=o[l.name];if(null==m){if(l.optional){l.partial&&(a+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(So(m)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(m)+"`");if(0===m.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var d=0;d<m.length;d++){if(c=i(m[d]),!t[s].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");a+=(0===d?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(m).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):i(m),!t[s].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');a+=l.prefix+c}}else a+=l}return a}}function Po(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Ho(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function Do(n,e){return n.keys=e,n}function Bo(n){return n&&n.sensitive?"":"i"}function $o(n,e,t){So(e)||(t=e||t,e=[]);for(var r=(t=t||{}).strict,a=!1!==t.end,o="",i=0;i<n.length;i++){var s=n[i];if("string"==typeof s)o+=Po(s);else{var l=Po(s.prefix),c="(?:"+s.pattern+")";e.push(s),s.repeat&&(c+="(?:"+l+c+")*"),o+=c=s.optional?s.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var m=Po(t.delimiter||"/"),d=o.slice(-m.length)===m;return r||(o=(d?o.slice(0,-m.length):o)+"(?:"+m+"(?=$))?"),o+=a?"$":r&&d?"":"(?="+m+"|$)",Do(new RegExp("^"+o,Bo(t)),e)}function Lo(n,e,t){return So(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)e.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return Do(n,e)}(n,e):So(n)?function(n,e,t){for(var r=[],a=0;a<n.length;a++)r.push(Lo(n[a],e,t).source);return Do(new RegExp("(?:"+r.join("|")+")",Bo(t)),e)}(n,e,t):function(n,e,t){return $o(zo(n,t),e,t)}(n,e,t)}To.parse=jo,To.compile=Co,To.tokensToFunction=Ro,To.tokensToRegExp=Mo;var Fo=Object.create(null);function Oo(n,e,t){e=e||{};try{var r=Fo[n]||(Fo[n]=To.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),r(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function qo(n,e,t,r){var a="string"==typeof n?{path:n}:n;if(a._normalized)return a;if(a.name){var o=(a=eo({},n)).params;return o&&"object"==typeof o&&(a.params=eo({},o)),a}if(!a.path&&a.params&&e){(a=eo({},a))._normalized=!0;var i=eo(eo({},e.params),a.params);if(e.name)a.name=e.name,a.params=i;else if(e.matched.length){var s=e.matched[e.matched.length-1].path;a.path=Oo(s,i,e.path)}else 0;return a}var l=function(n){var e="",t="",r=n.indexOf("#");r>=0&&(e=n.slice(r),n=n.slice(0,r));var a=n.indexOf("?");return a>=0&&(t=n.slice(a+1),n=n.slice(0,a)),{path:n,query:t,hash:e}}(a.path||""),c=e&&e.path||"/",m=l.path?Eo(l.path,c,t||a.append):c,d=function(n,e,t){void 0===e&&(e={});var r,a=t||lo;try{r=a(n||"")}catch(n){r={}}for(var o in e){var i=e[o];r[o]=Array.isArray(i)?i.map(so):so(i)}return r}(l.query,a.query,r&&r.options.parseQuery),h=a.hash||l.hash;return h&&"#"!==h.charAt(0)&&(h="#"+h),{_normalized:!0,path:m,query:d,hash:h}}var No,Go=function(){},Vo={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,r=this.$route,a=t.resolve(this.to,r,this.append),o=a.location,i=a.route,s=a.href,l={},c=t.options.linkActiveClass,m=t.options.linkExactActiveClass,d=null==c?"router-link-active":c,h=null==m?"router-link-exact-active":m,p=null==this.activeClass?d:this.activeClass,u=null==this.exactActiveClass?h:this.exactActiveClass,f=i.redirectedFrom?ho(null,qo(i.redirectedFrom),null,t):i;l[u]=go(r,f,this.exactPath),l[p]=this.exact||this.exactPath?l[u]:function(n,e){return 0===n.path.replace(mo,"/").indexOf(e.path.replace(mo,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(r,f);var y=l[u]?this.ariaCurrentValue:null,g=function(n){Wo(n)&&(e.replace?t.replace(o,Go):t.push(o,Go))},v={click:Wo};Array.isArray(this.event)?this.event.forEach((function(n){v[n]=g})):v[this.event]=g;var b={class:l},w=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:i,navigate:g,isActive:l[p],isExactActive:l[u]});if(w){if(1===w.length)return w[0];if(w.length>1||!w.length)return 0===w.length?n():n("span",{},w)}if("a"===this.tag)b.on=v,b.attrs={href:s,"aria-current":y};else{var x=function n(e){var t;if(e)for(var r=0;r<e.length;r++){if("a"===(t=e[r]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(x){x.isStatic=!1;var E=x.data=eo({},x.data);for(var k in E.on=E.on||{},E.on){var S=E.on[k];k in v&&(E.on[k]=Array.isArray(S)?S:[S])}for(var T in v)T in E.on?E.on[T].push(v[T]):E.on[T]=g;var j=x.data.attrs=eo({},x.data.attrs);j.href=s,j["aria-current"]=y}else b.on=v}return n(this.tag,b,this.$slots.default)}};function Wo(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Uo="undefined"!=typeof window;function Xo(n,e,t,r,a){var o=e||[],i=t||Object.create(null),s=r||Object.create(null);n.forEach((function(n){!function n(e,t,r,a,o,i){var s=a.path,l=a.name;0;var c=a.pathToRegexpOptions||{},m=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return ko(e.path+"/"+n)}(s,o,c.strict);"boolean"==typeof a.caseSensitive&&(c.sensitive=a.caseSensitive);var d={path:m,regex:Jo(m,c),components:a.components||{default:a.component},alias:a.alias?"string"==typeof a.alias?[a.alias]:a.alias:[],instances:{},enteredCbs:{},name:l,parent:o,matchAs:i,redirect:a.redirect,beforeEnter:a.beforeEnter,meta:a.meta||{},props:null==a.props?{}:a.components?a.props:{default:a.props}};a.children&&a.children.forEach((function(a){var o=i?ko(i+"/"+a.path):void 0;n(e,t,r,a,d,o)}));t[d.path]||(e.push(d.path),t[d.path]=d);if(void 0!==a.alias)for(var h=Array.isArray(a.alias)?a.alias:[a.alias],p=0;p<h.length;++p){0;var u={path:h[p],children:a.children};n(e,t,r,u,o,d.path||"/")}l&&(r[l]||(r[l]=d))}(o,i,s,n,a)}));for(var l=0,c=o.length;l<c;l++)"*"===o[l]&&(o.push(o.splice(l,1)[0]),c--,l--);return{pathList:o,pathMap:i,nameMap:s}}function Jo(n,e){return To(n,[],e)}function Yo(n,e){var t=Xo(n),r=t.pathList,a=t.pathMap,o=t.nameMap;function i(n,t,i){var s=qo(n,t,!1,e),c=s.name;if(c){var m=o[c];if(!m)return l(null,s);var d=m.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var h in t.params)!(h in s.params)&&d.indexOf(h)>-1&&(s.params[h]=t.params[h]);return s.path=Oo(m.path,s.params),l(m,s,i)}if(s.path){s.params={};for(var p=0;p<r.length;p++){var u=r[p],f=a[u];if(Ko(f.regex,s.path,s.params))return l(f,s,i)}}return l(null,s)}function s(n,t){var r=n.redirect,a="function"==typeof r?r(ho(n,t,null,e)):r;if("string"==typeof a&&(a={path:a}),!a||"object"!=typeof a)return l(null,t);var s=a,c=s.name,m=s.path,d=t.query,h=t.hash,p=t.params;if(d=s.hasOwnProperty("query")?s.query:d,h=s.hasOwnProperty("hash")?s.hash:h,p=s.hasOwnProperty("params")?s.params:p,c){o[c];return i({_normalized:!0,name:c,query:d,hash:h,params:p},void 0,t)}if(m){var u=function(n,e){return Eo(n,e.parent?e.parent.path:"/",!0)}(m,n);return i({_normalized:!0,path:Oo(u,p),query:d,hash:h},void 0,t)}return l(null,t)}function l(n,t,r){return n&&n.redirect?s(n,r||t):n&&n.matchAs?function(n,e,t){var r=i({_normalized:!0,path:Oo(t,e.params)});if(r){var a=r.matched,o=a[a.length-1];return e.params=r.params,l(o,e)}return l(null,e)}(0,t,n.matchAs):ho(n,t,r,e)}return{match:i,addRoute:function(n,e){var t="object"!=typeof n?o[n]:void 0;Xo([e||n],r,a,o,t),t&&t.alias.length&&Xo(t.alias.map((function(n){return{path:n,children:[e]}})),r,a,o,t)},getRoutes:function(){return r.map((function(n){return a[n]}))},addRoutes:function(n){Xo(n,r,a,o)}}}function Ko(n,e,t){var r=e.match(n);if(!r)return!1;if(!t)return!0;for(var a=1,o=r.length;a<o;++a){var i=n.keys[a-1];i&&(t[i.name||"pathMatch"]="string"==typeof r[a]?io(r[a]):r[a])}return!0}var Zo=Uo&&window.performance&&window.performance.now?window.performance:Date;function Qo(){return Zo.now().toFixed(3)}var ni=Qo();function ei(){return ni}function ti(n){return ni=n}var ri=Object.create(null);function ai(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=eo({},window.history.state);return t.key=ei(),window.history.replaceState(t,"",e),window.addEventListener("popstate",si),function(){window.removeEventListener("popstate",si)}}function oi(n,e,t,r){if(n.app){var a=n.options.scrollBehavior;a&&n.app.$nextTick((function(){var o=function(){var n=ei();if(n)return ri[n]}(),i=a.call(n,e,t,r?o:null);i&&("function"==typeof i.then?i.then((function(n){hi(n,o)})).catch((function(n){0})):hi(i,o))}))}}function ii(){var n=ei();n&&(ri[n]={x:window.pageXOffset,y:window.pageYOffset})}function si(n){ii(),n.state&&n.state.key&&ti(n.state.key)}function li(n){return mi(n.x)||mi(n.y)}function ci(n){return{x:mi(n.x)?n.x:window.pageXOffset,y:mi(n.y)?n.y:window.pageYOffset}}function mi(n){return"number"==typeof n}var di=/^#\d/;function hi(n,e){var t,r="object"==typeof n;if(r&&"string"==typeof n.selector){var a=di.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(a){var o=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-t.left-e.x,y:r.top-t.top-e.y}}(a,o={x:mi((t=o).x)?t.x:0,y:mi(t.y)?t.y:0})}else li(n)&&(e=ci(n))}else r&&li(n)&&(e=ci(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var pi,ui=Uo&&((-1===(pi=window.navigator.userAgent).indexOf("Android 2.")&&-1===pi.indexOf("Android 4.0")||-1===pi.indexOf("Mobile Safari")||-1!==pi.indexOf("Chrome")||-1!==pi.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function fi(n,e){ii();var t=window.history;try{if(e){var r=eo({},t.state);r.key=ei(),t.replaceState(r,"",n)}else t.pushState({key:ti(Qo())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function yi(n){fi(n,!0)}var gi={redirected:2,aborted:4,cancelled:8,duplicated:16};function vi(n,e){return wi(n,e,gi.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return xi.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function bi(n,e){return wi(n,e,gi.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function wi(n,e,t,r){var a=new Error(r);return a._isRouter=!0,a.from=n,a.to=e,a.type=t,a}var xi=["params","query","hash"];function Ei(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function ki(n,e){return Ei(n)&&n._isRouter&&(null==e||n.type===e)}function Si(n,e,t){var r=function(a){a>=n.length?t():n[a]?e(n[a],(function(){r(a+1)})):r(a+1)};r(0)}function Ti(n){return function(e,t,r){var a=!1,o=0,i=null;ji(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){a=!0,o++;var l,c=Mi((function(e){var a;((a=e).__esModule||Ri&&"Module"===a[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:No.extend(e),t.components[s]=e,--o<=0&&r()})),m=Mi((function(n){var e="Failed to resolve async component "+s+": "+n;i||(i=Ei(n)?n:new Error(e),r(i))}));try{l=n(c,m)}catch(n){m(n)}if(l)if("function"==typeof l.then)l.then(c,m);else{var d=l.component;d&&"function"==typeof d.then&&d.then(c,m)}}})),a||r()}}function ji(n,e){return Ci(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function Ci(n){return Array.prototype.concat.apply([],n)}var Ri="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function Mi(n){var e=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!e)return e=!0,n.apply(this,t)}}var Ai=function(n,e){this.router=n,this.base=function(n){if(!n)if(Uo){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=uo,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function zi(n,e,t,r){var a=ji(n,(function(n,r,a,o){var i=function(n,e){"function"!=typeof n&&(n=No.extend(n));return n.options[e]}(n,e);if(i)return Array.isArray(i)?i.map((function(n){return t(n,r,a,o)})):t(i,r,a,o)}));return Ci(r?a.reverse():a)}function _i(n,e){if(e)return function(){return n.apply(e,arguments)}}Ai.prototype.listen=function(n){this.cb=n},Ai.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},Ai.prototype.onError=function(n){this.errorCbs.push(n)},Ai.prototype.transitionTo=function(n,e,t){var r,a=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var o=this.current;this.confirmTransition(r,(function(){a.updateRoute(r),e&&e(r),a.ensureURL(),a.router.afterHooks.forEach((function(n){n&&n(r,o)})),a.ready||(a.ready=!0,a.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!a.ready&&(ki(n,gi.redirected)&&o===uo||(a.ready=!0,a.readyErrorCbs.forEach((function(e){e(n)}))))}))},Ai.prototype.confirmTransition=function(n,e,t){var r=this,a=this.current;this.pending=n;var o,i,s=function(n){!ki(n)&&Ei(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=a.matched.length-1;if(go(n,a)&&l===c&&n.matched[l]===a.matched[c])return this.ensureURL(),n.hash&&oi(this.router,a,n,!1),s(((i=wi(o=a,n,gi.duplicated,'Avoided redundant navigation to current location: "'+o.fullPath+'".')).name="NavigationDuplicated",i));var m=function(n,e){var t,r=Math.max(n.length,e.length);for(t=0;t<r&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),d=m.updated,h=m.deactivated,p=m.activated,u=[].concat(function(n){return zi(n,"beforeRouteLeave",_i,!0)}(h),this.router.beforeHooks,function(n){return zi(n,"beforeRouteUpdate",_i)}(d),p.map((function(n){return n.beforeEnter})),Ti(p)),f=function(e,t){if(r.pending!==n)return s(bi(a,n));try{e(n,a,(function(e){!1===e?(r.ensureURL(!0),s(function(n,e){return wi(n,e,gi.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(a,n))):Ei(e)?(r.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(vi(a,n)),"object"==typeof e&&e.replace?r.replace(e):r.push(e)):t(e)}))}catch(n){s(n)}};Si(u,f,(function(){Si(function(n){return zi(n,"beforeRouteEnter",(function(n,e,t,r){return function(n,e,t){return function(r,a,o){return n(r,a,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),o(n)}))}}(n,t,r)}))}(p).concat(r.router.resolveHooks),f,(function(){if(r.pending!==n)return s(bi(a,n));r.pending=null,e(n),r.router.app&&r.router.app.$nextTick((function(){bo(n)}))}))}))},Ai.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},Ai.prototype.setupListeners=function(){},Ai.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=uo,this.pending=null};var Ii=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Pi(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,r=ui&&t;r&&this.listeners.push(ai());var a=function(){var t=n.current,a=Pi(n.base);n.current===uo&&a===n._startLocation||n.transitionTo(a,(function(n){r&&oi(e,n,t,!0)}))};window.addEventListener("popstate",a),this.listeners.push((function(){window.removeEventListener("popstate",a)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){fi(ko(r.base+n.fullPath)),oi(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){yi(ko(r.base+n.fullPath)),oi(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Pi(this.base)!==this.current.fullPath){var e=ko(this.base+this.current.fullPath);n?fi(e):yi(e)}},e.prototype.getCurrentLocation=function(){return Pi(this.base)},e}(Ai);function Pi(n){var e=window.location.pathname,t=e.toLowerCase(),r=n.toLowerCase();return!n||t!==r&&0!==t.indexOf(ko(r+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Hi=function(n){function e(e,t,r){n.call(this,e,t),r&&function(n){var e=Pi(n);if(!/^\/#/.test(e))return window.location.replace(ko(n+"/#"+e)),!0}(this.base)||Di()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=ui&&e;t&&this.listeners.push(ai());var r=function(){var e=n.current;Di()&&n.transitionTo(Bi(),(function(r){t&&oi(n.router,r,e,!0),ui||Fi(r.fullPath)}))},a=ui?"popstate":"hashchange";window.addEventListener(a,r),this.listeners.push((function(){window.removeEventListener(a,r)}))}},e.prototype.push=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){Li(n.fullPath),oi(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){Fi(n.fullPath),oi(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Bi()!==e&&(n?Li(e):Fi(e))},e.prototype.getCurrentLocation=function(){return Bi()},e}(Ai);function Di(){var n=Bi();return"/"===n.charAt(0)||(Fi("/"+n),!1)}function Bi(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function $i(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Li(n){ui?fi($i(n)):window.location.hash=n}function Fi(n){ui?yi($i(n)):window.location.replace($i(n))}var Oi=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var n=e.current;e.index=t,e.updateRoute(r),e.router.afterHooks.forEach((function(e){e&&e(r,n)}))}),(function(n){ki(n,gi.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(Ai),qi=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Yo(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!ui&&!1!==n.fallback,this.fallback&&(e="hash"),Uo||(e="abstract"),this.mode=e,e){case"history":this.history=new Ii(this,n.base);break;case"hash":this.history=new Hi(this,n.base,this.fallback);break;case"abstract":this.history=new Oi(this,n.base);break;default:0}},Ni={currentRoute:{configurable:!0}};qi.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Ni.currentRoute.get=function(){return this.history&&this.history.current},qi.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof Ii||t instanceof Hi){var r=function(n){t.setupListeners(),function(n){var r=t.current,a=e.options.scrollBehavior;ui&&a&&"fullPath"in n&&oi(e,n,r,!1)}(n)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},qi.prototype.beforeEach=function(n){return Vi(this.beforeHooks,n)},qi.prototype.beforeResolve=function(n){return Vi(this.resolveHooks,n)},qi.prototype.afterEach=function(n){return Vi(this.afterHooks,n)},qi.prototype.onReady=function(n,e){this.history.onReady(n,e)},qi.prototype.onError=function(n){this.history.onError(n)},qi.prototype.push=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.push(n,e,t)}));this.history.push(n,e,t)},qi.prototype.replace=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.replace(n,e,t)}));this.history.replace(n,e,t)},qi.prototype.go=function(n){this.history.go(n)},qi.prototype.back=function(){this.go(-1)},qi.prototype.forward=function(){this.go(1)},qi.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},qi.prototype.resolve=function(n,e,t){var r=qo(n,e=e||this.history.current,t,this),a=this.match(r,e),o=a.redirectedFrom||a.fullPath;return{location:r,route:a,href:function(n,e,t){var r="hash"===t?"#"+e:e;return n?ko(n+"/"+r):r}(this.history.base,o,this.mode),normalizedTo:r,resolved:a}},qi.prototype.getRoutes=function(){return this.matcher.getRoutes()},qi.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==uo&&this.history.transitionTo(this.history.getCurrentLocation())},qi.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==uo&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(qi.prototype,Ni);var Gi=qi;function Vi(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}qi.install=function n(e){if(!n.installed||No!==e){n.installed=!0,No=e;var t=function(n){return void 0!==n},r=function(n,e){var r=n.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",wo),e.component("RouterLink",Vo);var a=e.config.optionMergeStrategies;a.beforeRouteEnter=a.beforeRouteLeave=a.beforeRouteUpdate=a.created}},qi.version="3.6.5",qi.isNavigationFailure=ki,qi.NavigationFailureType=gi,qi.START_LOCATION=uo,Uo&&window.Vue&&window.Vue.use(qi);t(101);t(90),t(126);var Wi={NotFound:()=>t.e(33).then(t.bind(null,558)),Layout:()=>Promise.all([t.e(0),t.e(3)]).then(t.bind(null,557))},Ui={"v-705540d6":()=>t.e(35).then(t.bind(null,561)),"v-2e5d1dd6":()=>t.e(6).then(t.bind(null,562)),"v-174c6aeb":()=>t.e(36).then(t.bind(null,563)),"v-715e05f6":()=>t.e(34).then(t.bind(null,564)),"v-42b46279":()=>t.e(20).then(t.bind(null,565)),"v-51c0b6ee":()=>t.e(38).then(t.bind(null,566)),"v-3b2316a8":()=>t.e(37).then(t.bind(null,567)),"v-501863de":()=>t.e(41).then(t.bind(null,568)),"v-6a6ffff6":()=>t.e(39).then(t.bind(null,569)),"v-cc0f2d94":()=>t.e(40).then(t.bind(null,570)),"v-3c4bba52":()=>t.e(42).then(t.bind(null,571)),"v-e1c78694":()=>t.e(24).then(t.bind(null,572)),"v-694f1c96":()=>t.e(2).then(t.bind(null,573)),"v-11ee7d54":()=>t.e(44).then(t.bind(null,574)),"v-5a27c414":()=>t.e(47).then(t.bind(null,575)),"v-f5fd061c":()=>t.e(45).then(t.bind(null,576)),"v-4bba0115":()=>t.e(46).then(t.bind(null,577)),"v-ea210bc8":()=>t.e(43).then(t.bind(null,578)),"v-28f59836":()=>t.e(49).then(t.bind(null,579)),"v-041e49d4":()=>t.e(48).then(t.bind(null,580)),"v-53fa5556":()=>t.e(21).then(t.bind(null,581)),"v-cdf217ce":()=>t.e(50).then(t.bind(null,582)),"v-bda116b6":()=>t.e(25).then(t.bind(null,583)),"v-aec7c3da":()=>t.e(53).then(t.bind(null,584)),"v-18a8bd8d":()=>t.e(54).then(t.bind(null,585)),"v-2d66d4d4":()=>t.e(52).then(t.bind(null,586)),"v-6fda4365":()=>t.e(51).then(t.bind(null,587)),"v-9519fc44":()=>t.e(9).then(t.bind(null,588)),"v-2e496bf9":()=>t.e(55).then(t.bind(null,589)),"v-929b2664":()=>t.e(56).then(t.bind(null,590)),"v-7961c576":()=>t.e(57).then(t.bind(null,591)),"v-344dc095":()=>t.e(58).then(t.bind(null,592)),"v-36c7ff96":()=>t.e(13).then(t.bind(null,593)),"v-f8b85b64":()=>t.e(22).then(t.bind(null,594)),"v-548eae12":()=>t.e(7).then(t.bind(null,595)),"v-54435360":()=>t.e(5).then(t.bind(null,596)),"v-35c42dd6":()=>t.e(10).then(t.bind(null,597)),"v-5f69a516":()=>t.e(4).then(t.bind(null,598)),"v-2f52b1d2":()=>t.e(59).then(t.bind(null,599)),"v-48a1f714":()=>t.e(11).then(t.bind(null,600)),"v-0e8da270":()=>t.e(60).then(t.bind(null,601)),"v-68fd1656":()=>t.e(14).then(t.bind(null,602)),"v-243444d6":()=>t.e(61).then(t.bind(null,603)),"v-36f66c54":()=>t.e(12).then(t.bind(null,604)),"v-4b9df42c":()=>t.e(62).then(t.bind(null,605)),"v-5d26854b":()=>t.e(64).then(t.bind(null,606)),"v-859fe96e":()=>t.e(63).then(t.bind(null,607)),"v-7f8813c0":()=>t.e(15).then(t.bind(null,608)),"v-f09a4384":()=>t.e(67).then(t.bind(null,609)),"v-aa80698a":()=>t.e(66).then(t.bind(null,610)),"v-3bba326b":()=>t.e(65).then(t.bind(null,611)),"v-1eb73b85":()=>t.e(68).then(t.bind(null,612)),"v-43789173":()=>t.e(69).then(t.bind(null,613)),"v-6fe647a2":()=>t.e(8).then(t.bind(null,614)),"v-a4934214":()=>t.e(72).then(t.bind(null,615)),"v-68c3d022":()=>t.e(74).then(t.bind(null,616)),"v-7464d17e":()=>t.e(71).then(t.bind(null,617)),"v-a651494e":()=>t.e(26).then(t.bind(null,618)),"v-7e14e6f9":()=>t.e(70).then(t.bind(null,619)),"v-fef8d78c":()=>t.e(73).then(t.bind(null,620)),"v-8d05fbae":()=>t.e(76).then(t.bind(null,621)),"v-72f0afd8":()=>t.e(75).then(t.bind(null,622)),"v-35853b78":()=>t.e(77).then(t.bind(null,623)),"v-2ddae43b":()=>t.e(16).then(t.bind(null,624)),"v-4ca00b15":()=>t.e(23).then(t.bind(null,625)),"v-c8e5c632":()=>t.e(78).then(t.bind(null,626)),"v-80b04568":()=>t.e(79).then(t.bind(null,627)),"v-cb3a39e2":()=>t.e(28).then(t.bind(null,628)),"v-59b8ee9a":()=>t.e(27).then(t.bind(null,629)),"v-e498804c":()=>t.e(29).then(t.bind(null,630)),"v-2272963b":()=>t.e(80).then(t.bind(null,631)),"v-ac38b92e":()=>t.e(82).then(t.bind(null,632)),"v-62b213c6":()=>t.e(83).then(t.bind(null,633)),"v-126e2adc":()=>t.e(81).then(t.bind(null,634)),"v-db823ad2":()=>t.e(31).then(t.bind(null,635)),"v-5b77c997":()=>t.e(30).then(t.bind(null,636)),"v-8efb47ee":()=>t.e(84).then(t.bind(null,637)),"v-1eabf2d6":()=>t.e(85).then(t.bind(null,638)),"v-3c6a7dae":()=>t.e(32).then(t.bind(null,639))};function Xi(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Ji=/-(\w)/g,Yi=Xi(n=>n.replace(Ji,(n,e)=>e?e.toUpperCase():"")),Ki=/\B([A-Z])/g,Zi=Xi(n=>n.replace(Ki,"-$1").toLowerCase()),Qi=Xi(n=>n.charAt(0).toUpperCase()+n.slice(1));function ns(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(Qi(Yi(e))):n(Qi(e))||n(Zi(e))}const es=Object.assign({},Wi,Ui),ts=n=>es[n],rs=n=>Ui[n],as=n=>Wi[n],os=n=>Wt.component(n);function is(n){return ns(rs,n)}function ss(n){return ns(as,n)}function ls(n){return ns(ts,n)}function cs(n){return ns(os,n)}function ms(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!cs(n)&&ls(n)){const e=await ls(n)();Wt.component(n,e.default)}}))}function ds(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var hs=t(87),ps=t.n(hs),us=t(88),fs=t.n(us),ys={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${fs()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=vs(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=bs(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return ps()([{name:"description",content:this.$description}],n,this.siteMeta,ws)},updateCanonicalLink(){gs(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",vs(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){bs(null,this.currentMetaTags),gs()}};function gs(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function vs(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function bs(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function ws(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var xs=t(89),Es={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(xs)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),r=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),a=window.innerHeight+t;for(let n=0;n<e.length;n++){const o=e[n],i=e[n+1],s=0===n&&0===t||t>=o.parentElement.offsetTop+10&&(!i||t<i.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(s&&l!==decodeURIComponent(o.hash)){const t=o;if(a===r)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},ks=t(22),Ss=t.n(ks),Ts=[ys,Es,{mounted(){Ss.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Wt.component(n.name)||Ss.a.start(),t()}),this.$router.afterEach(()=>{Ss.a.done(),this.isSidebarOpen=!1})}}],js={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return ds("layout",n),Wt.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},Cs=t(14),Rs=Object(Cs.a)(js,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(Rs,"mixins",Ts);const Ms=[{name:"v-705540d6",path:"/eChart/",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-705540d6").then(t)}},{path:"/eChart/index.html",redirect:"/eChart/"},{name:"v-2e5d1dd6",path:"/eChart/eChart.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-2e5d1dd6").then(t)}},{name:"v-174c6aeb",path:"/guide/",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-174c6aeb").then(t)}},{path:"/guide/index.html",redirect:"/guide/"},{name:"v-715e05f6",path:"/",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-715e05f6").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-42b46279",path:"/JK-%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-42b46279").then(t)}},{path:"/JK-前端进阶训练营/",redirect:"/JK-%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/"},{path:"/JK-%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/index.html",redirect:"/JK-%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/"},{path:"/JK-前端进阶训练营/",redirect:"/JK-%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/"},{name:"v-51c0b6ee",path:"/guide/deploy.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-51c0b6ee").then(t)}},{name:"v-3b2316a8",path:"/guide/basicConfiguration.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-3b2316a8").then(t)}},{name:"v-501863de",path:"/guide/markdown.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-501863de").then(t)}},{name:"v-6a6ffff6",path:"/guide/directory.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-6a6ffff6").then(t)}},{name:"v-cc0f2d94",path:"/guide/introduce.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-cc0f2d94").then(t)}},{name:"v-3c4bba52",path:"/guide/quickStart.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-3c4bba52").then(t)}},{name:"v-e1c78694",path:"/node/database.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-e1c78694").then(t)}},{name:"v-694f1c96",path:"/node/",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-694f1c96").then(t)}},{path:"/node/index.html",redirect:"/node/"},{name:"v-11ee7d54",path:"/node/node.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-11ee7d54").then(t)}},{name:"v-5a27c414",path:"/progress/interview1.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-5a27c414").then(t)}},{name:"v-f5fd061c",path:"/node/nvm.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-f5fd061c").then(t)}},{name:"v-4bba0115",path:"/progress/",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-4bba0115").then(t)}},{path:"/progress/index.html",redirect:"/progress/"},{name:"v-ea210bc8",path:"/node/express.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-ea210bc8").then(t)}},{name:"v-28f59836",path:"/progress/interview3.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-28f59836").then(t)}},{name:"v-041e49d4",path:"/progress/interview2.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-041e49d4").then(t)}},{name:"v-53fa5556",path:"/progress/interview4.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-53fa5556").then(t)}},{name:"v-cdf217ce",path:"/progress/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-cdf217ce").then(t)}},{path:"/progress/每日学习总结.html",redirect:"/progress/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.html"},{path:"/progress/每日学习总结.html",redirect:"/progress/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.html"},{name:"v-bda116b6",path:"/react/",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-bda116b6").then(t)}},{path:"/react/index.html",redirect:"/react/"},{name:"v-aec7c3da",path:"/regular&git/",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-aec7c3da").then(t)}},{path:"/regular&git/index.html",redirect:"/regular&git/"},{name:"v-18a8bd8d",path:"/regular&git/git/",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-18a8bd8d").then(t)}},{path:"/regular&git/git/index.html",redirect:"/regular&git/git/"},{name:"v-2d66d4d4",path:"/react/react.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-2d66d4d4").then(t)}},{name:"v-6fda4365",path:"/qiankun/",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-6fda4365").then(t)}},{path:"/qiankun/index.html",redirect:"/qiankun/"},{name:"v-9519fc44",path:"/qiankun/qiankun1.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-9519fc44").then(t)}},{name:"v-2e496bf9",path:"/regular&git/regular/",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-2e496bf9").then(t)}},{path:"/regular&git/regular/index.html",redirect:"/regular&git/regular/"},{name:"v-929b2664",path:"/regular&git/regular/case.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-929b2664").then(t)}},{name:"v-7961c576",path:"/regular&git/regular/commonUse.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-7961c576").then(t)}},{name:"v-344dc095",path:"/three.js/",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-344dc095").then(t)}},{path:"/three.js/index.html",redirect:"/three.js/"},{name:"v-36c7ff96",path:"/three.js/SimpleFont.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-36c7ff96").then(t)}},{name:"v-f8b85b64",path:"/three.js/SimpleInteraction.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-f8b85b64").then(t)}},{name:"v-548eae12",path:"/three.js/SimpleDynamicEffect.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-548eae12").then(t)}},{name:"v-54435360",path:"/three.js/SimpleModel.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-54435360").then(t)}},{name:"v-35c42dd6",path:"/three.js/SpaceModel.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-35c42dd6").then(t)}},{name:"v-5f69a516",path:"/three.js/SpecialEffects.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-5f69a516").then(t)}},{name:"v-2f52b1d2",path:"/vue/",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-2f52b1d2").then(t)}},{path:"/vue/index.html",redirect:"/vue/"},{name:"v-48a1f714",path:"/vue/vue+svg.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-48a1f714").then(t)}},{name:"v-0e8da270",path:"/vue/vue-router.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-0e8da270").then(t)}},{name:"v-68fd1656",path:"/three.js/three.js.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-68fd1656").then(t)}},{name:"v-243444d6",path:"/vue/vueManageSystem.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-243444d6").then(t)}},{name:"v-36f66c54",path:"/vue/vue.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-36f66c54").then(t)}},{name:"v-4b9df42c",path:"/vue/vuex.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-4b9df42c").then(t)}},{name:"v-5d26854b",path:"/%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/deploy.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-5d26854b").then(t)}},{path:"/优化问题/deploy.html",redirect:"/%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/deploy.html"},{path:"/优化问题/deploy.html",redirect:"/%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/deploy.html"},{name:"v-859fe96e",path:"/webpack/",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-859fe96e").then(t)}},{path:"/webpack/index.html",redirect:"/webpack/"},{name:"v-7f8813c0",path:"/%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-7f8813c0").then(t)}},{path:"/优化问题/",redirect:"/%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/"},{path:"/%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/index.html",redirect:"/%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/"},{path:"/优化问题/",redirect:"/%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/"},{name:"v-f09a4384",path:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-f09a4384").then(t)}},{path:"/前端问题/",redirect:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/"},{path:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/index.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/"},{path:"/前端问题/",redirect:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/"},{name:"v-aa80698a",path:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/ArrObjStr.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-aa80698a").then(t)}},{path:"/前端问题/ArrObjStr.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/ArrObjStr.html"},{path:"/前端问题/ArrObjStr.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/ArrObjStr.html"},{name:"v-3bba326b",path:"/%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/tips.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-3bba326b").then(t)}},{path:"/优化问题/tips.html",redirect:"/%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/tips.html"},{path:"/优化问题/tips.html",redirect:"/%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/tips.html"},{name:"v-1eb73b85",path:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/axios.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-1eb73b85").then(t)}},{path:"/前端问题/axios.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/axios.html"},{path:"/前端问题/axios.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/axios.html"},{name:"v-43789173",path:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-43789173").then(t)}},{path:"/前端问题/刷新页面.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2.html"},{path:"/前端问题/刷新页面.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2.html"},{name:"v-6fe647a2",path:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/cssBase.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-6fe647a2").then(t)}},{path:"/前端问题/前端基础/cssBase.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/cssBase.html"},{path:"/前端问题/前端基础/cssBase.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/cssBase.html"},{name:"v-a4934214",path:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/htmlBase.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-a4934214").then(t)}},{path:"/前端问题/前端基础/htmlBase.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/htmlBase.html"},{path:"/前端问题/前端基础/htmlBase.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/htmlBase.html"},{name:"v-68c3d022",path:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/reactBase.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-68c3d022").then(t)}},{path:"/前端问题/前端基础/reactBase.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/reactBase.html"},{path:"/前端问题/前端基础/reactBase.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/reactBase.html"},{name:"v-7464d17e",path:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/canvas.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-7464d17e").then(t)}},{path:"/前端问题/前端基础/canvas.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/canvas.html"},{path:"/前端问题/前端基础/canvas.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/canvas.html"},{name:"v-a651494e",path:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-a651494e").then(t)}},{path:"/前端问题/模拟数据.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE.html"},{path:"/前端问题/模拟数据.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE.html"},{name:"v-7e14e6f9",path:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-7e14e6f9").then(t)}},{path:"/前端问题/前端基础/",redirect:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{path:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/index.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{path:"/前端问题/前端基础/",redirect:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{name:"v-fef8d78c",path:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/jsBase.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-fef8d78c").then(t)}},{path:"/前端问题/前端基础/jsBase.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/jsBase.html"},{path:"/前端问题/前端基础/jsBase.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/jsBase.html"},{name:"v-8d05fbae",path:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E7%80%91%E5%B8%83%E6%B5%81.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-8d05fbae").then(t)}},{path:"/前端问题/瀑布流.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E7%80%91%E5%B8%83%E6%B5%81.html"},{path:"/前端问题/瀑布流.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E7%80%91%E5%B8%83%E6%B5%81.html"},{name:"v-72f0afd8",path:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E6%82%AC%E6%B5%AE%E5%B0%8F%E5%9B%BE%E6%A0%87.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-72f0afd8").then(t)}},{path:"/前端问题/悬浮小图标.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E6%82%AC%E6%B5%AE%E5%B0%8F%E5%9B%BE%E6%A0%87.html"},{path:"/前端问题/悬浮小图标.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E6%82%AC%E6%B5%AE%E5%B0%8F%E5%9B%BE%E6%A0%87.html"},{name:"v-35853b78",path:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E8%B7%B3%E8%BD%AC%E7%9B%B8%E5%85%B3.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-35853b78").then(t)}},{path:"/前端问题/跳转相关.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E8%B7%B3%E8%BD%AC%E7%9B%B8%E5%85%B3.html"},{path:"/前端问题/跳转相关.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E8%B7%B3%E8%BD%AC%E7%9B%B8%E5%85%B3.html"},{name:"v-2ddae43b",path:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E9%80%92%E5%BD%92.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-2ddae43b").then(t)}},{path:"/前端问题/递归.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E9%80%92%E5%BD%92.html"},{path:"/前端问题/递归.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E9%80%92%E5%BD%92.html"},{name:"v-4ca00b15",path:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AF%E8%AF%B7%E6%B1%82%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-4ca00b15").then(t)}},{path:"/前端问题/前端请求接口的几种方式总结.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AF%E8%AF%B7%E6%B1%82%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93.html"},{path:"/前端问题/前端请求接口的几种方式总结.html",redirect:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AF%E8%AF%B7%E6%B1%82%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93.html"},{name:"v-c8e5c632",path:"/%E5%B0%8F%E6%A1%88%E4%BE%8B/",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-c8e5c632").then(t)}},{path:"/小案例/",redirect:"/%E5%B0%8F%E6%A1%88%E4%BE%8B/"},{path:"/%E5%B0%8F%E6%A1%88%E4%BE%8B/index.html",redirect:"/%E5%B0%8F%E6%A1%88%E4%BE%8B/"},{path:"/小案例/",redirect:"/%E5%B0%8F%E6%A1%88%E4%BE%8B/"},{name:"v-80b04568",path:"/%E5%B0%8F%E6%A1%88%E4%BE%8B/css%E6%A1%88%E4%BE%8B.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-80b04568").then(t)}},{path:"/小案例/css案例.html",redirect:"/%E5%B0%8F%E6%A1%88%E4%BE%8B/css%E6%A1%88%E4%BE%8B.html"},{path:"/小案例/css案例.html",redirect:"/%E5%B0%8F%E6%A1%88%E4%BE%8B/css%E6%A1%88%E4%BE%8B.html"},{name:"v-cb3a39e2",path:"/%E5%B0%8F%E6%A1%88%E4%BE%8B/%E9%80%9A%E7%94%A8%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B1%95%E7%A4%BA%E5%B9%B3%E5%8F%B0html%E6%A8%A1%E6%9D%BF/",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-cb3a39e2").then(t)}},{path:"/小案例/通用大数据可视化展示平台html模板/",redirect:"/%E5%B0%8F%E6%A1%88%E4%BE%8B/%E9%80%9A%E7%94%A8%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B1%95%E7%A4%BA%E5%B9%B3%E5%8F%B0html%E6%A8%A1%E6%9D%BF/"},{path:"/%E5%B0%8F%E6%A1%88%E4%BE%8B/%E9%80%9A%E7%94%A8%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B1%95%E7%A4%BA%E5%B9%B3%E5%8F%B0html%E6%A8%A1%E6%9D%BF/index.html",redirect:"/%E5%B0%8F%E6%A1%88%E4%BE%8B/%E9%80%9A%E7%94%A8%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B1%95%E7%A4%BA%E5%B9%B3%E5%8F%B0html%E6%A8%A1%E6%9D%BF/"},{path:"/小案例/通用大数据可视化展示平台html模板/",redirect:"/%E5%B0%8F%E6%A1%88%E4%BE%8B/%E9%80%9A%E7%94%A8%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B1%95%E7%A4%BA%E5%B9%B3%E5%8F%B0html%E6%A8%A1%E6%9D%BF/"},{name:"v-59b8ee9a",path:"/%E5%B0%8F%E6%A1%88%E4%BE%8B/%E5%8C%BA%E5%9F%9F%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E5%9C%86/",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-59b8ee9a").then(t)}},{path:"/小案例/区域随机生成圆/",redirect:"/%E5%B0%8F%E6%A1%88%E4%BE%8B/%E5%8C%BA%E5%9F%9F%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E5%9C%86/"},{path:"/%E5%B0%8F%E6%A1%88%E4%BE%8B/%E5%8C%BA%E5%9F%9F%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E5%9C%86/index.html",redirect:"/%E5%B0%8F%E6%A1%88%E4%BE%8B/%E5%8C%BA%E5%9F%9F%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E5%9C%86/"},{path:"/小案例/区域随机生成圆/",redirect:"/%E5%B0%8F%E6%A1%88%E4%BE%8B/%E5%8C%BA%E5%9F%9F%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E5%9C%86/"},{name:"v-e498804c",path:"/%E5%B0%8F%E6%A1%88%E4%BE%8B/%E9%9A%8F%E6%9C%BA%E7%82%B9%E9%A4%90/",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-e498804c").then(t)}},{path:"/小案例/随机点餐/",redirect:"/%E5%B0%8F%E6%A1%88%E4%BE%8B/%E9%9A%8F%E6%9C%BA%E7%82%B9%E9%A4%90/"},{path:"/%E5%B0%8F%E6%A1%88%E4%BE%8B/%E9%9A%8F%E6%9C%BA%E7%82%B9%E9%A4%90/index.html",redirect:"/%E5%B0%8F%E6%A1%88%E4%BE%8B/%E9%9A%8F%E6%9C%BA%E7%82%B9%E9%A4%90/"},{path:"/小案例/随机点餐/",redirect:"/%E5%B0%8F%E6%A1%88%E4%BE%8B/%E9%9A%8F%E6%9C%BA%E7%82%B9%E9%A4%90/"},{name:"v-2272963b",path:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/Ant_Design_Vue.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-2272963b").then(t)}},{path:"/插件小技巧/Ant_Design_Vue.html",redirect:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/Ant_Design_Vue.html"},{path:"/插件小技巧/Ant_Design_Vue.html",redirect:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/Ant_Design_Vue.html"},{name:"v-ac38b92e",path:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/api.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-ac38b92e").then(t)}},{path:"/插件小技巧/api.html",redirect:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/api.html"},{path:"/插件小技巧/api.html",redirect:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/api.html"},{name:"v-62b213c6",path:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/codemirror.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-62b213c6").then(t)}},{path:"/插件小技巧/codemirror.html",redirect:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/codemirror.html"},{path:"/插件小技巧/codemirror.html",redirect:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/codemirror.html"},{name:"v-126e2adc",path:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-126e2adc").then(t)}},{path:"/插件小技巧/",redirect:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{path:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/index.html",redirect:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{path:"/插件小技巧/",redirect:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{name:"v-db823ad2",path:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/d3.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-db823ad2").then(t)}},{path:"/插件小技巧/d3.html",redirect:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/d3.html"},{path:"/插件小技巧/d3.html",redirect:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/d3.html"},{name:"v-5b77c997",path:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/G6.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-5b77c997").then(t)}},{path:"/插件小技巧/G6.html",redirect:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/G6.html"},{path:"/插件小技巧/G6.html",redirect:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/G6.html"},{name:"v-8efb47ee",path:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/excel.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-8efb47ee").then(t)}},{path:"/插件小技巧/excel.html",redirect:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/excel.html"},{path:"/插件小技巧/excel.html",redirect:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/excel.html"},{name:"v-1eabf2d6",path:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/wangeditor.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-1eabf2d6").then(t)}},{path:"/插件小技巧/wangeditor.html",redirect:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/wangeditor.html"},{path:"/插件小技巧/wangeditor.html",redirect:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/wangeditor.html"},{name:"v-3c6a7dae",path:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/element.html",component:Rs,beforeEnter:(n,e,t)=>{ms("Layout","v-3c6a7dae").then(t)}},{path:"/插件小技巧/element.html",redirect:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/element.html"},{path:"/插件小技巧/element.html",redirect:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/element.html"},{path:"*",component:Rs}],As={title:"Liang's blog",description:"我的个人网站",base:"/",headTags:[["link",{rel:"icon",href:"/favicon.ico"}]],pages:[{title:"介绍",frontmatter:{},regularPath:"/eChart/",relativePath:"eChart/README.md",key:"v-705540d6",path:"/eChart/",headersStr:null,content:"eChart",normalizedContent:"echart",charsets:{}},{title:"eChart",frontmatter:{},regularPath:"/eChart/eChart.html",relativePath:"eChart/eChart.md",key:"v-2e5d1dd6",path:"/eChart/eChart.html",headers:[{level:2,title:"例子",slug:"例子",normalizedTitle:"例子",charIndex:65},{level:3,title:"暂无数据",slug:"暂无数据",normalizedTitle:"暂无数据",charIndex:72},{level:3,title:"Echarts自定义提示框（解决弹框显示不全问题）",slug:"echarts自定义提示框-解决弹框显示不全问题",normalizedTitle:"echarts自定义提示框（解决弹框显示不全问题）",charIndex:247},{level:3,title:"折线图",slug:"折线图",normalizedTitle:"折线图",charIndex:1232},{level:3,title:"柱状图",slug:"柱状图",normalizedTitle:"柱状图",charIndex:10675},{level:3,title:"饼图",slug:"饼图",normalizedTitle:"饼图",charIndex:546},{level:3,title:"仪表盘",slug:"仪表盘",normalizedTitle:"仪表盘",charIndex:549},{level:3,title:"矩形树图",slug:"矩形树图",normalizedTitle:"矩形树图",charIndex:73804},{level:2,title:"区域选择",slug:"区域选择",normalizedTitle:"区域选择",charIndex:78385},{level:3,title:"dataZoom[区域属性]",slug:"datazoom-区域属性",normalizedTitle:"datazoom[区域属性]",charIndex:78454},{level:2,title:"echarts柱状图圆角实现",slug:"echarts柱状图圆角实现",normalizedTitle:"echarts柱状图圆角实现",charIndex:82293},{level:2,title:"3D柱状图",slug:"_3d柱状图",normalizedTitle:"3d柱状图",charIndex:82559},{level:2,title:"3D饼图",slug:"_3d饼图",normalizedTitle:"3d饼图",charIndex:89937},{level:3,title:".vue文件 【bindListen方法可以提取到mixins里面，以供组件多次调用】",slug:"vue文件-【bindlisten方法可以提取到mixins里面-以供组件多次调用】",normalizedTitle:".vue文件 【bindlisten方法可以提取到mixins里面，以供组件多次调用】",charIndex:90013},{level:3,title:"chart.js",slug:"chart-js",normalizedTitle:"chart.js",charIndex:90289}],headersStr:"例子 暂无数据 Echarts自定义提示框（解决弹框显示不全问题） 折线图 柱状图 饼图 仪表盘 矩形树图 区域选择 dataZoom[区域属性] echarts柱状图圆角实现 3D柱状图 3D饼图 .vue文件 【bindListen方法可以提取到mixins里面，以供组件多次调用】 chart.js",content:"# eChart\n\neChart 官网：https://echarts.apache.org/zh/index.html\n\n\n# 例子\n\n\n# 暂无数据\n\n//暂无数据\nvar option = { title : {\n    text: \"暂无数据\",\n    x: \"center\",\n    y: \"center\",\n    textStyle: {\n        fontSize: 14,\n        fontWeight: \"normal\",\n    },\n};}\n\n\n\n# Echarts自定义提示框（解决弹框显示不全问题）\n\n# 方法一\n\nTIP\n\n利用 confine: true 属性固定显示提示框\n\n\n\n# 方法二\n\nTIP\n\n利用formatter，分列显示\n\n提示框浮层内容格式器，支持字符串模板和回调函数两种形式。\n\n# 字符串模板\n\n * 折线（区域）图、柱状（条形）图、K线图 : {a}（系列名称），{b}（类目值），{c}（数值）, {d}（无）\n * 散点图（气泡）图 : {a}（系列名称），{b}（数据名称），{c}（数值数组）, {d}（无）\n * 地图 : {a}（系列名称），{b}（区域名称），{c}（合并数值）, {d}（无）\n * 饼图、仪表盘、漏斗图: {a}（系列名称），{b}（数据项名称），{c}（数值）, {d}（百分比）\n\n示例：\n\ntooltip: {\n    trigger: 'axis',\n    formatter:'{a0}: {c0}&ensp;{a1}: {c1}<br/>{a2}: {c2}&ensp;{a3}: {c3}'\n}\n\n\n效果：\n\n\n\n# 回调函数\n\n利用回调函数自定义样式\n\n示例：\n\ntooltip: {\n\ttrigger: 'axis',\n\tformatter: function (params) {\n\t\tlet str=params[0].name+\"<br/>\";\n\t\tfor(let i=0;i<params.length;i++){\n\t\t\tlet p='<p style=\"display:inline-block;width:120px;\"><span style=\"display:inline-block;margin-right:5px;border-radius:50%;width:10px;height:10px;left:5px;background-color:'+params[i].color+'\"></span>' + params[i].seriesName + \" : \" + params[i].data+'</p>';\n\t\t\tif(i%2==0){\n\t\t\t\tstr+=p;\n\t\t\t}else{\n\t\t\t\tstr+=p+'<br/>'\n\t\t\t}\n\t\t}\n\t\treturn str;\n\t}\n}\n\n\n效果：\n\n\n\n\n# 折线图\n\n# 折现上无圆圈\n\n\n\nimport * as echarts from 'echarts';\n\nvar chartDom = document.getElementById('main');\nvar myChart = echarts.init(chartDom);\nvar option;\n\noption = {\n    title: {\n        text: '固收业务累盈利',\n        left: 'center'\n    },\n    tooltip: {\n        trigger: 'axis'\n    },\n    legend: {\n        top: '40px',\n        data: [\n            { name: 'T户', icon: 'rect' },\n            { name: 'A户：不含公估', icon: 'rect' },\n            { name: 'A户：浮动亏盈', icon: 'rect' }\n        ],\n        itemHeight: 1,\n        itemWidth: 25\n    },\n    grid: {\n        top: '100px',\n        left: '3%',\n        right: '4%',\n        bottom: '3%',\n        containLabel: true\n    },\n    xAxis: {\n        type: 'category',\n        boundaryGap: false,\n        data: ['08-01', '08-02', '08-03', '08-04', '08-05', '08-06', '08-07']\n    },\n    yAxis: {\n        type: 'value',\n        axisLabel: {\n            formatter: '{value} 亿元'\n        }\n    },\n    series: [\n        {\n            name: 'T户',\n            type: 'line',\n            stack: 'Total',\n            symbolSize: 0,\n            data: [120, 132, 101, 134, 90, 230, 210]\n        },\n        {\n            name: 'A户：不含公估',\n            type: 'line',\n            stack: 'Total',\n            symbolSize: 0,\n            data: [220, 182, 191, 234, 290, 330, 310]\n        },\n        {\n            name: 'A户：浮动亏盈',\n            type: 'line',\n            stack: 'Total',\n            symbolSize: 0,\n            data: [150, 232, 201, 154, 190, 330, 410]\n        }\n    ]\n};\n\noption && myChart.setOption(option);\n\n\n# 叠线+实心圆\n\n\n\nimport * as echarts from 'echarts';\n\nvar chartDom = document.getElementById('main');\nvar myChart = echarts.init(chartDom);\nvar option;\n\noption = {\n    tooltip: {\n        trigger: 'axis'\n    },\n    grid: {\n        left: '3%',\n        right: '4%',\n        bottom: '3%',\n        containLabel: true\n    },\n    xAxis: {\n        type: 'category',\n        boundaryGap: false,\n        data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']\n    },\n    yAxis: {\n        type: 'value'\n    },\n    series: [\n        {\n            name: '资产访问',\n            type: 'line',\n            symbol: 'circle', //折线点设置为实心点\n            symbolSize: 7, //折线点的大小\n            stack: 'Total',\n            data: [120, 132, 101, 134, 90, 230, 210],\n            smooth: true,\n            color: '#9abcf6'\n        },\n        {\n            name: '资产申请',\n            type: 'line',\n            symbol: 'circle', //折线点设置为实心点\n            symbolSize: 7, //折线点的大小\n            stack: 'Total',\n            data: [220, 182, 191, 234, 290, 330, 310],\n            smooth: true,\n            color: '#8adbc2'\n        }\n    ]\n};\n\noption && myChart.setOption(option);\n\n\n\n# 背景色\n\n\n\nimport * as echarts from 'echarts';\n\nvar chartDom = document.getElementById('main');\nvar myChart = echarts.init(chartDom);\nvar option;\n\noption = {\n    color: [\"#46a6ff\", \"#37c8cf\"],\n    tooltip: {\n        trigger: \"axis\",\n        //   鼠标的Y坐标的数值\n        //   axisPointer: {\n        //     type: \"cross\",\n        //     label: {\n        //       backgroundColor: \"#6a7985\",\n        //     },\n        //   },\n    },\n    // legend: {\n    //   data: [\"资产访问\", \"资产申请\"],\n    // }, // 头部展示\n    grid: {\n        x: 30, //左侧与y轴的距离\n        y: 30, //top部与x轴的距离\n        x2: 30, //右侧与y轴的距离\n        y2: 40, //bottom部与x轴的距离\n        borderWidth: 1,\n        //   containLabel: true,\n    },\n    xAxis: [\n        {\n            type: \"category\",\n            boundaryGap: false,\n            data: [\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"],\n        },\n    ],\n    yAxis: [\n        {\n            type: \"value\",\n        },\n    ],\n    series: [\n        {\n            name: \"资产访问\",\n            type: \"line\",\n            stack: \"Total\",\n            smooth: true,\n            lineStyle: {\n                width: 0,\n            },\n            showSymbol: false,\n            areaStyle: {\n                opacity: 0.8,\n                color: new this.$echarts.graphic.LinearGradient(0, 0, 0, 1, [\n                    {\n                        offset: 0,\n                        color: \"rgb(128, 255, 165)\",\n                    },\n                    {\n                        offset: 1,\n                        color: \"rgb(1, 191, 236)\",\n                    },\n                ]),\n            },\n            emphasis: {\n                focus: \"series\",\n            },\n            data: [140, 232, 101, 264, 90, 340, 250],\n        },\n        {\n            name: \"资产申请\",\n            type: \"line\",\n            stack: \"Total\",\n            smooth: true,\n            lineStyle: {\n                width: 0,\n            },\n            showSymbol: false,\n            areaStyle: {\n                opacity: 0.8,\n                color: new this.$echarts.graphic.LinearGradient(0, 0, 0, 1, [\n                    {\n                        offset: 0,\n                        color: \"rgb(0, 221, 255)\",\n                    },\n                    {\n                        offset: 1,\n                        color: \"rgb(77, 119, 255)\",\n                    },\n                ]),\n            },\n            emphasis: {\n                focus: \"series\",\n            },\n            data: [120, 282, 111, 234, 220, 340, 310],\n        },\n    ],\n};\n\noption && myChart.setOption(option);\n\n\n# 将图表网格线设置成虚线（图表横线网格）\n\n\n\nlet option = {\n    title: {\n        text: \"近一周資源訪問情況\",\n        x: \"left\",\n        y: \"top\",\n        textAlign: \"left\",\n    },\n    tooltip: {\n        trigger: \"axis\",\n    }, // 悬浮提示\n    xAxis: {\n        type: \"category\",\n        boundaryGap: false,\n        data: this.vistData.map((v) => {\n            return v.date;\n        }),\n        axisPointer: {\n            //hover线条颜色\n            lineStyle: {\n                color: \"#fff\",\n            },\n        },\n        axisTick: {\n            show: false, //隐藏x轴刻度\n        },\n        axisLine: {\n            lineStyle: {\n                color: \"#999\",\n            },\n        },\n        splitLine: {\n            //分割线以及线条样式\n            show: true,\n        },\n    },\n    yAxis: {\n        type: \"value\",\n        axisTick: {\n            show: true, //隐藏x轴刻度\n            color: \"#ccc\",\n        },\n        axisLine: {\n            lineStyle: {\n                color: \"#999\",\n            },\n        },\n        splitLine: {\n            lineStyle: {\n                type: \"dashed\", //虚线\n            },\n            show: true, //隐藏\n        },\n    },\n};\n\n\n# 修改颜色\n\n# 单条折线\n\n在与series统计的地方放置color数据，如下：\n\n{\n    series:[{\n        data:[820,932,901,934],\n        type:\"line\"\n    }],\n    color: [\"#4E68F1\"]  // 颜色\n}\n\n\n# 多条折线\n\n同理在与series同级的地方放置color数组：例如\n\n{\n    series:[{\n        data:[820,932,901,934],\n        type:\"line\",\n        symbol: \"circle\", //设定为实心点\n    }],\n        // 其中：当颜色不够时，会从第一个颜色再次开始遍历。\n        color: [\"#7EC0EE\", \"#FF9F7F\", \"#FFD700\", \"#C9C9C9\", \"#E066FF\", \"#C0FF3E\"]  \n}\n\n\n# 实心效果+修改颜色+实心拐点白色外边\n\n同理在与series同级的地方放置color数组+symbol：例如\n\nlet  series=[\n    {\n        data:[820,932,901,934],\n        type:\"line\",\n        symbol: \"circle\", //设定为实心点\n        symbolsize: 20,  // 实心圆的值\n        smooth: true, // 曲滑\n        itemStyle: {\n            normal: {\n                color: \"#4E68F1\", //点\n                lineStyle: {\n                    color: \"#4E68F1\", //线\n                    width: 1,\n                    // 以下添加 echarts-折线图-实心拐点白色外边\n                    borderColor: \"#ffffff\", \n                    borderType: \"solid\",\n                    borderWidth: 5,\n                },\n            },\n        },\n    }\n],\n\n\n# 折线图背景渐变\n\n\n\ngetcardvisit(id) {\n    var chartDom = document.getElementById(id);\n    var myChart = echarts.init(chartDom);\n    var option;\n\n    option = {\n        tooltip: {\n            trigger: \"axis\",\n        }, // 悬浮提示\n        grid: {\n            x: 30, //左侧与y轴的距离\n            y: 30, //top部与x轴的距离\n            x2: 30, //右侧与y轴的距离\n            y2: 40, //bottom部与x轴的距离\n            borderWidth: 1,\n        },\n        xAxis: {\n            type: \"category\",\n            boundaryGap: false,\n            data: [\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"],\n        },\n        yAxis: {\n            type: \"value\",\n        },\n        series: [\n            {\n                name: \"访问量\",\n                data: [100, 77, 44, 44, 4, 0, 4],\n                type: \"line\",\n                smooth: true, // 曲滑\n                itemStyle: {\n                    normal: {\n                        areaStyle: {\n                            type: \"default\",\n                            //渐变色实现===\n                            color: new this.$echarts.graphic.LinearGradient(\n                                0,\n                                0,\n                                0,\n                                1,\n                                //三种由深及浅的颜色\n                                [\n                                    {\n                                        offset: 0,\n                                        color: \"#78e09d\",\n                                    },\n                                    {\n                                        offset: 1,\n                                        color: \"#7eccf0\",\n                                    },\n                                ]\n                            ),\n                        },\n\n                        lineStyle: {\n                            //线的颜色\n                            color: \"#50c0e7\",\n                        },\n                        color: \"#78e09d\", //点\n                    },\n                },\n            },\n        ],\n    };\n\n    option && myChart.setOption(option);\n},\n\n\n\n# 柱状图\n\n# 用柱状图做排名\n\nvar that = this;\nvar chartDom = document.getElementById(\"topRanking\");\nvar myChart = this.$echarts.init(chartDom);\nvar option;\n// let dataLeft = [30, 40, 50, 60, 70, 99];\n// let dataRight = [\n//     \"经营支出KPI\",\n//     \"月经营分析报表\",\n//     \"高端女性消费群体标签\",\n//     \"客户风险能力评估模型\",\n//     \"客户基础信息服务API\",\n//     \"季度考核KPI\",\n// ];\nlet dataLeft = hotData.num.length ? hotData.num.reverse() : [];\nlet dataRight = hotData.assetName.length ?\n    hotData.assetName.reverse() : [];\noption = {\n    // tooltip: {\n    //   trigger: \"axis\",\n    //   axisPointer: {\n    //     type: \"shadow\",\n    //   },\n    // },\n    grid: {\n        x: 30, //左侧与y轴的距离\n        y: 30, //top部与x轴的距离\n        x2: 30, //右侧与y轴的距离\n        y2: 30, //bottom部与x轴的距离\n        containLabel: true,\n    },\n    xAxis: {\n        type: \"value\",\n        axisLabel: {\n            //坐标label\n            show: false,\n        },\n        axisLine: {\n            //坐标轴线\n            show: false,\n        },\n        axisTick: {\n            //x轴刻度线\n            show: false,\n        },\n        splitLine: {\n            //网格线\n            show: false,\n        },\n        // boundaryGap: [0, 0.01]\n    },\n    yAxis: [{\n        // inverse: true, // 倒叙\n        type: \"category\",\n        axisLine: {\n            show: false,\n        },\n        axisTick: {\n            show: false,\n        },\n        axisLabel: {\n            // formatter: \" {a|} {value} 次\",\n            formatter: function(value, index) {\n                let img = \"\";\n                if (index > dataLeft.length - 2) {\n                    img = \"ranking1\";\n                } else if (index > dataLeft.length - 3) {\n                    img = \"ranking2\";\n                } else if (index > dataLeft.length - 4) {\n                    img = \"ranking3\";\n                } else {\n                    img = \"ranking4\";\n                }\n\n                return ` {${img}|}  ${value} ${that.$i18ns(\"second\")}`;\n            },\n            rich: {\n                ranking1: {\n                    backgroundColor: {\n                        image: require(\"@/views/images/ranking1.png\"),\n                    },\n                    height: 24,\n                    alingn: \"center\",\n                    width: 32,\n                },\n                ranking2: {\n                    backgroundColor: {\n                        image: require(\"@/views/images/ranking2.png\"),\n                    },\n                    height: 24,\n                    alingn: \"center\",\n                    width: 32,\n                },\n                ranking3: {\n                    backgroundColor: {\n                        image: require(\"@/views/images/ranking3.png\"),\n                    },\n                    height: 24,\n                    alingn: \"center\",\n                    width: 32,\n                },\n                ranking4: {\n                    backgroundColor: {\n                        image: require(\"@/views/images/ranking4.png\"),\n                    },\n                    height: 24,\n                    alingn: \"center\",\n                    width: 32,\n                },\n            },\n            textStyle: {\n                // 这里str是 axisLabel的每一个值\n                color: function(str, i) {\n                    return i > dataLeft.length - 4 ? \"#eb6793\" : \"#747474\";\n                },\n            },\n        },\n        data: dataLeft,\n    }, {\n        type: \"category\",\n        axisLine: {\n            show: false,\n        },\n        axisTick: {\n            show: false,\n        },\n        axisLabel: {\n            //lable太长控制截取\n            show: true,\n            formatter: function(value) {\n                var res = value;\n                // 长度超过4个的以省略号显示\n                if (res.length > 8) {\n                    res = res.substring(0, 8) + \"..\";\n                }\n                return res;\n            },\n        },\n        data: dataRight,\n    }, ],\n    series: [{\n        type: \"bar\",\n        showBackground: true, // 柱状图的补充背景色\n        backgroundStyle: {\n            // color: \"red\",\n            borderRadius: 5,\n        }, // 阴影样式\n        barWidth: 10, //柱图宽度\n        itemStyle: {\n            barBorderRadius: [4, 4, 4, 4], //柱状图圆角，初始化效果\n            color: new this.$echarts.graphic.LinearGradient(0, 0, 0, 1, [{\n                offset: 0,\n                color: \"#508EFF\",\n            }, {\n                offset: 1,\n                color: \"#82AEFE\",\n            }, ]),\n        },\n        emphasis: {\n            itemStyle: {\n                color: new this.$echarts.graphic.LinearGradient(0, 0, 0, 1, [{\n                    offset: 0,\n                    color: \"#508EFF\",\n                }, {\n                    offset: 1,\n                    color: \"#82AEFE\",\n                }, ]),\n            },\n        },\n        data: dataLeft,\n    }, ],\n};\n\noption && myChart.setOption(option);\n\n\n效果：\n\n\n\n# 设置柱状图宽度\n\n修改series对应数组里面的barWidth属性即可设置柱形图宽度，当然还有最小宽，最大宽则是barMinWidth和barMaxWidth\n\n# 正负轴向柱状图(单)\n\n\n\nvar data1 = [\n    {\n        name: '信用债：A户',\n        value: -1\n    },\n    {\n        name: '信用债：T户-外币',\n        value: 1\n    },\n\n    {\n        name: '信用债：A户-本币',\n        value: 1\n    },\n    {\n        name: '信用债：T户-本币',\n        value: 1\n    },\n    {\n        name: '利率债：A',\n        value: 1\n    },\n    {\n        name: '利率债：T户',\n        value: 4\n    }\n];\n// data = data.sort((a, b) => {\n//     return b.value - a.value\n// });\ngetArrByKey = (data, k) => {\n    let key = k || 'value';\n    let res = [];\n    if (data) {\n        data.forEach(function (t) {\n            res.push(t[key]);\n        });\n    }\n    return res;\n};\ngetRightData = (data, k) => {\n    let key = k || 'value';\n    let res = [];\n    if (data) {\n        data.forEach(function (t) {\n            res.push(t[key] < 0 ? 0 : t[key]);\n        });\n    }\n    return res;\n};\ngetLeftData = (data, k) => {\n    let key = k || 'value';\n    let res = [];\n    if (data) {\n        data.forEach(function (t) {\n            res.push(t[key] > 0 ? 0 : t[key]);\n        });\n    }\n    return res;\n};\n\nopt = {\n    index: 0\n};\n// [起始最深颜色,结束的浅颜色]\n// colorLeft = ['#0CEBEA', '#368BFF'];\ncolorLeft = ['#1f83ff', '#1f83ff'];\ncolorRight = ['rgba(255,144,128,1)', 'rgba(255,144,128,1)'];\n\noption = {\n    backgroundColor: '#fff',\n    title: {\n        text: '累计盈利（亿）：区间变化',\n        left: 'center',\n        top: '5%',\n        textStyle: {\n            color: 'rgba(0,0,0,0.65)',\n            fontSize: 24\n        }\n    },\n    // legend: {\n    //   top: \"15%\",\n    //   right: \"16%\",\n    //   itemWidth: 70,\n    //   itemHeight: 22,\n    //   itemGap: 40,\n    //   orient: \"horizontal\",\n    //   icon: \"circle\",\n    //   textStyle: {\n    //     color: \"#000\",\n    //     fontSize: 16,\n    //   },\n    //   data: [\"飞行员\", \"乘务员\"],\n    // },\n    grid: [\n        {\n            show: false,\n            left: '10%',\n            top: '20%',\n            bottom: '30%',\n            width: '28%'\n        },\n        {\n            show: false,\n            left: '50%',\n            top: '20%',\n            bottom: '30%',\n            width: '20%'\n        },\n        {\n            show: false,\n            right: '10%',\n            top: '20%',\n            bottom: '30%',\n            width: '28%'\n        }\n    ],\n    tooltip: {\n        show: false,\n        // 设置  是否百分比\n        formatter: '{b} : {c}'\n    },\n    xAxis: [\n        {\n            type: 'value',\n            inverse: false,\n            axisLine: {\n                show: false\n            },\n            axisTick: {\n                show: false\n            },\n            position: 'bottom',\n            axisLabel: {\n                show: true,\n                textStyle: {\n                    color: '#000',\n                    type: 'dashed'\n                }\n            },\n            splitLine: {\n                show: true\n            }\n        },\n        {\n            gridIndex: 1,\n            show: true,\n            type: 'value',\n            inverse: false,\n            axisLine: {\n                show: false\n            },\n            axisTick: {\n                show: true\n            },\n            position: 'bottom',\n            axisLabel: {\n                show: true,\n                textStyle: {\n                    color: '#000'\n                }\n            },\n            splitLine: {\n                show: false\n            }\n        },\n        {\n            gridIndex: 2,\n            show: true,\n            type: 'value',\n            inverse: false,\n            axisLine: {\n                show: false\n            },\n            axisTick: {\n                show: false\n            },\n            position: 'bottom',\n            axisLabel: {\n                show: true,\n                textStyle: {\n                    color: '#000',\n                    type: 'dashed'\n                }\n            },\n            splitLine: {\n                show: true\n            }\n        }\n    ],\n    yAxis: [\n        {\n            gridIndex: 0,\n            triggerEvent: true,\n            show: true,\n            inverse: true,\n            data: getArrByKey(data1, 'name'),\n            axisLine: {\n                show: false\n            },\n            splitLine: {\n                show: false\n            },\n            axisTick: {\n                show: false\n            },\n            axisLabel: {\n                show: false\n            }\n        },\n        {\n            gridIndex: 1,\n            type: 'category',\n            inverse: true,\n            position: 'left',\n            axisLine: {\n                show: false\n            },\n            axisTick: {\n                show: false\n            },\n            axisLabel: {\n                show: true,\n                interval: 0,\n                align: 'auto',\n                verticalAlign: 'middle',\n                textStyle: {\n                    color: '#000',\n                    fontSize: 16,\n                    align: 'center'\n                }\n            },\n            data: getArrByKey(data1, 'name')\n        },\n        {\n            gridIndex: 2,\n            triggerEvent: true,\n            show: true,\n            inverse: true,\n            data: getArrByKey(data1, 'name'),\n            axisLine: {\n                show: false\n            },\n            splitLine: {\n                show: false\n            },\n            axisTick: {\n                show: false\n            },\n            axisLabel: {\n                show: false\n            }\n        }\n    ],\n    series: [\n        {\n            type: 'bar',\n            gridIndex: 0,\n            showBackground: false,\n            backgroundStyle: {\n                barBorderRadius: 30\n            },\n            xAxisIndex: 0,\n            yAxisIndex: 0,\n            data: getLeftData(data1),\n            barWidth: 20,\n            // barCategoryGap: '40%',\n            itemStyle: {\n                normal: {\n                    show: true,\n                    // 线性渐变，前四个参数分别是 x0, y0, x2, y2, 范围从 0 - 1，分别表示右,下,左,上。例如（0，0，0，1）表示从正上开始向下渐变；如果是（1，0，0，0），则是从正右开始向左渐变。\n                    // 相当于在图形包围盒中的百分比，如果最后一个参数传 true，则该四个值是绝对的像素位置\n                    color: new echarts.graphic.LinearGradient(\n                        0,\n                        0,\n                        1,\n                        0,\n                        [\n                            {\n                                offset: 0,\n                                color: colorRight[0] //指0%处的颜色\n                            },\n                            {\n                                offset: 1,\n                                color: colorRight[1] //指100%处的颜色\n                            }\n                        ],\n                        false\n                    )\n                    // barBorderRadius: [5, 0, 0, 5]\n                }\n            },\n\n            label: {\n                normal: {\n                    show: false,\n                    position: 'insideLeft',\n                    textStyle: {\n                        color: '#fff',\n                        fontSize: '14'\n                    }\n                }\n            }\n        },\n        {\n            type: 'bar',\n            xAxisIndex: 2,\n            yAxisIndex: 2,\n            gridIndex: 2,\n            showBackground: false,\n            backgroundStyle: {\n                barBorderRadius: 30\n            },\n            data: getRightData(data1),\n            barWidth: 20,\n            // barCategoryGap: '40%',\n            itemStyle: {\n                normal: {\n                    show: true,\n                    // 线性渐变，前四个参数分别是 x0, y0, x2, y2, 范围从 0 - 1，分别表示右,下,左,上。例如（0，0，0，1）表示从正上开始向下渐变；如果是（1，0，0，0），则是从正右开始向左渐变。\n                    // 相当于在图形包围盒中的百分比，如果最后一个参数传 true，则该四个值是绝对的像素位置\n                    color: new echarts.graphic.LinearGradient(\n                        0,\n                        0,\n                        1,\n                        0,\n                        [\n                            {\n                                offset: 0,\n                                color: colorRight[0] //指0%处的颜色\n                            },\n                            {\n                                offset: 1,\n                                color: colorRight[1] //指100%处的颜色\n                            }\n                        ],\n                        false\n                    )\n                    // barBorderRadius: [0, 5, 5, 0]\n                }\n            },\n            label: {\n                normal: {\n                    show: false,\n                    position: 'insideRight',\n                    textStyle: {\n                        color: '#ffffff',\n                        fontSize: '14'\n                    }\n                }\n            }\n        }\n    ]\n};\n\n\n\n# 正负轴向柱状图(多)\n\n\n\nvar data1 = [\n    {\n        name: '保证金余额',\n        value: -1,\n        value1: -2,\n        value2: -4\n    },\n    {\n        name: '追加保证金',\n        value: 1,\n        value1: 2,\n        value2: 3\n    },\n\n    {\n        name: '累计损益',\n        value: 1,\n        value1: -4,\n        value2: 0.5\n    },\n    {\n        name: '日损益',\n        value: 1,\n        value1: 1,\n        value2: -4\n    },\n    {\n        name: '维持保证金',\n        value: 1,\n        value1: 3,\n        value2: -0.5\n    },\n    {\n        name: '初始保证金',\n        value: 4,\n        value1: -2,\n        value2: 1.5\n    }\n];\n// data = data.sort((a, b) => {\n//     return b.value - a.value\n// });\ngetArrByKey = (data, k) => {\n    let key = k || 'value';\n    let res = [];\n    if (data) {\n        data.forEach(function (t) {\n            res.push(t[key]);\n        });\n    }\n    return res;\n};\ngetRightData = (data, k) => {\n    let key = k || 'value';\n    let res = [];\n    if (data) {\n        data.forEach(function (t) {\n            res.push(t[key] < 0 ? 0 : t[key]);\n        });\n    }\n    return res;\n};\ngetLeftData = (data, k) => {\n    let key = k || 'value';\n    let res = [];\n    if (data) {\n        data.forEach(function (t) {\n            res.push(t[key] > 0 ? 0 : t[key]);\n        });\n    }\n    return res;\n};\n\nopt = {\n    index: 0\n};\n// [起始最深颜色,结束的浅颜色]\n// colorLeft = ['#0CEBEA', '#368BFF'];\ncolorLeft = ['#1f83ff', '#1f83ff'];\ncolorRight = [\n    ['rgba(59,160,254,1)', 'rgba(59,160,254,1)'],\n    ['rgba(79,202,116,1)', 'rgba(79,202,116,1)'],\n    ['rgba(254,185,123,1)', 'rgba(254,185,123,1)']\n];\n\noption = {\n    backgroundColor: '#fff',\n    title: {\n        text: '日保证金情况监控',\n        left: 'center',\n        top: '5%',\n        textStyle: {\n            color: 'rgba(0,0,0,0.65)',\n            fontSize: 24\n        }\n    },\n    legend: {\n        top: \"12%\",\n        // right: \"16%\",\n        // itemWidth: 70,\n        // itemHeight: 22,\n        // itemGap: 40,\n        // orient: \"horizontal\",\n        // icon: \"circle\",\n        textStyle: {\n            color: \"#000\",\n            fontSize: 16,\n        },\n        data: [\"企业1\", \"企业2\",\"企业3\"],\n    },\n    grid: [\n        {\n            show: false,\n            left: '10%',\n            top: '20%',\n            bottom: '20%',\n            width: '28%'\n        },\n        {\n            show: false,\n            left: '50%',\n            top: '20%',\n            bottom: '20%',\n            width: '20%'\n        },\n        {\n            show: false,\n            right: '10%',\n            top: '20%',\n            bottom: '20%',\n            width: '28%'\n        }\n    ],\n    tooltip: {\n        show: false,\n        // 设置  是否百分比\n        formatter: '{b} : {c}'\n    },\n    xAxis: [\n        {\n            type: 'value',\n            inverse: false,\n            axisLine: {\n                show: false\n            },\n            axisTick: {\n                show: false\n            },\n            position: 'bottom',\n            axisLabel: {\n                show: true,\n                textStyle: {\n                    color: '#000',\n                    type: 'dashed'\n                }\n            },\n            splitLine: {\n                show: true\n            }\n        },\n        {\n            gridIndex: 1,\n            show: true,\n            type: 'value',\n            inverse: false,\n            axisLine: {\n                show: false\n            },\n            axisTick: {\n                show: true\n            },\n            position: 'bottom',\n            axisLabel: {\n                show: true,\n                textStyle: {\n                    color: '#000'\n                }\n            },\n            splitLine: {\n                show: false\n            }\n        },\n        {\n            gridIndex: 2,\n            show: true,\n            type: 'value',\n            inverse: false,\n            axisLine: {\n                show: false\n            },\n            axisTick: {\n                show: false\n            },\n            position: 'bottom',\n            axisLabel: {\n                show: true,\n                textStyle: {\n                    color: '#000',\n                    type: 'dashed'\n                }\n            },\n            splitLine: {\n                show: true\n            }\n        }\n    ],\n    yAxis: [\n        {\n            gridIndex: 0,\n            triggerEvent: true,\n            show: true,\n            inverse: true,\n            data: getArrByKey(data1, 'name'),\n            axisLine: {\n                show: false\n            },\n            splitLine: {\n                show: false\n            },\n            axisTick: {\n                show: false\n            },\n            axisLabel: {\n                show: false\n            }\n        },\n        {\n            gridIndex: 1,\n            type: 'category',\n            inverse: true,\n            position: 'left',\n            axisLine: {\n                show: false\n            },\n            axisTick: {\n                show: false\n            },\n            axisLabel: {\n                show: true,\n                interval: 0,\n                align: 'auto',\n                verticalAlign: 'middle',\n                textStyle: {\n                    color: '#000',\n                    fontSize: 16,\n                    align: 'center'\n                }\n            },\n            data: getArrByKey(data1, 'name')\n        },\n        {\n            gridIndex: 2,\n            triggerEvent: true,\n            show: true,\n            inverse: true,\n            data: getArrByKey(data1, 'name'),\n            axisLine: {\n                show: false\n            },\n            splitLine: {\n                show: false\n            },\n            axisTick: {\n                show: false\n            },\n            axisLabel: {\n                show: false\n            }\n        }\n    ],\n    series: [\n        {\n            name:'企业1',\n            type: 'bar',\n            gridIndex: 0,\n            showBackground: false,\n            backgroundStyle: {\n                barBorderRadius: 30\n            },\n            xAxisIndex: 0,\n            yAxisIndex: 0,\n            data: getLeftData(data1),\n            // max-barWidth: 20,\n            // barCategoryGap: '40%',\n            itemStyle: {\n                normal: {\n                    show: true,\n                    // 线性渐变，前四个参数分别是 x0, y0, x2, y2, 范围从 0 - 1，分别表示右,下,左,上。例如（0，0，0，1）表示从正上开始向下渐变；如果是（1，0，0，0），则是从正右开始向左渐变。\n                    // 相当于在图形包围盒中的百分比，如果最后一个参数传 true，则该四个值是绝对的像素位置\n                    color: new echarts.graphic.LinearGradient(\n                        0,\n                        0,\n                        1,\n                        0,\n                        [\n                            {\n                                offset: 0,\n                                color: colorRight[0][0] //指0%处的颜色\n                            },\n                            {\n                                offset: 1,\n                                color: colorRight[0][1] //指100%处的颜色\n                            }\n                        ],\n                        false\n                    )\n                    // barBorderRadius: [5, 0, 0, 5]\n                }\n            },\n\n            label: {\n                normal: {\n                    show: false,\n                    position: 'insideLeft',\n                    textStyle: {\n                        color: '#fff',\n                        fontSize: '14'\n                    }\n                }\n            }\n        },\n        {\n            name:'企业1',\n            type: 'bar',\n            xAxisIndex: 2,\n            yAxisIndex: 2,\n            gridIndex: 2,\n            showBackground: false,\n            backgroundStyle: {\n                barBorderRadius: 30\n            },\n            data: getRightData(data1),\n            // barWidth: 20,\n            // barCategoryGap: '40%',\n            itemStyle: {\n                normal: {\n                    show: true,\n                    // 线性渐变，前四个参数分别是 x0, y0, x2, y2, 范围从 0 - 1，分别表示右,下,左,上。例如（0，0，0，1）表示从正上开始向下渐变；如果是（1，0，0，0），则是从正右开始向左渐变。\n                    // 相当于在图形包围盒中的百分比，如果最后一个参数传 true，则该四个值是绝对的像素位置\n                    color: new echarts.graphic.LinearGradient(\n                        0,\n                        0,\n                        1,\n                        0,\n                        [\n                            {\n                                offset: 0,\n                                color: colorRight[0][0] //指0%处的颜色\n                            },\n                            {\n                                offset: 1,\n                                color: colorRight[0][1] //指100%处的颜色\n                            }\n                        ],\n                        false\n                    )\n                    // barBorderRadius: [0, 5, 5, 0]\n                }\n            },\n            label: {\n                normal: {\n                    show: false,\n                    position: 'insideRight',\n                    textStyle: {\n                        color: '#ffffff',\n                        fontSize: '14'\n                    }\n                }\n            }\n        },\n        {\n            name:'企业2',\n            type: 'bar',\n            gridIndex: 0,\n            showBackground: false,\n            backgroundStyle: {\n                barBorderRadius: 30\n            },\n            xAxisIndex: 0,\n            yAxisIndex: 0,\n            data: getLeftData(data1,'value1'),\n            // barWidth: 20,\n            // barCategoryGap: '40%',\n            itemStyle: {\n                normal: {\n                    show: true,\n                    // 线性渐变，前四个参数分别是 x0, y0, x2, y2, 范围从 0 - 1，分别表示右,下,左,上。例如（0，0，0，1）表示从正上开始向下渐变；如果是（1，0，0，0），则是从正右开始向左渐变。\n                    // 相当于在图形包围盒中的百分比，如果最后一个参数传 true，则该四个值是绝对的像素位置\n                    color: new echarts.graphic.LinearGradient(\n                        0,\n                        0,\n                        1,\n                        0,\n                        [\n                            {\n                                offset: 0,\n                                color: colorRight[1][0] //指0%处的颜色\n                            },\n                            {\n                                offset: 1,\n                                color: colorRight[1][1] //指100%处的颜色\n                            }\n                        ],\n                        false\n                    )\n                    // barBorderRadius: [5, 0, 0, 5]\n                }\n            },\n\n            label: {\n                normal: {\n                    show: false,\n                    position: 'insideLeft',\n                    textStyle: {\n                        color: '#fff',\n                        fontSize: '14'\n                    }\n                }\n            }\n        },\n        {\n            name:'企业2',\n            type: 'bar',\n            xAxisIndex: 2,\n            yAxisIndex: 2,\n            gridIndex: 2,\n            showBackground: false,\n            backgroundStyle: {\n                barBorderRadius: 30\n            },\n            data: getRightData(data1,'value1'),\n            // barWidth: 20,\n            // barCategoryGap: '40%',\n            itemStyle: {\n                normal: {\n                    show: true,\n                    // 线性渐变，前四个参数分别是 x0, y0, x2, y2, 范围从 0 - 1，分别表示右,下,左,上。例如（0，0，0，1）表示从正上开始向下渐变；如果是（1，0，0，0），则是从正右开始向左渐变。\n                    // 相当于在图形包围盒中的百分比，如果最后一个参数传 true，则该四个值是绝对的像素位置\n                    color: new echarts.graphic.LinearGradient(\n                        0,\n                        0,\n                        1,\n                        0,\n                        [\n                            {\n                                offset: 0,\n                                color: colorRight[1][0] //指0%处的颜色\n                            },\n                            {\n                                offset: 1,\n                                color: colorRight[1][1] //指100%处的颜色\n                            }\n                        ],\n                        false\n                    )\n                    // barBorderRadius: [0, 5, 5, 0]\n                }\n            },\n            label: {\n                normal: {\n                    show: false,\n                    position: 'insideRight',\n                    textStyle: {\n                        color: '#ffffff',\n                        fontSize: '14'\n                    }\n                }\n            }\n        },\n        {\n            name:'企业3',\n            type: 'bar',\n            gridIndex: 0,\n            showBackground: false,\n            backgroundStyle: {\n                barBorderRadius: 30\n            },\n            xAxisIndex: 0,\n            yAxisIndex: 0,\n            data: getLeftData(data1,'value2'),\n            // barWidth: 20,\n            // barCategoryGap: '40%',\n            itemStyle: {\n                normal: {\n                    show: true,\n                    // 线性渐变，前四个参数分别是 x0, y0, x2, y2, 范围从 0 - 1，分别表示右,下,左,上。例如（0，0，0，1）表示从正上开始向下渐变；如果是（1，0，0，0），则是从正右开始向左渐变。\n                    // 相当于在图形包围盒中的百分比，如果最后一个参数传 true，则该四个值是绝对的像素位置\n                    color: new echarts.graphic.LinearGradient(\n                        0,\n                        0,\n                        1,\n                        0,\n                        [\n                            {\n                                offset: 0,\n                                color: colorRight[2][0] //指0%处的颜色\n                            },\n                            {\n                                offset: 1,\n                                color: colorRight[2][1] //指100%处的颜色\n                            }\n                        ],\n                        false\n                    )\n                    // barBorderRadius: [5, 0, 0, 5]\n                }\n            },\n\n            label: {\n                normal: {\n                    show: false,\n                    position: 'insideLeft',\n                    textStyle: {\n                        color: '#fff',\n                        fontSize: '14'\n                    }\n                }\n            }\n        },\n        {\n            name:'企业3',\n            type: 'bar',\n            xAxisIndex: 2,\n            yAxisIndex: 2,\n            gridIndex: 2,\n            showBackground: false,\n            backgroundStyle: {\n                barBorderRadius: 30\n            },\n            data: getRightData(data1,'value2'),\n            // barWidth: 20,\n            // barCategoryGap: '40%',\n            itemStyle: {\n                normal: {\n                    show: true,\n                    // 线性渐变，前四个参数分别是 x0, y0, x2, y2, 范围从 0 - 1，分别表示右,下,左,上。例如（0，0，0，1）表示从正上开始向下渐变；如果是（1，0，0，0），则是从正右开始向左渐变。\n                    // 相当于在图形包围盒中的百分比，如果最后一个参数传 true，则该四个值是绝对的像素位置\n                    color: new echarts.graphic.LinearGradient(\n                        0,\n                        0,\n                        1,\n                        0,\n                        [\n                            {\n                                offset: 0,\n                                color: colorRight[2][0] //指0%处的颜色\n                            },\n                            {\n                                offset: 1,\n                                color: colorRight[2][1] //指100%处的颜色\n                            }\n                        ],\n                        false\n                    )\n                    // barBorderRadius: [0, 5, 5, 0]\n                }\n            },\n            label: {\n                normal: {\n                    show: false,\n                    position: 'insideRight',\n                    textStyle: {\n                        color: '#ffffff',\n                        fontSize: '14'\n                    }\n                }\n            }\n        },\n    ]\n};\n\n\n\n# 两柱状图\n\n\n\noption = {\n    title: {\n        text: \"生产监控系统\",\n        subtext: \"实时产能监控\",\n        left: \"center\",\n    },\n    tooltip: {\n        trigger: \"axis\",\n        axisPointer: {\n            // 坐标轴指示器，坐标轴触发有效\n            type: \"shadow\", // 默认为直线，可选为：'line' | 'shadow'\n        },\n        //     formatter: function(params){return Math.max(params.value,-params.value)}\n\n        formatter: function (params) {\n            return (\n                params[0].name +\n                \"<br>生产中：\" +\n                params[0].value +\n                \"<br>等待中：\" +\n                -params[1].value\n            );\n        },\n    },\n    legend: {\n        data: [\"等待中\", \"生产中\"],\n        left: \"right\",\n    },\n    grid: {\n        left: \"3%\",\n        right: \"4%\",\n        bottom: \"3%\",\n        containLabel: true,\n    },\n    xAxis: [\n        {\n            type: \"value\",\n        },\n    ],\n    yAxis: [\n        {\n            type: \"category\",\n            axisTick: { show: false },\n            data: [\n                \"分拣\",\n                \"清洗\",\n                \"抛光\",\n                \"研磨\",\n                \"脱膜\",\n                \"切割\",\n                \"压膜\",\n                \"压膜分配\",\n                \"光固化后处理\",\n                \"光固化\",\n            ],\n        },\n    ],\n    series: [\n        {\n            name: \"等待中\",\n            type: \"bar\",\n            stack: \"总量\",\n            label: {\n                normal: {\n                    show: true,\n                },\n            },\n            data: [400, 241, 360, 320, 302, 341, 374, -390, 450, 420],\n        },\n        {\n            name: \"生产中\",\n            type: \"bar\",\n            stack: \"总量\",\n            label: {\n                normal: {\n                    show: true,\n                    formatter: function (params) {\n                        return -params.value;\n                    },\n                },\n            },\n            data: [-120, -180, -120, -120, -132, -101, -134, -190, -230, -210],\n        },\n    ],\n};\n\n\n\n# 两柱状图标签\n\n\n\nvar xData = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"];\nvar lineData = [100, 100, 100, 100, 100, 100, 100];\nvar lastYearData = [3, 20, 62, 34, 55, 65, 33];\nvar thisYearData = [11, 38, 23, 39, 66, 66, 79];\nvar timeLineData = [1];\nlet legend = [\"2017\", \"2018\"];\nvar background = \"#0e2147\"; //背景\nlet textColor = \"#fff\";\nlet lineColor = \"rgba(255,255,255,0.2)\";\nlet colors = [\n    {\n        borderColor: \"rgba(227,161,96,1)\",\n        start: \"rgba(227,161,96,0.8)\",\n        end: \"rgba(227,161,96,0.3)\",\n    },\n    {\n        borderColor: \"rgba(0,222,255,1)\",\n        start: \"rgba(0,222,255,0.3)\",\n        end: \"rgba(0,222,255,0.8)\",\n    },\n];\nlet borderData = [];\nlet scale = 2;\nborderData = xData.map((item) => {\n    return scale;\n});\nvar option = {\n    baseOption: {\n        backgroundColor: background,\n        timeline: {\n            show: false,\n            top: 0,\n            data: [],\n        },\n        legend: {\n            top: \"5%\",\n            right: \"5%\",\n            itemWidth: 20,\n            itemHeight: 5,\n            // itemGap: 343,\n            icon: \"horizontal\",\n            textStyle: {\n                color: \"#ffffff\",\n                fontSize: 20,\n            },\n            data: legend,\n        },\n        grid: [\n            {\n                show: false,\n                left: \"5%\",\n                top: \"10%\",\n                bottom: \"8%\",\n                containLabel: true,\n                width: \"37%\",\n            },\n            {\n                show: false,\n                left: \"51%\",\n                top: \"10%\",\n                bottom: \"8%\",\n                width: \"0%\",\n            },\n            {\n                show: false,\n                right: \"2%\",\n                top: \"10%\",\n                bottom: \"8%\",\n                containLabel: true,\n                width: \"37%\",\n            },\n        ],\n        xAxis: [\n            {\n                type: \"value\",\n                inverse: true,\n                axisLine: {\n                    show: false,\n                },\n                axisTick: {\n                    show: false,\n                },\n                position: \"top\",\n                axisLabel: {\n                    show: true,\n                    color: textColor,\n                },\n                splitLine: {\n                    show: true,\n                    lineStyle: {\n                        color: lineColor,\n                    },\n                },\n            },\n            {\n                gridIndex: 1,\n                show: false,\n            },\n            {\n                gridIndex: 2,\n                axisLine: {\n                    show: false,\n                },\n                axisTick: {\n                    show: false,\n                },\n                position: \"top\",\n                axisLabel: {\n                    show: true,\n                    color: textColor,\n                },\n                splitLine: {\n                    show: true,\n                    lineStyle: {\n                        color: lineColor,\n                    },\n                },\n            },\n        ],\n        yAxis: [\n            {\n                type: \"category\",\n                inverse: true,\n                position: \"right\",\n                axisLine: {\n                    show: true,\n                    lineStyle: {\n                        color: lineColor,\n                    },\n                },\n\n                axisTick: {\n                    show: false,\n                },\n                axisLabel: {\n                    show: false,\n                },\n                data: xData,\n            },\n            {\n                gridIndex: 1,\n                type: \"category\",\n                inverse: true,\n                position: \"left\",\n                axisLine: {\n                    show: false,\n                },\n                axisTick: {\n                    show: false,\n                },\n                axisLabel: {\n                    show: true,\n                    padding: [30, 0, 0, 0],\n                    textStyle: {\n                        color: \"#ffffff\",\n                        fontSize: 20,\n                    },\n                    align: \"center\",\n                },\n                data: xData.map(function (value) {\n                    return {\n                        value: value,\n                        textStyle: {\n                            align: \"center\",\n                        },\n                    };\n                }),\n            },\n            {\n                gridIndex: 2,\n                type: \"category\",\n                inverse: true,\n                position: \"left\",\n                axisLine: {\n                    show: true,\n                    lineStyle: {\n                        color: lineColor,\n                    },\n                },\n                axisTick: {\n                    show: false,\n                },\n                axisLabel: {\n                    show: false,\n                },\n                data: xData,\n            },\n        ],\n        series: [],\n    },\n    options: [],\n};\n\noption.baseOption.timeline.data.push(timeLineData[0]);\noption.options.push({\n    series: [\n        {\n            name: \"2017\",\n            type: \"bar\",\n            barWidth: 25,\n            stack: \"1\",\n            itemStyle: {\n                normal: {\n                    color: new echarts.graphic.LinearGradient(0, 0, 1, 0, [\n                        {\n                            offset: 0,\n                            color: colors[0].start,\n                        },\n                        {\n                            offset: 1,\n                            color: colors[0].end,\n                        },\n                    ]),\n                },\n            },\n            label: {\n                normal: {\n                    show: false,\n                },\n            },\n            data: lastYearData,\n            animationEasing: \"elasticOut\",\n        },\n        {\n            name: \"2017\",\n            type: \"bar\",\n            barWidth: 25,\n            stack: \"1\",\n            itemStyle: {\n                normal: {\n                    color: colors[0].borderColor,\n                },\n            },\n            data: borderData,\n        },\n        {\n            name: \"2018\",\n            type: \"bar\",\n            stack: \"2\",\n            barWidth: 25,\n            xAxisIndex: 2,\n            yAxisIndex: 2,\n            itemStyle: {\n                normal: {\n                    color: new echarts.graphic.LinearGradient(0, 0, 1, 0, [\n                        {\n                            offset: 0,\n                            color: colors[1].start,\n                        },\n                        {\n                            offset: 1,\n                            color: colors[1].end,\n                        },\n                    ]),\n                },\n            },\n            label: {\n                normal: {\n                    show: false,\n                },\n            },\n            data: thisYearData,\n            animationEasing: \"elasticOut\",\n        },\n        {\n            name: \"2018\",\n            type: \"bar\",\n            xAxisIndex: 2,\n            yAxisIndex: 2,\n            barWidth: 25,\n            stack: \"2\",\n            itemStyle: {\n                normal: {\n                    color: colors[1].borderColor,\n                },\n            },\n            data: borderData,\n        },\n    ],\n});\n\n\n\n# Y轴坐标放图片\n\n\n\nvar chartDom = document.getElementById(\"topRanking\");\nvar myChart = this.$echarts.init(chartDom);\nvar option;\nlet dataLeft = [30, 40, 50, 60, 70, 99];\nlet dataRight = [\n    \"经营支出KPI\",\n    \"月经营分析报表\",\n    \"高端女性消费群体标签\",\n    \"客户风险能力评估模型\",\n    \"客户基础信息服务API\",\n    \"季度考核KPI\",\n];\n\noption = {\n    tooltip: {\n        trigger: \"axis\",\n        axisPointer: {\n            type: \"shadow\",\n        },\n    },\n    grid: {\n        x: 30, //左侧与y轴的距离\n        y: 30, //top部与x轴的距离\n        x2: 30, //右侧与y轴的距离\n        y2: 30, //bottom部与x轴的距离\n        containLabel: true,\n    },\n    xAxis: {\n        type: \"value\",\n        axisLabel: {\n            //坐标label\n            show: false,\n        },\n        axisLine: {\n            //坐标轴线\n            show: false,\n        },\n        axisTick: {\n            //x轴刻度线\n            show: false,\n        },\n        splitLine: {\n            //网格线\n            show: false,\n        },\n        // boundaryGap: [0, 0.01]\n    },\n    yAxis: [\n        {\n            type: \"category\",\n            axisLine: {\n                show: false,\n            },\n            axisTick: {\n                show: false,\n            },\n            axisLabel: {\n                // formatter: \" {a|} {value} 次\",\n                formatter: function (value, index) {\n                    console.log(value, \"==value\");\n                    console.log(index, \"==index\");\n                    let img = \"\";\n                    if (index > dataLeft.length - 2) {\n                        img = \"ranking1\";\n                    } else if (index > dataLeft.length - 3) {\n                        img = \"ranking2\";\n                    } else if (index > dataLeft.length - 4) {\n                        img = \"ranking3\";\n                    } else {\n                        img = \"ranking4\";\n                    }\n\n                    return ` {${img}|} ${value} 次`;\n                },\n                rich: {\n                    ranking1: {\n                        backgroundColor: {\n                            image: require(\"@/views/images/ranking1.png\"),\n                        },\n                        height: 24,\n                        alingn: \"center\",\n                        width: 32,\n                    },\n                    ranking2: {\n                        backgroundColor: {\n                            image: require(\"@/views/images/ranking2.png\"),\n                        },\n                        height: 24,\n                        alingn: \"center\",\n                        width: 32,\n                    },\n                    ranking3: {\n                        backgroundColor: {\n                            image: require(\"@/views/images/ranking3.png\"),\n                        },\n                        height: 24,\n                        alingn: \"center\",\n                        width: 32,\n                    },\n                    ranking4: {\n                        backgroundColor: {\n                            image: require(\"@/views/images/ranking4.png\"),\n                        },\n                        height: 24,\n                        alingn: \"center\",\n                        width: 32,\n                    },\n                },\n                textStyle: {\n                    // 这里str是 axisLabel的每一个值\n                    color: function (str, i) {\n                        return i > dataLeft.length - 4 ? \"#eb6793\" : \"#747474\";\n                    },\n                },\n            },\n            data: dataLeft,\n        },\n        {\n            type: \"category\",\n            axisLine: {\n                show: false,\n            },\n            axisTick: {\n                show: false,\n            },\n            data: dataRight,\n        },\n    ],\n    series: [\n        {\n            type: \"bar\",\n            showBackground: true, // 柱状图的补充背景色\n            barWidth: 10, //柱图宽度\n            itemStyle: {\n                barBorderRadius: [4, 4, 4, 4], //柱状图圆角，初始化效果\n                color: new this.$echarts.graphic.LinearGradient(0, 0, 0, 1, [\n                    { offset: 0, color: \"#83bff6\" },\n                    { offset: 0.5, color: \"#188df0\" },\n                    { offset: 1, color: \"#188df0\" },\n                ]),\n            },\n            emphasis: {\n                itemStyle: {\n                    color: new this.$echarts.graphic.LinearGradient(0, 0, 0, 1, [\n                        { offset: 0, color: \"#2378f7\" },\n                        { offset: 0.7, color: \"#2378f7\" },\n                        { offset: 1, color: \"#83bff6\" },\n                    ]),\n                },\n            },\n            data: dataLeft,\n        },\n    ],\n};\n\noption && myChart.setOption(option);\n\n\n# echarts中的柱状图设置最大值、最小值、和平均值线条（vue项目中）\n\n\n\nlet  option= {\n    tooltip: {\n        show: true,\n    },\n    xAxis: {\n        data: [\"衬衫\", \"羊毛衫\", \"雪纺衫\", \"裤子\", \"高跟鞋\", \"袜子\"],\n    },\n    yAxis: {\n        type: \"value\",\n    },\n    color:\"#baf\",\n    series: [\n        {\n            name: \"销量\",\n            type: \"bar\",\n            data: [5, 20, 36, 10, 10, 20],\n            // ----------------------看这里往下---------------------------------\n            markPoint: { // 设置最大值和最小值\n                data: [\n                    {\n                        type: \"max\",\n                        name: \"我是最大值\",\n                    },\n                    {\n                        type: \"min\",\n                        name: \"我是最小值\",\n                    },\n                ],\n            },\n            markLine:{ // 设置平均线\n                data:[\n                    {\n                        type:\"average\", \n                        name:\"我是平均值\",\n                        color:\"#baf\"\n                    }\n                ]\n            },\n            // --------------------看这里往上---------------------------------\n            label:{ // 展示具体柱状图的数值\n                show:true\n            }\n        },\n    ],\n},\n\n\n# 修改颜色\n\n# 单条柱状图\n\n# 只有一中颜色\n\nseries: [\n    {\n        data: [120, 200, 150, 80, 70, 110, 130],\n        type: 'bar',\n        barWidth: 10, //柱图宽度\n        itemStyle: {\n            normal: {\n                color:\"#FFD700\",\n            },\n        },\n    }\n]\n\n\n# 循环颜色\n\nitemStyle:{\n    normal: {\n        color: function (params) {\n            var colorList = [\n                \"#82B7F5\",\n                \"#FF6262\",\n                \"#29EB81\",\n                \"#FA1EC9\",\n                \"#3CEAF0\",\n                \"#F3B637\",\n                \"#AB79EB\",\n                \"#F48D32\",\n                \"#4E68F1\",\n                \"#EBD22B\",\n            ];\n            return colorList[params.dataIndex % colorList.length];\n        },\n            barBorderRadius: [4, 4, 4, 4], //柱状图圆角，初始化效果\n    },\n}\n\n\n# 渐变色\n\n\n\ngetCardAuth(id) {\n    var chartDom = document.getElementById(id);\n    var myChart = echarts.init(chartDom);\n    var option;\n\n    option = {\n        grid: {\n            x: 30, //左侧与y轴的距离\n            y: 30, //top部与x轴的距离\n            x2: 30, //右侧与y轴的距离\n            y2: 40, //bottom部与x轴的距离\n            borderWidth: 1,\n        },\n        xAxis: {\n            type: \"category\",\n            data: [\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"],\n        },\n        yAxis: {\n            type: \"value\",\n        },\n        series: [\n            {\n                data: [120, 200, 150, 80, 70, 110, 130],\n                type: \"bar\",\n                barWidth: 20, //柱图宽度\n                itemStyle: {\n                    normal: {\n                        color: function (params) {\n                            const colorList = [\n                                new echarts.graphic.LinearGradient(\n                                    0,\n                                    1,\n                                    0,\n                                    0,\n                                    [\n                                        {\n                                            offset: 0,\n                                            color: \"#2a96ff\",\n                                        },\n                                        {\n                                            offset: 1,\n                                            color: \"#87c5fe\",\n                                        },\n                                    ],\n                                    false\n                                ),\n                            ];\n\n                            return colorList[0];\n                        },\n                        barBorderRadius: [4, 4, 0, 0], //柱状图圆角，初始化效果\n                    },\n                },\n            },\n        ],\n    };\n\n    option && myChart.setOption(option);\n},\n\n\n# 多条柱状图\n\nseries: [\n    {\n        type: \"bar\",\n        itemStyle: {\n            normal: {\n                color: “#2C71C1”,\n            },\n        },\n    },\n    {\n        type: \"bar\",\n        itemStyle: {\n            normal: {\n                color: “#36A2EB”,\n            },\n        },\n    },\n    {\n        type: \"bar\",\n        itemStyle: {\n            normal: {\n                color: “#4BC0C0”,\n            },\n        },\n    },\n],\n\n\n\n# 饼图\n\n# legend的数据\n\nvar dom3 = document.getElementById(\"departChart\");\nvar myChart3 = this.$echarts.init(dom3);\n\nlet departChart = document.getElementById(\"departChart\")\nlet offsetWidth = departChart.offsetWidth;    // 返回元素的总宽度\n\nlet that = this;\nlet option = {\n    tooltip: {\n        trigger: \"item\",\n    },\n    legend: {\n        type: \"scroll\",\n        orient: \"vertical\",\n        right: 0,\n        top: 20,\n        bottom: 20,\n        //设置自定义legend 的重点\n        formatter: function (name) {\n            // 获取legend显示内容\n            // let data = that.allData.assetByDept; //这个是展示的数据\n            // let total = 0;\n            // let tarValue = 0;\n            return [\n                that.$echarts.format.truncateText(\n                    name,\n                    offsetWidth * 0.41,\n                    \"14px Microsoft Yahei\",\n                    \"…\" //如果宽度超过80会出现...\n                ),\n            ].join(\" \");\n        },\n        tooltip: {\n            show: true,\n            trigger: \"item\",\n        },\n    },\n    series: [\n        {\n            type: \"pie\",\n            center: [\"35%\", \"50%\"],\n            radius: [\"30%\", \"55%\"],\n\n            itemStyle: {\n                // borderRadius: 10,\n                borderColor: \"#fff\",\n                borderWidth: 2,\n            },\n\n            label: {\n                show: false,\n                position: \"center\",\n            },\n            labelLine: {\n                show: false,\n            },\n            data: this.allData.assetByDept,\n            emphasis: {\n                itemStyle: {\n                    shadowBlur: 10,\n                    shadowOffsetX: 0,\n                    shadowColor: \"rgba(0, 0, 0, 0.5)\",\n                },\n            },\n        },\n    ],\n};\n\nmyChart3.setOption(option);\n\n\n效果：\n\n\n\n# echarts饼图，自定义legend，解决legend字数太多和太长的问题，翻页处理\n\nlet option = {\n    tooltip: {\n        trigger: \"item\",\n        formatter: \"{a} <br/>{b}: {c} ({d}%)\"\n    },\n    legend: {\n        type: \"scroll\",\n        orient: \"vertical\",\n        right: 20,\n        top: 5,\n        bottom: 10,\n        pageIconColor: \"white\",//激活的分页按钮颜色\n        pageIconInactiveColor: \"#2f4554\",//没激活的分页按钮颜色\n        //设置自定义legend 的重点\n        formatter: function(name) {\n            // 获取legend显示内容\n            let data = data1;//这个是展示的数据\n            let total = 0;\n            let tarValue = 0;\n            let value = 0;\n            for (let i = 0, l = data.length; i < l; i++) {\n                total += data[i].value;\n                if (data[i].name == name) {\n                    tarValue = data[i].value;\n                    value = data[i].value;\n                }\n            }\n            let p = total== 0? 0 ：((tarValue / total) * 100).toFixed(1);\n            return [\n                \"{a|\" +\n                echarts.format.truncateText(\n                    name,\n                    80,\n                    \"14px Microsoft Yahei\",\n                    \"…\"//如果宽度超过80会出现...\n                ) +\n                \"}\",\n                \"{b|\" + p + \"%}\",\n                \"{x|\" + value + \"}\"  //a、b、x、跟下面的rich对应\n            ].join(\" \");\n        },\n        tooltip: {\n            show: true,\t//这个为true的话悬停到legend上会出现tooltip\n            trigger: 'item',\n        },\n        textStyle: {\n            rich: {\n                a: {\n                    color: \"white\",\n                    width: 80,\n                    align: \"left\"\n                },\n                b: {\n                    width: 50,\n                    align: \"left\",\n                    color: \"white\"\n                },\n                x: {\n                    width: 30,\n                    align: \"left\",\n                    color: \"white\"\n                }\n            }\n        }\n    },\n    graphic: {//环形中间的字\n        elements: [\n            {\n                type: \"text\",\n                left: \"28%\",\n                top: \"43%\",\n                style: {\n                    text: \"666666\",\n                    textAlign: \"center\",\n                    fill: \"#fff\",\n                    fontSize: 32\n                }\n            },\n            {\n                type: \"text\",\n                left: \"28%\",\n                top: \"56%\",\n                style: {\n                    text: \"总人数（人）\",\n                    textAlign: \"center\",\n                    fill: \"#fff\",\n                    fontSize: 14\n                }\n            }\n        ]\n    },\n    series: [\n        {\n            name: \"访问来源\",\n            type: \"pie\",\n            radius: [\"50%\",\"70%\"],//环形图\n            center: [\"35%\", \"50%\"],\n            labelLine: {\n                show: false\n            },\n            label: {\n                show: false\n            },\n            data: data1\n        }\n    ]\n};\n\n\n# echarts 饼图取消legend图例的点击事件，保留鼠标悬浮legend上显示tooltie提示信息的事件\n\nmyCharts.on('legendselectchanged', function(params) {\n    var option = this.getOption();\n    option.legend[0].selected[params.name] = true;//相当于取消点击事件\n    this.setOption(option)\n})\n\n\n# 通过调整 center 按照百分比调整位置\n\nseries: [{\n    name: '圆环图系列名称',         // 系列名称\n    type: 'pie',                    // 系列类型\n    left: '0%',\n    center: ['24%', '50%'],           // 饼图的中心（圆心）坐标，数组的第一项是横坐标，第二项是纵坐标。[ default: ['50%', '50%'] ]\n    radius: ['30%', '40%'],         // 饼图的半径，数组的第一项是内半径，第二项是外半径。[ default: [0, '75%'] ]\n    hoverAnimation: true,           // 是否开启 hover 在扇区上的放大动画效果。[ default: true ]\n    color: color,                   // 圆环图的颜色\n    label: {                        // 饼图图形上的文本标签，可用于说明图形的一些数据信息，比如值，名称等.\n        normal: {\n            show: false,             // 是否显示标签[ default: false ]\n            position: 'outside',    // 标签的位置。'outside'饼图扇区外侧，通过视觉引导线连到相应的扇区。'inside','inner' 同 'inside',饼图扇区内部。'center'在饼图中心位置。\n            formatter: '{b} : {c}次'  // 标签内容\n        }\n    },\n    labelLine: {                    // 标签的视觉引导线样式,在 label 位置 设置为'outside'的时候会显示视觉引导线。\n        normal: {\n            show: false,             // 是否显示视觉引导线。\n            length: 15,             // 在 label 位置 设置为'outside'的时候会显示视觉引导线。\n            length2: 10,            // 视觉引导项第二段的长度。\n            lineStyle: {            // 视觉引导线的样式\n                //color: '#000',\n                //width: 1\n            }\n        }\n    },\n    data: data                      // 系列中的数据内容数组。\n}],\n\n\n# 隐藏字体\n\nlabel: {\n    show: false,\n    position: 'center'\n},\nlabelLine: {\n    show: false\n},\n\n\n# 字体+线条+饼图颜色一致\n\n\n\nimport * as echarts from 'echarts';\n\nvar chartDom = document.getElementById('main');\nvar myChart = echarts.init(chartDom);\nvar option;\n\nconst colorList = ['#1890ff', '#36cbcb', '#4cc670', '#fad637', '#f2637b'];\nlet pieData = [\n    { value: 1048, name: '报表资产' },\n    { value: 735, name: '模型资产' },\n    { value: 580, name: '指标资产' },\n    { value: 484, name: '标签资产' },\n    { value: 300, name: '服务资产' }\n];\noption = {\n    tooltip: {\n        trigger: 'item'\n    },\n    color: colorList,\n    series: [\n        {\n            name: 'Access From',\n            type: 'pie',\n            radius: ['40%', '70%'],\n\n            label: {\n                formatter: '{name|{b} {c}}\\n{time|{c} ',\n                minMargin: 5,\n                edgeDistance: 10,\n                lineHeight: 15,\n                rich: {\n                    name: {\n                        fontSize: 16\n                    },\n                    time: {\n                        fontSize: 10,\n                        color: 'transparent'\n                        // color: '#999'\n                        // color: \"\"\n                    }\n                }\n            },\n            itemStyle: {\n                // color: (params) => {\n                //   var index = params.datasetIndex;\n                //   const color = ['#1890ff', '#36cbcb', '#4cc670', '#fad637', '#f2637b'];\n                //   return color[index];\n                // }\n            },\n            labelLine: {\n                length: 15,\n                length2: 0,\n                maxSurfaceAngle: 80\n            },\n            labelLayout: function (params) {\n                const isLeft = params.labelRect.x < myChart.getWidth() / 2;\n                const points = params.labelLinePoints;\n                // Update the end point.\n                points[2][0] = isLeft\n                    ? params.labelRect.x\n                : params.labelRect.x + params.labelRect.width;\n                return {\n                    labelLinePoints: points\n                };\n            },\n            emphasis: {\n                label: {\n                    show: true\n                },\n                itemStyle: {\n                    shadowBlur: 10,\n                    shadowOffsetX: 0,\n                    shadowColor: 'rgba(0, 0, 0, 0.5)'\n                }\n            },\n            data: pieData.map((v, i) => {\n                v.label = {\n                    color: colorList[i]\n                };\n                return v;\n            })\n        }\n    ]\n};\n\noption && myChart.setOption(option);\n\n\n# 圆环\n\n\n\nimport * as echarts from 'echarts';\n\nvar chartDom = document.getElementById('main');\nvar myChart = echarts.init(chartDom);\nvar option;\n\noption = {\n    tooltip: {\n        trigger: \"item\",\n    },\n    color: [\"#1890ff\", \"#36cbcb\", \"#4cc670\", \"#fad637\", \"#f2637b\"],\n    series: [\n        {\n            name: \"Access From\",\n            type: \"pie\",\n            radius: [\"40%\", \"70%\"],\n            itemStyle: {\n                borderRadius: 10,\n                borderColor: \"#fff\",\n                borderWidth: 2,\n            },\n            data: [\n                { value: 1048, name: \"报表数据\" },\n                { value: 735, name: \"模型资产\" },\n                { value: 580, name: \"指标数据\" },\n                { value: 484, name: \"标签数据\" },\n                { value: 300, name: \"服务资产\" },\n            ],\n            emphasis: {\n                itemStyle: {\n                    shadowBlur: 10,\n                    shadowOffsetX: 0,\n                    shadowColor: \"rgba(0, 0, 0, 0.5)\",\n                },\n            },\n        },\n    ],\n};\n\noption && myChart.setOption(option);\n\n\n# 修改饼图颜色\n\n颜色设置同上\n\n主要注意形态变化：\n\nseries: [\n    {\n        name: this.title,\n        type: \"pie\",\n        radius: \"50%\",\n        radius: [\"50%\", \"70%\"], //环形图\n        center: [\"50%\", \"70%\"], //饼图\n        roseType: \"radius\",//外边距不一的环形图 如上图\n        data: this.data,\n        color: this.color,\n        itemStyle : {\n            emphasis: {\n                shadowBlur: 10,\n                shadowOffsetX: 0,\n                shadowColor: \"rgba(0, 0, 0, 0.5)\",\n            },\n            normal: {\n                color: function (params) {\n                    var colorList = [\n                        \"#d4c8ba\",\n                        \"#b26b65\",\n                        \"#ee8462\",\n                        \"#fbb28f\",\n                        \"#f4d2b6\",\n                        \"#d9ddcc\",\n                        \"#a6a8a7\",\n                        \"#845c65\",\n                        \"#585b64\",\n                        \"#f8af9e\",\n                        \"#f18c7f\",\n                        \"#f1cf7f\",\n                    ];\n                    return colorList[params.dataIndex % colorList.length];\n                },\n            },\n        },\n    },\n],\n\n\n\n# 仪表盘\n\n# 进度仪表盘1\n\n\n\noption = {\n    title: {\n        top: '40px',\n        text: 'ST 6.1亿',\n        left: 'center'\n    },\n    tooltip: {\n        formatter: '{a} <br/>{b} : {c}%'\n    },\n    series: [\n        {\n            type: 'gauge',\n            center: ['50%', '70%'],\n            startAngle: 180, // 开始角度\n            endAngle: 0, // 结束角度\n            min: 0,\n            max: 100,\n            splitNumber: 10,\n            radius: '70%',\n            axisLine: {\n                lineStyle: {\n                    color: [[1, '#f00']],\n                    width: 0\n                }\n            },\n            axisTick: {\n                // 内刻度线条-短\n                splitNumber: 2,\n                lineStyle: {\n                    width: 2,\n                    color: '#999'\n                }\n            },\n            axisLabel: {\n                // 内刻度字体\n                distance: 10,\n                color: '#999',\n                fontSize: 20\n            },\n            splitLine: {\n                // 内刻度线条-长\n                length: 12,\n                lineStyle: {\n                    width: 3,\n                    color: '#999'\n                }\n            }\n        },\n        {\n            name: 'Pressure',\n            type: 'gauge',\n            center: ['50%', '70%'],\n            startAngle: 180, // 开始角度\n            endAngle: 0, // 结束角度\n            min: 0, // 最小值\n            max: 100, // 最大值\n            progress: {\n                //选中区域\n                show: true,\n                // roundCap: true, // 倒圆角\n                width: 18\n            },\n            itemStyle: {\n                color: new echarts.graphic.LinearGradient(1, 1, 0, 1, [\n                    {\n                        offset: 1,\n                        color: 'rgb(254,128,9)'\n                    },\n                    {\n                        offset: 0,\n                        color: 'rgb(254,175,107)'\n                    }\n                ]),\n                shadowColor: 'rgba(254,175,107,0.45)',\n                shadowBlur: 10\n                // shadowOffsetX: 2,\n                // shadowOffsetY: 2\n            },\n            pointer: {\n                // 指针\n                // icon: 'path://M2090.36389,615.30999 L2090.36389,615.30999 C2091.48372,615.30999 2092.40383,616.194028 2092.44859,617.312956 L2096.90698,728.755929 C2097.05155,732.369577 2094.2393,735.416212 2090.62566,735.56078 C2090.53845,735.564269 2090.45117,735.566014 2090.36389,735.566014 L2090.36389,735.566014 C2086.74736,735.566014 2083.81557,732.63423 2083.81557,729.017692 C2083.81557,728.930412 2083.81732,728.84314 2083.82081,728.755929 L2088.2792,617.312956 C2088.32396,616.194028 2089.24407,615.30999 2090.36389,615.30999 Z',\n                // length: '75%',\n                // width: 16,\n                // offsetCenter: [0, '5%']\n            },\n            axisLine: {\n                // 底色\n                // roundCap: true, // 倒圆角\n                lineStyle: {\n                    width: 18,\n                    color: [\n                        [\n                            1,\n                            new echarts.graphic.LinearGradient(0, 0, 1, 0, [\n                                {\n                                    offset: 0.1,\n                                    color: 'rgb(245,245,245)'\n                                },\n                                {\n                                    offset: 1,\n                                    color: 'rgb(210,223,232)'\n                                }\n                            ])\n                        ]\n                    ]\n                }\n            },\n            axisTick: {\n                // 内刻度线条-短\n                splitNumber: 1,\n                lineStyle: {\n                    width: 0\n                }\n            },\n            splitLine: {\n                // 内刻度线条-长\n                distance: -18,\n                length: 22,\n                lineStyle: {\n                    color: '#fff'\n                }\n            },\n            axisLabel: {\n                // 内刻度字体\n                // distance: 30,\n                color: 'transparent',\n                fontSize: 0\n            },\n            detail: {\n                // 展示值\n                offsetCenter: [0, '35%'],\n                valueAnimation: true,\n                formatter: '{value}%'\n            },\n            data: [\n                {\n                    value: 50\n                    // name: 'SCORE'\n                }\n            ]\n        }\n    ]\n};\n\n\n\n\n# 矩形树图\n\n# 基础\n\n\n\noption = {\n    title: {\n        text: '累计盈利（亿）：末期',\n        left: 'center'\n    },\n\n    legend: {\n        // top: \"15%\",\n        // right: \"16%\",\n        // itemWidth: 70,\n        // itemHeight: 22,\n        // itemGap: 40,\n        // orient: \"horizontal\",\n        // icon: \"circle\",\n        // textStyle: {\n        //   color: \"#000\",\n        //   fontSize: 16,\n        // },\n        data: [\n            '利率债：T户',\n            '利率债：A户',\n            '信用债：T户-本币',\n            '信用债1',\n            '信用债'\n        ]\n    },\n    series: [\n        {\n            type: 'treemap',\n            label: {\n                //显示文字标签定义\n                show: true,\n                formatter: '{b}', //定义显示的内容 {b}表示name\n                normal: {\n                    textStyle: {\n                        ellipsis: true //圆角\n                    }\n                }\n            },\n            itemStyle: {\n                normal: {\n                    borderColor: '#fff' //方块分割边框颜色\n                }\n            },\n            data: [\n                {\n                    name: '利率债：T户',\n                    value: 50\n                },\n                {\n                    name: '利率债：A户',\n                    value: 20\n                },\n                {\n                    name: '信用债：T户-本币',\n                    value: 10\n                },\n                {\n                    name: '信用债1',\n                    value: 5\n                },\n                {\n                    name: '信用债',\n                    value: 5\n                }\n            ]\n        }\n    ]\n};\n\n\n\n# 树状图\n\n\n\noption = {\n    title: {\n        text: '累计盈利（亿）：末期',\n        left: 'center'\n    },\n\n    legend: {\n        left: 'center',\n        top: '40px'\n    },\n    color: [\n        'rgb(114,193,254)',\n        'rgb(0,171,247)',\n        'rgb(254,174,126)',\n        'rgb(46,207,105)',\n        'rgb(254,133,133)'\n    ],\n    series: [\n        {\n            top: '80px',\n            type: 'treemap',\n            itemStyle: {\n                normal: {\n                    borderColor: '#fff', //方块分割边框颜色\n                    label: {\n                        show: true,\n                        position: 'insideBottomLeft',\n                        formatter: '{b}'\n                    },\n                    borderWidth: 1\n                }\n            },\n            roam: false, // 鼠标放大缩小\n            nodeClick: false, // 点击区域事件\n            breadcrumb: {\n                show: false //  底部的标签\n            },\n            data: [\n                {\n                    name: '利率债：T户',\n                    value: 50\n                },\n                {\n                    name: '利率债：A户',\n                    value: 20\n                },\n                {\n                    name: '信用债：T户-本币',\n                    value: 10\n                },\n                {\n                    name: '信用债1',\n                    value: 5\n                },\n                {\n                    name: '信用债',\n                    value: 5\n                }\n            ]\n        },\n        {\n            type: 'pie',\n            radius: '0%',\n            data: [\n                {\n                    labelLine: {\n                        show: false\n                    },\n                    label: {\n                        show: false\n                    },\n                    name: '利率债：T户',\n                    value: 50\n                },\n                {\n                    labelLine: {\n                        show: false\n                    },\n                    label: {\n                        show: false\n                    },\n                    name: '利率债：A户',\n                    value: 20\n                },\n                {\n                    labelLine: {\n                        show: false\n                    },\n                    label: {\n                        show: false\n                    },\n                    name: '信用债：T户-本币',\n                    value: 10\n                },\n                {\n                    labelLine: {\n                        show: false\n                    },\n                    label: {\n                        show: false\n                    },\n                    name: '信用债1',\n                    value: 5\n                },\n                {\n                    labelLine: {\n                        show: false\n                    },\n                    label: {\n                        show: false\n                    },\n                    name: '信用债',\n                    value: 5\n                }\n            ],\n            emphasis: {}\n        }\n    ]\n};\n\n\n\n\n# 区域选择\n\nhttps://blog.csdn.net/qq_35250826/article/details/87840565\n\n\n# dataZoom[区域属性]\n\n代码如下：\n\noption = {\n    // ...\n    dataZoom: [\n        {\n            type: \"slider\",\n            show: true,\n            height: \"5%\",\n            borderColor: \"#cae3ff\",\n            backgroundColor: \"#cae3ff\",\n            start: 0,\n            end: 100,\n        },\n        {\n            type: \"inside\",\n            start: 0,\n            end: 100,\n        },\n    ],\n    // ...\n}\n\n\n参数如下：\n\ndataZoom:[ //区域缩放\n    {\n        id: 'dataZoomX',\n        show:true, //是否显示 组件。如果设置为 false，不会显示，但是数据过滤的功能还存在。\n        backgroundColor:\"rgba(47,69,84,0)\", //组件的背景颜色\n        type: 'slider', //slider表示有滑动块的，inside表示内置的\n        dataBackground:{ //数据阴影的样式。\n            lineStyle:mylineStyle, //阴影的线条样式\n            areaStyle:myareaStyle, //阴影的填充样式\n        },\n        fillerColor:\"rgba(167,183,204,0.4)\", //选中范围的填充颜色。\n        borderColor:\"#ddd\", //边框颜色。\n        filterMode: 'filter', //'filter'：当前数据窗口外的数据，被 过滤掉。即 会 影响其他轴的数据范围。每个数据项，只要有一个维度在数据窗口外，整个数据项就会被过滤掉。\n        //'weakFilter'：当前数据窗口外的数据，被 过滤掉。即 会 影响其他轴的数据范围。每个数据项，只有当全部维度都在数据窗口同侧外部，整个数据项才会被过滤掉。\n        //'empty'：当前数据窗口外的数据，被 设置为空。即 不会 影响其他轴的数据范围。\n        //'none': 不过滤数据，只改变数轴范围。\n        xAxisIndex:0, //设置 dataZoom-inside 组件控制的 x轴,可以用数组表示多个轴\n        yAxisIndex:[0,2], //设置 dataZoom-inside 组件控制的 y轴,可以用数组表示多个轴\n        radiusAxisIndex:3, //设置 dataZoom-inside 组件控制的 radius 轴,可以用数组表示多个轴\n        angleAxisIndex:[0,2], //设置 dataZoom-inside 组件控制的 angle 轴,可以用数组表示多个轴\n        start: 30, //数据窗口范围的起始百分比,表示30%\n        end: 70, //数据窗口范围的结束百分比,表示70%\n        startValue:10, //数据窗口范围的起始数值\n        endValue:100, //数据窗口范围的结束数值。\n        orient:\"horizontal\", //布局方式是横还是竖。不仅是布局方式，对于直角坐标系而言，也决定了，缺省情况控制横向数轴还是纵向数轴。'horizontal'：水平。'vertical'：竖直。\n        zoomLock:false, //是否锁定选择区域（或叫做数据窗口）的大小。如果设置为 true\n        则锁定选择区域的大小，也就是说，只能平移，不能缩放。\n        throttle:100, //设置触发视图刷新的频率。单位为毫秒（ms）。\n        zoomOnMouseWheel:true, //如何触发缩放。可选值为：true：表示不按任何功能键，鼠标滚轮能触发缩放。false：表示鼠标滚轮不能触发缩放。'shift'：表示按住 shift 和鼠标滚轮能触发缩放。'ctrl'：表示按住 ctrl 和鼠标滚轮能触发缩放。'alt'：表示按住 alt 和鼠标滚轮能触发缩放。\n        moveOnMouseMove:true, //如何触发数据窗口平移。true：表示不按任何功能键，鼠标移动能触发数据窗口平移。false：表示鼠标滚轮不能触发缩放。'shift'：表示按住 shift 和鼠标移动能触发数据窗口平移。'ctrl'：表示按住 ctrl 和鼠标移动能触发数据窗口平移。'alt'：表示按住 alt 和鼠标移动能触发数据窗口平移。\n        left:\"center\", //组件离容器左侧的距离,'left', 'center', 'right','20%'\n        top:\"top\", //组件离容器上侧的距离,'top', 'middle', 'bottom','20%'\n        right:\"auto\", //组件离容器右侧的距离,'20%'\n        bottom:\"auto\", //组件离容器下侧的距离,'20%'\n\n    },\n    {\n        id: 'dataZoomY',\n        type: 'inside',\n        filterMode: 'empty',\n        disabled:false, //是否停止组件的功能。\n        xAxisIndex:0, //设置 dataZoom-inside 组件控制的 x轴,可以用数组表示多个轴\n        yAxisIndex:[0,2], //设置 dataZoom-inside 组件控制的 y轴,可以用数组表示多个轴\n        radiusAxisIndex:3, //设置 dataZoom-inside 组件控制的 radius 轴,可以用数组表示多个轴\n        angleAxisIndex:[0,2], //设置 dataZoom-inside 组件控制的 angle 轴,可以用数组表示多个轴\n        start: 30, //数据窗口范围的起始百分比,表示30%\n        end: 70, //数据窗口范围的结束百分比,表示70%\n        startValue:10, //数据窗口范围的起始数值\n        endValue:100, //数据窗口范围的结束数值。\n        orient:\"horizontal\", //布局方式是横还是竖。不仅是布局方式，对于直角坐标系而言，也决定了，缺省情况控制横向数轴还是纵向数轴。'horizontal'：水平。'vertical'：竖直。\n        zoomLock:false, //是否锁定选择区域（或叫做数据窗口）的大小。如果设置为 true 则锁定选择区域的大小，也就是说，只能平移，不能缩放。\n        throttle:100, //设置触发视图刷新的频率。单位为毫秒（ms）。\n        zoomOnMouseWheel:true, //如何触发缩放。可选值为：true：表示不按任何功能键，鼠标滚轮能触发缩放。false：表示鼠标滚轮不能触发缩放。'shift'：表示按住 shift 和鼠标滚轮能触发缩放。'ctrl'：表示按住 ctrl 和鼠标滚轮能触发缩放。'alt'：表示按住 alt 和鼠标滚轮能触发缩放。\n        moveOnMouseMove:true, //如何触发数据窗口平移。true：表示不按任何功能键，鼠标移动能触发数据窗口平移。false：表示鼠标滚轮不能触发缩放。'shift'：表示按住 shift 和鼠标移动能触发数据窗口平移。'ctrl'：表示按住 ctrl 和鼠标移动能触发数据窗口平移。'alt'：表示按住 alt 和鼠标移动能触发数据窗口平移。\n        maxSpan:2, // 限制拖动的最大值\n    }\n]\n\n\n# 调整与x轴的上下位置\n\n有时datazoom的组件会与x轴重叠，我们怎么调节两者之间的距离呢？----通过增加grid组件可以调节 主要是通过其中的bottom属性来调节\n\noption = {\n    grid: {\n        left: \"3%\",\n        right: \"4%\",\n        bottom: \"11%\",\n        top: \"55%\",\n        containLabel: true,\n    },\n}\n\n\n\n# echarts柱状图圆角实现\n\nhttps://blog.csdn.net/qq_27232885/article/details/102463335\n\nseries: [{\n    data: [120, 200, 150, 80, 70, 110, 130],\n    type: 'bar',\n    itemStyle:{\n        normal: {\n            barBorderRadius: [4, 4, 4, 4], //柱状图圆角，初始化效果\n        },\n    }\n}]\n\n\n\n# 3D柱状图\n\nhttps://www.freesion.com/article/6465742030/\n\n\n\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title>投票统计</title>\n        <script src=\"http://libs.baidu.com/jquery/2.0.0/jquery.min.js\"><\/script>\n        <script src=\"echarts.min.js\" type=\"text/javascript\"><\/script>\n        <script src=\"echarts-gl.js\"><\/script>\n        <style type=\"text/css\">\n            #biao{\n                width: 60vw;\n                height: 60vh;\n            }\n            body,html{\n                width: 100vw;\n                height: 100vh;\n                margin: 0;\n            }\n            #main{\n                width: 100vw;\n                height: 100vh;\n                display: flex;\n                flex-direction: row;\n                justify-content: center;\n                align-items: center;\n            }\n        </style>\n    </head>\n    <body>\n        <div id=\"main\">\n            <div id=\"biao\"></div>\n        </div>\n    </body>\n    <script type=\"text/javascript\">\n        // 基于准备好的dom，初始化echarts实例\n        var myChart = echarts.init(document.getElementById('main'));\n        var xData = ['', '', '', '', '']; //x轴数据\n        var days = ['']; //z轴数据\n        var data = [\n            [0, 0, 0],\n            [0, 1, 0],\n            [0, 2, 0],\n            [0, 3, 0],\n            [0, 4, 0],\n        ];              //y轴数据\n        var option = {\n            tooltip: {\n                show:false,\n                trigger: 'axis',\n                axisPointer: {            // 坐标轴指示器，坐标轴触发有效\n                    type: 'shadow'        // 默认为直线，可选为：'line' |  'shadow'\n                }\n            },\n            visualMap: {\n                show: false,\n                max: 15,\n                inRange: {\n                    color: ['#f9ef4d']\n                }\n            },\n            xAxis3D: {\n                name: 'x',\n                show: false,\n                axisLine: {\n                    show: true,\n                    lineStyle: {\n                        color: 'rgba(0,0,0,0)'\n                    }\n                },\n                axisTick:{       //刻度线\n                    show:false\n                },\n                axisLabel: {\n                    textStyle: {\n                        color: '#f9ef4d',\n                        fontSize: 30\n                    },\n                    interval: 0,  \n                    //x轴文字换行\n                    formatter: function(params) {\n                        var newParamsName = \"\"; // 最终拼接成的字符串\n                        var paramsNameNumber = params.length; // 实际标签的个数\n                        var provideNumber = 6; // 每行能显示的字的个数\n                        var rowNumber = Math.ceil(paramsNameNumber / provideNumber); // 换行的话，需要显示几行，向上取整\n                        if (paramsNameNumber > provideNumber) {\n                            for (var p = 0; p < rowNumber; p++) {\n                                var tempStr = \"\"; // 表示每一次截取的字符串\n                                var start = p * provideNumber; // 开始截取的位置\n                                var end = start + provideNumber; // 结束截取的位置\n                                if (p == rowNumber - 1) {\n                                    tempStr = params.substring(start, paramsNameNumber);\n                                } else {\n                                    tempStr = params.substring(start, end) + \"\\n\";\n                                }\n                                newParamsName += tempStr; // 最终拼成的字符串\n                            }\n                        } else {\n                            // 将旧标签的值赋给新标签\n                            newParamsName = params;\n                        }\n                        //将最终的字符串返回\n                        return newParamsName\n                    }\n                },\n                splitLine:{show: false},\n                nameGap: 1,\n                type: 'category',\n                data: xData\n            },\n            yAxis3D: {\n                name: 'y',\n                show: false,\n                axisLine: {\n                    show: true,\n                    lineStyle: {\n                        color: 'rgba(0,0,0,0)' //直接设置不显示出现bug，我就设置为透明\n                    }\n                },\n                splitLine:{show: false},\n                type: 'category',\n                data: days\n            },\n            zAxis3D: {\n                name: '',\n\n                axisLine: {\n                    show: true,\n                    lineStyle: {\n                        color: 'rgba(0,0,0,0)'\n                    }\n                },\n                splitLine:{show: false},\n                type: 'value'\n            },\n            grid3D: {\n                axisPointer:{\n                    show:false\n                },\n                boxWidth: 200,\n                boxDepth: 20,\n                light: {\n                    main: {\n                        intensity: 1.2,\n                        shadow: true\n                    },\n                    ambient: {\n                        intensity: 0.3\n                    }\n                },\n                viewControl: {\n                    alpha: 0,\n                    beta: 0,\n                }\n            },\n            series: [{\n                type: 'bar3D',\n                name:'投票数',\n                data: data.map(function(item) {\n                    return {\n                        value: [item[1], item[0], item[2]],\n                    }\n                }),\n                label: {\n                    show: true,\n                    position: 'top',\n                    textStyle: { //数值样式\n                        color: '#FFE66F',\n                        fontSize: 42,\n                        backgroundColor:'rgba(0,0,0,0)'\n                    }\n                },\n                shading: 'lambert',\n                //鼠标经过\n                emphasis: {\n                    label: {\n                        textStyle: {\n                            fontSize: 50,\n                        }\n                    },\n                },\n\n            }]\n        }\n        window.onresize = function(){\n            myChart.resize();\n        }\n        // 使用刚指定的配置项和数据显示图表。\n        myChart.setOption(option); \n        //后台获取数据\n        function main(){\n            $.ajax({\n                url: '',\n                type: 'post',\n                data:JSON.stringify({}),\n                dataType:'json',\n                contentType: 'application/json',\n                async:true,\n                success:function(data){\n                    var data1=[]\n                    var data2=[]\n                    for(var i=0;i<data.list.length;i++){\n                        data1[i]=[0,i,data.list[i].headCount]\n                        data2[i]=data.list[i].name\n                    }\n                    myChart.setOption({\n                        xAxis3D: {\n                            data: data2\n                        },\n                        series: [{\n                            // 根据名字对应到相应的系列\n                            name: '投票数',\n                            data: data1.map(function(item) {\n                                return {\n                                    value: [item[1], item[0], item[2]],\n                                }\n                            }),\n                        }]\n                    });\n                }\n\n            });\n\n        }\n        main()\n\n    <\/script>\n\n</html>\n\n\n\n# 3D饼图\n\nhttps://blog.csdn.net/weixin_41326021/article/details/120195920\n\n\n\n\n# .vue文件 【bindListen方法可以提取到mixins里面，以供组件多次调用】\n\n<template>\n    <div class=\"chart-container\">\n        <div class=\"chart\" ref=\"chart\"></div>\n        \x3c!-- 底座背景 --\x3e\n        <div class=\"bg\"></div> \n    </div>\n</template>\n\n<script>\n    import { getPie3D, getParametricEquation } from 'chart.js' //工具类js，页面路径自己修改\n\n    const color = ['#005aff', '#f8b551']\n\n    export default {\n        name: 'chart',\n        data () {\n            return {\n                optionData: [\n                    {\n                        name: '启用电梯',\n                        value: 176\n                    },\n                    {\n                        name: '停用电梯',\n                        value: 288\n                    }\n                ],\n                statusChart:null,\n                option:{}\n            }\n        },\n        created () {\n            this.setLabel()\n        },\n        mounted () {\n            this.initChart()\n\n            //根据窗口变化自动调节图表大小\n            const that = this\n            window.onresize = function () {\n                that.changeSize()\n            }\n        },\n        methods: {\n            // 初始化label样式\n            setLabel () {\n                this.optionData.forEach((item, index) => {\n                    item.itemStyle = {\n                        color: color[index]\n                    }\n                    item.label = {\n                        normal: {\n                            show: true,\n                            color: color[index],\n                            formatter: [\n                                '{b|{b}}',\n                                '{c|{c}}{b|台}',\n                                '{d|{d}%}'\n                            ].join('\\n'), // 用\\n来换行\n                            rich: {\n                                b: {\n                                    color: '#fff',\n                                    lineHeight: 25,\n                                    align: 'left'\n                                },\n                                c: {\n                                    fontSize: 22,\n                                    color: '#fff',\n                                    textShadowColor: '#1c90a6',\n                                    textShadowOffsetX: 0,\n                                    textShadowOffsetY: 2,\n                                    textShadowBlur: 5\n                                },\n                                d: {\n                                    color: color[index],\n                                    align: 'left'\n                                }\n                            }\n                        }\n                    }\n                    item.labelLine = {\n                        normal: {\n                            lineStyle: {\n                                width: 1,\n                                color: 'rgba(255,255,255,0.7)'\n                            }\n                        }\n                    }\n                })\n            },\n            // 图表初始化\n            initChart () {\n                this.statusChart = this.$echarts.init(this.$refs.chart)\n                // 传入数据生成 option, 构建3d饼状图, 参数工具文件已经备注的很详细\n                this.option = getPie3D(this.optionData, 0.8, 240, 28, 26, 0.5)\n                this.statusChart.setOption(this.option)\n                // 是否需要label指引线，如果要就添加一个透明的2d饼状图并调整角度使得labelLine和3d的饼状图对齐，并再次setOption\n                this.option.series.push({\n                    name: '电梯状态', //自己根据场景修改\n                    backgroundColor: 'transparent',\n                    type: 'pie',\n                    label: {\n                        opacity: 1,\n                        fontSize: 13,\n                        lineHeight: 20\n                    },\n                    startAngle: -40, // 起始角度，支持范围[0, 360]。\n                    clockwise: false, // 饼图的扇区是否是顺时针排布。上述这两项配置主要是为了对齐3d的样式\n                    radius: ['20%', '50%'],\n                    center: ['50%', '50%'],\n                    data: this.optionData,\n                    itemStyle: {\n                        opacity: 0  //这里必须是0，不然2d的图会覆盖在表面\n                    }\n                })\n                this.statusChart.setOption(this.option)\n                this.bindListen(this.statusChart)\n            },\n            // 监听鼠标事件，实现饼图选中效果（单选），近似实现高亮（放大）效果。\n            // optionName是防止有多个图表进行定向option传递，单个图表可以不传，默认是opiton\n            bindListen (myChart, optionName = 'option') {\n                let selectedIndex = ''\n                let hoveredIndex = ''\n                // 监听点击事件，实现选中效果（单选）\n                myChart.on('click', (params) => {\n                    // 从 option.series 中读取重新渲染扇形所需的参数，将是否选中取反。\n                    const isSelected = !this[optionName].series[params.seriesIndex].pieStatus\n                    .selected\n                    const isHovered =\n                          this[optionName].series[params.seriesIndex].pieStatus.hovered\n                    const k = this[optionName].series[params.seriesIndex].pieStatus.k\n                    const startRatio =\n                          this[optionName].series[params.seriesIndex].pieData.startRatio\n                    const endRatio =\n                          this[optionName].series[params.seriesIndex].pieData.endRatio\n                    // 如果之前选中过其他扇形，将其取消选中（对 option 更新）\n                    if (selectedIndex !== '' && selectedIndex !== params.seriesIndex) {\n                        this[optionName].series[\n                            selectedIndex\n                        ].parametricEquation = getParametricEquation(\n                            this[optionName].series[selectedIndex].pieData.startRatio,\n                            this[optionName].series[selectedIndex].pieData.endRatio,\n                            false,\n                            false,\n                            k,\n                            this[optionName].series[selectedIndex].pieData.value\n                        )\n                        this[optionName].series[selectedIndex].pieStatus.selected = false\n                    }\n                    // 对当前点击的扇形，执行选中/取消选中操作（对 option 更新）\n                    this[optionName].series[\n                        params.seriesIndex\n                    ].parametricEquation = getParametricEquation(\n                        startRatio,\n                        endRatio,\n                        isSelected,\n                        isHovered,\n                        k,\n                        this[optionName].series[params.seriesIndex].pieData.value\n                    )\n                    this[optionName].series[params.seriesIndex].pieStatus.selected = isSelected\n                    // 如果本次是选中操作，记录上次选中的扇形对应的系列号 seriesIndex\n                    selectedIndex = isSelected ? params.seriesIndex : null\n                    // 使用更新后的 option，渲染图表\n                    myChart.setOption(this[optionName])\n                })\n                // 监听 mouseover，近似实现高亮（放大）效果\n                myChart.on('mouseover', (params) => {\n                    // 准备重新渲染扇形所需的参数\n                    let isSelected\n                    let isHovered\n                    let startRatio\n                    let endRatio\n                    let k\n                    // 如果触发 mouseover 的扇形当前已高亮，则不做操作\n                    if (hoveredIndex === params.seriesIndex) {\n                        // 否则进行高亮及必要的取消高亮操作\n                    } else {\n                        // 如果当前有高亮的扇形，取消其高亮状态（对 option 更新）\n                        if (hoveredIndex !== '') {\n                            // 从 option.series 中读取重新渲染扇形所需的参数，将是否高亮设置为 false。\n                            isSelected = this[optionName].series[hoveredIndex].pieStatus.selected\n                            isHovered = false\n                            startRatio = this[optionName].series[hoveredIndex].pieData.startRatio\n                            endRatio = this[optionName].series[hoveredIndex].pieData.endRatio\n                            k = this[optionName].series[hoveredIndex].pieStatus.k\n                            // 对当前点击的扇形，执行取消高亮操作（对 option 更新）\n                            this[optionName].series[\n                                hoveredIndex\n                            ].parametricEquation = getParametricEquation(\n                                startRatio,\n                                endRatio,\n                                isSelected,\n                                isHovered,\n                                k,\n                                this[optionName].series[hoveredIndex].pieData.value\n                            )\n                            this[optionName].series[hoveredIndex].pieStatus.hovered = isHovered\n                            // 将此前记录的上次选中的扇形对应的系列号 seriesIndex 清空\n                            hoveredIndex = ''\n                        }\n                        // 如果触发 mouseover 的扇形不是透明圆环，将其高亮（对 option 更新）\n                        if (\n                            params.seriesName !== 'mouseoutSeries' &&\n                            params.seriesName !== 'pie2d'\n                        ) {\n                            // 从 option.series 中读取重新渲染扇形所需的参数，将是否高亮设置为 true。\n                            isSelected =\n                                this[optionName].series[params.seriesIndex].pieStatus.selected\n                            isHovered = true\n                            startRatio =\n                                this[optionName].series[params.seriesIndex].pieData.startRatio\n                            endRatio = this[optionName].series[params.seriesIndex].pieData.endRatio\n                            k = this[optionName].series[params.seriesIndex].pieStatus.k\n                            // 对当前点击的扇形，执行高亮操作（对 option 更新）\n                            this[optionName].series[\n                                params.seriesIndex\n                            ].parametricEquation = getParametricEquation(\n                                startRatio,\n                                endRatio,\n                                isSelected,\n                                isHovered,\n                                k,\n                                this[optionName].series[params.seriesIndex].pieData.value + 60\n                            )\n                            this[optionName].series[\n                                params.seriesIndex\n                            ].pieStatus.hovered = isHovered\n                            // 记录上次高亮的扇形对应的系列号 seriesIndex\n                            hoveredIndex = params.seriesIndex\n                        }\n                        // 使用更新后的 option，渲染图表\n                        myChart.setOption(this[optionName])\n                    }\n                })\n                // 修正取消高亮失败的 bug\n                myChart.on('globalout', () => {\n                    // 准备重新渲染扇形所需的参数\n                    let isSelected\n                    let isHovered\n                    let startRatio\n                    let endRatio\n                    let k\n                    if (hoveredIndex !== '') {\n                        // 从 option.series 中读取重新渲染扇形所需的参数，将是否高亮设置为 true。\n                        isSelected = this[optionName].series[hoveredIndex].pieStatus.selected\n                        isHovered = false\n                        k = this[optionName].series[hoveredIndex].pieStatus.k\n                        startRatio = this[optionName].series[hoveredIndex].pieData.startRatio\n                        endRatio = this[optionName].series[hoveredIndex].pieData.endRatio\n                        // 对当前点击的扇形，执行取消高亮操作（对 option 更新）\n                        this[optionName].series[\n                            hoveredIndex\n                        ].parametricEquation = getParametricEquation(\n                            startRatio,\n                            endRatio,\n                            isSelected,\n                            isHovered,\n                            k,\n                            this[optionName].series[hoveredIndex].pieData.value\n                        )\n                        this[optionName].series[hoveredIndex].pieStatus.hovered = isHovered\n                        // 将此前记录的上次选中的扇形对应的系列号 seriesIndex 清空\n                        hoveredIndex = ''\n                    }\n                    // 使用更新后的 option，渲染图表\n                    myChart.setOption(this[optionName])\n                })\n            },\n            // 自适应宽高\n            changeSize () {\n                this.statusChart.resize()\n            }\n        }\n    }\n<\/script>\n\n<style lang='less' scoped>\n    .chart-container {\n        position: relative;\n        width: 100%;\n        height: 100%;\n\n        .chart,\n        .bg {\n            width: 100%;\n            height: 100%;\n        }\n\n        .bg {\n            position: absolute;\n            bottom: 50px;\n            left: 50%;\n            z-index: -1;\n            width: 180px;\n            height: 73px;\n            background: no-repeat center;\n            background-image: url('https://ks3-cn-beijing.ksyun.com/sxjg-elevator/datav-platform-2.0/images/chart_opacity_bg.png');\n            background-size: 100% 100%;\n            transform: translateX(-50%);\n        }\n    }\n</style>\n\n\n\n# chart.js\n\n/**\n * 绘制3d图\n * @param pieData 总数据\n * @param internalDiameterRatio:透明的空心占比\n * @param distance 视角到主体的距离\n * @param alpha 旋转角度\n * @param pieHeight 立体的高度\n * @param opacity 饼或者环的透明度\n */\nconst getPie3D = (pieData, internalDiameterRatio, distance, alpha, pieHeight, opacity = 1) => {\n    const series = []\n    let sumValue = 0\n    let startValue = 0\n    let endValue = 0\n    let legendData = []\n    let legendBfb = []\n    const k = 1 - internalDiameterRatio\n    pieData.sort((a, b) => {\n        return b.value - a.value\n    })\n    // 为每一个饼图数据，生成一个 series-surface 配置\n    for (let i = 0; i < pieData.length; i++) {\n        sumValue += pieData[i].value\n        const seriesItem = {\n            name:\n            typeof pieData[i].name === 'undefined'\n            ? `series${i}`\n            : pieData[i].name,\n            type: 'surface',\n            parametric: true,\n            wireframe: {\n                show: false\n            },\n            pieData: pieData[i],\n            pieStatus: {\n                selected: false,\n                hovered: false,\n                k: k\n            },\n            center: ['10%', '50%']\n        }\n        if (typeof pieData[i].itemStyle !== 'undefined') {\n            const itemStyle = {}\n            itemStyle.color =\n                typeof pieData[i].itemStyle.color !== 'undefined'\n                ? pieData[i].itemStyle.color\n            : opacity\n            itemStyle.opacity =\n                typeof pieData[i].itemStyle.opacity !== 'undefined'\n                ? pieData[i].itemStyle.opacity\n            : opacity\n            seriesItem.itemStyle = itemStyle\n        }\n        series.push(seriesItem)\n    }\n\n    // 使用上一次遍历时，计算出的数据和 sumValue，调用 getParametricEquation 函数，\n    // 向每个 series-surface 传入不同的参数方程 series-surface.parametricEquation，也就是实现每一个扇形。\n    legendData = []\n    legendBfb = []\n    for (let i = 0; i < series.length; i++) {\n        endValue = startValue + series[i].pieData.value\n        series[i].pieData.startRatio = startValue / sumValue\n        series[i].pieData.endRatio = endValue / sumValue\n        series[i].parametricEquation = getParametricEquation(\n            series[i].pieData.startRatio,\n            series[i].pieData.endRatio,\n            false,\n            false,\n            k,\n            series[i].pieData.value\n        )\n        startValue = endValue\n        const bfb = fomatFloat(series[i].pieData.value / sumValue, 4)\n        legendData.push({\n            name: series[i].name,\n            value: bfb\n        })\n        legendBfb.push({\n            name: series[i].name,\n            value: bfb\n        })\n    }\n    const boxHeight = getHeight3D(series, pieHeight) // 通过pieHeight设定3d饼/环的高度，单位是px\n    // 准备待返回的配置项，把准备好的 legendData、series 传入。\n    const option = {\n        legend: {\n            show: false,\n            data: legendData,\n            orient: 'vertical',\n            left: 10,\n            top: 10,\n            itemGap: 10,\n            textStyle: {\n                color: '#A1E2FF'\n            },\n            icon: 'circle',\n            formatter: function (param) {\n                const item = legendBfb.filter(item => item.name === param)[0]\n                const bfs = fomatFloat(item.value * 100, 2) + '%'\n                return `${item.name}  ${bfs}`\n            }\n        },\n        labelLine: {\n            show: true,\n            lineStyle: {\n                color: '#fff'\n            }\n        },\n        label: {\n            show: true,\n            position: 'outside',\n            formatter: '{b} \\n{c} {d}%'\n        },\n        tooltip: {\n            backgroundColor: '#033b77',\n            borderColor: '#21f2c4',\n            textStyle: {\n                color: '#fff',\n                fontSize: 13\n            },\n            formatter: params => {\n                if (\n                    params.seriesName !== 'mouseoutSeries' &&\n                    params.seriesName !== 'pie2d'\n                ) {\n                    const bfb = (\n                        (option.series[params.seriesIndex].pieData.endRatio -\n                         option.series[params.seriesIndex].pieData.startRatio) *\n                        100\n                    ).toFixed(2)\n                    return (\n                        `${params.seriesName}<br/>` +\n                        `<span style=\"display:inline-block;margin-right:5px;border-radius:10px;width:10px;height:10px;background-color:${params.color};\"></span>` +\n                        `${bfb}%`\n                    )\n                }\n            }\n        },\n        xAxis3D: {\n            min: -1,\n            max: 1\n        },\n        yAxis3D: {\n            min: -1,\n            max: 1\n        },\n        zAxis3D: {\n            min: -1,\n            max: 1\n        },\n        grid3D: {\n            show: false,\n            boxHeight: boxHeight, // 圆环的高度\n            viewControl: {\n                // 3d效果可以放大、旋转等，请自己去查看官方配置\n                alpha, // 角度\n                distance, // 调整视角到主体的距离，类似调整zoom\n                rotateSensitivity: 0, // 设置为0无法旋转\n                zoomSensitivity: 0, // 设置为0无法缩放\n                panSensitivity: 0, // 设置为0无法平移\n                autoRotate: false // 自动旋转\n            }\n        },\n        series: series\n    }\n    return option\n}\n\n/**\n * 生成扇形的曲面参数方程，用于 series-surface.parametricEquation\n */\nconst getParametricEquation = (startRatio, endRatio, isSelected, isHovered, k, h) => {\n    // 计算\n    const midRatio = (startRatio + endRatio) / 2\n    const startRadian = startRatio * Math.PI * 2\n    const endRadian = endRatio * Math.PI * 2\n    const midRadian = midRatio * Math.PI * 2\n    // 如果只有一个扇形，则不实现选中效果。\n    if (startRatio === 0 && endRatio === 1) {\n        isSelected = false\n    }\n    // 通过扇形内径/外径的值，换算出辅助参数 k（默认值 1/3）\n    k = typeof k !== 'undefined' ? k : 1 / 3\n    // 计算选中效果分别在 x 轴、y 轴方向上的位移（未选中，则位移均为 0）\n    const offsetX = isSelected ? Math.cos(midRadian) * 0.1 : 0\n    const offsetY = isSelected ? Math.sin(midRadian) * 0.1 : 0\n    // 计算高亮效果的放大比例（未高亮，则比例为 1）\n    const hoverRate = isHovered ? 1.05 : 1\n    // 返回曲面参数方程\n    return {\n        u: {\n            min: -Math.PI,\n            max: Math.PI * 3,\n            step: Math.PI / 32\n        },\n        v: {\n            min: 0,\n            max: Math.PI * 2,\n            step: Math.PI / 20\n        },\n        x: function (u, v) {\n            if (u < startRadian) {\n                return (\n                    offsetX +\n                    Math.cos(startRadian) * (1 + Math.cos(v) * k) * hoverRate\n                )\n            }\n            if (u > endRadian) {\n                return (\n                    offsetX + Math.cos(endRadian) * (1 + Math.cos(v) * k) * hoverRate\n                )\n            }\n            return offsetX + Math.cos(u) * (1 + Math.cos(v) * k) * hoverRate\n        },\n        y: function (u, v) {\n            if (u < startRadian) {\n                return (\n                    offsetY +\n                    Math.sin(startRadian) * (1 + Math.cos(v) * k) * hoverRate\n                )\n            }\n            if (u > endRadian) {\n                return (\n                    offsetY + Math.sin(endRadian) * (1 + Math.cos(v) * k) * hoverRate\n                )\n            }\n            return offsetY + Math.sin(u) * (1 + Math.cos(v) * k) * hoverRate\n        },\n        z: function (u, v) {\n            if (u < -Math.PI * 0.5) {\n                return Math.sin(u)\n            }\n            if (u > Math.PI * 2.5) {\n                return Math.sin(u) * h * 0.1\n            }\n            return Math.sin(v) > 0 ? 1 * h * 0.1 : -1\n        }\n    }\n}\n\n/**\n * 获取3d丙图的最高扇区的高度\n */\nconst getHeight3D = (series, height) => {\n    series.sort((a, b) => {\n        return b.pieData.value - a.pieData.value\n    })\n    return (height * 25) / series[0].pieData.value\n}\n\n/**\n * 格式化浮点数\n */\nconst fomatFloat = (num, n) => {\n    let f = parseFloat(num)\n    if (isNaN(f)) {\n        return false\n    }\n    f = Math.round(num * Math.pow(10, n)) / Math.pow(10, n) // n 幂\n    let s = f.toString()\n    let rs = s.indexOf('.')\n    // 判定如果是整数，增加小数点再补0\n    if (rs < 0) {\n        rs = s.length\n        s += '.'\n    }\n    while (s.length <= rs + n) {\n        s += '0'\n    }\n    return s\n}\n\nexport { getPie3D, getParametricEquation }\n",normalizedContent:"# echart\n\nechart 官网：https://echarts.apache.org/zh/index.html\n\n\n# 例子\n\n\n# 暂无数据\n\n//暂无数据\nvar option = { title : {\n    text: \"暂无数据\",\n    x: \"center\",\n    y: \"center\",\n    textstyle: {\n        fontsize: 14,\n        fontweight: \"normal\",\n    },\n};}\n\n\n\n# echarts自定义提示框（解决弹框显示不全问题）\n\n# 方法一\n\ntip\n\n利用 confine: true 属性固定显示提示框\n\n\n\n# 方法二\n\ntip\n\n利用formatter，分列显示\n\n提示框浮层内容格式器，支持字符串模板和回调函数两种形式。\n\n# 字符串模板\n\n * 折线（区域）图、柱状（条形）图、k线图 : {a}（系列名称），{b}（类目值），{c}（数值）, {d}（无）\n * 散点图（气泡）图 : {a}（系列名称），{b}（数据名称），{c}（数值数组）, {d}（无）\n * 地图 : {a}（系列名称），{b}（区域名称），{c}（合并数值）, {d}（无）\n * 饼图、仪表盘、漏斗图: {a}（系列名称），{b}（数据项名称），{c}（数值）, {d}（百分比）\n\n示例：\n\ntooltip: {\n    trigger: 'axis',\n    formatter:'{a0}: {c0}&ensp;{a1}: {c1}<br/>{a2}: {c2}&ensp;{a3}: {c3}'\n}\n\n\n效果：\n\n\n\n# 回调函数\n\n利用回调函数自定义样式\n\n示例：\n\ntooltip: {\n\ttrigger: 'axis',\n\tformatter: function (params) {\n\t\tlet str=params[0].name+\"<br/>\";\n\t\tfor(let i=0;i<params.length;i++){\n\t\t\tlet p='<p style=\"display:inline-block;width:120px;\"><span style=\"display:inline-block;margin-right:5px;border-radius:50%;width:10px;height:10px;left:5px;background-color:'+params[i].color+'\"></span>' + params[i].seriesname + \" : \" + params[i].data+'</p>';\n\t\t\tif(i%2==0){\n\t\t\t\tstr+=p;\n\t\t\t}else{\n\t\t\t\tstr+=p+'<br/>'\n\t\t\t}\n\t\t}\n\t\treturn str;\n\t}\n}\n\n\n效果：\n\n\n\n\n# 折线图\n\n# 折现上无圆圈\n\n\n\nimport * as echarts from 'echarts';\n\nvar chartdom = document.getelementbyid('main');\nvar mychart = echarts.init(chartdom);\nvar option;\n\noption = {\n    title: {\n        text: '固收业务累盈利',\n        left: 'center'\n    },\n    tooltip: {\n        trigger: 'axis'\n    },\n    legend: {\n        top: '40px',\n        data: [\n            { name: 't户', icon: 'rect' },\n            { name: 'a户：不含公估', icon: 'rect' },\n            { name: 'a户：浮动亏盈', icon: 'rect' }\n        ],\n        itemheight: 1,\n        itemwidth: 25\n    },\n    grid: {\n        top: '100px',\n        left: '3%',\n        right: '4%',\n        bottom: '3%',\n        containlabel: true\n    },\n    xaxis: {\n        type: 'category',\n        boundarygap: false,\n        data: ['08-01', '08-02', '08-03', '08-04', '08-05', '08-06', '08-07']\n    },\n    yaxis: {\n        type: 'value',\n        axislabel: {\n            formatter: '{value} 亿元'\n        }\n    },\n    series: [\n        {\n            name: 't户',\n            type: 'line',\n            stack: 'total',\n            symbolsize: 0,\n            data: [120, 132, 101, 134, 90, 230, 210]\n        },\n        {\n            name: 'a户：不含公估',\n            type: 'line',\n            stack: 'total',\n            symbolsize: 0,\n            data: [220, 182, 191, 234, 290, 330, 310]\n        },\n        {\n            name: 'a户：浮动亏盈',\n            type: 'line',\n            stack: 'total',\n            symbolsize: 0,\n            data: [150, 232, 201, 154, 190, 330, 410]\n        }\n    ]\n};\n\noption && mychart.setoption(option);\n\n\n# 叠线+实心圆\n\n\n\nimport * as echarts from 'echarts';\n\nvar chartdom = document.getelementbyid('main');\nvar mychart = echarts.init(chartdom);\nvar option;\n\noption = {\n    tooltip: {\n        trigger: 'axis'\n    },\n    grid: {\n        left: '3%',\n        right: '4%',\n        bottom: '3%',\n        containlabel: true\n    },\n    xaxis: {\n        type: 'category',\n        boundarygap: false,\n        data: ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun']\n    },\n    yaxis: {\n        type: 'value'\n    },\n    series: [\n        {\n            name: '资产访问',\n            type: 'line',\n            symbol: 'circle', //折线点设置为实心点\n            symbolsize: 7, //折线点的大小\n            stack: 'total',\n            data: [120, 132, 101, 134, 90, 230, 210],\n            smooth: true,\n            color: '#9abcf6'\n        },\n        {\n            name: '资产申请',\n            type: 'line',\n            symbol: 'circle', //折线点设置为实心点\n            symbolsize: 7, //折线点的大小\n            stack: 'total',\n            data: [220, 182, 191, 234, 290, 330, 310],\n            smooth: true,\n            color: '#8adbc2'\n        }\n    ]\n};\n\noption && mychart.setoption(option);\n\n\n\n# 背景色\n\n\n\nimport * as echarts from 'echarts';\n\nvar chartdom = document.getelementbyid('main');\nvar mychart = echarts.init(chartdom);\nvar option;\n\noption = {\n    color: [\"#46a6ff\", \"#37c8cf\"],\n    tooltip: {\n        trigger: \"axis\",\n        //   鼠标的y坐标的数值\n        //   axispointer: {\n        //     type: \"cross\",\n        //     label: {\n        //       backgroundcolor: \"#6a7985\",\n        //     },\n        //   },\n    },\n    // legend: {\n    //   data: [\"资产访问\", \"资产申请\"],\n    // }, // 头部展示\n    grid: {\n        x: 30, //左侧与y轴的距离\n        y: 30, //top部与x轴的距离\n        x2: 30, //右侧与y轴的距离\n        y2: 40, //bottom部与x轴的距离\n        borderwidth: 1,\n        //   containlabel: true,\n    },\n    xaxis: [\n        {\n            type: \"category\",\n            boundarygap: false,\n            data: [\"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\", \"sun\"],\n        },\n    ],\n    yaxis: [\n        {\n            type: \"value\",\n        },\n    ],\n    series: [\n        {\n            name: \"资产访问\",\n            type: \"line\",\n            stack: \"total\",\n            smooth: true,\n            linestyle: {\n                width: 0,\n            },\n            showsymbol: false,\n            areastyle: {\n                opacity: 0.8,\n                color: new this.$echarts.graphic.lineargradient(0, 0, 0, 1, [\n                    {\n                        offset: 0,\n                        color: \"rgb(128, 255, 165)\",\n                    },\n                    {\n                        offset: 1,\n                        color: \"rgb(1, 191, 236)\",\n                    },\n                ]),\n            },\n            emphasis: {\n                focus: \"series\",\n            },\n            data: [140, 232, 101, 264, 90, 340, 250],\n        },\n        {\n            name: \"资产申请\",\n            type: \"line\",\n            stack: \"total\",\n            smooth: true,\n            linestyle: {\n                width: 0,\n            },\n            showsymbol: false,\n            areastyle: {\n                opacity: 0.8,\n                color: new this.$echarts.graphic.lineargradient(0, 0, 0, 1, [\n                    {\n                        offset: 0,\n                        color: \"rgb(0, 221, 255)\",\n                    },\n                    {\n                        offset: 1,\n                        color: \"rgb(77, 119, 255)\",\n                    },\n                ]),\n            },\n            emphasis: {\n                focus: \"series\",\n            },\n            data: [120, 282, 111, 234, 220, 340, 310],\n        },\n    ],\n};\n\noption && mychart.setoption(option);\n\n\n# 将图表网格线设置成虚线（图表横线网格）\n\n\n\nlet option = {\n    title: {\n        text: \"近一周資源訪問情況\",\n        x: \"left\",\n        y: \"top\",\n        textalign: \"left\",\n    },\n    tooltip: {\n        trigger: \"axis\",\n    }, // 悬浮提示\n    xaxis: {\n        type: \"category\",\n        boundarygap: false,\n        data: this.vistdata.map((v) => {\n            return v.date;\n        }),\n        axispointer: {\n            //hover线条颜色\n            linestyle: {\n                color: \"#fff\",\n            },\n        },\n        axistick: {\n            show: false, //隐藏x轴刻度\n        },\n        axisline: {\n            linestyle: {\n                color: \"#999\",\n            },\n        },\n        splitline: {\n            //分割线以及线条样式\n            show: true,\n        },\n    },\n    yaxis: {\n        type: \"value\",\n        axistick: {\n            show: true, //隐藏x轴刻度\n            color: \"#ccc\",\n        },\n        axisline: {\n            linestyle: {\n                color: \"#999\",\n            },\n        },\n        splitline: {\n            linestyle: {\n                type: \"dashed\", //虚线\n            },\n            show: true, //隐藏\n        },\n    },\n};\n\n\n# 修改颜色\n\n# 单条折线\n\n在与series统计的地方放置color数据，如下：\n\n{\n    series:[{\n        data:[820,932,901,934],\n        type:\"line\"\n    }],\n    color: [\"#4e68f1\"]  // 颜色\n}\n\n\n# 多条折线\n\n同理在与series同级的地方放置color数组：例如\n\n{\n    series:[{\n        data:[820,932,901,934],\n        type:\"line\",\n        symbol: \"circle\", //设定为实心点\n    }],\n        // 其中：当颜色不够时，会从第一个颜色再次开始遍历。\n        color: [\"#7ec0ee\", \"#ff9f7f\", \"#ffd700\", \"#c9c9c9\", \"#e066ff\", \"#c0ff3e\"]  \n}\n\n\n# 实心效果+修改颜色+实心拐点白色外边\n\n同理在与series同级的地方放置color数组+symbol：例如\n\nlet  series=[\n    {\n        data:[820,932,901,934],\n        type:\"line\",\n        symbol: \"circle\", //设定为实心点\n        symbolsize: 20,  // 实心圆的值\n        smooth: true, // 曲滑\n        itemstyle: {\n            normal: {\n                color: \"#4e68f1\", //点\n                linestyle: {\n                    color: \"#4e68f1\", //线\n                    width: 1,\n                    // 以下添加 echarts-折线图-实心拐点白色外边\n                    bordercolor: \"#ffffff\", \n                    bordertype: \"solid\",\n                    borderwidth: 5,\n                },\n            },\n        },\n    }\n],\n\n\n# 折线图背景渐变\n\n\n\ngetcardvisit(id) {\n    var chartdom = document.getelementbyid(id);\n    var mychart = echarts.init(chartdom);\n    var option;\n\n    option = {\n        tooltip: {\n            trigger: \"axis\",\n        }, // 悬浮提示\n        grid: {\n            x: 30, //左侧与y轴的距离\n            y: 30, //top部与x轴的距离\n            x2: 30, //右侧与y轴的距离\n            y2: 40, //bottom部与x轴的距离\n            borderwidth: 1,\n        },\n        xaxis: {\n            type: \"category\",\n            boundarygap: false,\n            data: [\"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\", \"sun\"],\n        },\n        yaxis: {\n            type: \"value\",\n        },\n        series: [\n            {\n                name: \"访问量\",\n                data: [100, 77, 44, 44, 4, 0, 4],\n                type: \"line\",\n                smooth: true, // 曲滑\n                itemstyle: {\n                    normal: {\n                        areastyle: {\n                            type: \"default\",\n                            //渐变色实现===\n                            color: new this.$echarts.graphic.lineargradient(\n                                0,\n                                0,\n                                0,\n                                1,\n                                //三种由深及浅的颜色\n                                [\n                                    {\n                                        offset: 0,\n                                        color: \"#78e09d\",\n                                    },\n                                    {\n                                        offset: 1,\n                                        color: \"#7eccf0\",\n                                    },\n                                ]\n                            ),\n                        },\n\n                        linestyle: {\n                            //线的颜色\n                            color: \"#50c0e7\",\n                        },\n                        color: \"#78e09d\", //点\n                    },\n                },\n            },\n        ],\n    };\n\n    option && mychart.setoption(option);\n},\n\n\n\n# 柱状图\n\n# 用柱状图做排名\n\nvar that = this;\nvar chartdom = document.getelementbyid(\"topranking\");\nvar mychart = this.$echarts.init(chartdom);\nvar option;\n// let dataleft = [30, 40, 50, 60, 70, 99];\n// let dataright = [\n//     \"经营支出kpi\",\n//     \"月经营分析报表\",\n//     \"高端女性消费群体标签\",\n//     \"客户风险能力评估模型\",\n//     \"客户基础信息服务api\",\n//     \"季度考核kpi\",\n// ];\nlet dataleft = hotdata.num.length ? hotdata.num.reverse() : [];\nlet dataright = hotdata.assetname.length ?\n    hotdata.assetname.reverse() : [];\noption = {\n    // tooltip: {\n    //   trigger: \"axis\",\n    //   axispointer: {\n    //     type: \"shadow\",\n    //   },\n    // },\n    grid: {\n        x: 30, //左侧与y轴的距离\n        y: 30, //top部与x轴的距离\n        x2: 30, //右侧与y轴的距离\n        y2: 30, //bottom部与x轴的距离\n        containlabel: true,\n    },\n    xaxis: {\n        type: \"value\",\n        axislabel: {\n            //坐标label\n            show: false,\n        },\n        axisline: {\n            //坐标轴线\n            show: false,\n        },\n        axistick: {\n            //x轴刻度线\n            show: false,\n        },\n        splitline: {\n            //网格线\n            show: false,\n        },\n        // boundarygap: [0, 0.01]\n    },\n    yaxis: [{\n        // inverse: true, // 倒叙\n        type: \"category\",\n        axisline: {\n            show: false,\n        },\n        axistick: {\n            show: false,\n        },\n        axislabel: {\n            // formatter: \" {a|} {value} 次\",\n            formatter: function(value, index) {\n                let img = \"\";\n                if (index > dataleft.length - 2) {\n                    img = \"ranking1\";\n                } else if (index > dataleft.length - 3) {\n                    img = \"ranking2\";\n                } else if (index > dataleft.length - 4) {\n                    img = \"ranking3\";\n                } else {\n                    img = \"ranking4\";\n                }\n\n                return ` {${img}|}  ${value} ${that.$i18ns(\"second\")}`;\n            },\n            rich: {\n                ranking1: {\n                    backgroundcolor: {\n                        image: require(\"@/views/images/ranking1.png\"),\n                    },\n                    height: 24,\n                    alingn: \"center\",\n                    width: 32,\n                },\n                ranking2: {\n                    backgroundcolor: {\n                        image: require(\"@/views/images/ranking2.png\"),\n                    },\n                    height: 24,\n                    alingn: \"center\",\n                    width: 32,\n                },\n                ranking3: {\n                    backgroundcolor: {\n                        image: require(\"@/views/images/ranking3.png\"),\n                    },\n                    height: 24,\n                    alingn: \"center\",\n                    width: 32,\n                },\n                ranking4: {\n                    backgroundcolor: {\n                        image: require(\"@/views/images/ranking4.png\"),\n                    },\n                    height: 24,\n                    alingn: \"center\",\n                    width: 32,\n                },\n            },\n            textstyle: {\n                // 这里str是 axislabel的每一个值\n                color: function(str, i) {\n                    return i > dataleft.length - 4 ? \"#eb6793\" : \"#747474\";\n                },\n            },\n        },\n        data: dataleft,\n    }, {\n        type: \"category\",\n        axisline: {\n            show: false,\n        },\n        axistick: {\n            show: false,\n        },\n        axislabel: {\n            //lable太长控制截取\n            show: true,\n            formatter: function(value) {\n                var res = value;\n                // 长度超过4个的以省略号显示\n                if (res.length > 8) {\n                    res = res.substring(0, 8) + \"..\";\n                }\n                return res;\n            },\n        },\n        data: dataright,\n    }, ],\n    series: [{\n        type: \"bar\",\n        showbackground: true, // 柱状图的补充背景色\n        backgroundstyle: {\n            // color: \"red\",\n            borderradius: 5,\n        }, // 阴影样式\n        barwidth: 10, //柱图宽度\n        itemstyle: {\n            barborderradius: [4, 4, 4, 4], //柱状图圆角，初始化效果\n            color: new this.$echarts.graphic.lineargradient(0, 0, 0, 1, [{\n                offset: 0,\n                color: \"#508eff\",\n            }, {\n                offset: 1,\n                color: \"#82aefe\",\n            }, ]),\n        },\n        emphasis: {\n            itemstyle: {\n                color: new this.$echarts.graphic.lineargradient(0, 0, 0, 1, [{\n                    offset: 0,\n                    color: \"#508eff\",\n                }, {\n                    offset: 1,\n                    color: \"#82aefe\",\n                }, ]),\n            },\n        },\n        data: dataleft,\n    }, ],\n};\n\noption && mychart.setoption(option);\n\n\n效果：\n\n\n\n# 设置柱状图宽度\n\n修改series对应数组里面的barwidth属性即可设置柱形图宽度，当然还有最小宽，最大宽则是barminwidth和barmaxwidth\n\n# 正负轴向柱状图(单)\n\n\n\nvar data1 = [\n    {\n        name: '信用债：a户',\n        value: -1\n    },\n    {\n        name: '信用债：t户-外币',\n        value: 1\n    },\n\n    {\n        name: '信用债：a户-本币',\n        value: 1\n    },\n    {\n        name: '信用债：t户-本币',\n        value: 1\n    },\n    {\n        name: '利率债：a',\n        value: 1\n    },\n    {\n        name: '利率债：t户',\n        value: 4\n    }\n];\n// data = data.sort((a, b) => {\n//     return b.value - a.value\n// });\ngetarrbykey = (data, k) => {\n    let key = k || 'value';\n    let res = [];\n    if (data) {\n        data.foreach(function (t) {\n            res.push(t[key]);\n        });\n    }\n    return res;\n};\ngetrightdata = (data, k) => {\n    let key = k || 'value';\n    let res = [];\n    if (data) {\n        data.foreach(function (t) {\n            res.push(t[key] < 0 ? 0 : t[key]);\n        });\n    }\n    return res;\n};\ngetleftdata = (data, k) => {\n    let key = k || 'value';\n    let res = [];\n    if (data) {\n        data.foreach(function (t) {\n            res.push(t[key] > 0 ? 0 : t[key]);\n        });\n    }\n    return res;\n};\n\nopt = {\n    index: 0\n};\n// [起始最深颜色,结束的浅颜色]\n// colorleft = ['#0cebea', '#368bff'];\ncolorleft = ['#1f83ff', '#1f83ff'];\ncolorright = ['rgba(255,144,128,1)', 'rgba(255,144,128,1)'];\n\noption = {\n    backgroundcolor: '#fff',\n    title: {\n        text: '累计盈利（亿）：区间变化',\n        left: 'center',\n        top: '5%',\n        textstyle: {\n            color: 'rgba(0,0,0,0.65)',\n            fontsize: 24\n        }\n    },\n    // legend: {\n    //   top: \"15%\",\n    //   right: \"16%\",\n    //   itemwidth: 70,\n    //   itemheight: 22,\n    //   itemgap: 40,\n    //   orient: \"horizontal\",\n    //   icon: \"circle\",\n    //   textstyle: {\n    //     color: \"#000\",\n    //     fontsize: 16,\n    //   },\n    //   data: [\"飞行员\", \"乘务员\"],\n    // },\n    grid: [\n        {\n            show: false,\n            left: '10%',\n            top: '20%',\n            bottom: '30%',\n            width: '28%'\n        },\n        {\n            show: false,\n            left: '50%',\n            top: '20%',\n            bottom: '30%',\n            width: '20%'\n        },\n        {\n            show: false,\n            right: '10%',\n            top: '20%',\n            bottom: '30%',\n            width: '28%'\n        }\n    ],\n    tooltip: {\n        show: false,\n        // 设置  是否百分比\n        formatter: '{b} : {c}'\n    },\n    xaxis: [\n        {\n            type: 'value',\n            inverse: false,\n            axisline: {\n                show: false\n            },\n            axistick: {\n                show: false\n            },\n            position: 'bottom',\n            axislabel: {\n                show: true,\n                textstyle: {\n                    color: '#000',\n                    type: 'dashed'\n                }\n            },\n            splitline: {\n                show: true\n            }\n        },\n        {\n            gridindex: 1,\n            show: true,\n            type: 'value',\n            inverse: false,\n            axisline: {\n                show: false\n            },\n            axistick: {\n                show: true\n            },\n            position: 'bottom',\n            axislabel: {\n                show: true,\n                textstyle: {\n                    color: '#000'\n                }\n            },\n            splitline: {\n                show: false\n            }\n        },\n        {\n            gridindex: 2,\n            show: true,\n            type: 'value',\n            inverse: false,\n            axisline: {\n                show: false\n            },\n            axistick: {\n                show: false\n            },\n            position: 'bottom',\n            axislabel: {\n                show: true,\n                textstyle: {\n                    color: '#000',\n                    type: 'dashed'\n                }\n            },\n            splitline: {\n                show: true\n            }\n        }\n    ],\n    yaxis: [\n        {\n            gridindex: 0,\n            triggerevent: true,\n            show: true,\n            inverse: true,\n            data: getarrbykey(data1, 'name'),\n            axisline: {\n                show: false\n            },\n            splitline: {\n                show: false\n            },\n            axistick: {\n                show: false\n            },\n            axislabel: {\n                show: false\n            }\n        },\n        {\n            gridindex: 1,\n            type: 'category',\n            inverse: true,\n            position: 'left',\n            axisline: {\n                show: false\n            },\n            axistick: {\n                show: false\n            },\n            axislabel: {\n                show: true,\n                interval: 0,\n                align: 'auto',\n                verticalalign: 'middle',\n                textstyle: {\n                    color: '#000',\n                    fontsize: 16,\n                    align: 'center'\n                }\n            },\n            data: getarrbykey(data1, 'name')\n        },\n        {\n            gridindex: 2,\n            triggerevent: true,\n            show: true,\n            inverse: true,\n            data: getarrbykey(data1, 'name'),\n            axisline: {\n                show: false\n            },\n            splitline: {\n                show: false\n            },\n            axistick: {\n                show: false\n            },\n            axislabel: {\n                show: false\n            }\n        }\n    ],\n    series: [\n        {\n            type: 'bar',\n            gridindex: 0,\n            showbackground: false,\n            backgroundstyle: {\n                barborderradius: 30\n            },\n            xaxisindex: 0,\n            yaxisindex: 0,\n            data: getleftdata(data1),\n            barwidth: 20,\n            // barcategorygap: '40%',\n            itemstyle: {\n                normal: {\n                    show: true,\n                    // 线性渐变，前四个参数分别是 x0, y0, x2, y2, 范围从 0 - 1，分别表示右,下,左,上。例如（0，0，0，1）表示从正上开始向下渐变；如果是（1，0，0，0），则是从正右开始向左渐变。\n                    // 相当于在图形包围盒中的百分比，如果最后一个参数传 true，则该四个值是绝对的像素位置\n                    color: new echarts.graphic.lineargradient(\n                        0,\n                        0,\n                        1,\n                        0,\n                        [\n                            {\n                                offset: 0,\n                                color: colorright[0] //指0%处的颜色\n                            },\n                            {\n                                offset: 1,\n                                color: colorright[1] //指100%处的颜色\n                            }\n                        ],\n                        false\n                    )\n                    // barborderradius: [5, 0, 0, 5]\n                }\n            },\n\n            label: {\n                normal: {\n                    show: false,\n                    position: 'insideleft',\n                    textstyle: {\n                        color: '#fff',\n                        fontsize: '14'\n                    }\n                }\n            }\n        },\n        {\n            type: 'bar',\n            xaxisindex: 2,\n            yaxisindex: 2,\n            gridindex: 2,\n            showbackground: false,\n            backgroundstyle: {\n                barborderradius: 30\n            },\n            data: getrightdata(data1),\n            barwidth: 20,\n            // barcategorygap: '40%',\n            itemstyle: {\n                normal: {\n                    show: true,\n                    // 线性渐变，前四个参数分别是 x0, y0, x2, y2, 范围从 0 - 1，分别表示右,下,左,上。例如（0，0，0，1）表示从正上开始向下渐变；如果是（1，0，0，0），则是从正右开始向左渐变。\n                    // 相当于在图形包围盒中的百分比，如果最后一个参数传 true，则该四个值是绝对的像素位置\n                    color: new echarts.graphic.lineargradient(\n                        0,\n                        0,\n                        1,\n                        0,\n                        [\n                            {\n                                offset: 0,\n                                color: colorright[0] //指0%处的颜色\n                            },\n                            {\n                                offset: 1,\n                                color: colorright[1] //指100%处的颜色\n                            }\n                        ],\n                        false\n                    )\n                    // barborderradius: [0, 5, 5, 0]\n                }\n            },\n            label: {\n                normal: {\n                    show: false,\n                    position: 'insideright',\n                    textstyle: {\n                        color: '#ffffff',\n                        fontsize: '14'\n                    }\n                }\n            }\n        }\n    ]\n};\n\n\n\n# 正负轴向柱状图(多)\n\n\n\nvar data1 = [\n    {\n        name: '保证金余额',\n        value: -1,\n        value1: -2,\n        value2: -4\n    },\n    {\n        name: '追加保证金',\n        value: 1,\n        value1: 2,\n        value2: 3\n    },\n\n    {\n        name: '累计损益',\n        value: 1,\n        value1: -4,\n        value2: 0.5\n    },\n    {\n        name: '日损益',\n        value: 1,\n        value1: 1,\n        value2: -4\n    },\n    {\n        name: '维持保证金',\n        value: 1,\n        value1: 3,\n        value2: -0.5\n    },\n    {\n        name: '初始保证金',\n        value: 4,\n        value1: -2,\n        value2: 1.5\n    }\n];\n// data = data.sort((a, b) => {\n//     return b.value - a.value\n// });\ngetarrbykey = (data, k) => {\n    let key = k || 'value';\n    let res = [];\n    if (data) {\n        data.foreach(function (t) {\n            res.push(t[key]);\n        });\n    }\n    return res;\n};\ngetrightdata = (data, k) => {\n    let key = k || 'value';\n    let res = [];\n    if (data) {\n        data.foreach(function (t) {\n            res.push(t[key] < 0 ? 0 : t[key]);\n        });\n    }\n    return res;\n};\ngetleftdata = (data, k) => {\n    let key = k || 'value';\n    let res = [];\n    if (data) {\n        data.foreach(function (t) {\n            res.push(t[key] > 0 ? 0 : t[key]);\n        });\n    }\n    return res;\n};\n\nopt = {\n    index: 0\n};\n// [起始最深颜色,结束的浅颜色]\n// colorleft = ['#0cebea', '#368bff'];\ncolorleft = ['#1f83ff', '#1f83ff'];\ncolorright = [\n    ['rgba(59,160,254,1)', 'rgba(59,160,254,1)'],\n    ['rgba(79,202,116,1)', 'rgba(79,202,116,1)'],\n    ['rgba(254,185,123,1)', 'rgba(254,185,123,1)']\n];\n\noption = {\n    backgroundcolor: '#fff',\n    title: {\n        text: '日保证金情况监控',\n        left: 'center',\n        top: '5%',\n        textstyle: {\n            color: 'rgba(0,0,0,0.65)',\n            fontsize: 24\n        }\n    },\n    legend: {\n        top: \"12%\",\n        // right: \"16%\",\n        // itemwidth: 70,\n        // itemheight: 22,\n        // itemgap: 40,\n        // orient: \"horizontal\",\n        // icon: \"circle\",\n        textstyle: {\n            color: \"#000\",\n            fontsize: 16,\n        },\n        data: [\"企业1\", \"企业2\",\"企业3\"],\n    },\n    grid: [\n        {\n            show: false,\n            left: '10%',\n            top: '20%',\n            bottom: '20%',\n            width: '28%'\n        },\n        {\n            show: false,\n            left: '50%',\n            top: '20%',\n            bottom: '20%',\n            width: '20%'\n        },\n        {\n            show: false,\n            right: '10%',\n            top: '20%',\n            bottom: '20%',\n            width: '28%'\n        }\n    ],\n    tooltip: {\n        show: false,\n        // 设置  是否百分比\n        formatter: '{b} : {c}'\n    },\n    xaxis: [\n        {\n            type: 'value',\n            inverse: false,\n            axisline: {\n                show: false\n            },\n            axistick: {\n                show: false\n            },\n            position: 'bottom',\n            axislabel: {\n                show: true,\n                textstyle: {\n                    color: '#000',\n                    type: 'dashed'\n                }\n            },\n            splitline: {\n                show: true\n            }\n        },\n        {\n            gridindex: 1,\n            show: true,\n            type: 'value',\n            inverse: false,\n            axisline: {\n                show: false\n            },\n            axistick: {\n                show: true\n            },\n            position: 'bottom',\n            axislabel: {\n                show: true,\n                textstyle: {\n                    color: '#000'\n                }\n            },\n            splitline: {\n                show: false\n            }\n        },\n        {\n            gridindex: 2,\n            show: true,\n            type: 'value',\n            inverse: false,\n            axisline: {\n                show: false\n            },\n            axistick: {\n                show: false\n            },\n            position: 'bottom',\n            axislabel: {\n                show: true,\n                textstyle: {\n                    color: '#000',\n                    type: 'dashed'\n                }\n            },\n            splitline: {\n                show: true\n            }\n        }\n    ],\n    yaxis: [\n        {\n            gridindex: 0,\n            triggerevent: true,\n            show: true,\n            inverse: true,\n            data: getarrbykey(data1, 'name'),\n            axisline: {\n                show: false\n            },\n            splitline: {\n                show: false\n            },\n            axistick: {\n                show: false\n            },\n            axislabel: {\n                show: false\n            }\n        },\n        {\n            gridindex: 1,\n            type: 'category',\n            inverse: true,\n            position: 'left',\n            axisline: {\n                show: false\n            },\n            axistick: {\n                show: false\n            },\n            axislabel: {\n                show: true,\n                interval: 0,\n                align: 'auto',\n                verticalalign: 'middle',\n                textstyle: {\n                    color: '#000',\n                    fontsize: 16,\n                    align: 'center'\n                }\n            },\n            data: getarrbykey(data1, 'name')\n        },\n        {\n            gridindex: 2,\n            triggerevent: true,\n            show: true,\n            inverse: true,\n            data: getarrbykey(data1, 'name'),\n            axisline: {\n                show: false\n            },\n            splitline: {\n                show: false\n            },\n            axistick: {\n                show: false\n            },\n            axislabel: {\n                show: false\n            }\n        }\n    ],\n    series: [\n        {\n            name:'企业1',\n            type: 'bar',\n            gridindex: 0,\n            showbackground: false,\n            backgroundstyle: {\n                barborderradius: 30\n            },\n            xaxisindex: 0,\n            yaxisindex: 0,\n            data: getleftdata(data1),\n            // max-barwidth: 20,\n            // barcategorygap: '40%',\n            itemstyle: {\n                normal: {\n                    show: true,\n                    // 线性渐变，前四个参数分别是 x0, y0, x2, y2, 范围从 0 - 1，分别表示右,下,左,上。例如（0，0，0，1）表示从正上开始向下渐变；如果是（1，0，0，0），则是从正右开始向左渐变。\n                    // 相当于在图形包围盒中的百分比，如果最后一个参数传 true，则该四个值是绝对的像素位置\n                    color: new echarts.graphic.lineargradient(\n                        0,\n                        0,\n                        1,\n                        0,\n                        [\n                            {\n                                offset: 0,\n                                color: colorright[0][0] //指0%处的颜色\n                            },\n                            {\n                                offset: 1,\n                                color: colorright[0][1] //指100%处的颜色\n                            }\n                        ],\n                        false\n                    )\n                    // barborderradius: [5, 0, 0, 5]\n                }\n            },\n\n            label: {\n                normal: {\n                    show: false,\n                    position: 'insideleft',\n                    textstyle: {\n                        color: '#fff',\n                        fontsize: '14'\n                    }\n                }\n            }\n        },\n        {\n            name:'企业1',\n            type: 'bar',\n            xaxisindex: 2,\n            yaxisindex: 2,\n            gridindex: 2,\n            showbackground: false,\n            backgroundstyle: {\n                barborderradius: 30\n            },\n            data: getrightdata(data1),\n            // barwidth: 20,\n            // barcategorygap: '40%',\n            itemstyle: {\n                normal: {\n                    show: true,\n                    // 线性渐变，前四个参数分别是 x0, y0, x2, y2, 范围从 0 - 1，分别表示右,下,左,上。例如（0，0，0，1）表示从正上开始向下渐变；如果是（1，0，0，0），则是从正右开始向左渐变。\n                    // 相当于在图形包围盒中的百分比，如果最后一个参数传 true，则该四个值是绝对的像素位置\n                    color: new echarts.graphic.lineargradient(\n                        0,\n                        0,\n                        1,\n                        0,\n                        [\n                            {\n                                offset: 0,\n                                color: colorright[0][0] //指0%处的颜色\n                            },\n                            {\n                                offset: 1,\n                                color: colorright[0][1] //指100%处的颜色\n                            }\n                        ],\n                        false\n                    )\n                    // barborderradius: [0, 5, 5, 0]\n                }\n            },\n            label: {\n                normal: {\n                    show: false,\n                    position: 'insideright',\n                    textstyle: {\n                        color: '#ffffff',\n                        fontsize: '14'\n                    }\n                }\n            }\n        },\n        {\n            name:'企业2',\n            type: 'bar',\n            gridindex: 0,\n            showbackground: false,\n            backgroundstyle: {\n                barborderradius: 30\n            },\n            xaxisindex: 0,\n            yaxisindex: 0,\n            data: getleftdata(data1,'value1'),\n            // barwidth: 20,\n            // barcategorygap: '40%',\n            itemstyle: {\n                normal: {\n                    show: true,\n                    // 线性渐变，前四个参数分别是 x0, y0, x2, y2, 范围从 0 - 1，分别表示右,下,左,上。例如（0，0，0，1）表示从正上开始向下渐变；如果是（1，0，0，0），则是从正右开始向左渐变。\n                    // 相当于在图形包围盒中的百分比，如果最后一个参数传 true，则该四个值是绝对的像素位置\n                    color: new echarts.graphic.lineargradient(\n                        0,\n                        0,\n                        1,\n                        0,\n                        [\n                            {\n                                offset: 0,\n                                color: colorright[1][0] //指0%处的颜色\n                            },\n                            {\n                                offset: 1,\n                                color: colorright[1][1] //指100%处的颜色\n                            }\n                        ],\n                        false\n                    )\n                    // barborderradius: [5, 0, 0, 5]\n                }\n            },\n\n            label: {\n                normal: {\n                    show: false,\n                    position: 'insideleft',\n                    textstyle: {\n                        color: '#fff',\n                        fontsize: '14'\n                    }\n                }\n            }\n        },\n        {\n            name:'企业2',\n            type: 'bar',\n            xaxisindex: 2,\n            yaxisindex: 2,\n            gridindex: 2,\n            showbackground: false,\n            backgroundstyle: {\n                barborderradius: 30\n            },\n            data: getrightdata(data1,'value1'),\n            // barwidth: 20,\n            // barcategorygap: '40%',\n            itemstyle: {\n                normal: {\n                    show: true,\n                    // 线性渐变，前四个参数分别是 x0, y0, x2, y2, 范围从 0 - 1，分别表示右,下,左,上。例如（0，0，0，1）表示从正上开始向下渐变；如果是（1，0，0，0），则是从正右开始向左渐变。\n                    // 相当于在图形包围盒中的百分比，如果最后一个参数传 true，则该四个值是绝对的像素位置\n                    color: new echarts.graphic.lineargradient(\n                        0,\n                        0,\n                        1,\n                        0,\n                        [\n                            {\n                                offset: 0,\n                                color: colorright[1][0] //指0%处的颜色\n                            },\n                            {\n                                offset: 1,\n                                color: colorright[1][1] //指100%处的颜色\n                            }\n                        ],\n                        false\n                    )\n                    // barborderradius: [0, 5, 5, 0]\n                }\n            },\n            label: {\n                normal: {\n                    show: false,\n                    position: 'insideright',\n                    textstyle: {\n                        color: '#ffffff',\n                        fontsize: '14'\n                    }\n                }\n            }\n        },\n        {\n            name:'企业3',\n            type: 'bar',\n            gridindex: 0,\n            showbackground: false,\n            backgroundstyle: {\n                barborderradius: 30\n            },\n            xaxisindex: 0,\n            yaxisindex: 0,\n            data: getleftdata(data1,'value2'),\n            // barwidth: 20,\n            // barcategorygap: '40%',\n            itemstyle: {\n                normal: {\n                    show: true,\n                    // 线性渐变，前四个参数分别是 x0, y0, x2, y2, 范围从 0 - 1，分别表示右,下,左,上。例如（0，0，0，1）表示从正上开始向下渐变；如果是（1，0，0，0），则是从正右开始向左渐变。\n                    // 相当于在图形包围盒中的百分比，如果最后一个参数传 true，则该四个值是绝对的像素位置\n                    color: new echarts.graphic.lineargradient(\n                        0,\n                        0,\n                        1,\n                        0,\n                        [\n                            {\n                                offset: 0,\n                                color: colorright[2][0] //指0%处的颜色\n                            },\n                            {\n                                offset: 1,\n                                color: colorright[2][1] //指100%处的颜色\n                            }\n                        ],\n                        false\n                    )\n                    // barborderradius: [5, 0, 0, 5]\n                }\n            },\n\n            label: {\n                normal: {\n                    show: false,\n                    position: 'insideleft',\n                    textstyle: {\n                        color: '#fff',\n                        fontsize: '14'\n                    }\n                }\n            }\n        },\n        {\n            name:'企业3',\n            type: 'bar',\n            xaxisindex: 2,\n            yaxisindex: 2,\n            gridindex: 2,\n            showbackground: false,\n            backgroundstyle: {\n                barborderradius: 30\n            },\n            data: getrightdata(data1,'value2'),\n            // barwidth: 20,\n            // barcategorygap: '40%',\n            itemstyle: {\n                normal: {\n                    show: true,\n                    // 线性渐变，前四个参数分别是 x0, y0, x2, y2, 范围从 0 - 1，分别表示右,下,左,上。例如（0，0，0，1）表示从正上开始向下渐变；如果是（1，0，0，0），则是从正右开始向左渐变。\n                    // 相当于在图形包围盒中的百分比，如果最后一个参数传 true，则该四个值是绝对的像素位置\n                    color: new echarts.graphic.lineargradient(\n                        0,\n                        0,\n                        1,\n                        0,\n                        [\n                            {\n                                offset: 0,\n                                color: colorright[2][0] //指0%处的颜色\n                            },\n                            {\n                                offset: 1,\n                                color: colorright[2][1] //指100%处的颜色\n                            }\n                        ],\n                        false\n                    )\n                    // barborderradius: [0, 5, 5, 0]\n                }\n            },\n            label: {\n                normal: {\n                    show: false,\n                    position: 'insideright',\n                    textstyle: {\n                        color: '#ffffff',\n                        fontsize: '14'\n                    }\n                }\n            }\n        },\n    ]\n};\n\n\n\n# 两柱状图\n\n\n\noption = {\n    title: {\n        text: \"生产监控系统\",\n        subtext: \"实时产能监控\",\n        left: \"center\",\n    },\n    tooltip: {\n        trigger: \"axis\",\n        axispointer: {\n            // 坐标轴指示器，坐标轴触发有效\n            type: \"shadow\", // 默认为直线，可选为：'line' | 'shadow'\n        },\n        //     formatter: function(params){return math.max(params.value,-params.value)}\n\n        formatter: function (params) {\n            return (\n                params[0].name +\n                \"<br>生产中：\" +\n                params[0].value +\n                \"<br>等待中：\" +\n                -params[1].value\n            );\n        },\n    },\n    legend: {\n        data: [\"等待中\", \"生产中\"],\n        left: \"right\",\n    },\n    grid: {\n        left: \"3%\",\n        right: \"4%\",\n        bottom: \"3%\",\n        containlabel: true,\n    },\n    xaxis: [\n        {\n            type: \"value\",\n        },\n    ],\n    yaxis: [\n        {\n            type: \"category\",\n            axistick: { show: false },\n            data: [\n                \"分拣\",\n                \"清洗\",\n                \"抛光\",\n                \"研磨\",\n                \"脱膜\",\n                \"切割\",\n                \"压膜\",\n                \"压膜分配\",\n                \"光固化后处理\",\n                \"光固化\",\n            ],\n        },\n    ],\n    series: [\n        {\n            name: \"等待中\",\n            type: \"bar\",\n            stack: \"总量\",\n            label: {\n                normal: {\n                    show: true,\n                },\n            },\n            data: [400, 241, 360, 320, 302, 341, 374, -390, 450, 420],\n        },\n        {\n            name: \"生产中\",\n            type: \"bar\",\n            stack: \"总量\",\n            label: {\n                normal: {\n                    show: true,\n                    formatter: function (params) {\n                        return -params.value;\n                    },\n                },\n            },\n            data: [-120, -180, -120, -120, -132, -101, -134, -190, -230, -210],\n        },\n    ],\n};\n\n\n\n# 两柱状图标签\n\n\n\nvar xdata = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"];\nvar linedata = [100, 100, 100, 100, 100, 100, 100];\nvar lastyeardata = [3, 20, 62, 34, 55, 65, 33];\nvar thisyeardata = [11, 38, 23, 39, 66, 66, 79];\nvar timelinedata = [1];\nlet legend = [\"2017\", \"2018\"];\nvar background = \"#0e2147\"; //背景\nlet textcolor = \"#fff\";\nlet linecolor = \"rgba(255,255,255,0.2)\";\nlet colors = [\n    {\n        bordercolor: \"rgba(227,161,96,1)\",\n        start: \"rgba(227,161,96,0.8)\",\n        end: \"rgba(227,161,96,0.3)\",\n    },\n    {\n        bordercolor: \"rgba(0,222,255,1)\",\n        start: \"rgba(0,222,255,0.3)\",\n        end: \"rgba(0,222,255,0.8)\",\n    },\n];\nlet borderdata = [];\nlet scale = 2;\nborderdata = xdata.map((item) => {\n    return scale;\n});\nvar option = {\n    baseoption: {\n        backgroundcolor: background,\n        timeline: {\n            show: false,\n            top: 0,\n            data: [],\n        },\n        legend: {\n            top: \"5%\",\n            right: \"5%\",\n            itemwidth: 20,\n            itemheight: 5,\n            // itemgap: 343,\n            icon: \"horizontal\",\n            textstyle: {\n                color: \"#ffffff\",\n                fontsize: 20,\n            },\n            data: legend,\n        },\n        grid: [\n            {\n                show: false,\n                left: \"5%\",\n                top: \"10%\",\n                bottom: \"8%\",\n                containlabel: true,\n                width: \"37%\",\n            },\n            {\n                show: false,\n                left: \"51%\",\n                top: \"10%\",\n                bottom: \"8%\",\n                width: \"0%\",\n            },\n            {\n                show: false,\n                right: \"2%\",\n                top: \"10%\",\n                bottom: \"8%\",\n                containlabel: true,\n                width: \"37%\",\n            },\n        ],\n        xaxis: [\n            {\n                type: \"value\",\n                inverse: true,\n                axisline: {\n                    show: false,\n                },\n                axistick: {\n                    show: false,\n                },\n                position: \"top\",\n                axislabel: {\n                    show: true,\n                    color: textcolor,\n                },\n                splitline: {\n                    show: true,\n                    linestyle: {\n                        color: linecolor,\n                    },\n                },\n            },\n            {\n                gridindex: 1,\n                show: false,\n            },\n            {\n                gridindex: 2,\n                axisline: {\n                    show: false,\n                },\n                axistick: {\n                    show: false,\n                },\n                position: \"top\",\n                axislabel: {\n                    show: true,\n                    color: textcolor,\n                },\n                splitline: {\n                    show: true,\n                    linestyle: {\n                        color: linecolor,\n                    },\n                },\n            },\n        ],\n        yaxis: [\n            {\n                type: \"category\",\n                inverse: true,\n                position: \"right\",\n                axisline: {\n                    show: true,\n                    linestyle: {\n                        color: linecolor,\n                    },\n                },\n\n                axistick: {\n                    show: false,\n                },\n                axislabel: {\n                    show: false,\n                },\n                data: xdata,\n            },\n            {\n                gridindex: 1,\n                type: \"category\",\n                inverse: true,\n                position: \"left\",\n                axisline: {\n                    show: false,\n                },\n                axistick: {\n                    show: false,\n                },\n                axislabel: {\n                    show: true,\n                    padding: [30, 0, 0, 0],\n                    textstyle: {\n                        color: \"#ffffff\",\n                        fontsize: 20,\n                    },\n                    align: \"center\",\n                },\n                data: xdata.map(function (value) {\n                    return {\n                        value: value,\n                        textstyle: {\n                            align: \"center\",\n                        },\n                    };\n                }),\n            },\n            {\n                gridindex: 2,\n                type: \"category\",\n                inverse: true,\n                position: \"left\",\n                axisline: {\n                    show: true,\n                    linestyle: {\n                        color: linecolor,\n                    },\n                },\n                axistick: {\n                    show: false,\n                },\n                axislabel: {\n                    show: false,\n                },\n                data: xdata,\n            },\n        ],\n        series: [],\n    },\n    options: [],\n};\n\noption.baseoption.timeline.data.push(timelinedata[0]);\noption.options.push({\n    series: [\n        {\n            name: \"2017\",\n            type: \"bar\",\n            barwidth: 25,\n            stack: \"1\",\n            itemstyle: {\n                normal: {\n                    color: new echarts.graphic.lineargradient(0, 0, 1, 0, [\n                        {\n                            offset: 0,\n                            color: colors[0].start,\n                        },\n                        {\n                            offset: 1,\n                            color: colors[0].end,\n                        },\n                    ]),\n                },\n            },\n            label: {\n                normal: {\n                    show: false,\n                },\n            },\n            data: lastyeardata,\n            animationeasing: \"elasticout\",\n        },\n        {\n            name: \"2017\",\n            type: \"bar\",\n            barwidth: 25,\n            stack: \"1\",\n            itemstyle: {\n                normal: {\n                    color: colors[0].bordercolor,\n                },\n            },\n            data: borderdata,\n        },\n        {\n            name: \"2018\",\n            type: \"bar\",\n            stack: \"2\",\n            barwidth: 25,\n            xaxisindex: 2,\n            yaxisindex: 2,\n            itemstyle: {\n                normal: {\n                    color: new echarts.graphic.lineargradient(0, 0, 1, 0, [\n                        {\n                            offset: 0,\n                            color: colors[1].start,\n                        },\n                        {\n                            offset: 1,\n                            color: colors[1].end,\n                        },\n                    ]),\n                },\n            },\n            label: {\n                normal: {\n                    show: false,\n                },\n            },\n            data: thisyeardata,\n            animationeasing: \"elasticout\",\n        },\n        {\n            name: \"2018\",\n            type: \"bar\",\n            xaxisindex: 2,\n            yaxisindex: 2,\n            barwidth: 25,\n            stack: \"2\",\n            itemstyle: {\n                normal: {\n                    color: colors[1].bordercolor,\n                },\n            },\n            data: borderdata,\n        },\n    ],\n});\n\n\n\n# y轴坐标放图片\n\n\n\nvar chartdom = document.getelementbyid(\"topranking\");\nvar mychart = this.$echarts.init(chartdom);\nvar option;\nlet dataleft = [30, 40, 50, 60, 70, 99];\nlet dataright = [\n    \"经营支出kpi\",\n    \"月经营分析报表\",\n    \"高端女性消费群体标签\",\n    \"客户风险能力评估模型\",\n    \"客户基础信息服务api\",\n    \"季度考核kpi\",\n];\n\noption = {\n    tooltip: {\n        trigger: \"axis\",\n        axispointer: {\n            type: \"shadow\",\n        },\n    },\n    grid: {\n        x: 30, //左侧与y轴的距离\n        y: 30, //top部与x轴的距离\n        x2: 30, //右侧与y轴的距离\n        y2: 30, //bottom部与x轴的距离\n        containlabel: true,\n    },\n    xaxis: {\n        type: \"value\",\n        axislabel: {\n            //坐标label\n            show: false,\n        },\n        axisline: {\n            //坐标轴线\n            show: false,\n        },\n        axistick: {\n            //x轴刻度线\n            show: false,\n        },\n        splitline: {\n            //网格线\n            show: false,\n        },\n        // boundarygap: [0, 0.01]\n    },\n    yaxis: [\n        {\n            type: \"category\",\n            axisline: {\n                show: false,\n            },\n            axistick: {\n                show: false,\n            },\n            axislabel: {\n                // formatter: \" {a|} {value} 次\",\n                formatter: function (value, index) {\n                    console.log(value, \"==value\");\n                    console.log(index, \"==index\");\n                    let img = \"\";\n                    if (index > dataleft.length - 2) {\n                        img = \"ranking1\";\n                    } else if (index > dataleft.length - 3) {\n                        img = \"ranking2\";\n                    } else if (index > dataleft.length - 4) {\n                        img = \"ranking3\";\n                    } else {\n                        img = \"ranking4\";\n                    }\n\n                    return ` {${img}|} ${value} 次`;\n                },\n                rich: {\n                    ranking1: {\n                        backgroundcolor: {\n                            image: require(\"@/views/images/ranking1.png\"),\n                        },\n                        height: 24,\n                        alingn: \"center\",\n                        width: 32,\n                    },\n                    ranking2: {\n                        backgroundcolor: {\n                            image: require(\"@/views/images/ranking2.png\"),\n                        },\n                        height: 24,\n                        alingn: \"center\",\n                        width: 32,\n                    },\n                    ranking3: {\n                        backgroundcolor: {\n                            image: require(\"@/views/images/ranking3.png\"),\n                        },\n                        height: 24,\n                        alingn: \"center\",\n                        width: 32,\n                    },\n                    ranking4: {\n                        backgroundcolor: {\n                            image: require(\"@/views/images/ranking4.png\"),\n                        },\n                        height: 24,\n                        alingn: \"center\",\n                        width: 32,\n                    },\n                },\n                textstyle: {\n                    // 这里str是 axislabel的每一个值\n                    color: function (str, i) {\n                        return i > dataleft.length - 4 ? \"#eb6793\" : \"#747474\";\n                    },\n                },\n            },\n            data: dataleft,\n        },\n        {\n            type: \"category\",\n            axisline: {\n                show: false,\n            },\n            axistick: {\n                show: false,\n            },\n            data: dataright,\n        },\n    ],\n    series: [\n        {\n            type: \"bar\",\n            showbackground: true, // 柱状图的补充背景色\n            barwidth: 10, //柱图宽度\n            itemstyle: {\n                barborderradius: [4, 4, 4, 4], //柱状图圆角，初始化效果\n                color: new this.$echarts.graphic.lineargradient(0, 0, 0, 1, [\n                    { offset: 0, color: \"#83bff6\" },\n                    { offset: 0.5, color: \"#188df0\" },\n                    { offset: 1, color: \"#188df0\" },\n                ]),\n            },\n            emphasis: {\n                itemstyle: {\n                    color: new this.$echarts.graphic.lineargradient(0, 0, 0, 1, [\n                        { offset: 0, color: \"#2378f7\" },\n                        { offset: 0.7, color: \"#2378f7\" },\n                        { offset: 1, color: \"#83bff6\" },\n                    ]),\n                },\n            },\n            data: dataleft,\n        },\n    ],\n};\n\noption && mychart.setoption(option);\n\n\n# echarts中的柱状图设置最大值、最小值、和平均值线条（vue项目中）\n\n\n\nlet  option= {\n    tooltip: {\n        show: true,\n    },\n    xaxis: {\n        data: [\"衬衫\", \"羊毛衫\", \"雪纺衫\", \"裤子\", \"高跟鞋\", \"袜子\"],\n    },\n    yaxis: {\n        type: \"value\",\n    },\n    color:\"#baf\",\n    series: [\n        {\n            name: \"销量\",\n            type: \"bar\",\n            data: [5, 20, 36, 10, 10, 20],\n            // ----------------------看这里往下---------------------------------\n            markpoint: { // 设置最大值和最小值\n                data: [\n                    {\n                        type: \"max\",\n                        name: \"我是最大值\",\n                    },\n                    {\n                        type: \"min\",\n                        name: \"我是最小值\",\n                    },\n                ],\n            },\n            markline:{ // 设置平均线\n                data:[\n                    {\n                        type:\"average\", \n                        name:\"我是平均值\",\n                        color:\"#baf\"\n                    }\n                ]\n            },\n            // --------------------看这里往上---------------------------------\n            label:{ // 展示具体柱状图的数值\n                show:true\n            }\n        },\n    ],\n},\n\n\n# 修改颜色\n\n# 单条柱状图\n\n# 只有一中颜色\n\nseries: [\n    {\n        data: [120, 200, 150, 80, 70, 110, 130],\n        type: 'bar',\n        barwidth: 10, //柱图宽度\n        itemstyle: {\n            normal: {\n                color:\"#ffd700\",\n            },\n        },\n    }\n]\n\n\n# 循环颜色\n\nitemstyle:{\n    normal: {\n        color: function (params) {\n            var colorlist = [\n                \"#82b7f5\",\n                \"#ff6262\",\n                \"#29eb81\",\n                \"#fa1ec9\",\n                \"#3ceaf0\",\n                \"#f3b637\",\n                \"#ab79eb\",\n                \"#f48d32\",\n                \"#4e68f1\",\n                \"#ebd22b\",\n            ];\n            return colorlist[params.dataindex % colorlist.length];\n        },\n            barborderradius: [4, 4, 4, 4], //柱状图圆角，初始化效果\n    },\n}\n\n\n# 渐变色\n\n\n\ngetcardauth(id) {\n    var chartdom = document.getelementbyid(id);\n    var mychart = echarts.init(chartdom);\n    var option;\n\n    option = {\n        grid: {\n            x: 30, //左侧与y轴的距离\n            y: 30, //top部与x轴的距离\n            x2: 30, //右侧与y轴的距离\n            y2: 40, //bottom部与x轴的距离\n            borderwidth: 1,\n        },\n        xaxis: {\n            type: \"category\",\n            data: [\"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\", \"sun\"],\n        },\n        yaxis: {\n            type: \"value\",\n        },\n        series: [\n            {\n                data: [120, 200, 150, 80, 70, 110, 130],\n                type: \"bar\",\n                barwidth: 20, //柱图宽度\n                itemstyle: {\n                    normal: {\n                        color: function (params) {\n                            const colorlist = [\n                                new echarts.graphic.lineargradient(\n                                    0,\n                                    1,\n                                    0,\n                                    0,\n                                    [\n                                        {\n                                            offset: 0,\n                                            color: \"#2a96ff\",\n                                        },\n                                        {\n                                            offset: 1,\n                                            color: \"#87c5fe\",\n                                        },\n                                    ],\n                                    false\n                                ),\n                            ];\n\n                            return colorlist[0];\n                        },\n                        barborderradius: [4, 4, 0, 0], //柱状图圆角，初始化效果\n                    },\n                },\n            },\n        ],\n    };\n\n    option && mychart.setoption(option);\n},\n\n\n# 多条柱状图\n\nseries: [\n    {\n        type: \"bar\",\n        itemstyle: {\n            normal: {\n                color: “#2c71c1”,\n            },\n        },\n    },\n    {\n        type: \"bar\",\n        itemstyle: {\n            normal: {\n                color: “#36a2eb”,\n            },\n        },\n    },\n    {\n        type: \"bar\",\n        itemstyle: {\n            normal: {\n                color: “#4bc0c0”,\n            },\n        },\n    },\n],\n\n\n\n# 饼图\n\n# legend的数据\n\nvar dom3 = document.getelementbyid(\"departchart\");\nvar mychart3 = this.$echarts.init(dom3);\n\nlet departchart = document.getelementbyid(\"departchart\")\nlet offsetwidth = departchart.offsetwidth;    // 返回元素的总宽度\n\nlet that = this;\nlet option = {\n    tooltip: {\n        trigger: \"item\",\n    },\n    legend: {\n        type: \"scroll\",\n        orient: \"vertical\",\n        right: 0,\n        top: 20,\n        bottom: 20,\n        //设置自定义legend 的重点\n        formatter: function (name) {\n            // 获取legend显示内容\n            // let data = that.alldata.assetbydept; //这个是展示的数据\n            // let total = 0;\n            // let tarvalue = 0;\n            return [\n                that.$echarts.format.truncatetext(\n                    name,\n                    offsetwidth * 0.41,\n                    \"14px microsoft yahei\",\n                    \"…\" //如果宽度超过80会出现...\n                ),\n            ].join(\" \");\n        },\n        tooltip: {\n            show: true,\n            trigger: \"item\",\n        },\n    },\n    series: [\n        {\n            type: \"pie\",\n            center: [\"35%\", \"50%\"],\n            radius: [\"30%\", \"55%\"],\n\n            itemstyle: {\n                // borderradius: 10,\n                bordercolor: \"#fff\",\n                borderwidth: 2,\n            },\n\n            label: {\n                show: false,\n                position: \"center\",\n            },\n            labelline: {\n                show: false,\n            },\n            data: this.alldata.assetbydept,\n            emphasis: {\n                itemstyle: {\n                    shadowblur: 10,\n                    shadowoffsetx: 0,\n                    shadowcolor: \"rgba(0, 0, 0, 0.5)\",\n                },\n            },\n        },\n    ],\n};\n\nmychart3.setoption(option);\n\n\n效果：\n\n\n\n# echarts饼图，自定义legend，解决legend字数太多和太长的问题，翻页处理\n\nlet option = {\n    tooltip: {\n        trigger: \"item\",\n        formatter: \"{a} <br/>{b}: {c} ({d}%)\"\n    },\n    legend: {\n        type: \"scroll\",\n        orient: \"vertical\",\n        right: 20,\n        top: 5,\n        bottom: 10,\n        pageiconcolor: \"white\",//激活的分页按钮颜色\n        pageiconinactivecolor: \"#2f4554\",//没激活的分页按钮颜色\n        //设置自定义legend 的重点\n        formatter: function(name) {\n            // 获取legend显示内容\n            let data = data1;//这个是展示的数据\n            let total = 0;\n            let tarvalue = 0;\n            let value = 0;\n            for (let i = 0, l = data.length; i < l; i++) {\n                total += data[i].value;\n                if (data[i].name == name) {\n                    tarvalue = data[i].value;\n                    value = data[i].value;\n                }\n            }\n            let p = total== 0? 0 ：((tarvalue / total) * 100).tofixed(1);\n            return [\n                \"{a|\" +\n                echarts.format.truncatetext(\n                    name,\n                    80,\n                    \"14px microsoft yahei\",\n                    \"…\"//如果宽度超过80会出现...\n                ) +\n                \"}\",\n                \"{b|\" + p + \"%}\",\n                \"{x|\" + value + \"}\"  //a、b、x、跟下面的rich对应\n            ].join(\" \");\n        },\n        tooltip: {\n            show: true,\t//这个为true的话悬停到legend上会出现tooltip\n            trigger: 'item',\n        },\n        textstyle: {\n            rich: {\n                a: {\n                    color: \"white\",\n                    width: 80,\n                    align: \"left\"\n                },\n                b: {\n                    width: 50,\n                    align: \"left\",\n                    color: \"white\"\n                },\n                x: {\n                    width: 30,\n                    align: \"left\",\n                    color: \"white\"\n                }\n            }\n        }\n    },\n    graphic: {//环形中间的字\n        elements: [\n            {\n                type: \"text\",\n                left: \"28%\",\n                top: \"43%\",\n                style: {\n                    text: \"666666\",\n                    textalign: \"center\",\n                    fill: \"#fff\",\n                    fontsize: 32\n                }\n            },\n            {\n                type: \"text\",\n                left: \"28%\",\n                top: \"56%\",\n                style: {\n                    text: \"总人数（人）\",\n                    textalign: \"center\",\n                    fill: \"#fff\",\n                    fontsize: 14\n                }\n            }\n        ]\n    },\n    series: [\n        {\n            name: \"访问来源\",\n            type: \"pie\",\n            radius: [\"50%\",\"70%\"],//环形图\n            center: [\"35%\", \"50%\"],\n            labelline: {\n                show: false\n            },\n            label: {\n                show: false\n            },\n            data: data1\n        }\n    ]\n};\n\n\n# echarts 饼图取消legend图例的点击事件，保留鼠标悬浮legend上显示tooltie提示信息的事件\n\nmycharts.on('legendselectchanged', function(params) {\n    var option = this.getoption();\n    option.legend[0].selected[params.name] = true;//相当于取消点击事件\n    this.setoption(option)\n})\n\n\n# 通过调整 center 按照百分比调整位置\n\nseries: [{\n    name: '圆环图系列名称',         // 系列名称\n    type: 'pie',                    // 系列类型\n    left: '0%',\n    center: ['24%', '50%'],           // 饼图的中心（圆心）坐标，数组的第一项是横坐标，第二项是纵坐标。[ default: ['50%', '50%'] ]\n    radius: ['30%', '40%'],         // 饼图的半径，数组的第一项是内半径，第二项是外半径。[ default: [0, '75%'] ]\n    hoveranimation: true,           // 是否开启 hover 在扇区上的放大动画效果。[ default: true ]\n    color: color,                   // 圆环图的颜色\n    label: {                        // 饼图图形上的文本标签，可用于说明图形的一些数据信息，比如值，名称等.\n        normal: {\n            show: false,             // 是否显示标签[ default: false ]\n            position: 'outside',    // 标签的位置。'outside'饼图扇区外侧，通过视觉引导线连到相应的扇区。'inside','inner' 同 'inside',饼图扇区内部。'center'在饼图中心位置。\n            formatter: '{b} : {c}次'  // 标签内容\n        }\n    },\n    labelline: {                    // 标签的视觉引导线样式,在 label 位置 设置为'outside'的时候会显示视觉引导线。\n        normal: {\n            show: false,             // 是否显示视觉引导线。\n            length: 15,             // 在 label 位置 设置为'outside'的时候会显示视觉引导线。\n            length2: 10,            // 视觉引导项第二段的长度。\n            linestyle: {            // 视觉引导线的样式\n                //color: '#000',\n                //width: 1\n            }\n        }\n    },\n    data: data                      // 系列中的数据内容数组。\n}],\n\n\n# 隐藏字体\n\nlabel: {\n    show: false,\n    position: 'center'\n},\nlabelline: {\n    show: false\n},\n\n\n# 字体+线条+饼图颜色一致\n\n\n\nimport * as echarts from 'echarts';\n\nvar chartdom = document.getelementbyid('main');\nvar mychart = echarts.init(chartdom);\nvar option;\n\nconst colorlist = ['#1890ff', '#36cbcb', '#4cc670', '#fad637', '#f2637b'];\nlet piedata = [\n    { value: 1048, name: '报表资产' },\n    { value: 735, name: '模型资产' },\n    { value: 580, name: '指标资产' },\n    { value: 484, name: '标签资产' },\n    { value: 300, name: '服务资产' }\n];\noption = {\n    tooltip: {\n        trigger: 'item'\n    },\n    color: colorlist,\n    series: [\n        {\n            name: 'access from',\n            type: 'pie',\n            radius: ['40%', '70%'],\n\n            label: {\n                formatter: '{name|{b} {c}}\\n{time|{c} ',\n                minmargin: 5,\n                edgedistance: 10,\n                lineheight: 15,\n                rich: {\n                    name: {\n                        fontsize: 16\n                    },\n                    time: {\n                        fontsize: 10,\n                        color: 'transparent'\n                        // color: '#999'\n                        // color: \"\"\n                    }\n                }\n            },\n            itemstyle: {\n                // color: (params) => {\n                //   var index = params.datasetindex;\n                //   const color = ['#1890ff', '#36cbcb', '#4cc670', '#fad637', '#f2637b'];\n                //   return color[index];\n                // }\n            },\n            labelline: {\n                length: 15,\n                length2: 0,\n                maxsurfaceangle: 80\n            },\n            labellayout: function (params) {\n                const isleft = params.labelrect.x < mychart.getwidth() / 2;\n                const points = params.labellinepoints;\n                // update the end point.\n                points[2][0] = isleft\n                    ? params.labelrect.x\n                : params.labelrect.x + params.labelrect.width;\n                return {\n                    labellinepoints: points\n                };\n            },\n            emphasis: {\n                label: {\n                    show: true\n                },\n                itemstyle: {\n                    shadowblur: 10,\n                    shadowoffsetx: 0,\n                    shadowcolor: 'rgba(0, 0, 0, 0.5)'\n                }\n            },\n            data: piedata.map((v, i) => {\n                v.label = {\n                    color: colorlist[i]\n                };\n                return v;\n            })\n        }\n    ]\n};\n\noption && mychart.setoption(option);\n\n\n# 圆环\n\n\n\nimport * as echarts from 'echarts';\n\nvar chartdom = document.getelementbyid('main');\nvar mychart = echarts.init(chartdom);\nvar option;\n\noption = {\n    tooltip: {\n        trigger: \"item\",\n    },\n    color: [\"#1890ff\", \"#36cbcb\", \"#4cc670\", \"#fad637\", \"#f2637b\"],\n    series: [\n        {\n            name: \"access from\",\n            type: \"pie\",\n            radius: [\"40%\", \"70%\"],\n            itemstyle: {\n                borderradius: 10,\n                bordercolor: \"#fff\",\n                borderwidth: 2,\n            },\n            data: [\n                { value: 1048, name: \"报表数据\" },\n                { value: 735, name: \"模型资产\" },\n                { value: 580, name: \"指标数据\" },\n                { value: 484, name: \"标签数据\" },\n                { value: 300, name: \"服务资产\" },\n            ],\n            emphasis: {\n                itemstyle: {\n                    shadowblur: 10,\n                    shadowoffsetx: 0,\n                    shadowcolor: \"rgba(0, 0, 0, 0.5)\",\n                },\n            },\n        },\n    ],\n};\n\noption && mychart.setoption(option);\n\n\n# 修改饼图颜色\n\n颜色设置同上\n\n主要注意形态变化：\n\nseries: [\n    {\n        name: this.title,\n        type: \"pie\",\n        radius: \"50%\",\n        radius: [\"50%\", \"70%\"], //环形图\n        center: [\"50%\", \"70%\"], //饼图\n        rosetype: \"radius\",//外边距不一的环形图 如上图\n        data: this.data,\n        color: this.color,\n        itemstyle : {\n            emphasis: {\n                shadowblur: 10,\n                shadowoffsetx: 0,\n                shadowcolor: \"rgba(0, 0, 0, 0.5)\",\n            },\n            normal: {\n                color: function (params) {\n                    var colorlist = [\n                        \"#d4c8ba\",\n                        \"#b26b65\",\n                        \"#ee8462\",\n                        \"#fbb28f\",\n                        \"#f4d2b6\",\n                        \"#d9ddcc\",\n                        \"#a6a8a7\",\n                        \"#845c65\",\n                        \"#585b64\",\n                        \"#f8af9e\",\n                        \"#f18c7f\",\n                        \"#f1cf7f\",\n                    ];\n                    return colorlist[params.dataindex % colorlist.length];\n                },\n            },\n        },\n    },\n],\n\n\n\n# 仪表盘\n\n# 进度仪表盘1\n\n\n\noption = {\n    title: {\n        top: '40px',\n        text: 'st 6.1亿',\n        left: 'center'\n    },\n    tooltip: {\n        formatter: '{a} <br/>{b} : {c}%'\n    },\n    series: [\n        {\n            type: 'gauge',\n            center: ['50%', '70%'],\n            startangle: 180, // 开始角度\n            endangle: 0, // 结束角度\n            min: 0,\n            max: 100,\n            splitnumber: 10,\n            radius: '70%',\n            axisline: {\n                linestyle: {\n                    color: [[1, '#f00']],\n                    width: 0\n                }\n            },\n            axistick: {\n                // 内刻度线条-短\n                splitnumber: 2,\n                linestyle: {\n                    width: 2,\n                    color: '#999'\n                }\n            },\n            axislabel: {\n                // 内刻度字体\n                distance: 10,\n                color: '#999',\n                fontsize: 20\n            },\n            splitline: {\n                // 内刻度线条-长\n                length: 12,\n                linestyle: {\n                    width: 3,\n                    color: '#999'\n                }\n            }\n        },\n        {\n            name: 'pressure',\n            type: 'gauge',\n            center: ['50%', '70%'],\n            startangle: 180, // 开始角度\n            endangle: 0, // 结束角度\n            min: 0, // 最小值\n            max: 100, // 最大值\n            progress: {\n                //选中区域\n                show: true,\n                // roundcap: true, // 倒圆角\n                width: 18\n            },\n            itemstyle: {\n                color: new echarts.graphic.lineargradient(1, 1, 0, 1, [\n                    {\n                        offset: 1,\n                        color: 'rgb(254,128,9)'\n                    },\n                    {\n                        offset: 0,\n                        color: 'rgb(254,175,107)'\n                    }\n                ]),\n                shadowcolor: 'rgba(254,175,107,0.45)',\n                shadowblur: 10\n                // shadowoffsetx: 2,\n                // shadowoffsety: 2\n            },\n            pointer: {\n                // 指针\n                // icon: 'path://m2090.36389,615.30999 l2090.36389,615.30999 c2091.48372,615.30999 2092.40383,616.194028 2092.44859,617.312956 l2096.90698,728.755929 c2097.05155,732.369577 2094.2393,735.416212 2090.62566,735.56078 c2090.53845,735.564269 2090.45117,735.566014 2090.36389,735.566014 l2090.36389,735.566014 c2086.74736,735.566014 2083.81557,732.63423 2083.81557,729.017692 c2083.81557,728.930412 2083.81732,728.84314 2083.82081,728.755929 l2088.2792,617.312956 c2088.32396,616.194028 2089.24407,615.30999 2090.36389,615.30999 z',\n                // length: '75%',\n                // width: 16,\n                // offsetcenter: [0, '5%']\n            },\n            axisline: {\n                // 底色\n                // roundcap: true, // 倒圆角\n                linestyle: {\n                    width: 18,\n                    color: [\n                        [\n                            1,\n                            new echarts.graphic.lineargradient(0, 0, 1, 0, [\n                                {\n                                    offset: 0.1,\n                                    color: 'rgb(245,245,245)'\n                                },\n                                {\n                                    offset: 1,\n                                    color: 'rgb(210,223,232)'\n                                }\n                            ])\n                        ]\n                    ]\n                }\n            },\n            axistick: {\n                // 内刻度线条-短\n                splitnumber: 1,\n                linestyle: {\n                    width: 0\n                }\n            },\n            splitline: {\n                // 内刻度线条-长\n                distance: -18,\n                length: 22,\n                linestyle: {\n                    color: '#fff'\n                }\n            },\n            axislabel: {\n                // 内刻度字体\n                // distance: 30,\n                color: 'transparent',\n                fontsize: 0\n            },\n            detail: {\n                // 展示值\n                offsetcenter: [0, '35%'],\n                valueanimation: true,\n                formatter: '{value}%'\n            },\n            data: [\n                {\n                    value: 50\n                    // name: 'score'\n                }\n            ]\n        }\n    ]\n};\n\n\n\n\n# 矩形树图\n\n# 基础\n\n\n\noption = {\n    title: {\n        text: '累计盈利（亿）：末期',\n        left: 'center'\n    },\n\n    legend: {\n        // top: \"15%\",\n        // right: \"16%\",\n        // itemwidth: 70,\n        // itemheight: 22,\n        // itemgap: 40,\n        // orient: \"horizontal\",\n        // icon: \"circle\",\n        // textstyle: {\n        //   color: \"#000\",\n        //   fontsize: 16,\n        // },\n        data: [\n            '利率债：t户',\n            '利率债：a户',\n            '信用债：t户-本币',\n            '信用债1',\n            '信用债'\n        ]\n    },\n    series: [\n        {\n            type: 'treemap',\n            label: {\n                //显示文字标签定义\n                show: true,\n                formatter: '{b}', //定义显示的内容 {b}表示name\n                normal: {\n                    textstyle: {\n                        ellipsis: true //圆角\n                    }\n                }\n            },\n            itemstyle: {\n                normal: {\n                    bordercolor: '#fff' //方块分割边框颜色\n                }\n            },\n            data: [\n                {\n                    name: '利率债：t户',\n                    value: 50\n                },\n                {\n                    name: '利率债：a户',\n                    value: 20\n                },\n                {\n                    name: '信用债：t户-本币',\n                    value: 10\n                },\n                {\n                    name: '信用债1',\n                    value: 5\n                },\n                {\n                    name: '信用债',\n                    value: 5\n                }\n            ]\n        }\n    ]\n};\n\n\n\n# 树状图\n\n\n\noption = {\n    title: {\n        text: '累计盈利（亿）：末期',\n        left: 'center'\n    },\n\n    legend: {\n        left: 'center',\n        top: '40px'\n    },\n    color: [\n        'rgb(114,193,254)',\n        'rgb(0,171,247)',\n        'rgb(254,174,126)',\n        'rgb(46,207,105)',\n        'rgb(254,133,133)'\n    ],\n    series: [\n        {\n            top: '80px',\n            type: 'treemap',\n            itemstyle: {\n                normal: {\n                    bordercolor: '#fff', //方块分割边框颜色\n                    label: {\n                        show: true,\n                        position: 'insidebottomleft',\n                        formatter: '{b}'\n                    },\n                    borderwidth: 1\n                }\n            },\n            roam: false, // 鼠标放大缩小\n            nodeclick: false, // 点击区域事件\n            breadcrumb: {\n                show: false //  底部的标签\n            },\n            data: [\n                {\n                    name: '利率债：t户',\n                    value: 50\n                },\n                {\n                    name: '利率债：a户',\n                    value: 20\n                },\n                {\n                    name: '信用债：t户-本币',\n                    value: 10\n                },\n                {\n                    name: '信用债1',\n                    value: 5\n                },\n                {\n                    name: '信用债',\n                    value: 5\n                }\n            ]\n        },\n        {\n            type: 'pie',\n            radius: '0%',\n            data: [\n                {\n                    labelline: {\n                        show: false\n                    },\n                    label: {\n                        show: false\n                    },\n                    name: '利率债：t户',\n                    value: 50\n                },\n                {\n                    labelline: {\n                        show: false\n                    },\n                    label: {\n                        show: false\n                    },\n                    name: '利率债：a户',\n                    value: 20\n                },\n                {\n                    labelline: {\n                        show: false\n                    },\n                    label: {\n                        show: false\n                    },\n                    name: '信用债：t户-本币',\n                    value: 10\n                },\n                {\n                    labelline: {\n                        show: false\n                    },\n                    label: {\n                        show: false\n                    },\n                    name: '信用债1',\n                    value: 5\n                },\n                {\n                    labelline: {\n                        show: false\n                    },\n                    label: {\n                        show: false\n                    },\n                    name: '信用债',\n                    value: 5\n                }\n            ],\n            emphasis: {}\n        }\n    ]\n};\n\n\n\n\n# 区域选择\n\nhttps://blog.csdn.net/qq_35250826/article/details/87840565\n\n\n# datazoom[区域属性]\n\n代码如下：\n\noption = {\n    // ...\n    datazoom: [\n        {\n            type: \"slider\",\n            show: true,\n            height: \"5%\",\n            bordercolor: \"#cae3ff\",\n            backgroundcolor: \"#cae3ff\",\n            start: 0,\n            end: 100,\n        },\n        {\n            type: \"inside\",\n            start: 0,\n            end: 100,\n        },\n    ],\n    // ...\n}\n\n\n参数如下：\n\ndatazoom:[ //区域缩放\n    {\n        id: 'datazoomx',\n        show:true, //是否显示 组件。如果设置为 false，不会显示，但是数据过滤的功能还存在。\n        backgroundcolor:\"rgba(47,69,84,0)\", //组件的背景颜色\n        type: 'slider', //slider表示有滑动块的，inside表示内置的\n        databackground:{ //数据阴影的样式。\n            linestyle:mylinestyle, //阴影的线条样式\n            areastyle:myareastyle, //阴影的填充样式\n        },\n        fillercolor:\"rgba(167,183,204,0.4)\", //选中范围的填充颜色。\n        bordercolor:\"#ddd\", //边框颜色。\n        filtermode: 'filter', //'filter'：当前数据窗口外的数据，被 过滤掉。即 会 影响其他轴的数据范围。每个数据项，只要有一个维度在数据窗口外，整个数据项就会被过滤掉。\n        //'weakfilter'：当前数据窗口外的数据，被 过滤掉。即 会 影响其他轴的数据范围。每个数据项，只有当全部维度都在数据窗口同侧外部，整个数据项才会被过滤掉。\n        //'empty'：当前数据窗口外的数据，被 设置为空。即 不会 影响其他轴的数据范围。\n        //'none': 不过滤数据，只改变数轴范围。\n        xaxisindex:0, //设置 datazoom-inside 组件控制的 x轴,可以用数组表示多个轴\n        yaxisindex:[0,2], //设置 datazoom-inside 组件控制的 y轴,可以用数组表示多个轴\n        radiusaxisindex:3, //设置 datazoom-inside 组件控制的 radius 轴,可以用数组表示多个轴\n        angleaxisindex:[0,2], //设置 datazoom-inside 组件控制的 angle 轴,可以用数组表示多个轴\n        start: 30, //数据窗口范围的起始百分比,表示30%\n        end: 70, //数据窗口范围的结束百分比,表示70%\n        startvalue:10, //数据窗口范围的起始数值\n        endvalue:100, //数据窗口范围的结束数值。\n        orient:\"horizontal\", //布局方式是横还是竖。不仅是布局方式，对于直角坐标系而言，也决定了，缺省情况控制横向数轴还是纵向数轴。'horizontal'：水平。'vertical'：竖直。\n        zoomlock:false, //是否锁定选择区域（或叫做数据窗口）的大小。如果设置为 true\n        则锁定选择区域的大小，也就是说，只能平移，不能缩放。\n        throttle:100, //设置触发视图刷新的频率。单位为毫秒（ms）。\n        zoomonmousewheel:true, //如何触发缩放。可选值为：true：表示不按任何功能键，鼠标滚轮能触发缩放。false：表示鼠标滚轮不能触发缩放。'shift'：表示按住 shift 和鼠标滚轮能触发缩放。'ctrl'：表示按住 ctrl 和鼠标滚轮能触发缩放。'alt'：表示按住 alt 和鼠标滚轮能触发缩放。\n        moveonmousemove:true, //如何触发数据窗口平移。true：表示不按任何功能键，鼠标移动能触发数据窗口平移。false：表示鼠标滚轮不能触发缩放。'shift'：表示按住 shift 和鼠标移动能触发数据窗口平移。'ctrl'：表示按住 ctrl 和鼠标移动能触发数据窗口平移。'alt'：表示按住 alt 和鼠标移动能触发数据窗口平移。\n        left:\"center\", //组件离容器左侧的距离,'left', 'center', 'right','20%'\n        top:\"top\", //组件离容器上侧的距离,'top', 'middle', 'bottom','20%'\n        right:\"auto\", //组件离容器右侧的距离,'20%'\n        bottom:\"auto\", //组件离容器下侧的距离,'20%'\n\n    },\n    {\n        id: 'datazoomy',\n        type: 'inside',\n        filtermode: 'empty',\n        disabled:false, //是否停止组件的功能。\n        xaxisindex:0, //设置 datazoom-inside 组件控制的 x轴,可以用数组表示多个轴\n        yaxisindex:[0,2], //设置 datazoom-inside 组件控制的 y轴,可以用数组表示多个轴\n        radiusaxisindex:3, //设置 datazoom-inside 组件控制的 radius 轴,可以用数组表示多个轴\n        angleaxisindex:[0,2], //设置 datazoom-inside 组件控制的 angle 轴,可以用数组表示多个轴\n        start: 30, //数据窗口范围的起始百分比,表示30%\n        end: 70, //数据窗口范围的结束百分比,表示70%\n        startvalue:10, //数据窗口范围的起始数值\n        endvalue:100, //数据窗口范围的结束数值。\n        orient:\"horizontal\", //布局方式是横还是竖。不仅是布局方式，对于直角坐标系而言，也决定了，缺省情况控制横向数轴还是纵向数轴。'horizontal'：水平。'vertical'：竖直。\n        zoomlock:false, //是否锁定选择区域（或叫做数据窗口）的大小。如果设置为 true 则锁定选择区域的大小，也就是说，只能平移，不能缩放。\n        throttle:100, //设置触发视图刷新的频率。单位为毫秒（ms）。\n        zoomonmousewheel:true, //如何触发缩放。可选值为：true：表示不按任何功能键，鼠标滚轮能触发缩放。false：表示鼠标滚轮不能触发缩放。'shift'：表示按住 shift 和鼠标滚轮能触发缩放。'ctrl'：表示按住 ctrl 和鼠标滚轮能触发缩放。'alt'：表示按住 alt 和鼠标滚轮能触发缩放。\n        moveonmousemove:true, //如何触发数据窗口平移。true：表示不按任何功能键，鼠标移动能触发数据窗口平移。false：表示鼠标滚轮不能触发缩放。'shift'：表示按住 shift 和鼠标移动能触发数据窗口平移。'ctrl'：表示按住 ctrl 和鼠标移动能触发数据窗口平移。'alt'：表示按住 alt 和鼠标移动能触发数据窗口平移。\n        maxspan:2, // 限制拖动的最大值\n    }\n]\n\n\n# 调整与x轴的上下位置\n\n有时datazoom的组件会与x轴重叠，我们怎么调节两者之间的距离呢？----通过增加grid组件可以调节 主要是通过其中的bottom属性来调节\n\noption = {\n    grid: {\n        left: \"3%\",\n        right: \"4%\",\n        bottom: \"11%\",\n        top: \"55%\",\n        containlabel: true,\n    },\n}\n\n\n\n# echarts柱状图圆角实现\n\nhttps://blog.csdn.net/qq_27232885/article/details/102463335\n\nseries: [{\n    data: [120, 200, 150, 80, 70, 110, 130],\n    type: 'bar',\n    itemstyle:{\n        normal: {\n            barborderradius: [4, 4, 4, 4], //柱状图圆角，初始化效果\n        },\n    }\n}]\n\n\n\n# 3d柱状图\n\nhttps://www.freesion.com/article/6465742030/\n\n\n\n<!doctype html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title>投票统计</title>\n        <script src=\"http://libs.baidu.com/jquery/2.0.0/jquery.min.js\"><\/script>\n        <script src=\"echarts.min.js\" type=\"text/javascript\"><\/script>\n        <script src=\"echarts-gl.js\"><\/script>\n        <style type=\"text/css\">\n            #biao{\n                width: 60vw;\n                height: 60vh;\n            }\n            body,html{\n                width: 100vw;\n                height: 100vh;\n                margin: 0;\n            }\n            #main{\n                width: 100vw;\n                height: 100vh;\n                display: flex;\n                flex-direction: row;\n                justify-content: center;\n                align-items: center;\n            }\n        </style>\n    </head>\n    <body>\n        <div id=\"main\">\n            <div id=\"biao\"></div>\n        </div>\n    </body>\n    <script type=\"text/javascript\">\n        // 基于准备好的dom，初始化echarts实例\n        var mychart = echarts.init(document.getelementbyid('main'));\n        var xdata = ['', '', '', '', '']; //x轴数据\n        var days = ['']; //z轴数据\n        var data = [\n            [0, 0, 0],\n            [0, 1, 0],\n            [0, 2, 0],\n            [0, 3, 0],\n            [0, 4, 0],\n        ];              //y轴数据\n        var option = {\n            tooltip: {\n                show:false,\n                trigger: 'axis',\n                axispointer: {            // 坐标轴指示器，坐标轴触发有效\n                    type: 'shadow'        // 默认为直线，可选为：'line' |  'shadow'\n                }\n            },\n            visualmap: {\n                show: false,\n                max: 15,\n                inrange: {\n                    color: ['#f9ef4d']\n                }\n            },\n            xaxis3d: {\n                name: 'x',\n                show: false,\n                axisline: {\n                    show: true,\n                    linestyle: {\n                        color: 'rgba(0,0,0,0)'\n                    }\n                },\n                axistick:{       //刻度线\n                    show:false\n                },\n                axislabel: {\n                    textstyle: {\n                        color: '#f9ef4d',\n                        fontsize: 30\n                    },\n                    interval: 0,  \n                    //x轴文字换行\n                    formatter: function(params) {\n                        var newparamsname = \"\"; // 最终拼接成的字符串\n                        var paramsnamenumber = params.length; // 实际标签的个数\n                        var providenumber = 6; // 每行能显示的字的个数\n                        var rownumber = math.ceil(paramsnamenumber / providenumber); // 换行的话，需要显示几行，向上取整\n                        if (paramsnamenumber > providenumber) {\n                            for (var p = 0; p < rownumber; p++) {\n                                var tempstr = \"\"; // 表示每一次截取的字符串\n                                var start = p * providenumber; // 开始截取的位置\n                                var end = start + providenumber; // 结束截取的位置\n                                if (p == rownumber - 1) {\n                                    tempstr = params.substring(start, paramsnamenumber);\n                                } else {\n                                    tempstr = params.substring(start, end) + \"\\n\";\n                                }\n                                newparamsname += tempstr; // 最终拼成的字符串\n                            }\n                        } else {\n                            // 将旧标签的值赋给新标签\n                            newparamsname = params;\n                        }\n                        //将最终的字符串返回\n                        return newparamsname\n                    }\n                },\n                splitline:{show: false},\n                namegap: 1,\n                type: 'category',\n                data: xdata\n            },\n            yaxis3d: {\n                name: 'y',\n                show: false,\n                axisline: {\n                    show: true,\n                    linestyle: {\n                        color: 'rgba(0,0,0,0)' //直接设置不显示出现bug，我就设置为透明\n                    }\n                },\n                splitline:{show: false},\n                type: 'category',\n                data: days\n            },\n            zaxis3d: {\n                name: '',\n\n                axisline: {\n                    show: true,\n                    linestyle: {\n                        color: 'rgba(0,0,0,0)'\n                    }\n                },\n                splitline:{show: false},\n                type: 'value'\n            },\n            grid3d: {\n                axispointer:{\n                    show:false\n                },\n                boxwidth: 200,\n                boxdepth: 20,\n                light: {\n                    main: {\n                        intensity: 1.2,\n                        shadow: true\n                    },\n                    ambient: {\n                        intensity: 0.3\n                    }\n                },\n                viewcontrol: {\n                    alpha: 0,\n                    beta: 0,\n                }\n            },\n            series: [{\n                type: 'bar3d',\n                name:'投票数',\n                data: data.map(function(item) {\n                    return {\n                        value: [item[1], item[0], item[2]],\n                    }\n                }),\n                label: {\n                    show: true,\n                    position: 'top',\n                    textstyle: { //数值样式\n                        color: '#ffe66f',\n                        fontsize: 42,\n                        backgroundcolor:'rgba(0,0,0,0)'\n                    }\n                },\n                shading: 'lambert',\n                //鼠标经过\n                emphasis: {\n                    label: {\n                        textstyle: {\n                            fontsize: 50,\n                        }\n                    },\n                },\n\n            }]\n        }\n        window.onresize = function(){\n            mychart.resize();\n        }\n        // 使用刚指定的配置项和数据显示图表。\n        mychart.setoption(option); \n        //后台获取数据\n        function main(){\n            $.ajax({\n                url: '',\n                type: 'post',\n                data:json.stringify({}),\n                datatype:'json',\n                contenttype: 'application/json',\n                async:true,\n                success:function(data){\n                    var data1=[]\n                    var data2=[]\n                    for(var i=0;i<data.list.length;i++){\n                        data1[i]=[0,i,data.list[i].headcount]\n                        data2[i]=data.list[i].name\n                    }\n                    mychart.setoption({\n                        xaxis3d: {\n                            data: data2\n                        },\n                        series: [{\n                            // 根据名字对应到相应的系列\n                            name: '投票数',\n                            data: data1.map(function(item) {\n                                return {\n                                    value: [item[1], item[0], item[2]],\n                                }\n                            }),\n                        }]\n                    });\n                }\n\n            });\n\n        }\n        main()\n\n    <\/script>\n\n</html>\n\n\n\n# 3d饼图\n\nhttps://blog.csdn.net/weixin_41326021/article/details/120195920\n\n\n\n\n# .vue文件 【bindlisten方法可以提取到mixins里面，以供组件多次调用】\n\n<template>\n    <div class=\"chart-container\">\n        <div class=\"chart\" ref=\"chart\"></div>\n        \x3c!-- 底座背景 --\x3e\n        <div class=\"bg\"></div> \n    </div>\n</template>\n\n<script>\n    import { getpie3d, getparametricequation } from 'chart.js' //工具类js，页面路径自己修改\n\n    const color = ['#005aff', '#f8b551']\n\n    export default {\n        name: 'chart',\n        data () {\n            return {\n                optiondata: [\n                    {\n                        name: '启用电梯',\n                        value: 176\n                    },\n                    {\n                        name: '停用电梯',\n                        value: 288\n                    }\n                ],\n                statuschart:null,\n                option:{}\n            }\n        },\n        created () {\n            this.setlabel()\n        },\n        mounted () {\n            this.initchart()\n\n            //根据窗口变化自动调节图表大小\n            const that = this\n            window.onresize = function () {\n                that.changesize()\n            }\n        },\n        methods: {\n            // 初始化label样式\n            setlabel () {\n                this.optiondata.foreach((item, index) => {\n                    item.itemstyle = {\n                        color: color[index]\n                    }\n                    item.label = {\n                        normal: {\n                            show: true,\n                            color: color[index],\n                            formatter: [\n                                '{b|{b}}',\n                                '{c|{c}}{b|台}',\n                                '{d|{d}%}'\n                            ].join('\\n'), // 用\\n来换行\n                            rich: {\n                                b: {\n                                    color: '#fff',\n                                    lineheight: 25,\n                                    align: 'left'\n                                },\n                                c: {\n                                    fontsize: 22,\n                                    color: '#fff',\n                                    textshadowcolor: '#1c90a6',\n                                    textshadowoffsetx: 0,\n                                    textshadowoffsety: 2,\n                                    textshadowblur: 5\n                                },\n                                d: {\n                                    color: color[index],\n                                    align: 'left'\n                                }\n                            }\n                        }\n                    }\n                    item.labelline = {\n                        normal: {\n                            linestyle: {\n                                width: 1,\n                                color: 'rgba(255,255,255,0.7)'\n                            }\n                        }\n                    }\n                })\n            },\n            // 图表初始化\n            initchart () {\n                this.statuschart = this.$echarts.init(this.$refs.chart)\n                // 传入数据生成 option, 构建3d饼状图, 参数工具文件已经备注的很详细\n                this.option = getpie3d(this.optiondata, 0.8, 240, 28, 26, 0.5)\n                this.statuschart.setoption(this.option)\n                // 是否需要label指引线，如果要就添加一个透明的2d饼状图并调整角度使得labelline和3d的饼状图对齐，并再次setoption\n                this.option.series.push({\n                    name: '电梯状态', //自己根据场景修改\n                    backgroundcolor: 'transparent',\n                    type: 'pie',\n                    label: {\n                        opacity: 1,\n                        fontsize: 13,\n                        lineheight: 20\n                    },\n                    startangle: -40, // 起始角度，支持范围[0, 360]。\n                    clockwise: false, // 饼图的扇区是否是顺时针排布。上述这两项配置主要是为了对齐3d的样式\n                    radius: ['20%', '50%'],\n                    center: ['50%', '50%'],\n                    data: this.optiondata,\n                    itemstyle: {\n                        opacity: 0  //这里必须是0，不然2d的图会覆盖在表面\n                    }\n                })\n                this.statuschart.setoption(this.option)\n                this.bindlisten(this.statuschart)\n            },\n            // 监听鼠标事件，实现饼图选中效果（单选），近似实现高亮（放大）效果。\n            // optionname是防止有多个图表进行定向option传递，单个图表可以不传，默认是opiton\n            bindlisten (mychart, optionname = 'option') {\n                let selectedindex = ''\n                let hoveredindex = ''\n                // 监听点击事件，实现选中效果（单选）\n                mychart.on('click', (params) => {\n                    // 从 option.series 中读取重新渲染扇形所需的参数，将是否选中取反。\n                    const isselected = !this[optionname].series[params.seriesindex].piestatus\n                    .selected\n                    const ishovered =\n                          this[optionname].series[params.seriesindex].piestatus.hovered\n                    const k = this[optionname].series[params.seriesindex].piestatus.k\n                    const startratio =\n                          this[optionname].series[params.seriesindex].piedata.startratio\n                    const endratio =\n                          this[optionname].series[params.seriesindex].piedata.endratio\n                    // 如果之前选中过其他扇形，将其取消选中（对 option 更新）\n                    if (selectedindex !== '' && selectedindex !== params.seriesindex) {\n                        this[optionname].series[\n                            selectedindex\n                        ].parametricequation = getparametricequation(\n                            this[optionname].series[selectedindex].piedata.startratio,\n                            this[optionname].series[selectedindex].piedata.endratio,\n                            false,\n                            false,\n                            k,\n                            this[optionname].series[selectedindex].piedata.value\n                        )\n                        this[optionname].series[selectedindex].piestatus.selected = false\n                    }\n                    // 对当前点击的扇形，执行选中/取消选中操作（对 option 更新）\n                    this[optionname].series[\n                        params.seriesindex\n                    ].parametricequation = getparametricequation(\n                        startratio,\n                        endratio,\n                        isselected,\n                        ishovered,\n                        k,\n                        this[optionname].series[params.seriesindex].piedata.value\n                    )\n                    this[optionname].series[params.seriesindex].piestatus.selected = isselected\n                    // 如果本次是选中操作，记录上次选中的扇形对应的系列号 seriesindex\n                    selectedindex = isselected ? params.seriesindex : null\n                    // 使用更新后的 option，渲染图表\n                    mychart.setoption(this[optionname])\n                })\n                // 监听 mouseover，近似实现高亮（放大）效果\n                mychart.on('mouseover', (params) => {\n                    // 准备重新渲染扇形所需的参数\n                    let isselected\n                    let ishovered\n                    let startratio\n                    let endratio\n                    let k\n                    // 如果触发 mouseover 的扇形当前已高亮，则不做操作\n                    if (hoveredindex === params.seriesindex) {\n                        // 否则进行高亮及必要的取消高亮操作\n                    } else {\n                        // 如果当前有高亮的扇形，取消其高亮状态（对 option 更新）\n                        if (hoveredindex !== '') {\n                            // 从 option.series 中读取重新渲染扇形所需的参数，将是否高亮设置为 false。\n                            isselected = this[optionname].series[hoveredindex].piestatus.selected\n                            ishovered = false\n                            startratio = this[optionname].series[hoveredindex].piedata.startratio\n                            endratio = this[optionname].series[hoveredindex].piedata.endratio\n                            k = this[optionname].series[hoveredindex].piestatus.k\n                            // 对当前点击的扇形，执行取消高亮操作（对 option 更新）\n                            this[optionname].series[\n                                hoveredindex\n                            ].parametricequation = getparametricequation(\n                                startratio,\n                                endratio,\n                                isselected,\n                                ishovered,\n                                k,\n                                this[optionname].series[hoveredindex].piedata.value\n                            )\n                            this[optionname].series[hoveredindex].piestatus.hovered = ishovered\n                            // 将此前记录的上次选中的扇形对应的系列号 seriesindex 清空\n                            hoveredindex = ''\n                        }\n                        // 如果触发 mouseover 的扇形不是透明圆环，将其高亮（对 option 更新）\n                        if (\n                            params.seriesname !== 'mouseoutseries' &&\n                            params.seriesname !== 'pie2d'\n                        ) {\n                            // 从 option.series 中读取重新渲染扇形所需的参数，将是否高亮设置为 true。\n                            isselected =\n                                this[optionname].series[params.seriesindex].piestatus.selected\n                            ishovered = true\n                            startratio =\n                                this[optionname].series[params.seriesindex].piedata.startratio\n                            endratio = this[optionname].series[params.seriesindex].piedata.endratio\n                            k = this[optionname].series[params.seriesindex].piestatus.k\n                            // 对当前点击的扇形，执行高亮操作（对 option 更新）\n                            this[optionname].series[\n                                params.seriesindex\n                            ].parametricequation = getparametricequation(\n                                startratio,\n                                endratio,\n                                isselected,\n                                ishovered,\n                                k,\n                                this[optionname].series[params.seriesindex].piedata.value + 60\n                            )\n                            this[optionname].series[\n                                params.seriesindex\n                            ].piestatus.hovered = ishovered\n                            // 记录上次高亮的扇形对应的系列号 seriesindex\n                            hoveredindex = params.seriesindex\n                        }\n                        // 使用更新后的 option，渲染图表\n                        mychart.setoption(this[optionname])\n                    }\n                })\n                // 修正取消高亮失败的 bug\n                mychart.on('globalout', () => {\n                    // 准备重新渲染扇形所需的参数\n                    let isselected\n                    let ishovered\n                    let startratio\n                    let endratio\n                    let k\n                    if (hoveredindex !== '') {\n                        // 从 option.series 中读取重新渲染扇形所需的参数，将是否高亮设置为 true。\n                        isselected = this[optionname].series[hoveredindex].piestatus.selected\n                        ishovered = false\n                        k = this[optionname].series[hoveredindex].piestatus.k\n                        startratio = this[optionname].series[hoveredindex].piedata.startratio\n                        endratio = this[optionname].series[hoveredindex].piedata.endratio\n                        // 对当前点击的扇形，执行取消高亮操作（对 option 更新）\n                        this[optionname].series[\n                            hoveredindex\n                        ].parametricequation = getparametricequation(\n                            startratio,\n                            endratio,\n                            isselected,\n                            ishovered,\n                            k,\n                            this[optionname].series[hoveredindex].piedata.value\n                        )\n                        this[optionname].series[hoveredindex].piestatus.hovered = ishovered\n                        // 将此前记录的上次选中的扇形对应的系列号 seriesindex 清空\n                        hoveredindex = ''\n                    }\n                    // 使用更新后的 option，渲染图表\n                    mychart.setoption(this[optionname])\n                })\n            },\n            // 自适应宽高\n            changesize () {\n                this.statuschart.resize()\n            }\n        }\n    }\n<\/script>\n\n<style lang='less' scoped>\n    .chart-container {\n        position: relative;\n        width: 100%;\n        height: 100%;\n\n        .chart,\n        .bg {\n            width: 100%;\n            height: 100%;\n        }\n\n        .bg {\n            position: absolute;\n            bottom: 50px;\n            left: 50%;\n            z-index: -1;\n            width: 180px;\n            height: 73px;\n            background: no-repeat center;\n            background-image: url('https://ks3-cn-beijing.ksyun.com/sxjg-elevator/datav-platform-2.0/images/chart_opacity_bg.png');\n            background-size: 100% 100%;\n            transform: translatex(-50%);\n        }\n    }\n</style>\n\n\n\n# chart.js\n\n/**\n * 绘制3d图\n * @param piedata 总数据\n * @param internaldiameterratio:透明的空心占比\n * @param distance 视角到主体的距离\n * @param alpha 旋转角度\n * @param pieheight 立体的高度\n * @param opacity 饼或者环的透明度\n */\nconst getpie3d = (piedata, internaldiameterratio, distance, alpha, pieheight, opacity = 1) => {\n    const series = []\n    let sumvalue = 0\n    let startvalue = 0\n    let endvalue = 0\n    let legenddata = []\n    let legendbfb = []\n    const k = 1 - internaldiameterratio\n    piedata.sort((a, b) => {\n        return b.value - a.value\n    })\n    // 为每一个饼图数据，生成一个 series-surface 配置\n    for (let i = 0; i < piedata.length; i++) {\n        sumvalue += piedata[i].value\n        const seriesitem = {\n            name:\n            typeof piedata[i].name === 'undefined'\n            ? `series${i}`\n            : piedata[i].name,\n            type: 'surface',\n            parametric: true,\n            wireframe: {\n                show: false\n            },\n            piedata: piedata[i],\n            piestatus: {\n                selected: false,\n                hovered: false,\n                k: k\n            },\n            center: ['10%', '50%']\n        }\n        if (typeof piedata[i].itemstyle !== 'undefined') {\n            const itemstyle = {}\n            itemstyle.color =\n                typeof piedata[i].itemstyle.color !== 'undefined'\n                ? piedata[i].itemstyle.color\n            : opacity\n            itemstyle.opacity =\n                typeof piedata[i].itemstyle.opacity !== 'undefined'\n                ? piedata[i].itemstyle.opacity\n            : opacity\n            seriesitem.itemstyle = itemstyle\n        }\n        series.push(seriesitem)\n    }\n\n    // 使用上一次遍历时，计算出的数据和 sumvalue，调用 getparametricequation 函数，\n    // 向每个 series-surface 传入不同的参数方程 series-surface.parametricequation，也就是实现每一个扇形。\n    legenddata = []\n    legendbfb = []\n    for (let i = 0; i < series.length; i++) {\n        endvalue = startvalue + series[i].piedata.value\n        series[i].piedata.startratio = startvalue / sumvalue\n        series[i].piedata.endratio = endvalue / sumvalue\n        series[i].parametricequation = getparametricequation(\n            series[i].piedata.startratio,\n            series[i].piedata.endratio,\n            false,\n            false,\n            k,\n            series[i].piedata.value\n        )\n        startvalue = endvalue\n        const bfb = fomatfloat(series[i].piedata.value / sumvalue, 4)\n        legenddata.push({\n            name: series[i].name,\n            value: bfb\n        })\n        legendbfb.push({\n            name: series[i].name,\n            value: bfb\n        })\n    }\n    const boxheight = getheight3d(series, pieheight) // 通过pieheight设定3d饼/环的高度，单位是px\n    // 准备待返回的配置项，把准备好的 legenddata、series 传入。\n    const option = {\n        legend: {\n            show: false,\n            data: legenddata,\n            orient: 'vertical',\n            left: 10,\n            top: 10,\n            itemgap: 10,\n            textstyle: {\n                color: '#a1e2ff'\n            },\n            icon: 'circle',\n            formatter: function (param) {\n                const item = legendbfb.filter(item => item.name === param)[0]\n                const bfs = fomatfloat(item.value * 100, 2) + '%'\n                return `${item.name}  ${bfs}`\n            }\n        },\n        labelline: {\n            show: true,\n            linestyle: {\n                color: '#fff'\n            }\n        },\n        label: {\n            show: true,\n            position: 'outside',\n            formatter: '{b} \\n{c} {d}%'\n        },\n        tooltip: {\n            backgroundcolor: '#033b77',\n            bordercolor: '#21f2c4',\n            textstyle: {\n                color: '#fff',\n                fontsize: 13\n            },\n            formatter: params => {\n                if (\n                    params.seriesname !== 'mouseoutseries' &&\n                    params.seriesname !== 'pie2d'\n                ) {\n                    const bfb = (\n                        (option.series[params.seriesindex].piedata.endratio -\n                         option.series[params.seriesindex].piedata.startratio) *\n                        100\n                    ).tofixed(2)\n                    return (\n                        `${params.seriesname}<br/>` +\n                        `<span style=\"display:inline-block;margin-right:5px;border-radius:10px;width:10px;height:10px;background-color:${params.color};\"></span>` +\n                        `${bfb}%`\n                    )\n                }\n            }\n        },\n        xaxis3d: {\n            min: -1,\n            max: 1\n        },\n        yaxis3d: {\n            min: -1,\n            max: 1\n        },\n        zaxis3d: {\n            min: -1,\n            max: 1\n        },\n        grid3d: {\n            show: false,\n            boxheight: boxheight, // 圆环的高度\n            viewcontrol: {\n                // 3d效果可以放大、旋转等，请自己去查看官方配置\n                alpha, // 角度\n                distance, // 调整视角到主体的距离，类似调整zoom\n                rotatesensitivity: 0, // 设置为0无法旋转\n                zoomsensitivity: 0, // 设置为0无法缩放\n                pansensitivity: 0, // 设置为0无法平移\n                autorotate: false // 自动旋转\n            }\n        },\n        series: series\n    }\n    return option\n}\n\n/**\n * 生成扇形的曲面参数方程，用于 series-surface.parametricequation\n */\nconst getparametricequation = (startratio, endratio, isselected, ishovered, k, h) => {\n    // 计算\n    const midratio = (startratio + endratio) / 2\n    const startradian = startratio * math.pi * 2\n    const endradian = endratio * math.pi * 2\n    const midradian = midratio * math.pi * 2\n    // 如果只有一个扇形，则不实现选中效果。\n    if (startratio === 0 && endratio === 1) {\n        isselected = false\n    }\n    // 通过扇形内径/外径的值，换算出辅助参数 k（默认值 1/3）\n    k = typeof k !== 'undefined' ? k : 1 / 3\n    // 计算选中效果分别在 x 轴、y 轴方向上的位移（未选中，则位移均为 0）\n    const offsetx = isselected ? math.cos(midradian) * 0.1 : 0\n    const offsety = isselected ? math.sin(midradian) * 0.1 : 0\n    // 计算高亮效果的放大比例（未高亮，则比例为 1）\n    const hoverrate = ishovered ? 1.05 : 1\n    // 返回曲面参数方程\n    return {\n        u: {\n            min: -math.pi,\n            max: math.pi * 3,\n            step: math.pi / 32\n        },\n        v: {\n            min: 0,\n            max: math.pi * 2,\n            step: math.pi / 20\n        },\n        x: function (u, v) {\n            if (u < startradian) {\n                return (\n                    offsetx +\n                    math.cos(startradian) * (1 + math.cos(v) * k) * hoverrate\n                )\n            }\n            if (u > endradian) {\n                return (\n                    offsetx + math.cos(endradian) * (1 + math.cos(v) * k) * hoverrate\n                )\n            }\n            return offsetx + math.cos(u) * (1 + math.cos(v) * k) * hoverrate\n        },\n        y: function (u, v) {\n            if (u < startradian) {\n                return (\n                    offsety +\n                    math.sin(startradian) * (1 + math.cos(v) * k) * hoverrate\n                )\n            }\n            if (u > endradian) {\n                return (\n                    offsety + math.sin(endradian) * (1 + math.cos(v) * k) * hoverrate\n                )\n            }\n            return offsety + math.sin(u) * (1 + math.cos(v) * k) * hoverrate\n        },\n        z: function (u, v) {\n            if (u < -math.pi * 0.5) {\n                return math.sin(u)\n            }\n            if (u > math.pi * 2.5) {\n                return math.sin(u) * h * 0.1\n            }\n            return math.sin(v) > 0 ? 1 * h * 0.1 : -1\n        }\n    }\n}\n\n/**\n * 获取3d丙图的最高扇区的高度\n */\nconst getheight3d = (series, height) => {\n    series.sort((a, b) => {\n        return b.piedata.value - a.piedata.value\n    })\n    return (height * 25) / series[0].piedata.value\n}\n\n/**\n * 格式化浮点数\n */\nconst fomatfloat = (num, n) => {\n    let f = parsefloat(num)\n    if (isnan(f)) {\n        return false\n    }\n    f = math.round(num * math.pow(10, n)) / math.pow(10, n) // n 幂\n    let s = f.tostring()\n    let rs = s.indexof('.')\n    // 判定如果是整数，增加小数点再补0\n    if (rs < 0) {\n        rs = s.length\n        s += '.'\n    }\n    while (s.length <= rs + n) {\n        s += '0'\n    }\n    return s\n}\n\nexport { getpie3d, getparametricequation }\n",charsets:{cjk:!0}},{title:"vuepress搭建框架创建个人博客",frontmatter:{},regularPath:"/guide/",relativePath:"guide/README.md",key:"v-174c6aeb",path:"/guide/",headersStr:null,content:"# vuepress搭建框架创建个人博客\n\nvuepress官网https://vuepress.vuejs.org/zh/ (opens new window)",normalizedContent:"# vuepress搭建框架创建个人博客\n\nvuepress官网https://vuepress.vuejs.org/zh/ (opens new window)",charsets:{cjk:!0}},{title:"Home",frontmatter:{home:!0,heroImage:"/image/headimg.jpg",heroText:"Lchushan",tagline:"Liang's blog",actionText:"优化问题 →",actionLink:"/优化问题/",features:[{title:"前端知识",details:"记录html/css/js等的基础知识，总结vue/react/优化问题。"},{title:"VuePress",details:"使用VuePress进行搭建个人博客的流程。"},{title:"算法题库",details:"基本的算法。"}],footer:"MIT Licensed | Copyright © 2021-present Evan You"},regularPath:"/",relativePath:"README.md",key:"v-715e05f6",path:"/",headersStr:null,content:"pad-文件下载名称的前端查找结果-----前端没有办法处理（测试机上前端代码查找流程）\n\n\\1. window.navigator && window.navigator.msSaveBlob事件没有，所以不能使用window.navigator.msSaveBlob事件进行下载\n\n\\2. Content-Type前端写死：blob，测试机下载文件失败（Content-Type只能为arraybuffer）\n\n\\3. Content-Type：arraybuffer下载的返回，调用的以下的转码，导致的下载文件成功，但是文件名unknown\n\nvar uInt8Array = new Uint8Array(response);\nvar i = uInt8Array.length;\nvar binaryString = new Array(i);\nwhile (i--) {\n    binaryString[i] = String.fromCharCode(uInt8Array[i]);\n}\nvar data = binaryString.join('');\nvar base64 = window.btoa(data);\nvar dataUrl = 'data:application/octet-stream;charset=utf-16le;base64,' + base64;\nvar element = document.createElement('a');\nelement.href = dataUrl;\nelement.download = decodeURI(fileName);\nelement.style.display = 'none';\ndocument.body.appendChild(element);\nelement.click();\ndocument.body.removeChild(element);\nURL.revokeObjectURL(dataUrl)\n\n\n3.1 更改 dataUrl = 'data:application/pdf;charset=utf-16le;base64,' + base64; ---- 无法下载文件\n\n3.2 更改 dataUrl = 'data:application/octet-stream;charset=utf-8;base64,' + base64; ---- 无法下载文件\n\n\\4. 写死a标签的download 属性，测试机的结果还是unknown 如：element.download = \"xxx.pdf\";",normalizedContent:"pad-文件下载名称的前端查找结果-----前端没有办法处理（测试机上前端代码查找流程）\n\n\\1. window.navigator && window.navigator.mssaveblob事件没有，所以不能使用window.navigator.mssaveblob事件进行下载\n\n\\2. content-type前端写死：blob，测试机下载文件失败（content-type只能为arraybuffer）\n\n\\3. content-type：arraybuffer下载的返回，调用的以下的转码，导致的下载文件成功，但是文件名unknown\n\nvar uint8array = new uint8array(response);\nvar i = uint8array.length;\nvar binarystring = new array(i);\nwhile (i--) {\n    binarystring[i] = string.fromcharcode(uint8array[i]);\n}\nvar data = binarystring.join('');\nvar base64 = window.btoa(data);\nvar dataurl = 'data:application/octet-stream;charset=utf-16le;base64,' + base64;\nvar element = document.createelement('a');\nelement.href = dataurl;\nelement.download = decodeuri(filename);\nelement.style.display = 'none';\ndocument.body.appendchild(element);\nelement.click();\ndocument.body.removechild(element);\nurl.revokeobjecturl(dataurl)\n\n\n3.1 更改 dataurl = 'data:application/pdf;charset=utf-16le;base64,' + base64; ---- 无法下载文件\n\n3.2 更改 dataurl = 'data:application/octet-stream;charset=utf-8;base64,' + base64; ---- 无法下载文件\n\n\\4. 写死a标签的download 属性，测试机的结果还是unknown 如：element.download = \"xxx.pdf\";",charsets:{cjk:!0}},{title:"1.学习方法",frontmatter:{},regularPath:"/JK-%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/",relativePath:"JK-前端进阶训练营/README.md",key:"v-42b46279",path:"/JK-%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/",headers:[{level:2,title:"1.学习方法",slug:"_1-学习方法",normalizedTitle:"1.学习方法",charIndex:2},{level:2,title:"2.构建知识体系",slug:"_2-构建知识体系",normalizedTitle:"2.构建知识体系",charIndex:23},{level:2,title:"3.工程体系",slug:"_3-工程体系",normalizedTitle:"3.工程体系",charIndex:58},{level:2,title:"4.编程语言通识与JavaScript语言",slug:"_4-编程语言通识与javascript语言",normalizedTitle:"4.编程语言通识与javascript语言",charIndex:897},{level:2,title:"5.JavaScript词法，类型",slug:"_5-javascript词法-类型",normalizedTitle:"5.javascript词法，类型",charIndex:2106},{level:2,title:"6.JavaScript表达式，类型转换",slug:"_6-javascript表达式-类型转换",normalizedTitle:"6.javascript表达式，类型转换",charIndex:2128},{level:2,title:"7.JavaScript 语法对象",slug:"_7-javascript-语法对象",normalizedTitle:"7.javascript 语法对象",charIndex:2153},{level:2,title:"8.JavaScript结构化",slug:"_8-javascript结构化",normalizedTitle:"8.javascript结构化",charIndex:2175},{level:2,title:"9.JavaScript结构化（二）",slug:"_9-javascript结构化-二",normalizedTitle:"9.javascript结构化（二）",charIndex:2195},{level:2,title:"10.浏览器工作原理 HTTP+语法与词法分析",slug:"_10-浏览器工作原理-http-语法与词法分析",normalizedTitle:"10.浏览器工作原理 http+语法与词法分析",charIndex:2218},{level:2,title:"11.浏览器工作原理 HTTP+语法与词法分析（二）",slug:"_11-浏览器工作原理-http-语法与词法分析-二",normalizedTitle:"11.浏览器工作原理 http+语法与词法分析（二）",charIndex:2246}],headersStr:"1.学习方法 2.构建知识体系 3.工程体系 4.编程语言通识与JavaScript语言 5.JavaScript词法，类型 6.JavaScript表达式，类型转换 7.JavaScript 语法对象 8.JavaScript结构化 9.JavaScript结构化（二） 10.浏览器工作原理 HTTP+语法与词法分析 11.浏览器工作原理 HTTP+语法与词法分析（二）",content:"# 1.学习方法\n\n整理法\n\n追溯法\n\n\n# 2.构建知识体系\n\n文档\n\nW3C\n\nECMA -5.1版本\n\n\n# 3.工程体系\n\n职业规划\n\n自己决定\n\n业务型成就\n\n 1. 业务目标\n    1. 理解公司业务的核心目标\n    2. 目标转化为指标\n 2. 技术方案\n    1. 业务指标到技术指标的转化\n    2. 形成纸面方案、完成小规模试验\n 3. 实施方案\n    1. 确定实施目标、参与人\n    2. 管理实施进度\n 4. 结果评估\n    1. 数据采集、数据报表\n    2. 向上级汇报\n\n技术难题\n\n 1. 目标\n    1. 公认的技术难点\n 2. 方案与实施\n    1. 依靠扎实的编程能力、架构能力形成解决方案\n 3. 结果\n    1. 问题解决\n\n工程型成就\n\n 1. 目标\n    1. 质量、效率\n 2. 方案与实施\n    1. 规章制度\n    2. 库\n    3. 工具\n    4. 系统\n 3. 结果\n    1. 线上监控\n\n工具链\n\n 1. 工具链的作用\n 2. 工具的分类\n    1. 脚手架\n    2. 本地调试\n    3. 单元测试\n    4. 发布\n 3. 工具链体系的设计\n    1. 版本问题\n    2. 数据统计\n\ninit=>run=>test=>publish\n\n持续集成\n\n客户端软件持续集成\n\nDaily build\n\nBVT\n\n前端持续集成\n\nCheck-in build\n\nlint + Rule Check\n\n技术架构\n\n客户端架构：解决软件需求规模带来的复杂性\n\n服务端架构：解决大量用户访问带来的复杂性\n\n前端架构：？【解决大量页面需求带来的重复劳动问题】——【复用】\n\n数据驱动的思考方法\n\n 1. 目标\n    1. 分析业务目标定数据指标\n 2. 现状\n    1. 采集数据建立数据展示系统\n 3. 方案\n    1. 设计技术方案预估数据\n 4. 实施\n    1. 小规模实验推广全公司落地形成制度\n 5. 结果\n    1. 统计最终效果汇报\n 6. 目标。。。\n\n\n# 4.编程语言通识与JavaScript语言\n\n语言按语法分类\n\n * 非形式语言\n   * 中文，英文\n * 形式语言（乔姆斯基普系）\n   * 0型 无限制文法\n   * 1型 上下文相关文法\n   * 2型 上下文无关文法\n   * 3型 正则文法\n\n产生式（BNF）\n\n * 用尖括号括起来的名称来表示语法结构名\n * 语法结构分成基础结构和需要用其他语法结构定义的复合结构\n   * 基础结构称终结符\n   * 复合结构称非终结符\n * 引号和中间的字符表示终结符\n * 可以有括号\n * *表示重复多次\n * |表示或\n * +表示至少一次\n\n产生式（BNF）\n\n四则运算：\n\n * 1+2*3\n\n终结符：\n\n * number\n * +-*/\n\n非终结符：\n\n * multiplicativeExpression\n * AddtiveExpression\n\n\n\n例子：【编写带括号的四则运算产生式】\n\n通过产生式理解乔姆斯基普系\n\n * 0型 无限制文法\n   * ?::=?\n * 1型 上下文相关文法\n   * ?<A>?::=?<B>?\n * 2型 上下文无关文法\n   * <A>::=?\n * 3型 正则文法\n   * <A>::=<A>?\n   * <A>::=?<A> x\n\n其他产生式\n\nEBNF ABNF Customised\n\n图灵完备性\n\n * 图灵完备性\n   * 命令式——图灵机\n     * goto\n     * if和while\n   * 声明式——lambda\n     * 递归\n\n动态与静态\n\n * 动态\n   * 在用户的设备/在线服务器上\n   * 产品实际运行时\n   * Runtime\n * 静态\n   * 在程序员的设备上\n   * 产品开发时\n   * Compiletime\n\n类型系统\n\n * 动态类型系统与静态类型系统\n * 强类型与弱类型\n   * String + Number\n   * String == Boolean\n * 复合类型\n   * 结构体\n   * 函数签名\n * 子类型\n   * 逆变/协变\n\n一般命令式编程语言\n\n * Atom\n   * Identifier\n   * Literal\n * Express\n   * Atom\n   * Operator\n   * Punctuator\n * Statement\n   * Expression\n   * Keyword\n   * Punctuator\n * Structure\n   * Function\n   * Class\n   * Process\n   * Namespace\n   * 。。。\n * Program\n   * Program\n   * Module\n   * Package\n   * Library\n\n语法=》语义=》运行时\n\n\n# 5.JavaScript词法，类型\n\n\n# 6.JavaScript表达式，类型转换\n\n\n# 7.JavaScript 语法对象\n\n\n# 8.JavaScript结构化\n\n\n# 9.JavaScript结构化（二）\n\n\n# 10.浏览器工作原理 HTTP+语法与词法分析\n\n\n# 11.浏览器工作原理 HTTP+语法与词法分析（二）",normalizedContent:"# 1.学习方法\n\n整理法\n\n追溯法\n\n\n# 2.构建知识体系\n\n文档\n\nw3c\n\necma -5.1版本\n\n\n# 3.工程体系\n\n职业规划\n\n自己决定\n\n业务型成就\n\n 1. 业务目标\n    1. 理解公司业务的核心目标\n    2. 目标转化为指标\n 2. 技术方案\n    1. 业务指标到技术指标的转化\n    2. 形成纸面方案、完成小规模试验\n 3. 实施方案\n    1. 确定实施目标、参与人\n    2. 管理实施进度\n 4. 结果评估\n    1. 数据采集、数据报表\n    2. 向上级汇报\n\n技术难题\n\n 1. 目标\n    1. 公认的技术难点\n 2. 方案与实施\n    1. 依靠扎实的编程能力、架构能力形成解决方案\n 3. 结果\n    1. 问题解决\n\n工程型成就\n\n 1. 目标\n    1. 质量、效率\n 2. 方案与实施\n    1. 规章制度\n    2. 库\n    3. 工具\n    4. 系统\n 3. 结果\n    1. 线上监控\n\n工具链\n\n 1. 工具链的作用\n 2. 工具的分类\n    1. 脚手架\n    2. 本地调试\n    3. 单元测试\n    4. 发布\n 3. 工具链体系的设计\n    1. 版本问题\n    2. 数据统计\n\ninit=>run=>test=>publish\n\n持续集成\n\n客户端软件持续集成\n\ndaily build\n\nbvt\n\n前端持续集成\n\ncheck-in build\n\nlint + rule check\n\n技术架构\n\n客户端架构：解决软件需求规模带来的复杂性\n\n服务端架构：解决大量用户访问带来的复杂性\n\n前端架构：？【解决大量页面需求带来的重复劳动问题】——【复用】\n\n数据驱动的思考方法\n\n 1. 目标\n    1. 分析业务目标定数据指标\n 2. 现状\n    1. 采集数据建立数据展示系统\n 3. 方案\n    1. 设计技术方案预估数据\n 4. 实施\n    1. 小规模实验推广全公司落地形成制度\n 5. 结果\n    1. 统计最终效果汇报\n 6. 目标。。。\n\n\n# 4.编程语言通识与javascript语言\n\n语言按语法分类\n\n * 非形式语言\n   * 中文，英文\n * 形式语言（乔姆斯基普系）\n   * 0型 无限制文法\n   * 1型 上下文相关文法\n   * 2型 上下文无关文法\n   * 3型 正则文法\n\n产生式（bnf）\n\n * 用尖括号括起来的名称来表示语法结构名\n * 语法结构分成基础结构和需要用其他语法结构定义的复合结构\n   * 基础结构称终结符\n   * 复合结构称非终结符\n * 引号和中间的字符表示终结符\n * 可以有括号\n * *表示重复多次\n * |表示或\n * +表示至少一次\n\n产生式（bnf）\n\n四则运算：\n\n * 1+2*3\n\n终结符：\n\n * number\n * +-*/\n\n非终结符：\n\n * multiplicativeexpression\n * addtiveexpression\n\n\n\n例子：【编写带括号的四则运算产生式】\n\n通过产生式理解乔姆斯基普系\n\n * 0型 无限制文法\n   * ?::=?\n * 1型 上下文相关文法\n   * ?<a>?::=?<b>?\n * 2型 上下文无关文法\n   * <a>::=?\n * 3型 正则文法\n   * <a>::=<a>?\n   * <a>::=?<a> x\n\n其他产生式\n\nebnf abnf customised\n\n图灵完备性\n\n * 图灵完备性\n   * 命令式——图灵机\n     * goto\n     * if和while\n   * 声明式——lambda\n     * 递归\n\n动态与静态\n\n * 动态\n   * 在用户的设备/在线服务器上\n   * 产品实际运行时\n   * runtime\n * 静态\n   * 在程序员的设备上\n   * 产品开发时\n   * compiletime\n\n类型系统\n\n * 动态类型系统与静态类型系统\n * 强类型与弱类型\n   * string + number\n   * string == boolean\n * 复合类型\n   * 结构体\n   * 函数签名\n * 子类型\n   * 逆变/协变\n\n一般命令式编程语言\n\n * atom\n   * identifier\n   * literal\n * express\n   * atom\n   * operator\n   * punctuator\n * statement\n   * expression\n   * keyword\n   * punctuator\n * structure\n   * function\n   * class\n   * process\n   * namespace\n   * 。。。\n * program\n   * program\n   * module\n   * package\n   * library\n\n语法=》语义=》运行时\n\n\n# 5.javascript词法，类型\n\n\n# 6.javascript表达式，类型转换\n\n\n# 7.javascript 语法对象\n\n\n# 8.javascript结构化\n\n\n# 9.javascript结构化（二）\n\n\n# 10.浏览器工作原理 http+语法与词法分析\n\n\n# 11.浏览器工作原理 http+语法与词法分析（二）",charsets:{cjk:!0}},{title:"部署",frontmatter:{},regularPath:"/guide/deploy.html",relativePath:"guide/deploy.md",key:"v-51c0b6ee",path:"/guide/deploy.html",headers:[{level:2,title:"GitHub Pages",slug:"github-pages",normalizedTitle:"github pages",charIndex:181},{level:2,title:"Gitee Pages",slug:"gitee-pages",normalizedTitle:"gitee pages",charIndex:1002}],headersStr:"GitHub Pages Gitee Pages",content:'# 部署\n\n下述的指南基于以下条件：\n\n * 文档放置在项目的 docs 目录中；\n * 使用的是默认的构建输出位置；\n * VuePress 以本地依赖的形式被安装到你的项目中，并且配置了如下的 npm scripts:\n\n{\n  "scripts": {\n    "docs:build": "vuepress build docs"\n  }\n}\n\n\n\n# GitHub Pages\n\n官网介绍 GitHub Pages(opens new window)\n\n 1. 在 docs/.vuepress/config.js 中设置正确的 base。\n    \n    如果你打算发布到 https://<USERNAME>.github.io/，则可以省略这一步，因为 base 默认即是 "/"。\n    \n    如果你打算发布到 https://<USERNAME>.github.io/<REPO>/（也就是说你的仓库在 https://github.com/<USERNAME>/<REPO>），则将 base 设置为 "/<REPO>/"。\n\n 2. 在你的项目中，创建一个如下的 deploy.sh 文件（请自行判断去掉高亮行的注释）:\n\n#!/usr/bin/env sh\n\n# 确保脚本抛出遇到的错误\nset -e\n\n# 生成静态文件\nnpm run docs:build\n\n# 进入生成的文件夹\ncd docs/.vuepress/dist\n\n# 如果是发布到自定义域名\n# echo \'www.example.com\' > CNAME\n\ngit init\ngit add -A\ngit commit -m \'deploy\'\n\n# 如果发布到 https://<USERNAME>.github.io\n# git push -f git@github.com:<USERNAME>/<USERNAME>.github.io.git master\n\n# 如果发布到 https://<USERNAME>.github.io/<REPO>\n# git push -f git@github.com:<USERNAME>/<REPO>.git master:gh-pages\n\ncd -\n\n\nTIP\n\n你可以在你的持续集成的设置中，设置在每次 push 代码时自动运行上述脚本。\n\n\n# Gitee Pages\n\n官网介绍 Gitee Pages(opens new window)',normalizedContent:'# 部署\n\n下述的指南基于以下条件：\n\n * 文档放置在项目的 docs 目录中；\n * 使用的是默认的构建输出位置；\n * vuepress 以本地依赖的形式被安装到你的项目中，并且配置了如下的 npm scripts:\n\n{\n  "scripts": {\n    "docs:build": "vuepress build docs"\n  }\n}\n\n\n\n# github pages\n\n官网介绍 github pages(opens new window)\n\n 1. 在 docs/.vuepress/config.js 中设置正确的 base。\n    \n    如果你打算发布到 https://<username>.github.io/，则可以省略这一步，因为 base 默认即是 "/"。\n    \n    如果你打算发布到 https://<username>.github.io/<repo>/（也就是说你的仓库在 https://github.com/<username>/<repo>），则将 base 设置为 "/<repo>/"。\n\n 2. 在你的项目中，创建一个如下的 deploy.sh 文件（请自行判断去掉高亮行的注释）:\n\n#!/usr/bin/env sh\n\n# 确保脚本抛出遇到的错误\nset -e\n\n# 生成静态文件\nnpm run docs:build\n\n# 进入生成的文件夹\ncd docs/.vuepress/dist\n\n# 如果是发布到自定义域名\n# echo \'www.example.com\' > cname\n\ngit init\ngit add -a\ngit commit -m \'deploy\'\n\n# 如果发布到 https://<username>.github.io\n# git push -f git@github.com:<username>/<username>.github.io.git master\n\n# 如果发布到 https://<username>.github.io/<repo>\n# git push -f git@github.com:<username>/<repo>.git master:gh-pages\n\ncd -\n\n\ntip\n\n你可以在你的持续集成的设置中，设置在每次 push 代码时自动运行上述脚本。\n\n\n# gitee pages\n\n官网介绍 gitee pages(opens new window)',charsets:{cjk:!0}},{title:"基本配置",frontmatter:{},regularPath:"/guide/basicConfiguration.html",relativePath:"guide/basicConfiguration.md",key:"v-3b2316a8",path:"/guide/basicConfiguration.html",headers:[{level:3,title:"配置文件",slug:"配置文件",normalizedTitle:"配置文件",charIndex:11}],headersStr:"配置文件",content:"# 基本配置\n\n\n# 配置文件\n\n如果没有任何配置，这个网站将会是非常局限的，用户也无法在你的网站上自由导航。为了更好地自定义你的网站，让我们首先在你的文档目录下创建一个 .vuepress 目录，所有 VuePress 相关的文件都将会被放在这里。你的项目结构可能是这样：\n\n.\n├─ docs\n│  ├─ README.md\n│  └─ .vuepress\n│     └─ config.js\n└─ package.json\n\n\n一个 VuePress 网站必要的配置文件是 .vuepress/config.js，它应该导出一个 JavaScript 对象：\n\nmodule.exports = {\n  title: 'Hello VuePress',\n  description: 'Just playing around'\n}\n\n\n对于上述的配置，如果你运行起 dev server，你应该能看到一个页面，它包含一个页头，里面包含一个标题和一个搜索框。VuePress 内置了基于 headers 的搜索 —— 它会自动为所有页面的标题、h2 和 h3 构建起一个简单的搜索索引。",normalizedContent:"# 基本配置\n\n\n# 配置文件\n\n如果没有任何配置，这个网站将会是非常局限的，用户也无法在你的网站上自由导航。为了更好地自定义你的网站，让我们首先在你的文档目录下创建一个 .vuepress 目录，所有 vuepress 相关的文件都将会被放在这里。你的项目结构可能是这样：\n\n.\n├─ docs\n│  ├─ readme.md\n│  └─ .vuepress\n│     └─ config.js\n└─ package.json\n\n\n一个 vuepress 网站必要的配置文件是 .vuepress/config.js，它应该导出一个 javascript 对象：\n\nmodule.exports = {\n  title: 'hello vuepress',\n  description: 'just playing around'\n}\n\n\n对于上述的配置，如果你运行起 dev server，你应该能看到一个页面，它包含一个页头，里面包含一个标题和一个搜索框。vuepress 内置了基于 headers 的搜索 —— 它会自动为所有页面的标题、h2 和 h3 构建起一个简单的搜索索引。",charsets:{cjk:!0}},{title:"Markdown 拓展",frontmatter:{},regularPath:"/guide/markdown.html",relativePath:"guide/markdown.md",key:"v-501863de",path:"/guide/markdown.html",headers:[{level:2,title:"Header Anchors",slug:"header-anchors",normalizedTitle:"header anchors",charIndex:18},{level:3,title:"链接",slug:"链接",normalizedTitle:"链接",charIndex:54},{level:3,title:"链接的重定向",slug:"链接的重定向",normalizedTitle:"链接的重定向",charIndex:633},{level:3,title:"外部链接",slug:"外部链接",normalizedTitle:"外部链接",charIndex:911},{level:2,title:"自定义容器",slug:"自定义容器",normalizedTitle:"自定义容器",charIndex:1051},{level:2,title:"代码块中的语法高亮",slug:"代码块中的语法高亮",normalizedTitle:"代码块中的语法高亮",charIndex:1428},{level:2,title:"代码块中的行高亮",slug:"代码块中的行高亮",normalizedTitle:"代码块中的行高亮",charIndex:1944},{level:2,title:"行号",slug:"行号",normalizedTitle:"行号",charIndex:2753},{level:2,title:"导入代码段 beta",slug:"导入代码段-beta",normalizedTitle:"导入代码段 beta",charIndex:2854},{level:2,title:"进阶配置",slug:"进阶配置",normalizedTitle:"进阶配置",charIndex:5497},{level:2,title:"Vuepress插件全文搜索",slug:"vuepress插件全文搜索",normalizedTitle:"vuepress插件全文搜索",charIndex:5937}],headersStr:"Header Anchors 链接 链接的重定向 外部链接 自定义容器 代码块中的语法高亮 代码块中的行高亮 行号 导入代码段 beta 进阶配置 Vuepress插件全文搜索",content:"# Markdown 拓展\n\n\n# Header Anchors\n\n所有的标题将会自动地应用 anchor 链接，anchor 的渲染可以通过 markdown.anchor 来配置。\n\n\n# 链接\n\n# 内部链接\n\n网站内部的链接，将会被转换成<router-link> 用于 SPA 导航。同时，站内的每一个文件夹下的 README.md 或者 index.md 文件都会被自动编译为 index.html，对应的链接将被视为 /。\n\n以如下的文件结构为例：\n\n.\n├─ README.md\n├─ foo\n│  ├─ README.md\n│  ├─ one.md\n│  └─ two.md\n└─ bar\n   ├─ README.md\n   ├─ three.md\n   └─ four.md\n\n\n假设你现在在 foo/one.md 中：\n\n[Home](/) \x3c!-- 跳转到根部的 README.md --\x3e\n[foo](/foo/) \x3c!-- 跳转到 foo 文件夹的 index.html --\x3e\n[foo heading](./#heading) \x3c!-- 跳转到 foo/index.html 的特定标题位置 --\x3e\n[bar - three](../bar/three.md) \x3c!-- 具体文件可以使用 .md 结尾（推荐） --\x3e\n[bar - four](../bar/four.html) \x3c!-- 也可以用 .html --\x3e\n\n\n\n# 链接的重定向\n\nVuePress 支持重定向到干净链接。如果一个链接 /foo 找不到，VuePress 会自行寻找一个可用的 /foo/ 或 /foo.html。反过来，当 /foo/ 或 /foo.html 中的一个找不到时，VuePress 也会尝试寻找另一个。\n\nTIP\n\n无论是否使用了 permalink 和 clean-urls 插件，你的相对路径都应该依赖于当前的文件结构来定义。在上面的例子中，即使你将 /foo/one.md 的路径设为了 /foo/one/，你依然应该通过 ./two.md 来访问 /foo/two.md。\n\n\n# 外部链接\n\n外部的链接将会被自动地设置为 target=\"_blank\" rel=\"noopener noreferrer\":\n\n * vuejs.org(opens new window)\n * VuePress on GitHub(opens new window)\n\n\n# 自定义容器\n\n输入\n\n::: tip\n这是一个提示\n:::\n\n::: warning\n这是一个警告\n:::\n\n::: danger\n这是一个危险警告\n:::\n\n::: details\n这是一个详情块，在 IE / Edge 中不生效\n:::\n\n\n输出\n\nTIP\n\n这是一个提示\n\nWARNING\n\n这是一个警告\n\nDANGER\n\n这是一个危险警告\n\nDETAILS\n\n这是一个详情块，在 IE / Edge 中不生效\n\n你也可以自定义块中的标题：\n\n::: danger STOP\n危险区域，禁止通行\n:::\n\n::: details 点击查看代码\n```js\nconsole.log('你好，VuePress！')\n```\n:::\n\n\nSTOP\n\n危险区域，禁止通行\n\n点击查看代码\n\nconsole.log('你好，VuePress！')\n\n\n\n# 代码块中的语法高亮\n\nVuePress 使用了 Prism (opens new window)来为 markdown 中的代码块实现语法高亮。Prism 支持大量的编程语言，你需要做的只是在代码块的开始倒勾中附加一个有效的语言别名：\n\n输入\n\n``` js\nexport default {\n  name: 'MyComponent',\n  // ...\n}\n```\n\n\n输出\n\nexport default {\n  name: 'MyComponent',\n  // ...\n}\n\n\n输入\n\n``` html\n&lt;ul>\n  &lt;li\n    v-for=\"todo in todos\"\n    :key=\"todo.id\"\n  >\n    {{ todo.text }}\n  &lt;/li>\n&lt;/ul>\n```\n\n\n输出\n\n<ul>\n  <li\n    v-for=\"todo in todos\"\n    :key=\"todo.id\"\n  >\n    {{ todo.text }}\n  </li>\n</ul>\n\n\n在 Prism 的网站上查看 合法的语言列表 (opens new window)。\n\n\n# 代码块中的行高亮\n\n输入\n\n``` js {4}\nexport default {\n  data () {\n    return {\n      msg: 'Highlighted!'\n    }\n  }\n}\n```\n\n\n输出\n\nexport default {\n  data () {\n    return {\n      msg: 'Highlighted!'\n    }\n  }\n}\n\n\n除了单行以外，你也可指定多行，行数区间，或是两者都指定。\n\n * 行数区间: 例如 {5-8}, {3-10}, {10-17}\n * 多个单行: 例如 {4,7,9}\n * 行数区间与多个单行: 例如 {4,7-13,16,23-27,40}\n\nInput\n\n``` js{1,4,6-7}\nexport default { // Highlighted\n  data () {\n    return {\n      msg: `Highlighted!\n      This line isn't highlighted,\n      but this and the next 2 are.`,\n      motd: 'VuePress is awesome',\n      lorem: 'ipsum',\n    }\n  }\n}\n```\n\n\nOutput\n\nexport default { // Highlighted\n  data () {\n    return {\n      msg: `Highlighted!\n      This line isn't highlighted,\n      but this and the next 2 are.`,\n      motd: 'VuePress is awesome',\n      lorem: 'ipsum',\n    }\n  }\n}\n\n\n\n# 行号\n\n你可以通过配置来为每个代码块显示行号：\n\nmodule.exports = {\n  markdown: {\n    lineNumbers: true\n  }\n}\n\n\n * 示例:\n\n\n\n\n# 导入代码段 beta\n\n你可以通过下述的语法导入已经存在的文件中的代码段：\n\n<<< @/filepath\n\n\n它也支持 行高亮：\n\n<<< @/filepath{highlightLines}\n\n\n输入\n\n&lt;&lt;&lt; @/../@vuepress/markdown/__tests__/fragments/snippet.js{2}\n\n\n输出\n\nexport default function () {\n  // ..\n}\n\n\nTIP\n\n由于代码段的导入将在 webpack 编译之前执行，因此你无法使用 webpack 中的路径别名，此处的 @ 默认值是 process.cwd()。\n\n为了只导入对应部分的代码，你也可运用 VS Code region (opens new window)。你可以在文件路径后方的 # 紧接着提供一个自定义的区域名称（预设为 snippet ）\n\n输入\n\n<<< @/../@vuepress/markdown/__tests__/fragments/snippet-with-region.js#snippet{1}\n\n\n代码文件\n\n// #region snippet\nfunction foo () {\n  return ({\n    dest: '../../vuepress',\n    locales: {\n      '/': {\n        lang: 'en-US',\n        title: 'VuePress',\n        description: 'Vue-powered Static Site Generator'\n      },\n      '/zh/': {\n        lang: 'zh-CN',\n        title: 'VuePress',\n        description: 'Vue 驱动的静态网站生成器'\n      }\n    },\n    head: [\n      ['link', { rel: 'icon', href: `/logo.png` }],\n      ['link', { rel: 'manifest', href: '/manifest.json' }],\n      ['meta', { name: 'theme-color', content: '#3eaf7c' }],\n      ['meta', { name: 'apple-mobile-web-app-capable', content: 'yes' }],\n      ['meta', { name: 'apple-mobile-web-app-status-bar-style', content: 'black' }],\n      ['link', { rel: 'apple-touch-icon', href: `/icons/apple-touch-icon-152x152.png` }],\n      ['link', { rel: 'mask-icon', href: '/icons/safari-pinned-tab.svg', color: '#3eaf7c' }],\n      ['meta', { name: 'msapplication-TileImage', content: '/icons/msapplication-icon-144x144.png' }],\n      ['meta', { name: 'msapplication-TileColor', content: '#000000' }]\n    ]\n  })\n}\n// #endregion snippet\n\nexport default foo\n\n\n输出\n\nfunction foo () {\n  return ({\n    dest: '../../vuepress',\n    locales: {\n      '/': {\n        lang: 'en-US',\n        title: 'VuePress',\n        description: 'Vue-powered Static Site Generator'\n      },\n      '/zh/': {\n        lang: 'zh-CN',\n        title: 'VuePress',\n        description: 'Vue 驱动的静态网站生成器'\n      }\n    },\n    head: [\n      ['link', { rel: 'icon', href: `/logo.png` }],\n      ['link', { rel: 'manifest', href: '/manifest.json' }],\n      ['meta', { name: 'theme-color', content: '#3eaf7c' }],\n      ['meta', { name: 'apple-mobile-web-app-capable', content: 'yes' }],\n      ['meta', { name: 'apple-mobile-web-app-status-bar-style', content: 'black' }],\n      ['link', { rel: 'apple-touch-icon', href: `/icons/apple-touch-icon-152x152.png` }],\n      ['link', { rel: 'mask-icon', href: '/icons/safari-pinned-tab.svg', color: '#3eaf7c' }],\n      ['meta', { name: 'msapplication-TileImage', content: '/icons/msapplication-icon-144x144.png' }],\n      ['meta', { name: 'msapplication-TileColor', content: '#000000' }]\n    ]\n  })\n}\n\n\n\n# 进阶配置\n\nVuePress 使用 markdown-it (opens new window)来渲染 Markdown，上述大多数的拓展也都是通过自定义的插件实现的。想要进一步的话，你可以通过 .vuepress/config.js 的 markdown 选项，来对当前的 markdown-it 实例做一些自定义的配置：\n\nmodule.exports = {\n  markdown: {\n    // markdown-it-anchor 的选项\n    anchor: { permalink: false },\n    // markdown-it-toc 的选项\n    toc: { includeLevel: [1, 2] },\n    extendMarkdown: md => {\n      // 使用更多的 markdown-it 插件!\n      md.use(require('markdown-it-xxx'))\n    }\n  }\n}\n\n\n\n# Vuepress插件全文搜索\n\nvuepress-plugin-fulltext-search:借助flexsearch库将全文搜索功能添加到您的vuepress网站-源码\n\n使用库向您的网站添加全文搜索功能。\n\n首先，安装插件。\n\nnpm i vuepress-plugin-fulltext-search -D \n// yarn add vuepress-plugin-fulltext-search -D \n\n\n然后，在您的docs/.vuepress/config.js启用插件：\n\n// docs/.vuepress/config.js\n\nmodule.exports = { \n    // ...  \n    plugins : [ 'fulltext-search' ] , \n} \n\n\n就是这样！\n\n只需编译您的应用程序，然后亲自查看即可。\n\nWebpack别名@SearchBox将替换为插件的实现，因此它应可自动与任何VuePress主题一起使用。\n\n搜索参数 可以提供query URL搜索参数以自动填充和集中搜索框",normalizedContent:"# markdown 拓展\n\n\n# header anchors\n\n所有的标题将会自动地应用 anchor 链接，anchor 的渲染可以通过 markdown.anchor 来配置。\n\n\n# 链接\n\n# 内部链接\n\n网站内部的链接，将会被转换成<router-link> 用于 spa 导航。同时，站内的每一个文件夹下的 readme.md 或者 index.md 文件都会被自动编译为 index.html，对应的链接将被视为 /。\n\n以如下的文件结构为例：\n\n.\n├─ readme.md\n├─ foo\n│  ├─ readme.md\n│  ├─ one.md\n│  └─ two.md\n└─ bar\n   ├─ readme.md\n   ├─ three.md\n   └─ four.md\n\n\n假设你现在在 foo/one.md 中：\n\n[home](/) \x3c!-- 跳转到根部的 readme.md --\x3e\n[foo](/foo/) \x3c!-- 跳转到 foo 文件夹的 index.html --\x3e\n[foo heading](./#heading) \x3c!-- 跳转到 foo/index.html 的特定标题位置 --\x3e\n[bar - three](../bar/three.md) \x3c!-- 具体文件可以使用 .md 结尾（推荐） --\x3e\n[bar - four](../bar/four.html) \x3c!-- 也可以用 .html --\x3e\n\n\n\n# 链接的重定向\n\nvuepress 支持重定向到干净链接。如果一个链接 /foo 找不到，vuepress 会自行寻找一个可用的 /foo/ 或 /foo.html。反过来，当 /foo/ 或 /foo.html 中的一个找不到时，vuepress 也会尝试寻找另一个。\n\ntip\n\n无论是否使用了 permalink 和 clean-urls 插件，你的相对路径都应该依赖于当前的文件结构来定义。在上面的例子中，即使你将 /foo/one.md 的路径设为了 /foo/one/，你依然应该通过 ./two.md 来访问 /foo/two.md。\n\n\n# 外部链接\n\n外部的链接将会被自动地设置为 target=\"_blank\" rel=\"noopener noreferrer\":\n\n * vuejs.org(opens new window)\n * vuepress on github(opens new window)\n\n\n# 自定义容器\n\n输入\n\n::: tip\n这是一个提示\n:::\n\n::: warning\n这是一个警告\n:::\n\n::: danger\n这是一个危险警告\n:::\n\n::: details\n这是一个详情块，在 ie / edge 中不生效\n:::\n\n\n输出\n\ntip\n\n这是一个提示\n\nwarning\n\n这是一个警告\n\ndanger\n\n这是一个危险警告\n\ndetails\n\n这是一个详情块，在 ie / edge 中不生效\n\n你也可以自定义块中的标题：\n\n::: danger stop\n危险区域，禁止通行\n:::\n\n::: details 点击查看代码\n```js\nconsole.log('你好，vuepress！')\n```\n:::\n\n\nstop\n\n危险区域，禁止通行\n\n点击查看代码\n\nconsole.log('你好，vuepress！')\n\n\n\n# 代码块中的语法高亮\n\nvuepress 使用了 prism (opens new window)来为 markdown 中的代码块实现语法高亮。prism 支持大量的编程语言，你需要做的只是在代码块的开始倒勾中附加一个有效的语言别名：\n\n输入\n\n``` js\nexport default {\n  name: 'mycomponent',\n  // ...\n}\n```\n\n\n输出\n\nexport default {\n  name: 'mycomponent',\n  // ...\n}\n\n\n输入\n\n``` html\n&lt;ul>\n  &lt;li\n    v-for=\"todo in todos\"\n    :key=\"todo.id\"\n  >\n    {{ todo.text }}\n  &lt;/li>\n&lt;/ul>\n```\n\n\n输出\n\n<ul>\n  <li\n    v-for=\"todo in todos\"\n    :key=\"todo.id\"\n  >\n    {{ todo.text }}\n  </li>\n</ul>\n\n\n在 prism 的网站上查看 合法的语言列表 (opens new window)。\n\n\n# 代码块中的行高亮\n\n输入\n\n``` js {4}\nexport default {\n  data () {\n    return {\n      msg: 'highlighted!'\n    }\n  }\n}\n```\n\n\n输出\n\nexport default {\n  data () {\n    return {\n      msg: 'highlighted!'\n    }\n  }\n}\n\n\n除了单行以外，你也可指定多行，行数区间，或是两者都指定。\n\n * 行数区间: 例如 {5-8}, {3-10}, {10-17}\n * 多个单行: 例如 {4,7,9}\n * 行数区间与多个单行: 例如 {4,7-13,16,23-27,40}\n\ninput\n\n``` js{1,4,6-7}\nexport default { // highlighted\n  data () {\n    return {\n      msg: `highlighted!\n      this line isn't highlighted,\n      but this and the next 2 are.`,\n      motd: 'vuepress is awesome',\n      lorem: 'ipsum',\n    }\n  }\n}\n```\n\n\noutput\n\nexport default { // highlighted\n  data () {\n    return {\n      msg: `highlighted!\n      this line isn't highlighted,\n      but this and the next 2 are.`,\n      motd: 'vuepress is awesome',\n      lorem: 'ipsum',\n    }\n  }\n}\n\n\n\n# 行号\n\n你可以通过配置来为每个代码块显示行号：\n\nmodule.exports = {\n  markdown: {\n    linenumbers: true\n  }\n}\n\n\n * 示例:\n\n\n\n\n# 导入代码段 beta\n\n你可以通过下述的语法导入已经存在的文件中的代码段：\n\n<<< @/filepath\n\n\n它也支持 行高亮：\n\n<<< @/filepath{highlightlines}\n\n\n输入\n\n&lt;&lt;&lt; @/../@vuepress/markdown/__tests__/fragments/snippet.js{2}\n\n\n输出\n\nexport default function () {\n  // ..\n}\n\n\ntip\n\n由于代码段的导入将在 webpack 编译之前执行，因此你无法使用 webpack 中的路径别名，此处的 @ 默认值是 process.cwd()。\n\n为了只导入对应部分的代码，你也可运用 vs code region (opens new window)。你可以在文件路径后方的 # 紧接着提供一个自定义的区域名称（预设为 snippet ）\n\n输入\n\n<<< @/../@vuepress/markdown/__tests__/fragments/snippet-with-region.js#snippet{1}\n\n\n代码文件\n\n// #region snippet\nfunction foo () {\n  return ({\n    dest: '../../vuepress',\n    locales: {\n      '/': {\n        lang: 'en-us',\n        title: 'vuepress',\n        description: 'vue-powered static site generator'\n      },\n      '/zh/': {\n        lang: 'zh-cn',\n        title: 'vuepress',\n        description: 'vue 驱动的静态网站生成器'\n      }\n    },\n    head: [\n      ['link', { rel: 'icon', href: `/logo.png` }],\n      ['link', { rel: 'manifest', href: '/manifest.json' }],\n      ['meta', { name: 'theme-color', content: '#3eaf7c' }],\n      ['meta', { name: 'apple-mobile-web-app-capable', content: 'yes' }],\n      ['meta', { name: 'apple-mobile-web-app-status-bar-style', content: 'black' }],\n      ['link', { rel: 'apple-touch-icon', href: `/icons/apple-touch-icon-152x152.png` }],\n      ['link', { rel: 'mask-icon', href: '/icons/safari-pinned-tab.svg', color: '#3eaf7c' }],\n      ['meta', { name: 'msapplication-tileimage', content: '/icons/msapplication-icon-144x144.png' }],\n      ['meta', { name: 'msapplication-tilecolor', content: '#000000' }]\n    ]\n  })\n}\n// #endregion snippet\n\nexport default foo\n\n\n输出\n\nfunction foo () {\n  return ({\n    dest: '../../vuepress',\n    locales: {\n      '/': {\n        lang: 'en-us',\n        title: 'vuepress',\n        description: 'vue-powered static site generator'\n      },\n      '/zh/': {\n        lang: 'zh-cn',\n        title: 'vuepress',\n        description: 'vue 驱动的静态网站生成器'\n      }\n    },\n    head: [\n      ['link', { rel: 'icon', href: `/logo.png` }],\n      ['link', { rel: 'manifest', href: '/manifest.json' }],\n      ['meta', { name: 'theme-color', content: '#3eaf7c' }],\n      ['meta', { name: 'apple-mobile-web-app-capable', content: 'yes' }],\n      ['meta', { name: 'apple-mobile-web-app-status-bar-style', content: 'black' }],\n      ['link', { rel: 'apple-touch-icon', href: `/icons/apple-touch-icon-152x152.png` }],\n      ['link', { rel: 'mask-icon', href: '/icons/safari-pinned-tab.svg', color: '#3eaf7c' }],\n      ['meta', { name: 'msapplication-tileimage', content: '/icons/msapplication-icon-144x144.png' }],\n      ['meta', { name: 'msapplication-tilecolor', content: '#000000' }]\n    ]\n  })\n}\n\n\n\n# 进阶配置\n\nvuepress 使用 markdown-it (opens new window)来渲染 markdown，上述大多数的拓展也都是通过自定义的插件实现的。想要进一步的话，你可以通过 .vuepress/config.js 的 markdown 选项，来对当前的 markdown-it 实例做一些自定义的配置：\n\nmodule.exports = {\n  markdown: {\n    // markdown-it-anchor 的选项\n    anchor: { permalink: false },\n    // markdown-it-toc 的选项\n    toc: { includelevel: [1, 2] },\n    extendmarkdown: md => {\n      // 使用更多的 markdown-it 插件!\n      md.use(require('markdown-it-xxx'))\n    }\n  }\n}\n\n\n\n# vuepress插件全文搜索\n\nvuepress-plugin-fulltext-search:借助flexsearch库将全文搜索功能添加到您的vuepress网站-源码\n\n使用库向您的网站添加全文搜索功能。\n\n首先，安装插件。\n\nnpm i vuepress-plugin-fulltext-search -d \n// yarn add vuepress-plugin-fulltext-search -d \n\n\n然后，在您的docs/.vuepress/config.js启用插件：\n\n// docs/.vuepress/config.js\n\nmodule.exports = { \n    // ...  \n    plugins : [ 'fulltext-search' ] , \n} \n\n\n就是这样！\n\n只需编译您的应用程序，然后亲自查看即可。\n\nwebpack别名@searchbox将替换为插件的实现，因此它应可自动与任何vuepress主题一起使用。\n\n搜索参数 可以提供query url搜索参数以自动填充和集中搜索框",charsets:{cjk:!0}},{title:"目录结构",frontmatter:{},regularPath:"/guide/directory.html",relativePath:"guide/directory.md",key:"v-6a6ffff6",path:"/guide/directory.html",headersStr:null,content:'# 目录结构\n\nVuePress 遵循 “约定优于配置” 的原则，推荐的目录结构如下：\n\n.\n├── docs\n│   ├── .vuepress (可选的)\n│   │   ├── components (可选的)\n│   │   ├── theme (可选的)\n│   │   │   └── Layout.vue\n│   │   ├── public (可选的)\n│   │   ├── styles (可选的)\n│   │   │   ├── index.styl\n│   │   │   └── palette.styl\n│   │   ├── templates (可选的, 谨慎配置)\n│   │   │   ├── dev.html\n│   │   │   └── ssr.html\n│   │   ├── config.js (可选的)\n│   │   └── enhanceApp.js (可选的)\n│   │ \n│   ├── README.md\n│   ├── guide\n│   │   └── README.md\n│   └── config.md\n│ \n└── package.json\n\n\nWARNING\n\n请留意目录名的大写。\n\ndocs/.vuepress: 用于存放全局的配置、组件、静态资源等。\ndocs/.vuepress/components: 该目录中的 Vue 组件将会被自动注册为全局组件。\ndocs/.vuepress/theme: 用于存放本地主题。\ndocs/.vuepress/styles: 用于存放样式相关的文件。\ndocs/.vuepress/styles/index.styl: 将会被自动应用的全局样式文件，会生成在最终的 CSS 文件结尾，具有比默认样式更高的优先级。\ndocs/.vuepress/styles/palette.styl: 用于重写默认颜色常量，或者设置新的 stylus 颜色常量。\ndocs/.vuepress/public: 静态资源目录。\ndocs/.vuepress/templates: 存储 HTML 模板文件。\ndocs/.vuepress/templates/dev.html: 用于开发环境的 HTML 模板文件。\ndocs/.vuepress/templates/ssr.html: 构建时基于 Vue SSR 的 HTML 模板文件。\ndocs/.vuepress/config.js: 配置文件的入口文件，也可以是 YML 或 toml。\ndocs/.vuepress/enhanceApp.js: 客户端应用的增强。\n\n\nWARNING\n\n当你想要去自定义 templates/ssr.html 或 templates/dev.html 时，最好基于 默认的模板文件 (opens new window)来修改，否则可能会导致构建出错。\n\n#默认的页面路由 此处我们把 docs 目录作为 targetDir （参考 命令行接口），下面所有的“文件的相对路径”都是相对于 docs 目录的。在项目根目录下的 package.json 中添加 scripts ：\n\n{\n  "scripts": {\n    "dev": "vuepress dev docs",\n    "build": "vuepress build docs"\n  }\n}\n',normalizedContent:'# 目录结构\n\nvuepress 遵循 “约定优于配置” 的原则，推荐的目录结构如下：\n\n.\n├── docs\n│   ├── .vuepress (可选的)\n│   │   ├── components (可选的)\n│   │   ├── theme (可选的)\n│   │   │   └── layout.vue\n│   │   ├── public (可选的)\n│   │   ├── styles (可选的)\n│   │   │   ├── index.styl\n│   │   │   └── palette.styl\n│   │   ├── templates (可选的, 谨慎配置)\n│   │   │   ├── dev.html\n│   │   │   └── ssr.html\n│   │   ├── config.js (可选的)\n│   │   └── enhanceapp.js (可选的)\n│   │ \n│   ├── readme.md\n│   ├── guide\n│   │   └── readme.md\n│   └── config.md\n│ \n└── package.json\n\n\nwarning\n\n请留意目录名的大写。\n\ndocs/.vuepress: 用于存放全局的配置、组件、静态资源等。\ndocs/.vuepress/components: 该目录中的 vue 组件将会被自动注册为全局组件。\ndocs/.vuepress/theme: 用于存放本地主题。\ndocs/.vuepress/styles: 用于存放样式相关的文件。\ndocs/.vuepress/styles/index.styl: 将会被自动应用的全局样式文件，会生成在最终的 css 文件结尾，具有比默认样式更高的优先级。\ndocs/.vuepress/styles/palette.styl: 用于重写默认颜色常量，或者设置新的 stylus 颜色常量。\ndocs/.vuepress/public: 静态资源目录。\ndocs/.vuepress/templates: 存储 html 模板文件。\ndocs/.vuepress/templates/dev.html: 用于开发环境的 html 模板文件。\ndocs/.vuepress/templates/ssr.html: 构建时基于 vue ssr 的 html 模板文件。\ndocs/.vuepress/config.js: 配置文件的入口文件，也可以是 yml 或 toml。\ndocs/.vuepress/enhanceapp.js: 客户端应用的增强。\n\n\nwarning\n\n当你想要去自定义 templates/ssr.html 或 templates/dev.html 时，最好基于 默认的模板文件 (opens new window)来修改，否则可能会导致构建出错。\n\n#默认的页面路由 此处我们把 docs 目录作为 targetdir （参考 命令行接口），下面所有的“文件的相对路径”都是相对于 docs 目录的。在项目根目录下的 package.json 中添加 scripts ：\n\n{\n  "scripts": {\n    "dev": "vuepress dev docs",\n    "build": "vuepress build docs"\n  }\n}\n',charsets:{cjk:!0}},{title:"介绍",frontmatter:{},regularPath:"/guide/introduce.html",relativePath:"guide/introduce.md",key:"v-cc0f2d94",path:"/guide/introduce.html",headersStr:null,content:"记录使用vuepress搭建个人博客知识",normalizedContent:"记录使用vuepress搭建个人博客知识",charsets:{cjk:!0}},{title:"快速上手",frontmatter:{},regularPath:"/guide/quickStart.html",relativePath:"guide/quickStart.md",key:"v-3c4bba52",path:"/guide/quickStart.html",headersStr:null,content:'# 快速上手\n\n前提条件\n\nWARNING\n\nVuePress 需要 Node.js (opens new window)>= 8.6\n\n本文会帮助你从头搭建一个简单的 VuePress 文档。如果你想在一个现有项目中使用 VuePress 管理文档，从步骤 3 开始。\n\n 1. 创建并进入一个新目录\n    \n    mkdir vuepress-starter && cd vuepress-starter\n    \n\n 2. 使用你喜欢的包管理器进行初始化\n    \n    yarn init # npm init\n    \n\n 3. 将 VuePress 安装为本地依赖\n    \n    我们已经不再推荐全局安装 VuePress\n    \n    yarn add -D vuepress # npm install -D vuepress\n    \n    \n    注意\n    \n    如果你的现有项目依赖了 webpack 3.x，我们推荐使用 Yarn (opens new window)而不是 npm 来安装 VuePress。因为在这种情形下，npm 会生成错误的依赖树。\n\n 4. 创建你的第一篇文档\n    \n    mkdir docs && echo \'# Hello VuePress\' > docs/README.md\n    \n\n 5. 在 package.json 中添加一些 scripts(opens new window)\n    \n    这一步骤是可选的，但我们推荐你完成它。在下文中，我们会默认这些 scripts 已经被添加。\n    \n    {\n      "scripts": {\n        "docs:dev": "vuepress dev docs",\n        "docs:build": "vuepress build docs"\n      }\n    }\n    \n\n 6. 在本地启动服务器\n    \n    yarn docs:dev # npm run docs:dev\n    \n    \n    VuePress 会在 http://localhost:8080 (opens new window)启动一个热重载的开发服务器。',normalizedContent:'# 快速上手\n\n前提条件\n\nwarning\n\nvuepress 需要 node.js (opens new window)>= 8.6\n\n本文会帮助你从头搭建一个简单的 vuepress 文档。如果你想在一个现有项目中使用 vuepress 管理文档，从步骤 3 开始。\n\n 1. 创建并进入一个新目录\n    \n    mkdir vuepress-starter && cd vuepress-starter\n    \n\n 2. 使用你喜欢的包管理器进行初始化\n    \n    yarn init # npm init\n    \n\n 3. 将 vuepress 安装为本地依赖\n    \n    我们已经不再推荐全局安装 vuepress\n    \n    yarn add -d vuepress # npm install -d vuepress\n    \n    \n    注意\n    \n    如果你的现有项目依赖了 webpack 3.x，我们推荐使用 yarn (opens new window)而不是 npm 来安装 vuepress。因为在这种情形下，npm 会生成错误的依赖树。\n\n 4. 创建你的第一篇文档\n    \n    mkdir docs && echo \'# hello vuepress\' > docs/readme.md\n    \n\n 5. 在 package.json 中添加一些 scripts(opens new window)\n    \n    这一步骤是可选的，但我们推荐你完成它。在下文中，我们会默认这些 scripts 已经被添加。\n    \n    {\n      "scripts": {\n        "docs:dev": "vuepress dev docs",\n        "docs:build": "vuepress build docs"\n      }\n    }\n    \n\n 6. 在本地启动服务器\n    \n    yarn docs:dev # npm run docs:dev\n    \n    \n    vuepress 会在 http://localhost:8080 (opens new window)启动一个热重载的开发服务器。',charsets:{cjk:!0}},{title:"数据库",frontmatter:{},regularPath:"/node/database.html",relativePath:"node/database.md",key:"v-e1c78694",path:"/node/database.html",headers:[{level:3,title:"数据库介绍",slug:"数据库介绍",normalizedTitle:"数据库介绍",charIndex:10},{level:3,title:"基本概念",slug:"基本概念",normalizedTitle:"基本概念",charIndex:99},{level:3,title:"基本操作",slug:"基本操作",normalizedTitle:"基本操作",charIndex:354},{level:2,title:"常用SQL语句",slug:"常用sql语句",normalizedTitle:"常用sql语句",charIndex:1026},{level:3,title:"几种常用函数",slug:"几种常用函数",normalizedTitle:"几种常用函数",charIndex:2514},{level:2,title:"使用node操作数据库",slug:"使用node操作数据库",normalizedTitle:"使用node操作数据库",charIndex:3746},{level:3,title:"前端与后台",slug:"前端与后台",normalizedTitle:"前端与后台",charIndex:6139}],headersStr:"数据库介绍 基本概念 基本操作 常用SQL语句 几种常用函数 使用node操作数据库 前端与后台",content:"# 数据库\n\n\n# 数据库介绍\n\n数据库就是数据的仓库，用来按照特定的结构去组织和管理我们的数据，有了数据库我们就可以更加方便、便捷的操作（C / R / U / D）我们需要保存的数据。\n\n\n# 基本概念\n\n * 数据库 存储数据的仓库或是软件\n\n * 表\n\n * 字段 —— 指的就是列\n\n * 字段类型 —— 指的就是列能够存储的数据种类\n\n * * int\n   * char()\n   * varchar()\n   * date\n   * decimal\n\n * 数据库查询：指的是操作数据库的过程（查、增、删、改）\n\n * 数据库查询语言：SQL(Structured Query Language)结构化查询语言.\n\n * 主键：是用来标识数据表中每一行数据的唯一性的，确保独一无二性\n\n\n# 基本操作\n\n数据库管理工具\n\n数据库管理工具本质上就是一个使用数据库服务器软件（Server）提供的服务的数据库客户端（Client）\n\n命令行工具(了解)\n\n一般如果只是简单操作数据库，可以使用 MySQL 内置的命令行工具完成：\n\n进入 MySQL 客户端的 REPL 环境过后，可以通过标准的 SQL 语句操作数据库。\n\n常见的操作指令：\n\nmysql> show databases;  -- 显示全部数据库\nmysql> create database <db-name>;  -- 创建一个指定名称的数据库\nmysql> use <db-name>;  -- 使用一个数据库，相当于进入指定的数据库\nmysql> show tables;  -- 显示当前数据库中有哪些表\nmysql> create table <table-name> (id int, name varchar(20), age int);  -- 创建一个指定名称的数据表，并添加 3 个列\nmysql> desc <table-name>;  -- 查看指定表结构\nmysql> source ./path/to/sql-file.sql  -- 执行本地 SQL 文件中的 SQL 语句\nmysql> drop table <table-name>;  -- 删除一个指定名称的数据表\nmysql> drop database <db-name>;  -- 删除一个指定名称的数据库\nmysql> exit|quit;  -- 退出数据库终端\n\n\n\n# 常用SQL语句\n\n查询\n\n-- 1. 查询的SQL语句  查询出来的数据都是结果集\n-- 语法:  select * from 表名 where 条件 \nselect * from  stuInfo;  --  表示查询所有的数据信息\nselect id,name,gender from stuinfo; -- 根据指定的字段来查询\nselect * from stuinfo where id = 2;  -- 查询id为2的那一条数据\nselect name,age from stuinfo where id = 3;  -- 查询id为3的那条数据中的name age id\nselect * from stuinfo where id =3 or id= 5; -- 查询id为3 和5 的那两条数据\nselect * from stuinfo where id = 2 or id = 3 or id = 4;\nselect * from stuinfo where id in (2,3,4,5,7);  -- 查询id为 2  3  4  5  7 的那些数据\n\n\n增加\n\n-- 2. 增加语句\n-- 语法: insert [into] 表名 (字段1,字段2...) values (值1,值2...);\ninsert into stuinfo (id,name,gender,age,phone) values (NULL,'张三','男',20,'1302012345');\ninsert into stuinfo (name,age,gender) values ('李四',21,'男');\ninsert into stuinfo values (null,\"王五\",\"男\",21);  -- 如果直接写值的话,必须和字段匹配起来,这样写会报错的\ninsert into stuinfo values (null,\"王五\",\"男\",21,\"1234666\"); -- 没有字段的时候,如果要是直接添加值的话,必须和字段对应,不能缺少\n\n\n删除\n\n-- 3. 删除语句\n-- 语法: DELETE FROM 表名 where 条件  \nDELETE FROM stuinfo where id = 7;\nDELETE FROM stuinfo where id = 2 or id = 8;\nDELETE FROM stuinfo where id in (4,5,10);\nDELETE FROM stuinfo WHERE gender ='男' AND age = 20;  -- 通过多条件来删除数据  and 在这里表示并且的关系 \nDELETE FROM stuinfo WHERE id > 10;   -- 还可以根据id的特性\n\n\n修改\n\n-- 4. 修改语句\n-- 语法: UPDATE 表名 set 字段1= 值1,字段2 = 值2... where 条件 \nUPDATE stuinfo set gender = '男';  -- 如果后面没有跟条件的话,则表示将表中所有的数据中的gender都改成了男\nUPDATE stuinfo set gender = '女' WHERE id = 3; --  将id为3的那条数据中的gender修改为“女”\nUPDATE stuinfo set gender = '女' WHERE age = 21 and name = '李四'; -- 将数据表中名字叫\"李四\"\n\n\n\n# 几种常用函数\n\ncount,MAX,MIN,avg\n\nSELECT count(*) FROM stuinfo; -- count用来统计所有的数据条数 会根据里面的参数来进行统计\nSELECT count(id) FROM stuinfo; -- 根据id来统计具体的数据条数\nSELECT count(phone) FROM stuinfo; -- 根据phone字段来统计具体的条数,如果数据为空则会忽略\nSELECT MAX(age) FROM stuinfo;        -- 查询年龄中的最大值\nSELECT MIN(age) FROM stuinfo;  -- 查询年龄中的最小值\nSELECT avg(age) FROM stuinfo;  -- 查询年龄中的平均值 average 平均值\n\n\norder by\n\nSELECT * FROM stuinfo order by id;  -- order by是用来排序的,默认是以升序进行排序 asc就是升序排序\nSELECT * FROM stuinfo ORDER BY id desc; \nSELECT * FROM stuinfo ORDER BY age desc;  -- desc是降序排列\n\n\nlimit\n\nSELECT * FROM stuinfo ORDER BY id;\nselect * from stuinfo limit 3;  -- 取结果集中的前3条\nSELECT * FROM stuinfo  ORDER BY id limit 3;\n\n-- limit  n (索引) m (数量)   数据表中数据的索引默认也是从0开始的,索引只会对剩下的数据进行排序\nSELECT * FROM stuinfo ORDER BY id LIMIT 3, 3;\n\n-- 还可以这样来实现一个分页  limit count(数量)  offset index(索引);\nSELECT * FROM stuinfo ORDER BY id limit 3 offset 0; -- 从索引为0的位置向下查询3条\nSELECT * FROM stuinfo ORDER BY id limit 3 offset 3; -- 从索引为3的位置向下查询3条\nSELECT * FROM stuinfo ORDER BY id limit 3 offset 6; -- 从索引为6的位置向下查询3条\n\n-- 经过上面的规律可以总结如下:\nint pageCount = 3 ; -- 每页显示的条数\nint  pageSize = 1 ; -- 当前的页码  1 第1页  2 第2页 3 第3页\n\n SELECT * FROM stuinfo ORDER BY id LIMIT pageCount offset (pageSize - 1)* pageCount;\n\n\n\n# 使用node操作数据库\n\n# 安装mysql模块\n\nnpm install mysql -S\n\n\n# 连接数据库\n\n// 导入MySQL模块\nvar mysql = require('mysql');\n\n// 创建一个数据库连接\nvar connection = mysql.createConnection({\n    host:       '127.0.0.1'  // 数据库服务器的地址\n    user:       'root',         // 数据库的账号 \n    password:   'root',         // 数据库的密码\n    database:   'itheima'     // 数据库名称\n});\n\n// 连接数据库或打开数据库\nconnection.connect();\n\n\n# 查询基本操作\n\nvar sqlStr = 'select * from heros';\nconnection.query(sqlStr, function (err, results, fields) {\n    if (err) throw err;\n    console.log(results.length);\n});\n\n\n# 在查询语句中使用参数\n\n// 获取客户端传递过来的查询参数\nvar id = 8;\nvar name = '小红';\n\n// 拼接查询参数\nconnection.query('select * from heros where id=\"' + id + '\" and name=\"' + name + '\"', function (err, results, fields) {\n    if (err) throw err;\n    console.log(results.length);\n});\n\n\n# 使用参数化查询语句\n\n// 通过问号的形式拼接查询参数，问号相当于占位符，将来，传递的真实的数据会替换掉问号所在的区域\n// 真实参数列表可以通过数组的形式进行传递，问号占位符所代表的参数顺序，就是实际数组中每一项的作用\nconst sqlStr = 'select count(*) from heros where id=? and name=?';\nconnection.query(sqlStr, [id, name], function (err, results, fields) {\n    if (err) throw err;\n    console.log(results[0]['count(*)']);\n});\n\n\n# 添加数据\n\n// 插入数据\nvar sqlStr = 'insert into heros (name, gender, avatar) values (?, ?, ?)';\nconnection.query(sqlStr, ['小小', '女', 'img/119.jpg'], function(err, results, fields){\n    if(err) throw err;\n    console.log(results);\n});\n\n\n# 便捷的插入数据\n\nvar user = { name: '尼古拉斯凯奇', age: 54, gender: '男', address: '美国' };\nconnection.query('insert into users set ?',user , function (err, result, fields) {\n    if (err) throw err;\n    console.log(result);\n});\n\n\n# 更新数据\n\nvar sqlStr = 'update heros set name=?, gender=? where id=?';\nconnection.query(sqlStr, ['武松', '男', 12], function(err, results, fields){\n    if(err) throw err;\n    console.log(results);\n});\n\n\n# 便捷的更新数据\n\nvar user = {\n    id:6,\n    age:9,\n    name:'OK'\n}\nconnection.query('update users_copy set ? where id=?', [user, 6], function(err, results){\n    if(err) throw err;\n    console.log(results);\n});\n\n\n# 删除数据\n\n硬删除\n\n// 数据硬删除，执行成功之后，匹配到的数据记录，将会从表中删除\nconnection.query('delete from heros where id=12', function(err, results, fields){\n    if(err) throw err;\n    console.log(results);\n});\n\n\n软删除\n\n// 数据软删除，通过给表添加isdel字段，来标识数据记录是否被删除，true表示被删除，false表示未删除\n// 数据软删除的好处：能最大限度地保留数据的原始性\nconnection.query('update heros set isdel=? where id=?', [true, 10], function(err, results, fields){\n    if(err) throw err;\n    console.log(results);\n});\n\n\n\n# 前端与后台\n\n",normalizedContent:"# 数据库\n\n\n# 数据库介绍\n\n数据库就是数据的仓库，用来按照特定的结构去组织和管理我们的数据，有了数据库我们就可以更加方便、便捷的操作（c / r / u / d）我们需要保存的数据。\n\n\n# 基本概念\n\n * 数据库 存储数据的仓库或是软件\n\n * 表\n\n * 字段 —— 指的就是列\n\n * 字段类型 —— 指的就是列能够存储的数据种类\n\n * * int\n   * char()\n   * varchar()\n   * date\n   * decimal\n\n * 数据库查询：指的是操作数据库的过程（查、增、删、改）\n\n * 数据库查询语言：sql(structured query language)结构化查询语言.\n\n * 主键：是用来标识数据表中每一行数据的唯一性的，确保独一无二性\n\n\n# 基本操作\n\n数据库管理工具\n\n数据库管理工具本质上就是一个使用数据库服务器软件（server）提供的服务的数据库客户端（client）\n\n命令行工具(了解)\n\n一般如果只是简单操作数据库，可以使用 mysql 内置的命令行工具完成：\n\n进入 mysql 客户端的 repl 环境过后，可以通过标准的 sql 语句操作数据库。\n\n常见的操作指令：\n\nmysql> show databases;  -- 显示全部数据库\nmysql> create database <db-name>;  -- 创建一个指定名称的数据库\nmysql> use <db-name>;  -- 使用一个数据库，相当于进入指定的数据库\nmysql> show tables;  -- 显示当前数据库中有哪些表\nmysql> create table <table-name> (id int, name varchar(20), age int);  -- 创建一个指定名称的数据表，并添加 3 个列\nmysql> desc <table-name>;  -- 查看指定表结构\nmysql> source ./path/to/sql-file.sql  -- 执行本地 sql 文件中的 sql 语句\nmysql> drop table <table-name>;  -- 删除一个指定名称的数据表\nmysql> drop database <db-name>;  -- 删除一个指定名称的数据库\nmysql> exit|quit;  -- 退出数据库终端\n\n\n\n# 常用sql语句\n\n查询\n\n-- 1. 查询的sql语句  查询出来的数据都是结果集\n-- 语法:  select * from 表名 where 条件 \nselect * from  stuinfo;  --  表示查询所有的数据信息\nselect id,name,gender from stuinfo; -- 根据指定的字段来查询\nselect * from stuinfo where id = 2;  -- 查询id为2的那一条数据\nselect name,age from stuinfo where id = 3;  -- 查询id为3的那条数据中的name age id\nselect * from stuinfo where id =3 or id= 5; -- 查询id为3 和5 的那两条数据\nselect * from stuinfo where id = 2 or id = 3 or id = 4;\nselect * from stuinfo where id in (2,3,4,5,7);  -- 查询id为 2  3  4  5  7 的那些数据\n\n\n增加\n\n-- 2. 增加语句\n-- 语法: insert [into] 表名 (字段1,字段2...) values (值1,值2...);\ninsert into stuinfo (id,name,gender,age,phone) values (null,'张三','男',20,'1302012345');\ninsert into stuinfo (name,age,gender) values ('李四',21,'男');\ninsert into stuinfo values (null,\"王五\",\"男\",21);  -- 如果直接写值的话,必须和字段匹配起来,这样写会报错的\ninsert into stuinfo values (null,\"王五\",\"男\",21,\"1234666\"); -- 没有字段的时候,如果要是直接添加值的话,必须和字段对应,不能缺少\n\n\n删除\n\n-- 3. 删除语句\n-- 语法: delete from 表名 where 条件  \ndelete from stuinfo where id = 7;\ndelete from stuinfo where id = 2 or id = 8;\ndelete from stuinfo where id in (4,5,10);\ndelete from stuinfo where gender ='男' and age = 20;  -- 通过多条件来删除数据  and 在这里表示并且的关系 \ndelete from stuinfo where id > 10;   -- 还可以根据id的特性\n\n\n修改\n\n-- 4. 修改语句\n-- 语法: update 表名 set 字段1= 值1,字段2 = 值2... where 条件 \nupdate stuinfo set gender = '男';  -- 如果后面没有跟条件的话,则表示将表中所有的数据中的gender都改成了男\nupdate stuinfo set gender = '女' where id = 3; --  将id为3的那条数据中的gender修改为“女”\nupdate stuinfo set gender = '女' where age = 21 and name = '李四'; -- 将数据表中名字叫\"李四\"\n\n\n\n# 几种常用函数\n\ncount,max,min,avg\n\nselect count(*) from stuinfo; -- count用来统计所有的数据条数 会根据里面的参数来进行统计\nselect count(id) from stuinfo; -- 根据id来统计具体的数据条数\nselect count(phone) from stuinfo; -- 根据phone字段来统计具体的条数,如果数据为空则会忽略\nselect max(age) from stuinfo;        -- 查询年龄中的最大值\nselect min(age) from stuinfo;  -- 查询年龄中的最小值\nselect avg(age) from stuinfo;  -- 查询年龄中的平均值 average 平均值\n\n\norder by\n\nselect * from stuinfo order by id;  -- order by是用来排序的,默认是以升序进行排序 asc就是升序排序\nselect * from stuinfo order by id desc; \nselect * from stuinfo order by age desc;  -- desc是降序排列\n\n\nlimit\n\nselect * from stuinfo order by id;\nselect * from stuinfo limit 3;  -- 取结果集中的前3条\nselect * from stuinfo  order by id limit 3;\n\n-- limit  n (索引) m (数量)   数据表中数据的索引默认也是从0开始的,索引只会对剩下的数据进行排序\nselect * from stuinfo order by id limit 3, 3;\n\n-- 还可以这样来实现一个分页  limit count(数量)  offset index(索引);\nselect * from stuinfo order by id limit 3 offset 0; -- 从索引为0的位置向下查询3条\nselect * from stuinfo order by id limit 3 offset 3; -- 从索引为3的位置向下查询3条\nselect * from stuinfo order by id limit 3 offset 6; -- 从索引为6的位置向下查询3条\n\n-- 经过上面的规律可以总结如下:\nint pagecount = 3 ; -- 每页显示的条数\nint  pagesize = 1 ; -- 当前的页码  1 第1页  2 第2页 3 第3页\n\n select * from stuinfo order by id limit pagecount offset (pagesize - 1)* pagecount;\n\n\n\n# 使用node操作数据库\n\n# 安装mysql模块\n\nnpm install mysql -s\n\n\n# 连接数据库\n\n// 导入mysql模块\nvar mysql = require('mysql');\n\n// 创建一个数据库连接\nvar connection = mysql.createconnection({\n    host:       '127.0.0.1'  // 数据库服务器的地址\n    user:       'root',         // 数据库的账号 \n    password:   'root',         // 数据库的密码\n    database:   'itheima'     // 数据库名称\n});\n\n// 连接数据库或打开数据库\nconnection.connect();\n\n\n# 查询基本操作\n\nvar sqlstr = 'select * from heros';\nconnection.query(sqlstr, function (err, results, fields) {\n    if (err) throw err;\n    console.log(results.length);\n});\n\n\n# 在查询语句中使用参数\n\n// 获取客户端传递过来的查询参数\nvar id = 8;\nvar name = '小红';\n\n// 拼接查询参数\nconnection.query('select * from heros where id=\"' + id + '\" and name=\"' + name + '\"', function (err, results, fields) {\n    if (err) throw err;\n    console.log(results.length);\n});\n\n\n# 使用参数化查询语句\n\n// 通过问号的形式拼接查询参数，问号相当于占位符，将来，传递的真实的数据会替换掉问号所在的区域\n// 真实参数列表可以通过数组的形式进行传递，问号占位符所代表的参数顺序，就是实际数组中每一项的作用\nconst sqlstr = 'select count(*) from heros where id=? and name=?';\nconnection.query(sqlstr, [id, name], function (err, results, fields) {\n    if (err) throw err;\n    console.log(results[0]['count(*)']);\n});\n\n\n# 添加数据\n\n// 插入数据\nvar sqlstr = 'insert into heros (name, gender, avatar) values (?, ?, ?)';\nconnection.query(sqlstr, ['小小', '女', 'img/119.jpg'], function(err, results, fields){\n    if(err) throw err;\n    console.log(results);\n});\n\n\n# 便捷的插入数据\n\nvar user = { name: '尼古拉斯凯奇', age: 54, gender: '男', address: '美国' };\nconnection.query('insert into users set ?',user , function (err, result, fields) {\n    if (err) throw err;\n    console.log(result);\n});\n\n\n# 更新数据\n\nvar sqlstr = 'update heros set name=?, gender=? where id=?';\nconnection.query(sqlstr, ['武松', '男', 12], function(err, results, fields){\n    if(err) throw err;\n    console.log(results);\n});\n\n\n# 便捷的更新数据\n\nvar user = {\n    id:6,\n    age:9,\n    name:'ok'\n}\nconnection.query('update users_copy set ? where id=?', [user, 6], function(err, results){\n    if(err) throw err;\n    console.log(results);\n});\n\n\n# 删除数据\n\n硬删除\n\n// 数据硬删除，执行成功之后，匹配到的数据记录，将会从表中删除\nconnection.query('delete from heros where id=12', function(err, results, fields){\n    if(err) throw err;\n    console.log(results);\n});\n\n\n软删除\n\n// 数据软删除，通过给表添加isdel字段，来标识数据记录是否被删除，true表示被删除，false表示未删除\n// 数据软删除的好处：能最大限度地保留数据的原始性\nconnection.query('update heros set isdel=? where id=?', [true, 10], function(err, results, fields){\n    if(err) throw err;\n    console.log(results);\n});\n\n\n\n# 前端与后台\n\n",charsets:{cjk:!0}},{title:"nodejs",frontmatter:{},regularPath:"/node/",relativePath:"node/README.md",key:"v-694f1c96",path:"/node/",headers:[{level:2,title:"fs模块--读写模块",slug:"fs模块-读写模块",normalizedTitle:"fs模块--读写模块",charIndex:405},{level:2,title:"http模块--通讯模块",slug:"http模块-通讯模块",normalizedTitle:"http模块--通讯模块",charIndex:470},{level:2,title:"根据请求返回对应的资源",slug:"根据请求返回对应的资源",normalizedTitle:"根据请求返回对应的资源",charIndex:489},{level:2,title:"同步与异步读取文件",slug:"同步与异步读取文件",normalizedTitle:"同步与异步读取文件",charIndex:551},{level:2,title:"path模块--路径",slug:"path模块-路径",normalizedTitle:"path模块--路径",charIndex:705},{level:2,title:"第三方引用模块",slug:"第三方引用模块",normalizedTitle:"第三方引用模块",charIndex:1050},{level:2,title:"module.exports和exports引用自定义模块",slug:"module-exports和exports引用自定义模块",normalizedTitle:"module.exports和exports引用自定义模块",charIndex:1286},{level:2,title:"startsWith与endsWith",slug:"startswith与endswith",normalizedTitle:"startswith与endswith",charIndex:1498},{level:2,title:"art-template模块--模板",slug:"art-template模块-模板",normalizedTitle:"art-template模块--模板",charIndex:1690},{level:2,title:"appendFile()-文件写入",slug:"appendfile-文件写入",normalizedTitle:"appendfile()-文件写入",charIndex:1771},{level:2,title:"获取get方式的参数",slug:"获取get方式的参数",normalizedTitle:"获取get方式的参数",charIndex:1961},{level:2,title:"获取post方式的参数",slug:"获取post方式的参数",normalizedTitle:"获取post方式的参数",charIndex:2042},{level:2,title:"核心模块：querystring",slug:"核心模块-querystring",normalizedTitle:"核心模块：querystring",charIndex:2141}],headersStr:"fs模块--读写模块 http模块--通讯模块 根据请求返回对应的资源 同步与异步读取文件 path模块--路径 第三方引用模块 module.exports和exports引用自定义模块 startsWith与endsWith art-template模块--模板 appendFile()-文件写入 获取get方式的参数 获取post方式的参数 核心模块：querystring",content:"# nodejs\n\n# 学习node.js的建议：\n\n当前node.js学习阶段，是服务器端的开发，要把自己当作一名后端开发人员，用后端的思维去考虑问题。\n\n虽然都是JavaScript这门脚本语言，但是承载的角色有所不同，要区别对待\n\n我们之前写的项目最终都是运行在服务端的，要时刻建立一种请求，处理，响应的前后端交互思维\n\n抓紧一切事件进行练习，以巩固听课效果\n\n# node的组成\n\nECMAScript\n\n常用模块（核心模块） 安装node的时候就已经自带\n\n第三方模块 我们使用的时候需要去下载\n\npageage.json 记录我们安装的依赖包\n\n# npm\n\nnpm init -y（初始化）\n\nnpm install 包名 -S（--save 开发和部署的依赖包）\n\nnpm install 包名 -D（--save-dev开发依赖包）\n\nnpm install 包名 -g（全局包）\n\n\n\n# fs模块--读写模块\n\n例子：（读写模块）\n\n\n\n路径：（__dirname:弄得执行的js文件所在的目录的根目录）\n\n\n\n\n# http模块--通讯模块\n\n\n\n\n# 根据请求返回对应的资源\n\n获得请求方式，请求地址\n\n\n\n判断用户的请求方式和请求地址\n\n\n\n不符合，返回404\n\n\n\n\n# 同步与异步读取文件\n\n同步读取文件，输出的结果按照一步一步读取\n\n\n\n异步读取文件\n\n\n\n同步读取文件捕获错误：（同步操作：如果中间有某一个环节出问题，或阻塞下面的操作继续执行）\n\n\n\n异步读取不需要捕获错误，本身自带了回调函数，可以实现捕获错误\n\n\n\n在异步操作中实现同步操作的步骤 read\n\n\n\n\n# path模块--路径\n\n# node 自带的路径模块 path 模块，专门用来处理文件路径来使用\n\npath.join() 把字符串按照地址的方式相连成地址路径\n\n\n\n在path.join()中可以使用 ./ 会自动合并成路径\n\n\n\n在path.join()中可以使用 ../ 跳出当前，返回上一路径\n\n\n\n不利用path.join()\n\n\n\n在path.join()中可以使用 ./\n\n\n\npath.basename() 获取文件的名称，不写后缀，返回的有后缀\n\n\n\npath.basename() 获取文件的名称，写上后缀，返回的无后缀名\n\n\n\npath.basename() 获取文件的名称，写上后缀，返回的无后缀名\n\n\n\npath.dirname() 获取文件的根目录\n\n\n\n\n# 第三方引用模块\n\n步骤：\n\n 1. 先下载第三方模块（使用npm的方式）\n    \n    1. 初始化\n       \n       \n    \n    2. 下载\n       \n       \n\n 2. 引入第三方模块，引入方式和核心模块的引入方式一样\n    \n    \n\n 3. 查询第三方模块的官网文档\n    \n    1. 打开官网\n       \n       \n    \n    2. 查看文档选择需要的格式等\n       \n       \n\n\n# module.exports和exports引用自定义模块\n\n第三方模块的引用：data1和data2就是我们自己定义的模块，那么我们想再data3中使用我们自己定义的模块\n\n因为在data1中我们将成员通过global暴露，global是node中的顶级对象；\n\n我们不推荐使用global顶级对象去暴露成员，这样如果是相同的成员，后面的会将前面覆盖。\n\n\n\n运用module.exports的方式：（推荐）\n\n\n\n\n# startsWith与endsWith\n\nstartsWith: 用来检测字符串是以某一个或者某一些字符开始的\n\nendsWith: 用来检测字符串是以某一个或者某一些字符结束的\n\n# 输入变量\n\n\n\n# startsWith的运用方式1：\n\n\n\n# startsWith的运用方式2：\n\n\n\n# endsWith的运用方式1：\n\n\n\n# endsWith的运用方式2：\n\n\n\n\n# art-template模块--模板\n\nart-template是第三方模块\n\n\n\n方式一：\n\n\n\n方式二：a.\n\n\n\n方式二：b.\n\n\n\n方式三：\n\n\n\n\n# appendFile()-文件写入\n\nfs.writeFile()\n\n1.使用右边的方式，写如文件，后写入的内容会将前面的内容覆盖\n\n2.在写入文件的时候，如果只是文件没有，会自动新建一个文件，但是如果文件夹没有，不会自动新建\n\n\n\nfs.appendFile()\n\n1.使用右边的方式，追加内容到文件内，如果没有这个文件，也会自动新建一个文件，但不会自动新建文件夹\n\n\n\n\n# 获取get方式的参数\n\n运用template把数据渲染到页面中\n\n\n\nurl\n\n\n\nurl.parse()\n\n\n\nurl.parse().query\n\n\n\n\n# 获取post方式的参数\n\n定义暂存的变量\n\n\n\n注册data事件，不断的接收传输的数据块，将数据块拼接起来\n\n\n\n注册end事件，数据一定是在end事件中才传输完成\n\n\n\n总体：***\n\n\n\n\n# 核心模块：querystring\n\nquerystring模块：将字符串转成对象\n\n",normalizedContent:"# nodejs\n\n# 学习node.js的建议：\n\n当前node.js学习阶段，是服务器端的开发，要把自己当作一名后端开发人员，用后端的思维去考虑问题。\n\n虽然都是javascript这门脚本语言，但是承载的角色有所不同，要区别对待\n\n我们之前写的项目最终都是运行在服务端的，要时刻建立一种请求，处理，响应的前后端交互思维\n\n抓紧一切事件进行练习，以巩固听课效果\n\n# node的组成\n\necmascript\n\n常用模块（核心模块） 安装node的时候就已经自带\n\n第三方模块 我们使用的时候需要去下载\n\npageage.json 记录我们安装的依赖包\n\n# npm\n\nnpm init -y（初始化）\n\nnpm install 包名 -s（--save 开发和部署的依赖包）\n\nnpm install 包名 -d（--save-dev开发依赖包）\n\nnpm install 包名 -g（全局包）\n\n\n\n# fs模块--读写模块\n\n例子：（读写模块）\n\n\n\n路径：（__dirname:弄得执行的js文件所在的目录的根目录）\n\n\n\n\n# http模块--通讯模块\n\n\n\n\n# 根据请求返回对应的资源\n\n获得请求方式，请求地址\n\n\n\n判断用户的请求方式和请求地址\n\n\n\n不符合，返回404\n\n\n\n\n# 同步与异步读取文件\n\n同步读取文件，输出的结果按照一步一步读取\n\n\n\n异步读取文件\n\n\n\n同步读取文件捕获错误：（同步操作：如果中间有某一个环节出问题，或阻塞下面的操作继续执行）\n\n\n\n异步读取不需要捕获错误，本身自带了回调函数，可以实现捕获错误\n\n\n\n在异步操作中实现同步操作的步骤 read\n\n\n\n\n# path模块--路径\n\n# node 自带的路径模块 path 模块，专门用来处理文件路径来使用\n\npath.join() 把字符串按照地址的方式相连成地址路径\n\n\n\n在path.join()中可以使用 ./ 会自动合并成路径\n\n\n\n在path.join()中可以使用 ../ 跳出当前，返回上一路径\n\n\n\n不利用path.join()\n\n\n\n在path.join()中可以使用 ./\n\n\n\npath.basename() 获取文件的名称，不写后缀，返回的有后缀\n\n\n\npath.basename() 获取文件的名称，写上后缀，返回的无后缀名\n\n\n\npath.basename() 获取文件的名称，写上后缀，返回的无后缀名\n\n\n\npath.dirname() 获取文件的根目录\n\n\n\n\n# 第三方引用模块\n\n步骤：\n\n 1. 先下载第三方模块（使用npm的方式）\n    \n    1. 初始化\n       \n       \n    \n    2. 下载\n       \n       \n\n 2. 引入第三方模块，引入方式和核心模块的引入方式一样\n    \n    \n\n 3. 查询第三方模块的官网文档\n    \n    1. 打开官网\n       \n       \n    \n    2. 查看文档选择需要的格式等\n       \n       \n\n\n# module.exports和exports引用自定义模块\n\n第三方模块的引用：data1和data2就是我们自己定义的模块，那么我们想再data3中使用我们自己定义的模块\n\n因为在data1中我们将成员通过global暴露，global是node中的顶级对象；\n\n我们不推荐使用global顶级对象去暴露成员，这样如果是相同的成员，后面的会将前面覆盖。\n\n\n\n运用module.exports的方式：（推荐）\n\n\n\n\n# startswith与endswith\n\nstartswith: 用来检测字符串是以某一个或者某一些字符开始的\n\nendswith: 用来检测字符串是以某一个或者某一些字符结束的\n\n# 输入变量\n\n\n\n# startswith的运用方式1：\n\n\n\n# startswith的运用方式2：\n\n\n\n# endswith的运用方式1：\n\n\n\n# endswith的运用方式2：\n\n\n\n\n# art-template模块--模板\n\nart-template是第三方模块\n\n\n\n方式一：\n\n\n\n方式二：a.\n\n\n\n方式二：b.\n\n\n\n方式三：\n\n\n\n\n# appendfile()-文件写入\n\nfs.writefile()\n\n1.使用右边的方式，写如文件，后写入的内容会将前面的内容覆盖\n\n2.在写入文件的时候，如果只是文件没有，会自动新建一个文件，但是如果文件夹没有，不会自动新建\n\n\n\nfs.appendfile()\n\n1.使用右边的方式，追加内容到文件内，如果没有这个文件，也会自动新建一个文件，但不会自动新建文件夹\n\n\n\n\n# 获取get方式的参数\n\n运用template把数据渲染到页面中\n\n\n\nurl\n\n\n\nurl.parse()\n\n\n\nurl.parse().query\n\n\n\n\n# 获取post方式的参数\n\n定义暂存的变量\n\n\n\n注册data事件，不断的接收传输的数据块，将数据块拼接起来\n\n\n\n注册end事件，数据一定是在end事件中才传输完成\n\n\n\n总体：***\n\n\n\n\n# 核心模块：querystring\n\nquerystring模块：将字符串转成对象\n\n",charsets:{cjk:!0}},{title:"node",frontmatter:{},regularPath:"/node/node.html",relativePath:"node/node.md",key:"v-11ee7d54",path:"/node/node.html",headers:[{level:2,title:"node命令",slug:"node命令",normalizedTitle:"node命令",charIndex:11}],headersStr:"node命令",content:"# node\n\n\n# node命令\n\n重新编译npm rebuild",normalizedContent:"# node\n\n\n# node命令\n\n重新编译npm rebuild",charsets:{cjk:!0}},{title:"面试题1",frontmatter:{},regularPath:"/progress/interview1.html",relativePath:"progress/interview1.md",key:"v-5a27c414",path:"/progress/interview1.html",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"nvm",frontmatter:{},regularPath:"/node/nvm.html",relativePath:"node/nvm.md",key:"v-f5fd061c",path:"/node/nvm.html",headers:[{level:2,title:"Mac 安装nvm",slug:"mac-安装nvm",normalizedTitle:"mac 安装nvm",charIndex:10},{level:3,title:"第一种安装方案，手动下载",slug:"第一种安装方案-手动下载",normalizedTitle:"第一种安装方案，手动下载",charIndex:91},{level:3,title:"第二种安装方案，通过brew安装",slug:"第二种安装方案-通过brew安装",normalizedTitle:"第二种安装方案，通过brew安装",charIndex:712},{level:2,title:"nvm操作",slug:"nvm操作",normalizedTitle:"nvm操作",charIndex:1260}],headersStr:"Mac 安装nvm 第一种安装方案，手动下载 第二种安装方案，通过brew安装 nvm操作",content:'# nvm\n\n\n# Mac 安装nvm\n\n路径：https://blog.csdn.net/ForeverMyheart/article/details/127203419\n\n\n# 第一种安装方案，手动下载\n\n# 1、下载nvm\n\n从github下载nvm仓库到 ~/目录 地址：https://github.com/nvm-sh/nvm.git\n\n# 2、执行install.sh\n\n进入 nvm目录中执行install.sh 等待执行完成，执行的操作方法就是直接将文件拖入终端然后回车。\n\n# 3、配置nvm环境变量将下述代码复制到 ~/.bash_profile\n\nexport NVM_DIR="$HOME/.nvm"\n[ -s "$NVM_DIR/nvm.sh" ] && \\. "$NVM_DIR/nvm.sh" \n # This loads nvm\n[ -s "$NVM_DIR/bash_completion" ] && \\. "$NVM_DIR/bash_completion"\n# This loads nvm bash_completio\n\n\n如果没有配置环境变量，要先配置环境变量 ，配置环境变量的方法：\n\n1.在终端输入touch ~/.bash_profile\n\n2.在终端输入source ~/.bash_profile\n\n3.在终端输入. ~/.nvm/nvm.sh\n\n4.打开环境变量文件的方法：open ~/.bash_profile\n\n# 4、执行source ~/.bash_profile\n\n# 5、执行nvm --version是否可以正常输出，若不行则重启终端再次尝试\n\n\n# 第二种安装方案，通过brew安装\n\n# 1、brew install nvm\n\n首先要保证之前没有安装过node，如果之前安装过，就先 brew uninstall noded\n\n# 2、报错处理\n\n上面的操作之后，终端可能会报错：Command failed with exit 128: git，不要着急，这是终端输入brew -v ，回提示添加git config --global --add safe.directory /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core和git config --global --add safe.directory /usr/local/Homebrew/Library/Taps/homebrew/homebrew-cask,只要将两行代码复制到终端执行，之后再重新brew install nvm，之后就是等待了\n\n# 3、下载后配置\n\n下载完之后，需要在环境变量的文件中添加 echo "source $(brew --prefix nvm)/nvm.sh" >> .bash_profile，并source ~/.bash_profile保存变量，之后就可以正常使用了\n\n\n# nvm操作\n\n1：nvm install 版本号-- 安装指定node版本\n\n2：nvm uninstall 版本号-- 删除指定node版本\n\n3：nvm use 版本号 --切换使用指定的node版本\n\n4：nvm list 或 nvm ls -- 列出所有安装的node版本\n\n5：nvm current -- 显示当前的node版本\n\n6：nvm alias default 版本号 -- 可以指定默认打开终端时的node版本',normalizedContent:'# nvm\n\n\n# mac 安装nvm\n\n路径：https://blog.csdn.net/forevermyheart/article/details/127203419\n\n\n# 第一种安装方案，手动下载\n\n# 1、下载nvm\n\n从github下载nvm仓库到 ~/目录 地址：https://github.com/nvm-sh/nvm.git\n\n# 2、执行install.sh\n\n进入 nvm目录中执行install.sh 等待执行完成，执行的操作方法就是直接将文件拖入终端然后回车。\n\n# 3、配置nvm环境变量将下述代码复制到 ~/.bash_profile\n\nexport nvm_dir="$home/.nvm"\n[ -s "$nvm_dir/nvm.sh" ] && \\. "$nvm_dir/nvm.sh" \n # this loads nvm\n[ -s "$nvm_dir/bash_completion" ] && \\. "$nvm_dir/bash_completion"\n# this loads nvm bash_completio\n\n\n如果没有配置环境变量，要先配置环境变量 ，配置环境变量的方法：\n\n1.在终端输入touch ~/.bash_profile\n\n2.在终端输入source ~/.bash_profile\n\n3.在终端输入. ~/.nvm/nvm.sh\n\n4.打开环境变量文件的方法：open ~/.bash_profile\n\n# 4、执行source ~/.bash_profile\n\n# 5、执行nvm --version是否可以正常输出，若不行则重启终端再次尝试\n\n\n# 第二种安装方案，通过brew安装\n\n# 1、brew install nvm\n\n首先要保证之前没有安装过node，如果之前安装过，就先 brew uninstall noded\n\n# 2、报错处理\n\n上面的操作之后，终端可能会报错：command failed with exit 128: git，不要着急，这是终端输入brew -v ，回提示添加git config --global --add safe.directory /usr/local/homebrew/library/taps/homebrew/homebrew-core和git config --global --add safe.directory /usr/local/homebrew/library/taps/homebrew/homebrew-cask,只要将两行代码复制到终端执行，之后再重新brew install nvm，之后就是等待了\n\n# 3、下载后配置\n\n下载完之后，需要在环境变量的文件中添加 echo "source $(brew --prefix nvm)/nvm.sh" >> .bash_profile，并source ~/.bash_profile保存变量，之后就可以正常使用了\n\n\n# nvm操作\n\n1：nvm install 版本号-- 安装指定node版本\n\n2：nvm uninstall 版本号-- 删除指定node版本\n\n3：nvm use 版本号 --切换使用指定的node版本\n\n4：nvm list 或 nvm ls -- 列出所有安装的node版本\n\n5：nvm current -- 显示当前的node版本\n\n6：nvm alias default 版本号 -- 可以指定默认打开终端时的node版本',charsets:{cjk:!0}},{title:"未分类",frontmatter:{},regularPath:"/progress/",relativePath:"progress/README.md",key:"v-4bba0115",path:"/progress/",headersStr:null,content:"面试题（https://osjobs.net/topk/）\n\n未分类问题\n\npostcss插件：处理css\n\n箭头是语法，promise是特性\n\n 1. Babel 是js的编辑器\n    \n    1. 预设（presets）\n    2. plyfill 就是js库\n    3. .babelrc为Babel的设置\n\n 2. 无论什么项目，都把数据量变大\n\n 3. 交互体验要求更高\n\n 4. 性能要求更高（代码执行效率提高）\n\n 5. 网速可能不稳定\n\n 6. 研发效率的提高（写代码和上线的效率）\n\n====文件上传\n\n// 两个对象返回不相同的属性\ndiff(a, b){\n    var ret = Object.assign({}, a, b);\n    for (var key in ret){\n        if (key in a && key in b) delete ret[key];\n    }\n    return ret;\n},\n\n\n# window.requestAnimationFrame解锁\n\nwindow.requestAnimationFrame() 这个方法是用来在页面重绘之前，通知浏览器调用一个指定的函数，以满足开发者操作动画的需要。即可以这样说，该方法接受一个函数为参，该函数会在重绘前调用。 因浏览器不同，为了兼容性，有三种格式的： requestID = window.requestAnimationFrame(callback); requestID = window.mozRequestAnimationFrame(callback); requestID = window.webkitRequestAnimationFrame(callback); requestID = window.oRequestAnimationFrame(callback); requestID = window.msRequestAnimationFrame(callback);\n\ncallback 会收到一个参数，这个 DOMHighResTimeStamp 类型的参数指示当前时间距离开始触发 requestAnimationFrame 的回调的时间。\n\nwindow.cancelAnimationFrame(requestID) 可以取消这个回调函数。\n\n递归组件\n\nhttps://www.cnblogs.com/konghaowei/p/12489639.html",normalizedContent:"面试题（https://osjobs.net/topk/）\n\n未分类问题\n\npostcss插件：处理css\n\n箭头是语法，promise是特性\n\n 1. babel 是js的编辑器\n    \n    1. 预设（presets）\n    2. plyfill 就是js库\n    3. .babelrc为babel的设置\n\n 2. 无论什么项目，都把数据量变大\n\n 3. 交互体验要求更高\n\n 4. 性能要求更高（代码执行效率提高）\n\n 5. 网速可能不稳定\n\n 6. 研发效率的提高（写代码和上线的效率）\n\n====文件上传\n\n// 两个对象返回不相同的属性\ndiff(a, b){\n    var ret = object.assign({}, a, b);\n    for (var key in ret){\n        if (key in a && key in b) delete ret[key];\n    }\n    return ret;\n},\n\n\n# window.requestanimationframe解锁\n\nwindow.requestanimationframe() 这个方法是用来在页面重绘之前，通知浏览器调用一个指定的函数，以满足开发者操作动画的需要。即可以这样说，该方法接受一个函数为参，该函数会在重绘前调用。 因浏览器不同，为了兼容性，有三种格式的： requestid = window.requestanimationframe(callback); requestid = window.mozrequestanimationframe(callback); requestid = window.webkitrequestanimationframe(callback); requestid = window.orequestanimationframe(callback); requestid = window.msrequestanimationframe(callback);\n\ncallback 会收到一个参数，这个 domhighrestimestamp 类型的参数指示当前时间距离开始触发 requestanimationframe 的回调的时间。\n\nwindow.cancelanimationframe(requestid) 可以取消这个回调函数。\n\n递归组件\n\nhttps://www.cnblogs.com/konghaowei/p/12489639.html",charsets:{cjk:!0}},{title:"express",frontmatter:{},regularPath:"/node/express.html",relativePath:"node/express.md",key:"v-ea210bc8",path:"/node/express.html",headers:[{level:2,title:"express的介绍：",slug:"express的介绍",normalizedTitle:"express的介绍：",charIndex:14},{level:2,title:"express的使用：",slug:"express的使用",normalizedTitle:"express的使用：",charIndex:156},{level:2,title:"接收get和post的不同的请求",slug:"接收get和post的不同的请求",normalizedTitle:"接收get和post的不同的请求",charIndex:752},{level:2,title:"EJS模板引擎介绍",slug:"ejs模板引擎介绍",normalizedTitle:"ejs模板引擎介绍",charIndex:1226},{level:2,title:"express.static托管静态页面",slug:"express-static托管静态页面",normalizedTitle:"express.static托管静态页面",charIndex:2073},{level:2,title:"使用include引入公共部分",slug:"使用include引入公共部分",normalizedTitle:"使用include引入公共部分",charIndex:2957},{level:2,title:"express.Router创建路由",slug:"express-router创建路由",normalizedTitle:"express.router创建路由",charIndex:3365}],headersStr:"express的介绍： express的使用： 接收get和post的不同的请求 EJS模板引擎介绍 express.static托管静态页面 使用include引入公共部分 express.Router创建路由",content:"# express\n\n\n# express的介绍：\n\n基于node.js平台，快速、开放、极简的Web开发框架。\n\nexpress的框架核心特性：\n\n 1. 可以设置中间件来响应HTTP请求。\n 2. 定义了路由表用于执行不同的HTTP请求动作。\n 3. 可以通过向模板传递参数来动态渲染HTML页面。\n\n\n# express的使用：\n\n安装：\n\nnpm install express -S;     //先安装express框架\n\n\n使用：\n\n// 1. 引入框架模块\nvar express = require('express')\n\n// 2. 创建服务器\nvar app = express();\n\n// 3. 开启服务器并监听端口\napp.listen(3000,()=>{\n    console.log('express server is running at http://127.0.0.1:3000');\n})\n\n// 4.给app对象注册中间件,监听请求\n// use是一个中间件,可以用来监听get和post请求\napp.use((req,res)=>{\n    // res.end('hello world') // 返回英文数据\n    // res.writeHeader(200,{\n    //   'Content-Type':'text/plan;charset=utf-8'\n    // })\n    // res.end('express框架的基本使用...');// 直接返回带有中文的内容会有乱码 加响应头后可以解决\n\n    res.send('express框架的基本使用...') ;// 可以直接返回中文并解析不会出现乱码\n})\n\n\n\n\n# 接收get和post的不同的请求\n\n使用：\n\n// 1. 引入框架模块\nvar express = require('express')\n\n// 2. 创建服务器\nvar app = express();\n\n// 3. 开启服务器并监听端口\napp.listen(3000,()=>{\n    console.log('express server is running at http://127.0.0.1:3000');\n})\n\n// 4.给app对象注册中间件,监听请求\n// use是一个中间件,可以用来监听get和post请求\napp.get('/',(req,res)=>{\n    res.send('这是一个index的主页面...')\n})\n\napp.get('/movie', (req, res) => {\n    res.send('这是一个电影的主页面...')\n})\n\napp.post('/login', (req, res) => {\n    res.send('这是一个登陆的主页面...')\n})\n\n\n\n\n# EJS模板引擎介绍\n\nexpress框架中推荐使用的页面模板引擎是ejs，而不是art-template\n\n使用步骤：\n\n 1. 使用命令 npm i ejs -S 安装这个模板引擎\n 2. 给express框架设置默认的模板引擎\n 3. 设置模板引擎文件的默认路径\n\n使用：\n\n// 1. 引入模块\nvar express =require('express')\n\n// 2. 创建服务器对象\nvar app = express()\n// 通过app.set方法，设置express的默认模板引擎为ejs\n// 第一个参数是'view engine' 是固定的写法,表示我们要设置默认的模板引擎\napp.set('view engine','ejs')\n// 通过app.set('views',path)来设置默认模板页面的存放路径;\n// 第一个参数'views'是固定写法\n// 注意,在express中,已经默认约定好了,如果用户不设置app.set('views',path), \n// 那么,默认的模板 文件存放路径就是'./views',就是当前根目录下面的views文件夹,约定大于配置\napp.set('views','./views')\n\n// 3. 启动服务器并监听端口\napp.listen(3000,()=>{\n    console.log('express server is running at http://127.0.0.1:3000');\n})\n\n// 4. 给app对象注册中间件,并监听请求\napp.get('/',(req,res)=>{\n    // 注意:ejs模板引擎,默认的模板文件名后缀名不是.html,而是ejs\n    res.render('index.ejs',{})\n})\n\napp.get('/movie', (req, res) => {\n    res.render('movie.ejs', {})\n})\n\n\n\n\n# express.static托管静态页面\n\n利用Express内置的express.static可以方便地托管静态文件,例如图片、CSS、JavaScript文件等。\n\n将静态资源 文件所在的目录作为参数传递给express.static中间件就可以提供静态资源文件的访问了.\n\n例如,假设在public目录放置了图片、CSS和JavaScript文件,你就可以:\n\napp.use(express.static('public'));\n\n\n现在public目录下面的文件就可以访问了。\n\nhttp://localhost:3000/images/kitten.jpg\nhttp://localhost:3000/css/style.css\nhttp://localhost:3000/js/app.js\nhttp://localhost:3000/images/bg.png\nhttp://localhost:3000/images/hello.html\n//所有文件的路径都是相对于存储目录的,因此存放静态文件的目录名不会出现在URL中.\n\n\n如果你希望所有通过express.static访问的文件都存放在一个\"虚拟(virtual)\"目录(即目录根本不存在)下面,可以通过为静态资源目录指定一个挂载路径的方式来实现,如下所示:\n\napp.use('/static'express.static('public'));\n\n\n现在，你就可以通过带有“/static\"前缀的地址来访问public目录下面的文件了.\n\nhttp://localhost:3000/static/images/kitten.jpg\nhttp://localhost:3000/static/css/style.css\nhttp://localhost:3000/static/js/app.js\nhttp://localhost:3000/static/images/bg.png\nhttp://localhost:3000/static/images/hello.html\n\n\n\n# 使用include引入公共部分\n\n使用ejs模板引擎中的include()方法来引入即可. <%- %>表示不转义输出.\n\n<%- include('./layout/header.ejs')%>\n    <h2>这是一个主页面的内容</h2>\n    <p>姓名:<%= name%></p>\n    <p>性别:<%= gender%></p>\n    <p>年龄:<%= age%></p>\n    <p>爱好:</p>\n    <ul>\n        <% hobby.forEach(item=>{ %>\n            <li><%= item%></li>\n        <%})%>\n    </ul>\n    <img src=\"/a/b/public/images/psb.jpg\" alt=\"\">\n<%- include('./layout/footer.ejs')%>\n\n\n\n# express.Router创建路由\n\napp.route()\n\n可以使用app.router()创建路由路径的链式路由句柄.由于路径在一个地方指定,这样做有助于创建模块化的路由.\n\nlet express = require('express')\n\nlet router = express.Router();\n\nrouter.get('/',(req,res)=>{\n    res.render('index',{})\n})\n    .get('/add',(req,res)=>{\n    res.render('add',{})\n})\n    .get('/info',(req,res)=>{\n    res.render('info',{})\n})\n    .get('/edit',(req,res)=>{\n    res.render('edit',{})\n})\n    .post('/detail',(req,res)=>{\n    res.send('这是post请求发送的数据')\n})\nmodule.exports = router;\n\n\nexpress.Router\n\n可使用express.Router类创建模块化、可挂载的路由句柄。Router实例是一个完整的中间件和路由系统，因此常称其为一个\"mini-app\"。\n\n在项目目录下创建名为router.js的文件，内容如下:\n\n// 1. 导入模块\nvar express = require('express')\n\n// 2. 创建一个路由模块\nvar router = express.Router();\n\n// 将请求路径挂载到router路由对象上\nrouter.get('/', (req, res) => {\n    // res.send('这是主页面的内容...')\n    res.render('index', { name: 'tom', age: 20, gender: '男', hobby: ['吃饭', '睡觉', '打豆豆'] })\n})\nrouter.get('/movie', (req, res) => {\n    // res.send('这是一个电影页面的内容啊...')\n    res.render('movie', {})\n})\nrouter.get('/login', (req, res) => {\n    // res.send('这是一个用户登陆的请求啊......')\n    res.render('login', {})\n})\n\nrouter.post('/', (req, res) => {\n    res.send('这是一个post请求啊...')\n})\n// 将创建的router暴露出去\nmodule.exports = router\n\n\n在app.js中的内容如下:\n\n// 1. 引入模块\nvar express = require('express')\nvar ejs = require('ejs')\nvar router = require('./route.js')\n\n// 2. 创建服务器对象\nvar app = express();\n\n// 3. 启动服务,并监听端口\napp.listen(3000,()=>{\n    console.log('express server is running at http://127.0.0.1:3000');\n})\n\napp.set('view engine','ejs');\napp.set('views','./views')\nejs.delimiter = '?';\n// 实现静态资源的托管 \n// app.use(express.static('public'))\napp.use('/a/b/public',express.static('public')) ;// 可以放在任何虚拟目录里面,而不会受到影响\napp.use('/c/d/assets',express.static('assets'))\n\n// 4. 注册路由模块\napp.use(router)\n",normalizedContent:"# express\n\n\n# express的介绍：\n\n基于node.js平台，快速、开放、极简的web开发框架。\n\nexpress的框架核心特性：\n\n 1. 可以设置中间件来响应http请求。\n 2. 定义了路由表用于执行不同的http请求动作。\n 3. 可以通过向模板传递参数来动态渲染html页面。\n\n\n# express的使用：\n\n安装：\n\nnpm install express -s;     //先安装express框架\n\n\n使用：\n\n// 1. 引入框架模块\nvar express = require('express')\n\n// 2. 创建服务器\nvar app = express();\n\n// 3. 开启服务器并监听端口\napp.listen(3000,()=>{\n    console.log('express server is running at http://127.0.0.1:3000');\n})\n\n// 4.给app对象注册中间件,监听请求\n// use是一个中间件,可以用来监听get和post请求\napp.use((req,res)=>{\n    // res.end('hello world') // 返回英文数据\n    // res.writeheader(200,{\n    //   'content-type':'text/plan;charset=utf-8'\n    // })\n    // res.end('express框架的基本使用...');// 直接返回带有中文的内容会有乱码 加响应头后可以解决\n\n    res.send('express框架的基本使用...') ;// 可以直接返回中文并解析不会出现乱码\n})\n\n\n\n\n# 接收get和post的不同的请求\n\n使用：\n\n// 1. 引入框架模块\nvar express = require('express')\n\n// 2. 创建服务器\nvar app = express();\n\n// 3. 开启服务器并监听端口\napp.listen(3000,()=>{\n    console.log('express server is running at http://127.0.0.1:3000');\n})\n\n// 4.给app对象注册中间件,监听请求\n// use是一个中间件,可以用来监听get和post请求\napp.get('/',(req,res)=>{\n    res.send('这是一个index的主页面...')\n})\n\napp.get('/movie', (req, res) => {\n    res.send('这是一个电影的主页面...')\n})\n\napp.post('/login', (req, res) => {\n    res.send('这是一个登陆的主页面...')\n})\n\n\n\n\n# ejs模板引擎介绍\n\nexpress框架中推荐使用的页面模板引擎是ejs，而不是art-template\n\n使用步骤：\n\n 1. 使用命令 npm i ejs -s 安装这个模板引擎\n 2. 给express框架设置默认的模板引擎\n 3. 设置模板引擎文件的默认路径\n\n使用：\n\n// 1. 引入模块\nvar express =require('express')\n\n// 2. 创建服务器对象\nvar app = express()\n// 通过app.set方法，设置express的默认模板引擎为ejs\n// 第一个参数是'view engine' 是固定的写法,表示我们要设置默认的模板引擎\napp.set('view engine','ejs')\n// 通过app.set('views',path)来设置默认模板页面的存放路径;\n// 第一个参数'views'是固定写法\n// 注意,在express中,已经默认约定好了,如果用户不设置app.set('views',path), \n// 那么,默认的模板 文件存放路径就是'./views',就是当前根目录下面的views文件夹,约定大于配置\napp.set('views','./views')\n\n// 3. 启动服务器并监听端口\napp.listen(3000,()=>{\n    console.log('express server is running at http://127.0.0.1:3000');\n})\n\n// 4. 给app对象注册中间件,并监听请求\napp.get('/',(req,res)=>{\n    // 注意:ejs模板引擎,默认的模板文件名后缀名不是.html,而是ejs\n    res.render('index.ejs',{})\n})\n\napp.get('/movie', (req, res) => {\n    res.render('movie.ejs', {})\n})\n\n\n\n\n# express.static托管静态页面\n\n利用express内置的express.static可以方便地托管静态文件,例如图片、css、javascript文件等。\n\n将静态资源 文件所在的目录作为参数传递给express.static中间件就可以提供静态资源文件的访问了.\n\n例如,假设在public目录放置了图片、css和javascript文件,你就可以:\n\napp.use(express.static('public'));\n\n\n现在public目录下面的文件就可以访问了。\n\nhttp://localhost:3000/images/kitten.jpg\nhttp://localhost:3000/css/style.css\nhttp://localhost:3000/js/app.js\nhttp://localhost:3000/images/bg.png\nhttp://localhost:3000/images/hello.html\n//所有文件的路径都是相对于存储目录的,因此存放静态文件的目录名不会出现在url中.\n\n\n如果你希望所有通过express.static访问的文件都存放在一个\"虚拟(virtual)\"目录(即目录根本不存在)下面,可以通过为静态资源目录指定一个挂载路径的方式来实现,如下所示:\n\napp.use('/static'express.static('public'));\n\n\n现在，你就可以通过带有“/static\"前缀的地址来访问public目录下面的文件了.\n\nhttp://localhost:3000/static/images/kitten.jpg\nhttp://localhost:3000/static/css/style.css\nhttp://localhost:3000/static/js/app.js\nhttp://localhost:3000/static/images/bg.png\nhttp://localhost:3000/static/images/hello.html\n\n\n\n# 使用include引入公共部分\n\n使用ejs模板引擎中的include()方法来引入即可. <%- %>表示不转义输出.\n\n<%- include('./layout/header.ejs')%>\n    <h2>这是一个主页面的内容</h2>\n    <p>姓名:<%= name%></p>\n    <p>性别:<%= gender%></p>\n    <p>年龄:<%= age%></p>\n    <p>爱好:</p>\n    <ul>\n        <% hobby.foreach(item=>{ %>\n            <li><%= item%></li>\n        <%})%>\n    </ul>\n    <img src=\"/a/b/public/images/psb.jpg\" alt=\"\">\n<%- include('./layout/footer.ejs')%>\n\n\n\n# express.router创建路由\n\napp.route()\n\n可以使用app.router()创建路由路径的链式路由句柄.由于路径在一个地方指定,这样做有助于创建模块化的路由.\n\nlet express = require('express')\n\nlet router = express.router();\n\nrouter.get('/',(req,res)=>{\n    res.render('index',{})\n})\n    .get('/add',(req,res)=>{\n    res.render('add',{})\n})\n    .get('/info',(req,res)=>{\n    res.render('info',{})\n})\n    .get('/edit',(req,res)=>{\n    res.render('edit',{})\n})\n    .post('/detail',(req,res)=>{\n    res.send('这是post请求发送的数据')\n})\nmodule.exports = router;\n\n\nexpress.router\n\n可使用express.router类创建模块化、可挂载的路由句柄。router实例是一个完整的中间件和路由系统，因此常称其为一个\"mini-app\"。\n\n在项目目录下创建名为router.js的文件，内容如下:\n\n// 1. 导入模块\nvar express = require('express')\n\n// 2. 创建一个路由模块\nvar router = express.router();\n\n// 将请求路径挂载到router路由对象上\nrouter.get('/', (req, res) => {\n    // res.send('这是主页面的内容...')\n    res.render('index', { name: 'tom', age: 20, gender: '男', hobby: ['吃饭', '睡觉', '打豆豆'] })\n})\nrouter.get('/movie', (req, res) => {\n    // res.send('这是一个电影页面的内容啊...')\n    res.render('movie', {})\n})\nrouter.get('/login', (req, res) => {\n    // res.send('这是一个用户登陆的请求啊......')\n    res.render('login', {})\n})\n\nrouter.post('/', (req, res) => {\n    res.send('这是一个post请求啊...')\n})\n// 将创建的router暴露出去\nmodule.exports = router\n\n\n在app.js中的内容如下:\n\n// 1. 引入模块\nvar express = require('express')\nvar ejs = require('ejs')\nvar router = require('./route.js')\n\n// 2. 创建服务器对象\nvar app = express();\n\n// 3. 启动服务,并监听端口\napp.listen(3000,()=>{\n    console.log('express server is running at http://127.0.0.1:3000');\n})\n\napp.set('view engine','ejs');\napp.set('views','./views')\nejs.delimiter = '?';\n// 实现静态资源的托管 \n// app.use(express.static('public'))\napp.use('/a/b/public',express.static('public')) ;// 可以放在任何虚拟目录里面,而不会受到影响\napp.use('/c/d/assets',express.static('assets'))\n\n// 4. 注册路由模块\napp.use(router)\n",charsets:{cjk:!0}},{title:"32个手撕JS，彻底摆脱初级前端（面试高频）",frontmatter:{},regularPath:"/progress/interview3.html",relativePath:"progress/interview3.md",key:"v-28f59836",path:"/progress/interview3.html",headers:[{level:2,title:"01.数组扁平化",slug:"_01-数组扁平化",normalizedTitle:"01.数组扁平化",charIndex:29},{level:2,title:"02.数组去重",slug:"_02-数组去重",normalizedTitle:"02.数组去重",charIndex:746},{level:2,title:"03.类数组转化为数组",slug:"_03-类数组转化为数组",normalizedTitle:"03.类数组转化为数组",charIndex:1990},{level:2,title:"04.Array.prototype.filter()",slug:"_04-array-prototype-filter",normalizedTitle:"04.array.prototype.filter()",charIndex:2361},{level:2,title:"05.Array.prototype.map()",slug:"_05-array-prototype-map",normalizedTitle:"05.array.prototype.map()",charIndex:3370},{level:2,title:"06.Array.prototype.forEach()",slug:"_06-array-prototype-foreach",normalizedTitle:"06.array.prototype.foreach()",charIndex:4124},{level:2,title:"07.Array.prototype.reduce()",slug:"_07-array-prototype-reduce",normalizedTitle:"07.array.prototype.reduce()",charIndex:4828},{level:2,title:"08.Function.prototype.apply()",slug:"_08-function-prototype-apply",normalizedTitle:"08.function.prototype.apply()",charIndex:5958},{level:2,title:"09.Function.prototype.call",slug:"_09-function-prototype-call",normalizedTitle:"09.function.prototype.call",charIndex:6315},{level:2,title:"10.Function.prototype.bind",slug:"_10-function-prototype-bind",normalizedTitle:"10.function.prototype.bind",charIndex:6658},{level:2,title:"11.debounce（防抖）",slug:"_11-debounce-防抖",normalizedTitle:"11.debounce（防抖）",charIndex:7074},{level:2,title:"12.throttle（节流）",slug:"_12-throttle-节流",normalizedTitle:"12.throttle（节流）",charIndex:7403},{level:2,title:"13.函数珂里化",slug:"_13-函数珂里化",normalizedTitle:"13.函数珂里化",charIndex:7728},{level:2,title:"14.模拟new操作",slug:"_14-模拟new操作",normalizedTitle:"14.模拟new操作",charIndex:8067},{level:2,title:"15.instanceof",slug:"_15-instanceof",normalizedTitle:"15.instanceof",charIndex:8558},{level:2,title:"16.原型继承",slug:"_16-原型继承",normalizedTitle:"16.原型继承",charIndex:8947},{level:2,title:"17.Object.is",slug:"_17-object-is",normalizedTitle:"17.object.is",charIndex:9197},{level:2,title:"18.Object.assign",slug:"_18-object-assign",normalizedTitle:"18.object.assign",charIndex:9432},{level:2,title:"19.深拷贝",slug:"_19-深拷贝",normalizedTitle:"19.深拷贝",charIndex:10260},{level:2,title:"20.Promise",slug:"_20-promise",normalizedTitle:"20.promise",charIndex:11204},{level:2,title:"21.Promise.all",slug:"_21-promise-all",normalizedTitle:"21.promise.all",charIndex:14614},{level:2,title:"22.Promise.race",slug:"_22-promise-race",normalizedTitle:"22.promise.race",charIndex:15086},{level:2,title:"23.Promise并行限制",slug:"_23-promise并行限制",normalizedTitle:"23.promise并行限制",charIndex:15367},{level:2,title:"24.JSONP",slug:"_24-jsonp",normalizedTitle:"24.jsonp",charIndex:16293},{level:2,title:"25.AJAX",slug:"_25-ajax",normalizedTitle:"25.ajax",charIndex:16975},{level:2,title:"26.event模块",slug:"_26-event模块",normalizedTitle:"26.event模块",charIndex:17518},{level:2,title:"27.图片懒加载",slug:"_27-图片懒加载",normalizedTitle:"27.图片懒加载",charIndex:19555},{level:2,title:"28.滚动加载",slug:"_28-滚动加载",normalizedTitle:"28.滚动加载",charIndex:20181},{level:2,title:"29.渲染几万条数据不卡住页面",slug:"_29-渲染几万条数据不卡住页面",normalizedTitle:"29.渲染几万条数据不卡住页面",charIndex:20603},{level:2,title:"30.打印出当前网页使用了多少种HTML元素",slug:"_30-打印出当前网页使用了多少种html元素",normalizedTitle:"30.打印出当前网页使用了多少种html元素",charIndex:21372},{level:2,title:"31.将VirtualDom转化为真实DOM结构",slug:"_31-将virtualdom转化为真实dom结构",normalizedTitle:"31.将virtualdom转化为真实dom结构",charIndex:21564},{level:2,title:"32.字符串解析问题",slug:"_32-字符串解析问题",normalizedTitle:"32.字符串解析问题",charIndex:22295}],headersStr:"01.数组扁平化 02.数组去重 03.类数组转化为数组 04.Array.prototype.filter() 05.Array.prototype.map() 06.Array.prototype.forEach() 07.Array.prototype.reduce() 08.Function.prototype.apply() 09.Function.prototype.call 10.Function.prototype.bind 11.debounce（防抖） 12.throttle（节流） 13.函数珂里化 14.模拟new操作 15.instanceof 16.原型继承 17.Object.is 18.Object.assign 19.深拷贝 20.Promise 21.Promise.all 22.Promise.race 23.Promise并行限制 24.JSONP 25.AJAX 26.event模块 27.图片懒加载 28.滚动加载 29.渲染几万条数据不卡住页面 30.打印出当前网页使用了多少种HTML元素 31.将VirtualDom转化为真实DOM结构 32.字符串解析问题",content:"# 32个手撕JS，彻底摆脱初级前端（面试高频）\n\n\n# 01.数组扁平化\n\n数组扁平化是指将一个多维数组变为一个一维数组\n\nconst arr = [1, [2, [3, [4, 5]]], 6];\n// => [1, 2, 3, 4, 5, 6]\n\n\n方法一：使用flat()\n\nconst res1 = arr.flat(Infinity);\n\n\n方法二：利用正则\n\nconst res2 = JSON.stringify(arr).replace(/\\[|\\]/g, '').split(',');\n\n\n但数据类型都会变为字符串\n\n方法三：正则改良版本\n\nconst res3 = JSON.parse('[' + JSON.stringify(arr).replace(/\\[|\\]/g, '') + ']');\n\n\n方法四：使用reduce\n\nconst flatten = arr => {\n  return arr.reduce((pre, cur) => {\n    return pre.concat(Array.isArray(cur) ? flatten(cur) : cur);\n  }, [])\n}\nconst res4 = flatten(arr);\n\n\n方法五：函数递归\n\nconst res5 = [];\nconst fn = arr => {\n  for (let i = 0; i < arr.length; i++) {\n    if (Array.isArray(arr[i])) {\n      fn(arr[i]);\n    } else {\n      res5.push(arr[i]);\n    }\n  }\n}\nfn(arr);\n\n\n\n# 02.数组去重\n\nconst arr = [1, 1, '1', 17, true, true, false, false, 'true', 'a', {}, {}];\n// => [1, '1', 17, true, false, 'true', 'a', {}, {}]\n\n\n方法一：利用Set\n\nconst res1 = Array.from(new Set(arr));\n\n\n方法二：两层for循环+splice\n\nconst unique1 = arr => {\n  let len = arr.length;\n  for (let i = 0; i < len; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (arr[i] === arr[j]) {\n        arr.splice(j, 1);\n        // 每删除一个树，j--保证j的值经过自加后不变。同时，len--，减少循环次数提升性能\n        len--;\n        j--;\n      }\n    }\n  }\n  return arr;\n}\n\n\n方法三：利用indexOf\n\nconst unique2 = arr => {\n  const res = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (res.indexOf(arr[i]) === -1) res.push(arr[i]);\n  }\n  return res;\n}\n\n\n当然也可以用include、filter，思路大同小异。\n\n方法四：利用include\n\nconst unique3 = arr => {\n  const res = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (!res.includes(arr[i])) res.push(arr[i]);\n  }\n  return res;\n}\n\n\n方法五：利用filter\n\nconst unique4 = arr => {\n  return arr.filter((item, index) => {\n    return arr.indexOf(item) === index;\n  });\n}\n\n\n方法六：利用Map\n\nconst unique5 = arr => {\n  const map = new Map();\n  const res = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (!map.has(arr[i])) {\n      map.set(arr[i], true)\n      res.push(arr[i]);\n    }\n  }\n  return res;\n}\n\n\n\n# 03.类数组转化为数组\n\n类数组是具有length属性，但不具有数组原型上的方法。常见的类数组有arguments、DOM操作方法返回的结果。\n\n方法一：Array.from\n\nArray.from(document.querySelectorAll('div'))\n\n\n方法二：Array.prototype.slice.call()\n\nArray.prototype.slice.call(document.querySelectorAll('div'))\n\n\n方法三：扩展运算符\n\n[...document.querySelectorAll('div')]\n\n\n方法四：利用concat\n\nArray.prototype.concat.apply([], document.querySelectorAll('div'));\n\n\n\n# 04.Array.prototype.filter()\n\n语法\n\nvar newArray = arr.filter(callback(element[,index[,arry]])[,thisArg])\n\n\n参数\n\ncallback：用来测试数组的每个元素的函数。返回true表示该元素通过测试，保留该元素，false则不保留。它接受以下三个参数：\n\nelement：数组中当前正在处理的元素\n\nindex：（可选）正在处理的元素在数组中的索引。\n\narray：（可选）调用了filter的数组本身。\n\nthisArg：（可选）执行callback时，用于this的值。\n\n返回值\n\n一个新的、由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组\n\nArray.prototype.filter = function(callback, thisArg) {\n    if (this == undefined) {\n        throw new TypeError('this is null or not undefined');\n    }\n    if (typeof callback !== 'function') {\n        throw new TypeError(callback + 'is not a function');\n    }\n    const res = [];\n    // 让O成为回调函数的对象传递（强制转换对象）\n    const O = Object(this);\n    // >>>0 保证len为number，且为正整数\n    const len = O.length >>> 0;\n    for (let i = 0; i < len; i++) {\n        // 检查i是否在O的属性（会检查原型链）\n        if (i in O) {\n            // 回调函数调用传参\n            if (callback.call(thisArg, O[i], i, O)) {\n                res.push(O[i]);\n            }\n        }\n    }\n    return res;\n}\n\n\n对于>>>0有疑问的：解释>>>0的作用\n\n\n# 05.Array.prototype.map()\n\n参数\n\ncallback：生成新数组元素的函数，使用三个参数：\n\ncurrentValue：callback数组中正在处理的当前元素。\n\nindex：（可选）callback数组中正在处理的当前元素的索引。\n\narray：（可选）map方法调用的数组。\n\nthisArg：（可选）执行callback函数时值被用作this。\n\n返回值\n\n执行由原数组每个元素执行回调函数的结果组成的新数组\n\nArray.prototype.map = function(callback, thisArg) {\n    if (this == undefined) {\n        throw new TypeError('this is null or not defined');\n    }\n    if (typeof callback !== 'function') {\n        throw new TypeError(callback + ' is not a function');\n    }\n    const res = [];\n    // 同理\n    const O = Object(this);\n    const len = O.length >>> 0;\n    for (let i = 0; i < len; i++) {\n        if (i in O) {\n            // 调用回调函数并传入新数组\n            res[i] = callback.call(thisArg, O[i], i, this);\n        }\n    }\n    return res;\n}\n\n\n\n# 06.Array.prototype.forEach()\n\n参数\n\ncallback：为数组中每个元素执行的函数，该函数接收一至三个参数：\n\ncurrentValue：数组中正在处理的当前元素。\n\nindex：（可选）数组中正在处理的当前元素的索引。\n\narray：（可选）forEach方法正在操作的数组。\n\nthisArg：（可选）执行callback函数时值被用作this。\n\n返回值\n\nundefined\n\nforEach跟map类似，唯一不同的是forEach是没有返回值的。\n\nArray.prototype.forEach = function(callback, thisArg) {\n    if (this == null) {\n        throw new TypeError('this is null or not defined');\n    }\n    if (typeof callback !== \"function\") {\n        throw new TypeError(callback + ' is not a function');\n    }\n    const O = Object(this);\n    const len = O.length >>> 0;\n    let k = 0;\n    while (k < len) {\n        if (k in O) {\n            callback.call(thisArg, O[k], k, O);\n        }\n        k++;\n    }\n}\n\n\n\n# 07.Array.prototype.reduce()\n\n参数\n\ncallback：执行数组中每个值（如果没有提供initialValue则第一个值除外）的函数，包含四个参数：\n\naccumulator：累计器累计回调的返回值；他是上一次调用回调时返回的累积值，或initialValue（见于下方）。\n\ncurrentValue：数组中正在处理的当前元素。\n\nindex：（可选）数组中正在处理的当前元素的索引。如果提供了initialValue，则起始索引号为0，否则从索引1起始。\n\narray：（可选）reduce方法正在操作的数组。\n\ninitialValue：（可选）\n\n返回值\n\n函数累计处理的结果\n\nArray.prototype.reduce = function(callback, initialValue) {\n  if (this == undefined) {\n    throw new TypeError('this is null or not defined');\n  }\n  if (typeof callback !== 'function') {\n    throw new TypeError(callbackfn + ' is not a function');\n  }\n  const O = Object(this);\n  const len = this.length >>> 0;\n  let accumulator = initialValue;\n  let k = 0;\n  // 如果第二个参数为undefined的情况下\n  // 则数组的第一个有效值作为累加器的初始值\n  if (accumulator === undefined) {\n    while (k < len && !(k in O)) {\n      k++;\n    }\n    // 如果超出数组界限还没有找到累加器的初始值，则TypeError\n    if (k >= len) {\n      throw new TypeError('Reduce of empty array with no initial value');\n    }\n    accumulator = O[k++];\n  }\n  while (k < len) {\n    if (k in O) {\n      accumulator = callback.call(undefined, accumulator, O[k], k, O);\n    }\n    k++;\n  }\n  return accumulator;\n}\n\n\n\n# 08.Function.prototype.apply()\n\n第一个参数是绑定的this，默认为window，第二个参数是数组或类数组\n\nFunction.prototype.apply = function(context = window, args) {\n    if (typeof this !== 'function') {\n        throw new TypeError('Type Error');\n    }\n    const fn = Symbol('fn');\n    context[fn] = this;\n\n    const res = context[fn](...args);\n    delete context[fn];\n    return res;\n}\n\n\n\n# 09.Function.prototype.call\n\n于call唯一不同的是，call()方法接受的是一个参数列表\n\nFunction.prototype.call = function(context = window, ...args) {\n    if (typeof this !== 'function') {\n        throw new TypeError('Type Error');\n    }\n    const fn = Symbol('fn');\n    context[fn] = this;\n\n    const res = this[fn](...args);\n    delete this.fn;\n    return res;\n}\n\n\n\n# 10.Function.prototype.bind\n\nFunction.prototype.bind = function(context, ...args) {\n    if (typeof this !== 'function') {\n        throw new Error(\"Type Error\");\n    }\n    // 保存this的值\n    var self = this;\n\n    return function F() {\n        // 考虑new的情况\n        if(this instanceof F) {\n            return new self(...args, ...arguments)\n        }\n        return self.apply(context, [...args, ...arguments])\n    }\n}\n\n\n\n# 11.debounce（防抖）\n\n触发高频时间后n秒内函数只会执行一次,如果n秒内高频时间再次触发,则重新计算时间。\n\nconst debounce = (fn, time) => {\n    let timeout = null;\n    return function() {\n        clearTimeout(timeout)\n        timeout = setTimeout(() => {\n            fn.apply(this, arguments);\n        }, time);\n    }\n};\n\n\n防抖常应用于用户进行搜索输入节约请求资源，window触发resize事件时进行防抖只触发一次。\n\n\n# 12.throttle（节流）\n\n高频时间触发,但n秒内只会执行一次,所以节流会稀释函数的执行频率。\n\nconst throttle = (fn, time) => {\n    let flag = true;\n    return function() {\n        if (!flag) return;\n        flag = false;\n        setTimeout(() => {\n            fn.apply(this, arguments);\n            flag = true;\n        }, time);\n    }\n}\n\n\n节流常应用于鼠标不断点击触发、监听滚动事件。\n\n\n# 13.函数珂里化\n\n> 指的是将一个接受多个参数的函数 变为 接受一个参数返回一个函数的固定形式，这样便于再次调用，例如f(1)(2)\n\n经典面试题：实现add(1)(2)(3)(4)=10; 、 add(1)(1,2,3)(2)=9;\n\nfunction add() {\n  const _args = [...arguments];\n  function fn() {\n    _args.push(...arguments);\n    return fn;\n  }\n  fn.toString = function() {\n    return _args.reduce((sum, cur) => sum + cur);\n  }\n  return fn;\n}\n\n\n\n# 14.模拟new操作\n\n3个步骤：\n\n 1. 以ctor.prototype为原型创建一个对象。\n 2. 执行构造函数并将this绑定到新创建的对象上。\n 3. 判断构造函数执行返回的结果是否是引用数据类型，若是则返回构造函数执行的结果，否则返回创建的对象。\n\nfunction newOperator(ctor, ...args) {\n  if (typeof ctor !== 'function') {\n    throw new TypeError('Type Error');\n  }\n  const obj = Object.create(ctor.prototype);\n  const res = ctor.apply(obj, args);\n\n  const isObject = typeof res === 'object' && res !== null;\n  const isFunction = typeof res === 'function';\n  return isObject || isFunction ? res : obj;\n}\n\n\n\n# 15.instanceof\n\ninstanceof运算符用于检测构造函数的prototype属性是否出现在某个实例对象的原型链上。\n\nconst myInstanceof = (left, right) => {\n  // 基本数据类型都返回false\n  if (typeof left !== 'object' || left === null) return false;\n  let proto = Object.getPrototypeOf(left);\n  while (true) {\n    if (proto === null) return false;\n    if (proto === right.prototype) return true;\n    proto = Object.getPrototypeOf(proto);\n  }\n}\n\n\n\n# 16.原型继承\n\n这里只写寄生组合继承了，中间还有几个演变过来的继承但都有一些缺陷\n\nfunction Parent5) {\n  this.name = 'parent';\n}\nfunction Child() {\n  Parent.call(this);\n  this.type = 'children';\n}\nChild.prototype = Object.create(Parent.prototype);\nChild.prototype.constructor = Child;\n\n\n\n# 17.Object.is\n\nObject.is解决的主要是这两个问题：\n\n+0 === -0  // true\nNaN === NaN // false\n\n\nconst is= (x, y) => {\n  if (x === y) {\n    // +0和-0应该不相等\n    return x !== 0 || y !== 0 || 1/x === 1/y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\n\n\n\n# 18.Object.assign\n\nObject.assign()方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象（请注意这个操作是浅拷贝）\n\nObject.defineProperty(Object, 'assign', {\n  value: function(target, ...args) {\n    if (target == null) {\n      return new TypeError('Cannot convert undefined or null to object');\n    }\n\n    // 目标对象需要统一是引用数据类型，若不是会自动转换\n    const to = Object(target);\n\n    for (let i = 0; i < args.length; i++) {\n      // 每一个源对象\n      const nextSource = args[i];\n      if (nextSource !== null) {\n        // 使用for...in和hasOwnProperty双重判断，确保只拿到本身的属性、方法（不包含继承的）\n        for (const nextKey in nextSource) {\n          if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n            to[nextKey] = nextSource[nextKey];\n          }\n        }\n      }\n    }\n    return to;\n  },\n  // 不可枚举\n  enumerable: false,\n  writable: true,\n  configurable: true,\n})\n\n\n\n# 19.深拷贝\n\n递归的完整版本（考虑到了Symbol属性）：\n\nconst cloneDeep1 = (target, hash = new WeakMap()) => {\n  // 对于传入参数处理\n  if (typeof target !== 'object' || target === null) {\n    return target;\n  }\n  // 哈希表中存在直接返回\n  if (hash.has(target)) return hash.get(target);\n\n  const cloneTarget = Array.isArray(target) ? [] : {};\n  hash.set(target, cloneTarget);\n\n  // 针对Symbol属性\n  const symKeys = Object.getOwnPropertySymbols(target);\n  if (symKeys.length) {\n    symKeys.forEach(symKey => {\n      if (typeof target[symKey] === 'object' && target[symKey] !== null) {\n        cloneTarget[symKey] = cloneDeep1(target[symKey]);\n      } else {\n        cloneTarget[symKey] = target[symKey];\n      }\n    })\n  }\n\n  for (const i in target) {\n    if (Object.prototype.hasOwnProperty.call(target, i)) {\n      cloneTarget[i] =\n        typeof target[i] === 'object' && target[i] !== null\n        ? cloneDeep1(target[i], hash)\n        : target[i];\n    }\n  }\n  return cloneTarget;\n}\n\n\n\n# 20.Promise\n\n实现思路：Promise源码实现\n\nconst PENDING = 'PENDING';      // 进行中\nconst FULFILLED = 'FULFILLED';  // 已成功\nconst REJECTED = 'REJECTED';    // 已失败\n\nclass Promise {\n  constructor(exector) {\n    // 初始化状态\n    this.status = PENDING;\n    // 将成功、失败结果放在this上，便于then、catch访问\n    this.value = undefined;\n    this.reason = undefined;\n    // 成功态回调函数队列\n    this.onFulfilledCallbacks = [];\n    // 失败态回调函数队列\n    this.onRejectedCallbacks = [];\n\n    const resolve = value => {\n      // 只有进行中状态才能更改状态\n      if (this.status === PENDING) {\n        this.status = FULFILLED;\n        this.value = value;\n        // 成功态函数依次执行\n        this.onFulfilledCallbacks.forEach(fn => fn(this.value));\n      }\n    }\n    const reject = reason => {\n      // 只有进行中状态才能更改状态\n      if (this.status === PENDING) {\n        this.status = REJECTED;\n        this.reason = reason;\n        // 失败态函数依次执行\n        this.onRejectedCallbacks.forEach(fn => fn(this.reason))\n      }\n    }\n    try {\n      // 立即执行executor\n      // 把内部的resolve和reject传入executor，用户可调用resolve和reject\n      exector(resolve, reject);\n    } catch(e) {\n      // executor执行出错，将错误内容reject抛出去\n      reject(e);\n    }\n  }\n  then(onFulfilled, onRejected) {\n    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;\n    onRejected = typeof onRejected === 'function'? onRejected:\n      reason => { throw new Error(reason instanceof Error ? reason.message:reason) }\n    // 保存this\n    const self = this;\n    return new Promise((resolve, reject) => {\n      if (self.status === PENDING) {\n        self.onFulfilledCallbacks.push(() => {\n          // try捕获错误\n          try {\n            // 模拟微任务\n            setTimeout(() => {\n              const result = onFulfilled(self.value);\n              // 分两种情况：\n              // 1. 回调函数返回值是Promise，执行then操作\n              // 2. 如果不是Promise，调用新Promise的resolve函数\n              result instanceof Promise ? result.then(resolve, reject) : resolve(result);\n            })\n          } catch(e) {\n            reject(e);\n          }\n        });\n        self.onRejectedCallbacks.push(() => {\n          // 以下同理\n          try {\n            setTimeout(() => {\n              const result = onRejected(self.reason);\n              // 不同点：此时是reject\n              result instanceof Promise ? result.then(resolve, reject) : reject(result);\n            })\n          } catch(e) {\n            reject(e);\n          }\n        })\n      } else if (self.status === FULFILLED) {\n        try {\n          setTimeout(() => {\n            const result = onFulfilled(self.value);\n            result instanceof Promise ? result.then(resolve, reject) : resolve(result);\n          });\n        } catch(e) {\n          reject(e);\n        }\n      } else if (self.status === REJECTED){\n        try {\n          setTimeout(() => {\n            const result = onRejected(self.reason);\n            result instanceof Promise ? result.then(resolve, reject) : reject(result);\n          })\n        } catch(e) {\n          reject(e);\n        }\n      }\n    });\n  }\n  catch(onRejected) {\n    return this.then(null, onRejected);\n  }\n  static resolve(value) {\n    if (value instanceof Promise) {\n      // 如果是Promise实例，直接返回\n      return value;\n    } else {\n      // 如果不是Promise实例，返回一个新的Promise对象，状态为FULFILLED\n      return new Promise((resolve, reject) => resolve(value));\n    }\n  }\n  static reject(reason) {\n    return new Promise((resolve, reject) => {\n      reject(reason);\n    })\n  }\n}\n\n\n\n# 21.Promise.all\n\nPromise.all是支持链式调用的，本质上就是返回了一个Promise实例，通过resolve和reject来改变实例状态。\n\nPromise.myAll = function(promiseArr) {\n  return new Promise((resolve, reject) => {\n    const ans = [];\n    let index = 0;\n    for (let i = 0; i < promiseArr.length; i++) {\n      promiseArr[i]\n      .then(res => {\n        ans[i] = res;\n        index++;\n        if (index === promiseArr.length) {\n          resolve(ans);\n        }\n      })\n      .catch(err => reject(err));\n    }\n  })\n}\n\n\n\n# 22.Promise.race\n\nPromise.race = function(promiseArr) {\n  return new Promise((resolve, reject) => {\n    promiseArr.forEach(p => {\n      // 如果不是Promise实例需要转化为Promise实例\n      Promise.resolve(p).then(\n        val => resolve(val),\n        err => reject(err),\n      )\n    })\n  })\n}\n\n\n\n# 23.Promise并行限制\n\n就是实现有并行限制的Promise调度器问题。\n\n详细实现思路：某条高频面试原题：实现有并行限制的Promise调度器\n\nclass Scheduler {\n  constructor() {\n    this.queue = [];\n    this.maxCount = 2;\n    this.runCounts = 0;\n  }\n  add(promiseCreator) {\n    this.queue.push(promiseCreator);\n  }\n  taskStart() {\n    for (let i = 0; i < this.maxCount; i++) {\n      this.request();\n    }\n  }\n  request() {\n    if (!this.queue || !this.queue.length || this.runCounts >= this.maxCount) {\n      return;\n    }\n    this.runCounts++;\n\n    this.queue.shift()().then(() => {\n      this.runCounts--;\n      this.request();\n    });\n  }\n}\n\nconst timeout = time => new Promise(resolve => {\n  setTimeout(resolve, time);\n})\n\nconst scheduler = new Scheduler();\n\nconst addTask = (time,order) => {\n  scheduler.add(() => timeout(time).then(()=>console.log(order)))\n}\n\n\naddTask(1000, '1');\naddTask(500, '2');\naddTask(300, '3');\naddTask(400, '4');\nscheduler.taskStart()\n// 2\n// 3\n// 1\n// 4\n\n\n\n# 24.JSONP\n\nscript标签不遵循同源协议，可以用来进行跨域请求，优点就是兼容性好但仅限于GET请求\n\nconst jsonp = ({ url, params, callbackName }) => {\n  const generateUrl = () => {\n    let dataSrc = '';\n    for (let key in params) {\n      if (Object.prototype.hasOwnProperty.call(params, key)) {\n        dataSrc += `${key}=${params[key]}&`;\n      }\n    }\n    dataSrc += `callback=${callbackName}`;\n    return `${url}?${dataSrc}`;\n  }\n  return new Promise((resolve, reject) => {\n    const scriptEle = document.createElement('script');\n    scriptEle.src = generateUrl();\n    document.body.appendChild(scriptEle);\n    window[callbackName] = data => {\n      resolve(data);\n      document.removeChild(scriptEle);\n    }\n  })\n}\n\n\n\n# 25.AJAX\n\nconst getJSON = function(url) {\n  return new Promise((resolve, reject) => {\n    const xhr = XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject('Mscrosoft.XMLHttp');\n    xhr.open('GET', url, false);\n    xhr.setRequestHeader('Accept', 'application/json');\n    xhr.onreadystatechange = function() {\n      if (xhr.readyState !== 4) return;\n      if (xhr.status === 200 || xhr.status === 304) {\n        resolve(xhr.responseText);\n      } else {\n        reject(new Error(xhr.responseText));\n      }\n    }\n    xhr.send();\n  })\n}\n\n\n\n# 26.event模块\n\n实现node中回调函数的机制，node中回调函数其实是内部使用了观察者模式。\n\n> 观察者模式：定义了对象间一种一对多的依赖关系，当目标对象Subject发生改变时，所有依赖它的对象Observer都会得到通知。\n\nfunction EventEmitter() {\n  this.events = new Map();\n}\n\n// 需要实现的一些方法：\n// addListener、removeListener、once、removeAllListeners、emit\n\n// 模拟实现addlistener方法\nconst wrapCallback = (fn, once = false) => ({ callback: fn, once });\nEventEmitter.prototype.addListener = function(type, fn, once = false) {\n  const hanlder = this.events.get(type);\n  if (!hanlder) {\n    // 没有type绑定事件\n    this.events.set(type, wrapCallback(fn, once));\n  } else if (hanlder && typeof hanlder.callback === 'function') {\n    // 目前type事件只有一个回调\n    this.events.set(type, [hanlder, wrapCallback(fn, once)]);\n  } else {\n    // 目前type事件数>=2\n    hanlder.push(wrapCallback(fn, once));\n  }\n}\n// 模拟实现removeListener\nEventEmitter.prototype.removeListener = function(type, listener) {\n  const hanlder = this.events.get(type);\n  if (!hanlder) return;\n  if (!Array.isArray(this.events)) {\n    if (hanlder.callback === listener.callback) this.events.delete(type);\n    else return;\n  }\n  for (let i = 0; i < hanlder.length; i++) {\n    const item = hanlder[i];\n    if (item.callback === listener.callback) {\n      hanlder.splice(i, 1);\n      i--;\n      if (hanlder.length === 1) {\n        this.events.set(type, hanlder[0]);\n      }\n    }\n  }\n}\n// 模拟实现once方法\nEventEmitter.prototype.once = function(type, listener) {\n  this.addListener(type, listener, true);\n}\n// 模拟实现emit方法\nEventEmitter.prototype.emit = function(type, ...args) {\n  const hanlder = this.events.get(type);\n  if (!hanlder) return;\n  if (Array.isArray(hanlder)) {\n    hanlder.forEach(item => {\n      item.callback.apply(this, args);\n      if (item.once) {\n        this.removeListener(type, item);\n      }\n    })\n  } else {\n    hanlder.callback.apply(this, args);\n    if (hanlder.once) {\n      this.events.delete(type);\n    }\n  }\n  return true;\n}\nEventEmitter.prototype.removeAllListeners = function(type) {\n  const hanlder = this.events.get(type);\n  if (!hanlder) return;\n  this.events.delete(type);\n}\n\n\n\n# 27.图片懒加载\n\n可以给img标签统一自定义属性data-src='default.png'，当检测到图片出现在窗口之后再补充src属性，此时才会进行图片资源加载。\n\nfunction lazyload() {\n  const imgs = document.getElementsByTagName('img');\n  const len = imgs.length;\n  // 视口的高度\n  const viewHeight = document.documentElement.clientHeight;\n  // 滚动条高度\n  const scrollHeight = document.documentElement.scrollTop || document.body.scrollTop;\n  for (let i = 0; i < len; i++) {\n    const offsetHeight = imgs[i].offsetTop;\n    if (offsetHeight < viewHeight + scrollHeight) {\n      const src = imgs[i].dataset.src;\n      imgs[i].src = src;\n    }\n  }\n}\n\n// 可以使用节流优化一下\nwindow.addEventListener('scroll', lazyload);\n\n\n\n# 28.滚动加载\n\n原理就是监听页面滚动事件，分析clientHeight、scrollTop、scrollHeight三者的属性关系。\n\nwindow.addEventListener('scroll', function() {\n  const clientHeight = document.documentElement.clientHeight;\n  const scrollTop = document.documentElement.scrollTop;\n  const scrollHeight = document.documentElement.scrollHeight;\n  if (clientHeight + scrollTop >= scrollHeight) {\n    // 检测到滚动至页面底部，进行后续操作\n    // ...\n  }\n}, false);\n\n\n一个Demo：页面滚动加载的Demo\n\n\n# 29.渲染几万条数据不卡住页面\n\n渲染大数据时，合理使用createDocumentFragment和requestAnimationFrame，将操作切分为一小段一小段执行。\n\nsetTimeout(() => {\n  // 插入十万条数据\n  const total = 100000;\n  // 一次插入的数据\n  const once = 20;\n  // 插入数据需要的次数\n  const loopCount = Math.ceil(total / once);\n  let countOfRender = 0;\n  const ul = document.querySelector('ul');\n  // 添加数据的方法\n  function add() {\n    const fragment = document.createDocumentFragment();\n    for(let i = 0; i < once; i++) {\n      const li = document.createElement('li');\n      li.innerText = Math.floor(Math.random() * total);\n      fragment.appendChild(li);\n    }\n    ul.appendChild(fragment);\n    countOfRender += 1;\n    loop();\n  }\n  function loop() {\n    if(countOfRender < loopCount) {\n      window.requestAnimationFrame(add);\n    }\n  }\n  loop();\n}, 0)\n\n\n\n# 30.打印出当前网页使用了多少种HTML元素\n\n一行代码可以解决：\n\nconst fn = () => {\n  return [...new Set([...document.querySelectorAll('*')].map(el => el.tagName))].length;\n}\n\n\n值得注意的是：DOM操作返回的是类数组，需要转换为数组之后才可以调用数组的方法。\n\n\n# 31.将VirtualDom转化为真实DOM结构\n\n这是当前SPA应用的核心概念之一\n\n// vnode结构：\n// {\n//   tag,\n//   attrs,\n//   children,\n// }\n\n//Virtual DOM => DOM\nfunction render(vnode, container) {\n  container.appendChild(_render(vnode));\n}\nfunction _render(vnode) {\n  // 如果是数字类型转化为字符串\n  if (typeof vnode === 'number') {\n    vnode = String(vnode);\n  }\n  // 字符串类型直接就是文本节点\n  if (typeof vnode === 'string') {\n    return document.createTextNode(vnode);\n  }\n  // 普通DOM\n  const dom = document.createElement(vnode.tag);\n  if (vnode.attrs) {\n    // 遍历属性\n    Object.keys(vnode.attrs).forEach(key => {\n      const value = vnode.attrs[key];\n      dom.setAttribute(key, value);\n    })\n  }\n  // 子数组进行递归操作\n  vnode.children.forEach(child => render(child, dom));\n  return dom;\n}\n\n\n\n# 32.字符串解析问题\n\nvar a = {\n    b: 123,\n    c: '456',\n    e: '789',\n}\nvar str=`a{a.b}aa{a.c}aa {a.d}aaaa`;\n// => 'a123aa456aa {a.d}aaaa'\n\n\n实现函数使得将str字符串中的{}内的变量替换，如果属性不存在保持原样（比如{a.d}）\n\n类似于模版字符串，但有一点出入，实际上原理大差不差\n\nconst fn1 = (str, obj) => {\n    let res = '';\n    // 标志位，标志前面是否有{\n    let flag = false;\n    let start;\n    for (let i = 0; i < str.length; i++) {\n        if (str[i] === '{') {\n            flag = true;\n            start = i + 1;\n            continue;\n        }\n        if (!flag) res += str[i];\n        else {\n            if (str[i] === '}') {\n                flag = false;\n                res += match(str.slice(start, i), obj);\n            }\n        }\n    }\n    return res;\n}\n// 对象匹配操作\nconst match = (str, obj) => {\n    const keys = str.split('.').slice(1);\n    let index = 0;\n    let o = obj;\n    while (index < keys.length) {\n        const key = keys[index];\n        if (!o[key]) {\n            return `{${str}}`;\n        } else {\n            o = o[key];\n        }\n        index++;\n    }\n    return o;\n}\n\n\n> 原作者姓名：洛",normalizedContent:"# 32个手撕js，彻底摆脱初级前端（面试高频）\n\n\n# 01.数组扁平化\n\n数组扁平化是指将一个多维数组变为一个一维数组\n\nconst arr = [1, [2, [3, [4, 5]]], 6];\n// => [1, 2, 3, 4, 5, 6]\n\n\n方法一：使用flat()\n\nconst res1 = arr.flat(infinity);\n\n\n方法二：利用正则\n\nconst res2 = json.stringify(arr).replace(/\\[|\\]/g, '').split(',');\n\n\n但数据类型都会变为字符串\n\n方法三：正则改良版本\n\nconst res3 = json.parse('[' + json.stringify(arr).replace(/\\[|\\]/g, '') + ']');\n\n\n方法四：使用reduce\n\nconst flatten = arr => {\n  return arr.reduce((pre, cur) => {\n    return pre.concat(array.isarray(cur) ? flatten(cur) : cur);\n  }, [])\n}\nconst res4 = flatten(arr);\n\n\n方法五：函数递归\n\nconst res5 = [];\nconst fn = arr => {\n  for (let i = 0; i < arr.length; i++) {\n    if (array.isarray(arr[i])) {\n      fn(arr[i]);\n    } else {\n      res5.push(arr[i]);\n    }\n  }\n}\nfn(arr);\n\n\n\n# 02.数组去重\n\nconst arr = [1, 1, '1', 17, true, true, false, false, 'true', 'a', {}, {}];\n// => [1, '1', 17, true, false, 'true', 'a', {}, {}]\n\n\n方法一：利用set\n\nconst res1 = array.from(new set(arr));\n\n\n方法二：两层for循环+splice\n\nconst unique1 = arr => {\n  let len = arr.length;\n  for (let i = 0; i < len; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (arr[i] === arr[j]) {\n        arr.splice(j, 1);\n        // 每删除一个树，j--保证j的值经过自加后不变。同时，len--，减少循环次数提升性能\n        len--;\n        j--;\n      }\n    }\n  }\n  return arr;\n}\n\n\n方法三：利用indexof\n\nconst unique2 = arr => {\n  const res = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (res.indexof(arr[i]) === -1) res.push(arr[i]);\n  }\n  return res;\n}\n\n\n当然也可以用include、filter，思路大同小异。\n\n方法四：利用include\n\nconst unique3 = arr => {\n  const res = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (!res.includes(arr[i])) res.push(arr[i]);\n  }\n  return res;\n}\n\n\n方法五：利用filter\n\nconst unique4 = arr => {\n  return arr.filter((item, index) => {\n    return arr.indexof(item) === index;\n  });\n}\n\n\n方法六：利用map\n\nconst unique5 = arr => {\n  const map = new map();\n  const res = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (!map.has(arr[i])) {\n      map.set(arr[i], true)\n      res.push(arr[i]);\n    }\n  }\n  return res;\n}\n\n\n\n# 03.类数组转化为数组\n\n类数组是具有length属性，但不具有数组原型上的方法。常见的类数组有arguments、dom操作方法返回的结果。\n\n方法一：array.from\n\narray.from(document.queryselectorall('div'))\n\n\n方法二：array.prototype.slice.call()\n\narray.prototype.slice.call(document.queryselectorall('div'))\n\n\n方法三：扩展运算符\n\n[...document.queryselectorall('div')]\n\n\n方法四：利用concat\n\narray.prototype.concat.apply([], document.queryselectorall('div'));\n\n\n\n# 04.array.prototype.filter()\n\n语法\n\nvar newarray = arr.filter(callback(element[,index[,arry]])[,thisarg])\n\n\n参数\n\ncallback：用来测试数组的每个元素的函数。返回true表示该元素通过测试，保留该元素，false则不保留。它接受以下三个参数：\n\nelement：数组中当前正在处理的元素\n\nindex：（可选）正在处理的元素在数组中的索引。\n\narray：（可选）调用了filter的数组本身。\n\nthisarg：（可选）执行callback时，用于this的值。\n\n返回值\n\n一个新的、由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组\n\narray.prototype.filter = function(callback, thisarg) {\n    if (this == undefined) {\n        throw new typeerror('this is null or not undefined');\n    }\n    if (typeof callback !== 'function') {\n        throw new typeerror(callback + 'is not a function');\n    }\n    const res = [];\n    // 让o成为回调函数的对象传递（强制转换对象）\n    const o = object(this);\n    // >>>0 保证len为number，且为正整数\n    const len = o.length >>> 0;\n    for (let i = 0; i < len; i++) {\n        // 检查i是否在o的属性（会检查原型链）\n        if (i in o) {\n            // 回调函数调用传参\n            if (callback.call(thisarg, o[i], i, o)) {\n                res.push(o[i]);\n            }\n        }\n    }\n    return res;\n}\n\n\n对于>>>0有疑问的：解释>>>0的作用\n\n\n# 05.array.prototype.map()\n\n参数\n\ncallback：生成新数组元素的函数，使用三个参数：\n\ncurrentvalue：callback数组中正在处理的当前元素。\n\nindex：（可选）callback数组中正在处理的当前元素的索引。\n\narray：（可选）map方法调用的数组。\n\nthisarg：（可选）执行callback函数时值被用作this。\n\n返回值\n\n执行由原数组每个元素执行回调函数的结果组成的新数组\n\narray.prototype.map = function(callback, thisarg) {\n    if (this == undefined) {\n        throw new typeerror('this is null or not defined');\n    }\n    if (typeof callback !== 'function') {\n        throw new typeerror(callback + ' is not a function');\n    }\n    const res = [];\n    // 同理\n    const o = object(this);\n    const len = o.length >>> 0;\n    for (let i = 0; i < len; i++) {\n        if (i in o) {\n            // 调用回调函数并传入新数组\n            res[i] = callback.call(thisarg, o[i], i, this);\n        }\n    }\n    return res;\n}\n\n\n\n# 06.array.prototype.foreach()\n\n参数\n\ncallback：为数组中每个元素执行的函数，该函数接收一至三个参数：\n\ncurrentvalue：数组中正在处理的当前元素。\n\nindex：（可选）数组中正在处理的当前元素的索引。\n\narray：（可选）foreach方法正在操作的数组。\n\nthisarg：（可选）执行callback函数时值被用作this。\n\n返回值\n\nundefined\n\nforeach跟map类似，唯一不同的是foreach是没有返回值的。\n\narray.prototype.foreach = function(callback, thisarg) {\n    if (this == null) {\n        throw new typeerror('this is null or not defined');\n    }\n    if (typeof callback !== \"function\") {\n        throw new typeerror(callback + ' is not a function');\n    }\n    const o = object(this);\n    const len = o.length >>> 0;\n    let k = 0;\n    while (k < len) {\n        if (k in o) {\n            callback.call(thisarg, o[k], k, o);\n        }\n        k++;\n    }\n}\n\n\n\n# 07.array.prototype.reduce()\n\n参数\n\ncallback：执行数组中每个值（如果没有提供initialvalue则第一个值除外）的函数，包含四个参数：\n\naccumulator：累计器累计回调的返回值；他是上一次调用回调时返回的累积值，或initialvalue（见于下方）。\n\ncurrentvalue：数组中正在处理的当前元素。\n\nindex：（可选）数组中正在处理的当前元素的索引。如果提供了initialvalue，则起始索引号为0，否则从索引1起始。\n\narray：（可选）reduce方法正在操作的数组。\n\ninitialvalue：（可选）\n\n返回值\n\n函数累计处理的结果\n\narray.prototype.reduce = function(callback, initialvalue) {\n  if (this == undefined) {\n    throw new typeerror('this is null or not defined');\n  }\n  if (typeof callback !== 'function') {\n    throw new typeerror(callbackfn + ' is not a function');\n  }\n  const o = object(this);\n  const len = this.length >>> 0;\n  let accumulator = initialvalue;\n  let k = 0;\n  // 如果第二个参数为undefined的情况下\n  // 则数组的第一个有效值作为累加器的初始值\n  if (accumulator === undefined) {\n    while (k < len && !(k in o)) {\n      k++;\n    }\n    // 如果超出数组界限还没有找到累加器的初始值，则typeerror\n    if (k >= len) {\n      throw new typeerror('reduce of empty array with no initial value');\n    }\n    accumulator = o[k++];\n  }\n  while (k < len) {\n    if (k in o) {\n      accumulator = callback.call(undefined, accumulator, o[k], k, o);\n    }\n    k++;\n  }\n  return accumulator;\n}\n\n\n\n# 08.function.prototype.apply()\n\n第一个参数是绑定的this，默认为window，第二个参数是数组或类数组\n\nfunction.prototype.apply = function(context = window, args) {\n    if (typeof this !== 'function') {\n        throw new typeerror('type error');\n    }\n    const fn = symbol('fn');\n    context[fn] = this;\n\n    const res = context[fn](...args);\n    delete context[fn];\n    return res;\n}\n\n\n\n# 09.function.prototype.call\n\n于call唯一不同的是，call()方法接受的是一个参数列表\n\nfunction.prototype.call = function(context = window, ...args) {\n    if (typeof this !== 'function') {\n        throw new typeerror('type error');\n    }\n    const fn = symbol('fn');\n    context[fn] = this;\n\n    const res = this[fn](...args);\n    delete this.fn;\n    return res;\n}\n\n\n\n# 10.function.prototype.bind\n\nfunction.prototype.bind = function(context, ...args) {\n    if (typeof this !== 'function') {\n        throw new error(\"type error\");\n    }\n    // 保存this的值\n    var self = this;\n\n    return function f() {\n        // 考虑new的情况\n        if(this instanceof f) {\n            return new self(...args, ...arguments)\n        }\n        return self.apply(context, [...args, ...arguments])\n    }\n}\n\n\n\n# 11.debounce（防抖）\n\n触发高频时间后n秒内函数只会执行一次,如果n秒内高频时间再次触发,则重新计算时间。\n\nconst debounce = (fn, time) => {\n    let timeout = null;\n    return function() {\n        cleartimeout(timeout)\n        timeout = settimeout(() => {\n            fn.apply(this, arguments);\n        }, time);\n    }\n};\n\n\n防抖常应用于用户进行搜索输入节约请求资源，window触发resize事件时进行防抖只触发一次。\n\n\n# 12.throttle（节流）\n\n高频时间触发,但n秒内只会执行一次,所以节流会稀释函数的执行频率。\n\nconst throttle = (fn, time) => {\n    let flag = true;\n    return function() {\n        if (!flag) return;\n        flag = false;\n        settimeout(() => {\n            fn.apply(this, arguments);\n            flag = true;\n        }, time);\n    }\n}\n\n\n节流常应用于鼠标不断点击触发、监听滚动事件。\n\n\n# 13.函数珂里化\n\n> 指的是将一个接受多个参数的函数 变为 接受一个参数返回一个函数的固定形式，这样便于再次调用，例如f(1)(2)\n\n经典面试题：实现add(1)(2)(3)(4)=10; 、 add(1)(1,2,3)(2)=9;\n\nfunction add() {\n  const _args = [...arguments];\n  function fn() {\n    _args.push(...arguments);\n    return fn;\n  }\n  fn.tostring = function() {\n    return _args.reduce((sum, cur) => sum + cur);\n  }\n  return fn;\n}\n\n\n\n# 14.模拟new操作\n\n3个步骤：\n\n 1. 以ctor.prototype为原型创建一个对象。\n 2. 执行构造函数并将this绑定到新创建的对象上。\n 3. 判断构造函数执行返回的结果是否是引用数据类型，若是则返回构造函数执行的结果，否则返回创建的对象。\n\nfunction newoperator(ctor, ...args) {\n  if (typeof ctor !== 'function') {\n    throw new typeerror('type error');\n  }\n  const obj = object.create(ctor.prototype);\n  const res = ctor.apply(obj, args);\n\n  const isobject = typeof res === 'object' && res !== null;\n  const isfunction = typeof res === 'function';\n  return isobject || isfunction ? res : obj;\n}\n\n\n\n# 15.instanceof\n\ninstanceof运算符用于检测构造函数的prototype属性是否出现在某个实例对象的原型链上。\n\nconst myinstanceof = (left, right) => {\n  // 基本数据类型都返回false\n  if (typeof left !== 'object' || left === null) return false;\n  let proto = object.getprototypeof(left);\n  while (true) {\n    if (proto === null) return false;\n    if (proto === right.prototype) return true;\n    proto = object.getprototypeof(proto);\n  }\n}\n\n\n\n# 16.原型继承\n\n这里只写寄生组合继承了，中间还有几个演变过来的继承但都有一些缺陷\n\nfunction parent5) {\n  this.name = 'parent';\n}\nfunction child() {\n  parent.call(this);\n  this.type = 'children';\n}\nchild.prototype = object.create(parent.prototype);\nchild.prototype.constructor = child;\n\n\n\n# 17.object.is\n\nobject.is解决的主要是这两个问题：\n\n+0 === -0  // true\nnan === nan // false\n\n\nconst is= (x, y) => {\n  if (x === y) {\n    // +0和-0应该不相等\n    return x !== 0 || y !== 0 || 1/x === 1/y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\n\n\n\n# 18.object.assign\n\nobject.assign()方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象（请注意这个操作是浅拷贝）\n\nobject.defineproperty(object, 'assign', {\n  value: function(target, ...args) {\n    if (target == null) {\n      return new typeerror('cannot convert undefined or null to object');\n    }\n\n    // 目标对象需要统一是引用数据类型，若不是会自动转换\n    const to = object(target);\n\n    for (let i = 0; i < args.length; i++) {\n      // 每一个源对象\n      const nextsource = args[i];\n      if (nextsource !== null) {\n        // 使用for...in和hasownproperty双重判断，确保只拿到本身的属性、方法（不包含继承的）\n        for (const nextkey in nextsource) {\n          if (object.prototype.hasownproperty.call(nextsource, nextkey)) {\n            to[nextkey] = nextsource[nextkey];\n          }\n        }\n      }\n    }\n    return to;\n  },\n  // 不可枚举\n  enumerable: false,\n  writable: true,\n  configurable: true,\n})\n\n\n\n# 19.深拷贝\n\n递归的完整版本（考虑到了symbol属性）：\n\nconst clonedeep1 = (target, hash = new weakmap()) => {\n  // 对于传入参数处理\n  if (typeof target !== 'object' || target === null) {\n    return target;\n  }\n  // 哈希表中存在直接返回\n  if (hash.has(target)) return hash.get(target);\n\n  const clonetarget = array.isarray(target) ? [] : {};\n  hash.set(target, clonetarget);\n\n  // 针对symbol属性\n  const symkeys = object.getownpropertysymbols(target);\n  if (symkeys.length) {\n    symkeys.foreach(symkey => {\n      if (typeof target[symkey] === 'object' && target[symkey] !== null) {\n        clonetarget[symkey] = clonedeep1(target[symkey]);\n      } else {\n        clonetarget[symkey] = target[symkey];\n      }\n    })\n  }\n\n  for (const i in target) {\n    if (object.prototype.hasownproperty.call(target, i)) {\n      clonetarget[i] =\n        typeof target[i] === 'object' && target[i] !== null\n        ? clonedeep1(target[i], hash)\n        : target[i];\n    }\n  }\n  return clonetarget;\n}\n\n\n\n# 20.promise\n\n实现思路：promise源码实现\n\nconst pending = 'pending';      // 进行中\nconst fulfilled = 'fulfilled';  // 已成功\nconst rejected = 'rejected';    // 已失败\n\nclass promise {\n  constructor(exector) {\n    // 初始化状态\n    this.status = pending;\n    // 将成功、失败结果放在this上，便于then、catch访问\n    this.value = undefined;\n    this.reason = undefined;\n    // 成功态回调函数队列\n    this.onfulfilledcallbacks = [];\n    // 失败态回调函数队列\n    this.onrejectedcallbacks = [];\n\n    const resolve = value => {\n      // 只有进行中状态才能更改状态\n      if (this.status === pending) {\n        this.status = fulfilled;\n        this.value = value;\n        // 成功态函数依次执行\n        this.onfulfilledcallbacks.foreach(fn => fn(this.value));\n      }\n    }\n    const reject = reason => {\n      // 只有进行中状态才能更改状态\n      if (this.status === pending) {\n        this.status = rejected;\n        this.reason = reason;\n        // 失败态函数依次执行\n        this.onrejectedcallbacks.foreach(fn => fn(this.reason))\n      }\n    }\n    try {\n      // 立即执行executor\n      // 把内部的resolve和reject传入executor，用户可调用resolve和reject\n      exector(resolve, reject);\n    } catch(e) {\n      // executor执行出错，将错误内容reject抛出去\n      reject(e);\n    }\n  }\n  then(onfulfilled, onrejected) {\n    onfulfilled = typeof onfulfilled === 'function' ? onfulfilled : value => value;\n    onrejected = typeof onrejected === 'function'? onrejected:\n      reason => { throw new error(reason instanceof error ? reason.message:reason) }\n    // 保存this\n    const self = this;\n    return new promise((resolve, reject) => {\n      if (self.status === pending) {\n        self.onfulfilledcallbacks.push(() => {\n          // try捕获错误\n          try {\n            // 模拟微任务\n            settimeout(() => {\n              const result = onfulfilled(self.value);\n              // 分两种情况：\n              // 1. 回调函数返回值是promise，执行then操作\n              // 2. 如果不是promise，调用新promise的resolve函数\n              result instanceof promise ? result.then(resolve, reject) : resolve(result);\n            })\n          } catch(e) {\n            reject(e);\n          }\n        });\n        self.onrejectedcallbacks.push(() => {\n          // 以下同理\n          try {\n            settimeout(() => {\n              const result = onrejected(self.reason);\n              // 不同点：此时是reject\n              result instanceof promise ? result.then(resolve, reject) : reject(result);\n            })\n          } catch(e) {\n            reject(e);\n          }\n        })\n      } else if (self.status === fulfilled) {\n        try {\n          settimeout(() => {\n            const result = onfulfilled(self.value);\n            result instanceof promise ? result.then(resolve, reject) : resolve(result);\n          });\n        } catch(e) {\n          reject(e);\n        }\n      } else if (self.status === rejected){\n        try {\n          settimeout(() => {\n            const result = onrejected(self.reason);\n            result instanceof promise ? result.then(resolve, reject) : reject(result);\n          })\n        } catch(e) {\n          reject(e);\n        }\n      }\n    });\n  }\n  catch(onrejected) {\n    return this.then(null, onrejected);\n  }\n  static resolve(value) {\n    if (value instanceof promise) {\n      // 如果是promise实例，直接返回\n      return value;\n    } else {\n      // 如果不是promise实例，返回一个新的promise对象，状态为fulfilled\n      return new promise((resolve, reject) => resolve(value));\n    }\n  }\n  static reject(reason) {\n    return new promise((resolve, reject) => {\n      reject(reason);\n    })\n  }\n}\n\n\n\n# 21.promise.all\n\npromise.all是支持链式调用的，本质上就是返回了一个promise实例，通过resolve和reject来改变实例状态。\n\npromise.myall = function(promisearr) {\n  return new promise((resolve, reject) => {\n    const ans = [];\n    let index = 0;\n    for (let i = 0; i < promisearr.length; i++) {\n      promisearr[i]\n      .then(res => {\n        ans[i] = res;\n        index++;\n        if (index === promisearr.length) {\n          resolve(ans);\n        }\n      })\n      .catch(err => reject(err));\n    }\n  })\n}\n\n\n\n# 22.promise.race\n\npromise.race = function(promisearr) {\n  return new promise((resolve, reject) => {\n    promisearr.foreach(p => {\n      // 如果不是promise实例需要转化为promise实例\n      promise.resolve(p).then(\n        val => resolve(val),\n        err => reject(err),\n      )\n    })\n  })\n}\n\n\n\n# 23.promise并行限制\n\n就是实现有并行限制的promise调度器问题。\n\n详细实现思路：某条高频面试原题：实现有并行限制的promise调度器\n\nclass scheduler {\n  constructor() {\n    this.queue = [];\n    this.maxcount = 2;\n    this.runcounts = 0;\n  }\n  add(promisecreator) {\n    this.queue.push(promisecreator);\n  }\n  taskstart() {\n    for (let i = 0; i < this.maxcount; i++) {\n      this.request();\n    }\n  }\n  request() {\n    if (!this.queue || !this.queue.length || this.runcounts >= this.maxcount) {\n      return;\n    }\n    this.runcounts++;\n\n    this.queue.shift()().then(() => {\n      this.runcounts--;\n      this.request();\n    });\n  }\n}\n\nconst timeout = time => new promise(resolve => {\n  settimeout(resolve, time);\n})\n\nconst scheduler = new scheduler();\n\nconst addtask = (time,order) => {\n  scheduler.add(() => timeout(time).then(()=>console.log(order)))\n}\n\n\naddtask(1000, '1');\naddtask(500, '2');\naddtask(300, '3');\naddtask(400, '4');\nscheduler.taskstart()\n// 2\n// 3\n// 1\n// 4\n\n\n\n# 24.jsonp\n\nscript标签不遵循同源协议，可以用来进行跨域请求，优点就是兼容性好但仅限于get请求\n\nconst jsonp = ({ url, params, callbackname }) => {\n  const generateurl = () => {\n    let datasrc = '';\n    for (let key in params) {\n      if (object.prototype.hasownproperty.call(params, key)) {\n        datasrc += `${key}=${params[key]}&`;\n      }\n    }\n    datasrc += `callback=${callbackname}`;\n    return `${url}?${datasrc}`;\n  }\n  return new promise((resolve, reject) => {\n    const scriptele = document.createelement('script');\n    scriptele.src = generateurl();\n    document.body.appendchild(scriptele);\n    window[callbackname] = data => {\n      resolve(data);\n      document.removechild(scriptele);\n    }\n  })\n}\n\n\n\n# 25.ajax\n\nconst getjson = function(url) {\n  return new promise((resolve, reject) => {\n    const xhr = xmlhttprequest ? new xmlhttprequest() : new activexobject('mscrosoft.xmlhttp');\n    xhr.open('get', url, false);\n    xhr.setrequestheader('accept', 'application/json');\n    xhr.onreadystatechange = function() {\n      if (xhr.readystate !== 4) return;\n      if (xhr.status === 200 || xhr.status === 304) {\n        resolve(xhr.responsetext);\n      } else {\n        reject(new error(xhr.responsetext));\n      }\n    }\n    xhr.send();\n  })\n}\n\n\n\n# 26.event模块\n\n实现node中回调函数的机制，node中回调函数其实是内部使用了观察者模式。\n\n> 观察者模式：定义了对象间一种一对多的依赖关系，当目标对象subject发生改变时，所有依赖它的对象observer都会得到通知。\n\nfunction eventemitter() {\n  this.events = new map();\n}\n\n// 需要实现的一些方法：\n// addlistener、removelistener、once、removealllisteners、emit\n\n// 模拟实现addlistener方法\nconst wrapcallback = (fn, once = false) => ({ callback: fn, once });\neventemitter.prototype.addlistener = function(type, fn, once = false) {\n  const hanlder = this.events.get(type);\n  if (!hanlder) {\n    // 没有type绑定事件\n    this.events.set(type, wrapcallback(fn, once));\n  } else if (hanlder && typeof hanlder.callback === 'function') {\n    // 目前type事件只有一个回调\n    this.events.set(type, [hanlder, wrapcallback(fn, once)]);\n  } else {\n    // 目前type事件数>=2\n    hanlder.push(wrapcallback(fn, once));\n  }\n}\n// 模拟实现removelistener\neventemitter.prototype.removelistener = function(type, listener) {\n  const hanlder = this.events.get(type);\n  if (!hanlder) return;\n  if (!array.isarray(this.events)) {\n    if (hanlder.callback === listener.callback) this.events.delete(type);\n    else return;\n  }\n  for (let i = 0; i < hanlder.length; i++) {\n    const item = hanlder[i];\n    if (item.callback === listener.callback) {\n      hanlder.splice(i, 1);\n      i--;\n      if (hanlder.length === 1) {\n        this.events.set(type, hanlder[0]);\n      }\n    }\n  }\n}\n// 模拟实现once方法\neventemitter.prototype.once = function(type, listener) {\n  this.addlistener(type, listener, true);\n}\n// 模拟实现emit方法\neventemitter.prototype.emit = function(type, ...args) {\n  const hanlder = this.events.get(type);\n  if (!hanlder) return;\n  if (array.isarray(hanlder)) {\n    hanlder.foreach(item => {\n      item.callback.apply(this, args);\n      if (item.once) {\n        this.removelistener(type, item);\n      }\n    })\n  } else {\n    hanlder.callback.apply(this, args);\n    if (hanlder.once) {\n      this.events.delete(type);\n    }\n  }\n  return true;\n}\neventemitter.prototype.removealllisteners = function(type) {\n  const hanlder = this.events.get(type);\n  if (!hanlder) return;\n  this.events.delete(type);\n}\n\n\n\n# 27.图片懒加载\n\n可以给img标签统一自定义属性data-src='default.png'，当检测到图片出现在窗口之后再补充src属性，此时才会进行图片资源加载。\n\nfunction lazyload() {\n  const imgs = document.getelementsbytagname('img');\n  const len = imgs.length;\n  // 视口的高度\n  const viewheight = document.documentelement.clientheight;\n  // 滚动条高度\n  const scrollheight = document.documentelement.scrolltop || document.body.scrolltop;\n  for (let i = 0; i < len; i++) {\n    const offsetheight = imgs[i].offsettop;\n    if (offsetheight < viewheight + scrollheight) {\n      const src = imgs[i].dataset.src;\n      imgs[i].src = src;\n    }\n  }\n}\n\n// 可以使用节流优化一下\nwindow.addeventlistener('scroll', lazyload);\n\n\n\n# 28.滚动加载\n\n原理就是监听页面滚动事件，分析clientheight、scrolltop、scrollheight三者的属性关系。\n\nwindow.addeventlistener('scroll', function() {\n  const clientheight = document.documentelement.clientheight;\n  const scrolltop = document.documentelement.scrolltop;\n  const scrollheight = document.documentelement.scrollheight;\n  if (clientheight + scrolltop >= scrollheight) {\n    // 检测到滚动至页面底部，进行后续操作\n    // ...\n  }\n}, false);\n\n\n一个demo：页面滚动加载的demo\n\n\n# 29.渲染几万条数据不卡住页面\n\n渲染大数据时，合理使用createdocumentfragment和requestanimationframe，将操作切分为一小段一小段执行。\n\nsettimeout(() => {\n  // 插入十万条数据\n  const total = 100000;\n  // 一次插入的数据\n  const once = 20;\n  // 插入数据需要的次数\n  const loopcount = math.ceil(total / once);\n  let countofrender = 0;\n  const ul = document.queryselector('ul');\n  // 添加数据的方法\n  function add() {\n    const fragment = document.createdocumentfragment();\n    for(let i = 0; i < once; i++) {\n      const li = document.createelement('li');\n      li.innertext = math.floor(math.random() * total);\n      fragment.appendchild(li);\n    }\n    ul.appendchild(fragment);\n    countofrender += 1;\n    loop();\n  }\n  function loop() {\n    if(countofrender < loopcount) {\n      window.requestanimationframe(add);\n    }\n  }\n  loop();\n}, 0)\n\n\n\n# 30.打印出当前网页使用了多少种html元素\n\n一行代码可以解决：\n\nconst fn = () => {\n  return [...new set([...document.queryselectorall('*')].map(el => el.tagname))].length;\n}\n\n\n值得注意的是：dom操作返回的是类数组，需要转换为数组之后才可以调用数组的方法。\n\n\n# 31.将virtualdom转化为真实dom结构\n\n这是当前spa应用的核心概念之一\n\n// vnode结构：\n// {\n//   tag,\n//   attrs,\n//   children,\n// }\n\n//virtual dom => dom\nfunction render(vnode, container) {\n  container.appendchild(_render(vnode));\n}\nfunction _render(vnode) {\n  // 如果是数字类型转化为字符串\n  if (typeof vnode === 'number') {\n    vnode = string(vnode);\n  }\n  // 字符串类型直接就是文本节点\n  if (typeof vnode === 'string') {\n    return document.createtextnode(vnode);\n  }\n  // 普通dom\n  const dom = document.createelement(vnode.tag);\n  if (vnode.attrs) {\n    // 遍历属性\n    object.keys(vnode.attrs).foreach(key => {\n      const value = vnode.attrs[key];\n      dom.setattribute(key, value);\n    })\n  }\n  // 子数组进行递归操作\n  vnode.children.foreach(child => render(child, dom));\n  return dom;\n}\n\n\n\n# 32.字符串解析问题\n\nvar a = {\n    b: 123,\n    c: '456',\n    e: '789',\n}\nvar str=`a{a.b}aa{a.c}aa {a.d}aaaa`;\n// => 'a123aa456aa {a.d}aaaa'\n\n\n实现函数使得将str字符串中的{}内的变量替换，如果属性不存在保持原样（比如{a.d}）\n\n类似于模版字符串，但有一点出入，实际上原理大差不差\n\nconst fn1 = (str, obj) => {\n    let res = '';\n    // 标志位，标志前面是否有{\n    let flag = false;\n    let start;\n    for (let i = 0; i < str.length; i++) {\n        if (str[i] === '{') {\n            flag = true;\n            start = i + 1;\n            continue;\n        }\n        if (!flag) res += str[i];\n        else {\n            if (str[i] === '}') {\n                flag = false;\n                res += match(str.slice(start, i), obj);\n            }\n        }\n    }\n    return res;\n}\n// 对象匹配操作\nconst match = (str, obj) => {\n    const keys = str.split('.').slice(1);\n    let index = 0;\n    let o = obj;\n    while (index < keys.length) {\n        const key = keys[index];\n        if (!o[key]) {\n            return `{${str}}`;\n        } else {\n            o = o[key];\n        }\n        index++;\n    }\n    return o;\n}\n\n\n> 原作者姓名：洛",charsets:{cjk:!0}},{title:"计算机网络",frontmatter:{},regularPath:"/progress/interview2.html",relativePath:"progress/interview2.md",key:"v-041e49d4",path:"/progress/interview2.html",headers:[{level:2,title:"基础问题",slug:"基础问题",normalizedTitle:"基础问题",charIndex:2674},{level:2,title:"进阶问题",slug:"进阶问题",normalizedTitle:"进阶问题",charIndex:3324},{level:2,title:"输出题",slug:"输出题",normalizedTitle:"输出题",charIndex:4634}],headersStr:"基础问题 进阶问题 输出题",content:"# 计算机网络\n\n * 常见状态码知道哪些？304 403 405分别是什么\n * http 状态码 302 504分别代表什么意思\n * 响应状态码，200(from disk cache)，200（from memory cache），304 的区别。\n * POST 和 GET 的区别，除了长度，安全其他的\n * http 介绍一下，为什么 http2.0 不普及，websocket 的基本指令，性能\n * 爬虫，网站如何去做防止，如何判断\n * tcp 和 udp 区别\n * 那如果让你做一个视频聊天软件，你用 tcp 还是 udp ？为什么？\n * tcp 是怎么去保证可靠传输的？\n * tcp 三次握手\n * tcp 握手结束第一次的包有多大\n * TCP 的超时重传\n * TCP 为什么是三次握手呢？\n * TCP 如何去终止之前发送报文的？\n * tcp 拥塞控制（四部分）\n * CDN 的原理是什么\n * dns 过程\n * HTTP 协议，1.1 和 2.0 的区别，了解哪些请求方法，请求/响应头部\n * 为什么项目不用 https 以及 http 与 https 的区别\n * https 的加密过程以及如何防止中间人攻击\n * 为什么 tcp 连接是可靠的（校验和重传）\n * 通过什么机制处理服务端接收数据乱序丢包等（滑动窗口和拥塞控制）\n * 在 TCP 建立连接后，路由器发生了什么变化\n * http 的 header 和 body 讲的很详细 请求方式 请求头内容 状态码\n * http2 相关问题。在 http1 的时代，会经常把很多资源部署在不同域名下，为什么？（有可能是减少 cookie 的传输量）\n * TCP 和 UDP 的区别和场景，又问如果让你设计一个既保证准确性速度又快的协议，怎么做\n * OSI7 层模型 每层大致用处及相关协议\n * https ,http2.0，websocket(提了一下)，TLS握手，怎么知道数字证书的真假\n * http2.0 有了解吗？有抓包看看到底什么个情况吗？\n * cookie session 区别\n * session 怎么保存、有多台服务器，sessionid 怎么找\n * 为什么 cookie 可以用来保存登录状态\n * http 头部 chunk\n * get 发一个 tcp 包，post 发两个 tcp 包，这种情况是一定的吗，什么情况下不是这样\n * post 如何把数据放到 url 中\n * 一个 http 的报文的头和 body 之间有什么分隔\n * 出现 304 的场景，通过什么协议头来确认（304 的响应头）\n * websocket 原理，如何实现，和 http 报文结构有哪些不同（注意是结构不是特性）\n * cookie，localStorage，sessionStorage 使用和区别\n * ca 验证\n * wireshark 能抓包到 https 请求的内容吗\n * https 怎么预防中间人攻击\n * http 请求的过程中怎么知道数据已经发送完毕要断开连接，怎么断开\n * 网络的七层模型\n * get post head 这些请求方式有什么不同\n * 了解轮询和 websocket 吗？\n * 说一下 websocket 的四个阶段（websocket 不能使用时要怎么处理、使用什么方式来代替 websocket）\n\n\n# 操作系统\n\n * 进程和线程\n * 进程之间的通信知道吗？node 中自己实现过哪种通信？（说了管道，消息队列，套接字，信号量啥的，表示自己不会 node，没实现过，说了浏览器的多个 tag 之间也属于进程通信，表示不满意，不要说应用层上的东西）\n\n\n# 浏览器工作原理\n\n * 同源是什么意思，除了那三个没有了么\n * 事件冒泡和事件捕获，应用？注意？\n * 事件轮询 Eventloop\n * promise、console.log、setTimeout、执行顺序\n * 重绘和重排\n * URl 到页面加载过程\n * 跨域问题，解决，jsonp 原理，不受跨域影响的标签\n * Etag 是什么？\n * 浏览器储存 cookie，localStorage，sessionStorage 详细区别\n * http 缓存，如果缓存还在有效期内，但是资源变更了怎么办\n * jsonp 跨域的安全问题\n * cors 跨域，要支持两个域名怎么做\n * js 会阻塞加载，怎么阻塞的？\n * http 缓存更新静态文件的方式\n * postmessage\n * 浏览器卡顿，你怎么去排除？（服务器到后台都讲了一遍，他告诉我如果数据没问题，是浏览器的问题怎么排除，我说了代码中打断点调试，他不满意，说我 Chrome 的调试工具台掌握很不好）\n * PC浏览器的分布？主流浏览器的版本\n * 缓存问题，Etag 和 IF-modify-since 是怎么来的？\n * 非同源 cookie 怎么访问\n * 如果要你缓存图片你怎么做？\n * 有多台服务器，sessionid 怎么找\n\n\n# 浏览器安全\n\n * 知道哪些前端危险？如何防御\n * XSS 的原理，如何防御 XSS？为什么换成实体字符就好了？\n * 假如说某链接获取到你的敏感信息，发送奇怪请求到服务器，你怎么去防御？\n * 讲一讲 cookie 是怎么发送到服务端，具体过程，尽量详细\n * csrf token 能存储在 cookie 里吗？其实是可以的，只要服务端不要去从 cookie 里面取 csrf token 就行\n * 黑客是怎么去利用 cookie 的？这个请求到底是怎么构造的？\n * http 请求中 option 主要是干什么的\n * xss 的原理和防御措施（讲了加强 cookie，过滤输入，过滤输出）\n * CSRF 了解过吗，它的攻击流程是怎样的，如何防御（refencer 可不可以被修改、token 可不可以被窃取，既然有漏洞那不是白做了）\n\n\n# HTML\n\n * div 里面嵌套一个 tip，当 tip 改变的时候，div 会重新渲染吗，怎么样实现 div 不会重新渲染\n * html5 新特性\n * HTML 跟 HTML5 的区别（解释了本质区别，框架上的区别）\n * web 语义化、语义化标签有哪些、section 标签的作用\n\n\n# JS\n\n\n# 基础问题\n\n * let,const,var 的区别。const 定义的对象是否可以修改\n * js 的原型和原型链，原型链的终点在哪里？\n * js 的基本数据类型\n * 事件委托，详细讲\n * es6 新特性，常用语法有哪些\n * this 的原理，call，apply，bind 的区别\n * 全等和弱等的区别\n * 构造函数的原型\n * 函数柯里化\n * 数组浅拷贝\n * 立即执行函数\n * 浏览器事件模型, IE的有什么特殊, 如何兼容(attachEvent与addEventListener)\n * js 宏任务和微任务\n * 数组查找的方法\n * 了解过 for...of 吗\n * class 继承和 js 继承的区别\n * {}的原型链\n * typeof null 是什么，为什么是这个结果。\n * typeof 和 instanceof 有什么区别，说说判断的原理\n * 数组里面新加的方法你有用过哪些？\n * 微任务有哪些？\n * 如何判断 Array 和 Object\n * js 精度问题（0.1+0.2==0.3的问题）\n * 讲一下 generator 生成器\n * 讲一下声明提升\n * 讲一下块作用域\n * 原型对象的 constructor 指向谁\n * dom 规范跟 js 规范有什么区别？\n * js 定时器，设置一个时间，会在那个时间之后准时执行吗？\n * transition 有什么需要注意的地方？\n * js 的错误监控机制有了解吗？\n\n\n# 进阶问题\n\n * 闭包，应用\n * 防抖，节流\n * setTimeout 第二个参数为0时和匿名自执行函数区别\n * js 里堆和栈的区别\n * new 操作符之后的操作\n * this 指向\n * ES6 的使用，相比ES5的好处\n * 简单说一下 es6 的 symbol 属性\n * ES6的新特性（变量声明，字符串模板，数组的新方法 flat，函数的默认值，箭头函数、class 继承，promise，await/async 讲的很详细）\n * 如果要同时启动两个异步任务，怎么做\n * 深拷贝/浅拷贝问题\n * 说一下链表的实现\n * bind(object).bind(windows) 后的 this 指向\n * 构造继承里 Function.call(argu)里传进来的参数 argu 是什么\n * promise 介绍，你是怎么用 promise 的，怎么实现一个 promise\n * async 是什么的语法糖，generator 怎么用\n * ajax 有哪些状态，每个状态分别对应什么\n * 手动实现一个 ajax，这样实现的方法叫什么\n * require 和 import 的区别？AMD、CMD、ES6\n * callback 的缺点，Promise 的状态有哪些，generator，async 和 await\n * js 溢出怎么解决\n * 如何实现私有的方法/属性\n * ES5 实现继承的方法，构造继承，原型链继承，组合继承，寄生组合继承\n * 怎么用正则判断当前域名是否为 qq.com，或者 xxx.qq.com\n * try...catch...中如果异步代码出错怎么办？\n * js 怎么删除 cookie\n * cookie 的几个字段的功能\n * 怎么创建一个 Promise，参数是什么，怎么中断一个 promise，除了抛异常和 return new Promise()还有什么\n * 怎么判断一个空数组\n * 箭头函数跟普通函数的区别，普通函数的作用域\n * let const, babel 中的实现\n * fetch 的使用，考察通信是否了解\n * 事件机制，捕获和冒泡，如何阻止冒泡？\n * 阻塞、非阻塞和异步同步是对应的吗？一样的吗？\n * window.onload 和 document.ready，onload 是所有资源包括图片都加载完才执行\n * 如何给不存在的元素绑定事件监听\n * 可以在捕获阶段实现事件代理吗，为什么业界都用冒泡？（原因应该是，捕获和冒泡没有明显的优劣之分，但是冒泡事件流模型被大多数浏览器支持，兼容性更好）\n * promise 的 api：如果有10个调用请求，那么哪个api能查到最快调用的请求\n * promise 中不声明 async，可以用 await吗\n * 内存泄漏\n * 怎么判断一个元素有没有被引用\n * 全局变量为什么不会被垃圾处理\n * BOM 和 DOM 的区别,BOM 的方法讲完整一点\n * 点击事件是宏任务还是微任务\n * class 定义类和 function 定义类的区别\n\n\n# 输出题\n\n * 以下代码执行结果\n\n\n\n * 输出 for 循环中定时器的输出语句结果\n * 打印结果是什么\n\n\n\n * 问如何改造，才能实现真正的效果，闭包可以吗，然后用闭包实现一下这个效果\n\n\n\n\n# TS\n\n * TS 声明文件\n * TS 可选属性\n\n\n# CSS\n\n * 介绍一下 css 盒模型\n * position 的值有哪些，区别是什么\n * bfc 是什么。怎么样形成 bfc，bfc 有哪些用\n * 实现一个垂直水平居中\n * 左右布局，sider + 右侧自适应如何实现\n * animation 的参数，怎样实现一个动画\n * 说说盒模型和怪异盒模型\n * 预处理器 sass 优点\n * 样式框架的原理，布局方法有哪些，flex，grid，还有吗\n * 为什么下面的 margin 可以居中？\n\n> “\n> \n> .outer { display: flex; } .inner { margin: auto; }\n> \n> ”\n\n * margin-top 为负值，除了绝对定位还有哪些地方碰到过？\n * 怎么使两个 div 并列\n * 父元素和子元素宽高不知道的情况如何居中子元素（这个问题其实和父元素高度知不知道无关，因为文档流中父元素默认包裹子元素，高度是由子元素撑开的。）\n * CSS 基础好么，知道 DEN 么？\n * css 中隐藏元素的方法，display:none, visibility:hidden,区别？还有什么方式\n * css 绝对定位和相对定位都是以谁为基准\n * css 弹性盒子\n * CSS 和 JS 实现动画的方式\n * ease-in 怎么用 js 实现？\n * CSS 和 JS 实现动画哪个好？为什么？\n * 实现一个块从左到右的移动\n * css 设置元素隐藏，两种有什么区别？\n * css 选择器有哪些？\n * css 怎么实现列表中隔一行变一个颜色\n * 实现一个自适应内容的正方形盒子\n * css 有哪些单位\n * 讲一下 css 的 flex 布局\n * px 和 rem 的区别，举个例子说明一下\n * 浮动布局和 flex 布局相比有什么优缺点\n * 写 CSS 喜欢用什么布局\n\n\n# node\n\n * node 用什么实现模块化管理\n * 说一下 node 的 nextTick\n * 说说浏览器和 node.js 里面捕获错误的方式\n * 谈谈你对 nodejs 的理解\n * node 和浏览器有什么区别吗\n\n\n# 移动端&小程序\n\n * 移动端 300ms 的问题，以及 fastclick 的原理\n * 小程序的话，你做了哪些优化？说说吧\n\n\n# Webpack\n\n * 介绍一下 webpack，webpack 有哪些配置，loader 和 plugin 有什么区别\n * webpack 的原理机制、配置了入口之后发生了什么\n * Webpack 用过么？里面的 tree-shaking 什么原理？（tree-shaking 是因为 import 静态引入的能力，得以对文件内容进行浅层比较，去掉未被使用的代码。）\n * webpack 的打包时间优化\n * webpack 的打包流程\n * Require/import 如何解决循环引用 Webpack 是怎么做的\n * webpack 异步加载路由需要怎么配置，问还有优化首屏渲染的其他方法吗\n * webpack loader 在什么时期起作用\n * 写一个 webpack 插件应该怎么写\n * webpack 中如何实现按需加载的\n * webpack 依赖 node 吗？\n * 有了解过 webpack 里面的拆包吗，说一下你的拆包策略\n * 你觉得拆包的意义在哪，结合 http 的缓存详细说下拆包你觉得拆包的意义在哪，结合 http 的缓存详细说下拆包\n * 拆包过程有遇到过什么坑吗，如何解决的（有个 webpack 的 bundle 和 module 的 id 自增导致缓存失效的问题）\n * 了解 PWA 吗，webpack 怎么做 PWA\n\n\n# 设计模式\n\n * 设计模型 策略模式，单例模式，工厂模式\n\n\n# 前端框架\n\n * 了解有哪些框架，脏数据检测的原理、数据劫持的原理、订阅者发布者\n * 用过哪些前端 router ，实现方式原理[hash、history]\n * 框架的好处，坏处，单页面应用，seo 如何解决\n * jquery 的 each\n * jquery 的 ready\n * ready 和 upload 区别\n\n\n# Vue\n\n * Vue 的生命周期，create 和 mounted 之间发生了什么\n * vue created 和 beforemount 之前会发生什么\n * vue 什么生命周期以后就不会被监听了\n * 钩子？\n * 让你实现一个弹窗组件需要注意什么？\n * vue 数据双项绑定 + diff 算法\n * 既然有双向绑定，为什么 VUE 还有虚拟 dom 这个机制，以及这个机制的好处\n * VUE 路由的实现原理\n * 怎么去实现 vue 的计算属性\n * vue 构建 v-dom 树过程\n * vue-cli 做了哪些代码的优化，在开发环境到生产环境\n * Vue 的预渲染这个插件，具体是怎么去做的？\n * Vue 的子组件与子组件之间的通信讲讲吧\n * 父子组件的通信和子父组件的通信是不是也可以实现呢？\n * 说说你对 Vue 的总体看法，特点，以及与其他框架的不同的地方\n * Vue 的 spa 首屏优化怎么做的，说具体思路\n * vue 中通过一个按钮控制 input 获得焦点，怎么实现，通过 ref 获取对象跟原生的 js 有什么不同\n * vue 的高级组件了解吗？\n * Vue 的 computed 和 watch 有什么区别\n * 如果要计算页面渲染时间，应该在哪个阶段为止\n * Vue 生命周期中的 mounted ,在原生 js 中怎么实现？\n * Vue 的虚拟 DOM 和 patch 算法\n * vue 跟 jquery 的不同，操作 DOM,组件化，MVVM ,虚拟 DOM\n * Vuex 5个概念 为什么 mutations 不能异步？异步会怎样？\n * 对 vue 中 data 进行更新会发生什么（生命周期进行更新、渲染）\n * 如果要复用项目中的某一块逻辑，你怎么做\n * vue 中兄弟组件的通信方式（vuex，vue 组件传递分配 props）\n * 说说 v-if 和 v-show 的区别\n * 假设界面显示价格为 9.99 元，现在我去拉取了后台的价格，现在数据为 8.88 元。当你把数据设置为 8.88 后再到页面显示成 8.88 元。在这个期间你了不了解 vue 帮你做了什么事情？\n * 介绍 vuex 的各个模块和简单讲讲原理\n * dispatch 和 commit 的区别\n * vue 父组件先 mounted 还是子组件 mounted\n * Vue 中的 nextTick 了解吗？\n * vue 里面的 key 有什么作用\n\n\n# React\n\n * 介绍一下 react 生命周期\n * react diff 有了解么\n * 介绍一下 redux\n * react 数据流传递\n * react 父组件子组件兄弟组件传递信息\n * react16 新特性\n * this.setState 执行后干了什么\n * 为什么引进 redux\n * react 事件机制\n * render 在什么时候被调用\n * js 和 react 垃圾处理机制和回收\n * 为什么要用到 redux，redux 的原理\n\n\n# 项目工程\n\n * 登录功能，从前端到后台是怎么处理的\n * 用户登录怎么实现的，怎么知道是同一个用户（用 userId，那手机号不就没用了吗）\n * 手机号验证怎么做的，正则表达式的方法\n * 发送验证码功能，向同一个手机发送多次验证码（攻击），怎么处理\n * 项目前端怎么优化\n * 最近最熟悉的项目，遇到最难解决的问题\n * 搜索框优化，防抖节流，还有？\n * jQuery 用过吗，token 如何实现验证登录\n * 如果我从前端要请求一张图片，你觉得从前端到后端的整个流程是怎样的，详细讲讲在后端的处理流程，随便扯了点路由匹配啥的\n * 很大的日志读取，ip 出现最多的十次，怎么分片\n * 你是怎么压缩图片的？\n * 项目上线之后，怎样排除 js 中存在的问题？\n * 如何上传文件，pc 端\n * 本地存储你有做什么特别处理吗？\n * 说一下缓加载怎么实现的\n * 有 50g 的 QQ 号数据，一次只能运行 20g，想要找出出现次数最多的前十个 qq 号，怎么做？\n * 图片压缩后台怎么实现你知道吗？怎么牺牲图片的画质呢？\n * 输入 有做什么安全处理吗？（xss攻击，常见的字符转义处理有哪些？）\n * 知道 Base64 吗\n * 如果说要展示一个十万的数据在移动端的网页上怎么做\n * 自己做一个登录系统从前端到后端需要注意什么\n * 介绍一下雅虎的性能优化原则\n * 海量日志中找 ip 最多出现次数\n * 超大的日志文件, 提取其中的IP地址\n * 前后端通信数据格式\n * 用什么实现离线应用：manifest，原理呢？\n * 如何提高首屏加载速度\n * 图片懒加载怎么实现\n * 博客的话，做过哪些方面的优化呢？\n * 场景题：现在手机 QQ 要做个成语接龙，你怎么去做，说说思路吧\n * 你有什么较好的算法可以尽量减少成语库的数量吗？\n * 有没有想过前端如何去检测用户输入的是不是成语？\n * SSR\n * SEO 怎么做的，说说技术细节\n * 用 ajax 上传图片\n * 预渲染 prerender 怎么做的，说说技术细节,具体说一下预渲染的原理\n * 如何减少白屏时间和首屏时间\n * 如果部署上去的项目有人打开后一直是白屏，怎么去收集这种情况\n * 用户第二次访问网页，会快很多，是什么原理？\n * 让你设计一个登录、注册、忘记密码的页面你会怎么设计？\n * 组件化开发是为了什么\n * 5000 条数据展示\n * 如何知道用户发生的错误（window.onerror）\n * 富文本编辑器怎么实现？（给标签设置 contenteditable 属性，然后使用浏览器支持的 document.execCommand 命令模式 API）\n * 富文本编辑器的安全问题\n * 如果要实现在离线情况下编辑且不丢失数据，怎么办？（先回答的是使用 localStorage，回答之后不断追问，还问了能否直接用对象存，后面扯到了引擎方面的问题。）\n * 从底层谈谈 map 数据结构的设计。如果容量不够了怎么办，扩容过程中可能会耗费比较多的时间，如果在扩容时要访问怎么办；\n * 微信附近的人这个功能，如何设计\n * severless 的优点\n * git 相关操作\n * 如何实现一个可编辑的可以无限延伸的表格？\n * 除了 websocket 外还有什么方法能实现后端推送？\n * 自动化测试是怎么做的，怎么判断输出是不是符合期望\n * 100ms 请求事件，有几种写法\n * 如何能只发送信息，不进行数据缓存\n * 前端要加载一个图片有哪些方式，然后还问到了 base64 是怎么实现的，有什么缺点，icon 是怎么实现的\n * 后端一下子给你几万条数据，你要怎么处理。（一开始我说，这种情况下后端一定会分页的，然后又问没分页怎么办。然后我说前端手动分页，然后讲了一下具体的实现方法。）\n * 有一个高频触发的请求，你会怎么处理，这个饶了好久，一开始没get到面试官的点，一开始谈到了节流和防抖，然后面试官说这样会影响用户体验，而且这个需求就是需要高频触发，然后又说了一下需要高频请求的场景，一开始说到表单，然后说到购物车抢购。然后我又说加个 16 位随机字符串的参数，然后面试官说这样只是可以区分请求，在网络传输过程中，请求不一定是按先后顺序到达服务器的，那么服务器怎么知道请求的先后顺序呢，其实答案很简单，就是加个时间戳参数。不过当时一下子没反应过来，还谈到了域名发散，面试官说太复杂，然后才谈到加表明各个请求之间关系的参数。\n * 性能优化（讲了雅虎军规（资源加载、代码规范、缓存、服务器）下次可以优化讲成通用性能优化的方案雅虎军规+vue项目的优化）\n * 怎么保证 token 的安全性，拿到你的token就可以做全部的事情了吗？\n * 弱类型语言的缺点，平时哪些地方让你抓狂\n * 封装统一的网络请求的好处\n * 说一下 babel 是怎么实现各个浏览器兼容的，讲了一下 babel 的工作流程和AST树\n * 垃圾回收，如何使用这个方法来优化，主流的浏览器垃圾回收的算法，具体流程\n * 标记清除为什么比引用清除好\n * 要在页面上实行一个特别慢的 js 代码，会遇到什么问题，假设页面已经加载好，用户点击之后开始计算，造成没有响应的现象的原因（被禁用还是被延迟）\n * 阻塞会造成什么后果\n * 很大的计算，会让页面卡顿，有什么办法可以使页面不卡顿，也让任务完成（我回答了异步的方法，面试官问还有没有其他的方式，例如 html5 的新特性）\n * 实现百度搜索,foucs 有下拉框，根据输入内容能模糊查询\n * 无限滚动列表优化问题\n * 假如说我们的网页有一个表单，有人模拟 http 的 post 绕过了表单将数据发送到了后台应该怎么办\n * 怎么去实现一个多人在线文档（从技术和需求说，来自腾讯文档，怎么做到数据的渲染、怎么获取到数据、网络上需要做什么处理）\n * 详细说明一下你是怎么通过设置请求头解决了缓存问题吗？\n * 图片懒加载原理（节流是什么）\n * 点击穿透\n * fastClick 原理\n * 说说不用 nuxt 框架怎么实现 SSR，数据预取怎么实现的\n\n\n# 可能会问到的后端问题\n\n * RESTful 的原理\n * 数据库百万条数据，有几种语文，数学，计算平均分，排序出来，如何解决\n * 后台有注解，前端有吗？装饰器用过吗？\n * 关系型和非关系型数据库\n * 数据库的索引的原理和用法\n * 数据库的事务知道吗？\n * 连接查询有哪些方式？\n * 你知道 Java 为啥能够运行在几乎所有系统上吗？\n * linux 相关操作（查看进程用ps）\n * mysql 跟 mongondb 的不同\n * 数据库优化方法\n * pm2 查看日志的命令\n * koa 的底层原理\n * koa 的洋葱模型，和 express 有什么区别\n * 事务的原理了解吗\n * 什么是内外连接\n * 索引了解吗，为什么索引能加快速度\n * 同步和异步的区别\n * 如果有六百万名考生的高考成绩要排序应该怎么做\n * web服务用过哪些？\n * 你提到了nginx，有做过一些负载均衡吗？\n\n\n# 算法\n\n * 找出数组中 n 项，n 项的和为 m\n * 口述快速排序\n * 冒泡，及冒泡的优化\n * 讲讲迪杰斯特拉算法\n * 讲讲最小生成树算法\n * 讲讲 hash 算法\n * 堆排序\n * 数组三分，如果一个数组能够分成非空的三个部分，每个部分和相等，则返回 true\n * 查找算法应该用堆还是用栈\n * 数据结构有那些\n * 快排时间复杂度+快排什么时候最慢\n * 洗牌算法\n * dp 和二叉树\n * 二叉树根据一个节点查找下一个节点\n * 从一个数组的后十个数中找出 3 个和为 10 的数字\n * 找出两个字符串（str1,str2）的最大公共子长度\n * 一次可以跳一步，两步，三步，问n步的路有多少种到达终点方式？（斐波那契，写了个尾递归）\n * 大量数据的数组，怎么找出排名前n个数\n * 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1\n * 实现 string 的 indexOf() 函数\n * \n * 大数相加\n * 链表反转\n * 二叉树排序\n * 二叉树的翻转\n * 出现最多的字母个数\n * 找一篇文章中出现最多的英文单词\n * 正则匹配字符串\n * 现在给你一个树状对象，{value:1,children:{value:2,children:{...}}}这样的结构，如何把所有value删去，返回一个新对象？\n * 如何判断一个对象中有没有叫value的属性？不要考虑代码的复杂性，能说几种说几种\n * 说说你知道的排序和查找算法吧\n * 堆排序是如何实现的？时间复杂度是多少？\n * 有 1000 步的台阶，每次只能选择走 1 步、2 步或者 3 步，走完台阶一共有多少种走法\n * 长度为 1 亿的字符串，寻找字符串包含 'tencent' 子串的数量\n * 无序数组中选择第 k 大的数，分析算法时间复杂度\n * 两个整数求和会超过 int 范围 怎么运算\n * DFS 非递归 先序遍历\n * 数组中超过一半的数是同一个数，找出那个数（分析复杂度，如何优化）\n * 手撕二叉树的题目，leetcode124\n * 生成一个 8*8 的 01 棋盘，每行每列不能多于 1 个 1，输出生成的棋盘和符不符合规定\n * 数组和链表随机访问的时间复杂度\n * O(N) 寻找最长的连续字符串\n * 小明从老板那里拿到了一个密码表，说是如果解开密码表中的秘密，就可以升职加薪，赢取白富美，走向人生巅峰。这个密码表是一个 CSV 文件，里面的数据由数字（没有小数点）、字母组成。小明需要提取每个数据中的数字（例如 1a2b3c 提取后得到 123，提取后的数字整体看作一个十进制数），把数值为奇数的项相加，就可以解开这个秘密。请你实现一个函数 sum，帮小明完成这项工作。\n\n\n\n * 在一个字符串中找出连续重复的字符，这个字符可以是数字、字母和中文等\n * 有效括号 - 判断一个字符串中括号是否都能匹配\n * 一个字符串里面有一些不可见的字符，如\"\\n\"，写一个算法剔除它们\n\n\n# 手撕\n\n * 数据绑定实现【框架和抛开框架，手撕】\n * 排序数组，查询某个值，存在则返回索引，不存在返回插入位置；优化，for~二分 【手撕】\n * js实现阶乘\n * 创建一个 Person 类，其包含公有属性 name 和私有属性 age 以及公有方法 setAge ；创建一个 Teacher 类，使其继承 Person ，并包含私有属性 studentCount 和私有方法 setStudentCount\n * 实现一个类似百度输入框的功能，根据用户的输入，找出一个数组中匹配到的数显示出来\n * 一个输入框实现百度搜索那样的 autocomplete 效果\n * 请写一个函数，计算一篇英文文章中出现次数最多的单词及出现次数\n * 怎么用 js 实现队列\n * js 观察者模式\n * 数组扁平化\n * 实现一个实数的堆栈，使得其 push pop max 方法的时间复杂度为 O(1)\n * 有一个整数二维数组，每行的元素个数不同，输出它的全排列，同一行的数互斥。要求不使用递归完成\n * 实现一个函数，检查二叉树是否平衡。\n * 实现一个 Http 请求池，需要能够限制并发数\n * 合并二叉树\n * 奇偶链表\n * 使用闭包实现变量自加一\n * 双向链表转二叉树，二叉树转双向链表\n * url 正则匹配\n * nlogn 排序算法有哪些，快排稳定么\n * 构建排序二叉树\n * 搜索二叉树找第 k 大的数\n * 手写原生 ajax，new XMLHttpRequest()\n * 手写对象深拷贝\n * 获取标签名称为 div 的元素的个数，并且判断是不是数组，考察类型判断\n * 给两个构造函数 A 和 B ，如何实现 A 继承 B\n * 用户权限认证过程\n * 写个模块导出的案例\n * 说下异步的问题，写个 promise 的使用小案例\n * 拖拽代码 (手写)\n * 手撕代码：大数相乘\n * 手撕代码：函数无限柯里化（有n个参数，函数调用n+1次得到结果）\n * 手撕代码：实现一个轮询器，主要考察 Promise\n * 用 es5 的 let 实现一个闭包\n * 继承（实现私有属性和私有方法）\n * 设计实现一个固定执行顺序的 script 加载\n * 手写代码题：找出字符串中出现次数最多的字符及出现次数\n * 编程题（对输入的一段字符串（有逗号 有回车，挑出其中的数字，然后求和，求和之后再把数中的奇数加） 1.正则做法 2.字符串遍历做法，挑出数字 ， 换行，再按换行分割，再按，号分割，数组扁平，求和，变字符串，遍历\n * 数组去重手写，越多越好\n * 将一个平铺的数组用 js 写成树的结构\n * 完成函数的实现，使得它可以实现达到 Array.prototype.forEach 相同的功能\n * 看下面代码执行结果，说明原因\n\n\n\n * \n * token 过期怎么做\n * 怎么知道用户和 token 的对应关系\n * token 和 cookie 区别\n * token 为什么比 cookie 更不容易受到攻击，为什么要用 cookie\n * 手撕 Event bus\n * 手撕函数组合\n * 手撕对象扁平化\n\n\n\n * 给列表中的 li（里面是a标签）绑定点击事件，点击时弹出其在列表中的顺序（页面不跳转）\n * JS实现一个 JSON.stringify() 功能的函数\n * 三次重试：假设有一个函数名为 job,调用 job 后会执行一些异步任务，并返回一个 Promise ,但 job 执行的异步任务任务有可能会失败\n * 请实现函数 retry ,把 job 作为 retry 函数的参数传入，当 retry 执行后会尝试调用 job,如果 job 返回成功（即 Promise fulfilled），则 retry 函数返回job函数的返回内容；\n * 如果 job 返回失败（即 Promise rejected ）,retry 函数会再次尝试调用 job 函数。\n * 如果 job 连续三次均返回失败，retry 则不再尝试调用，并返回其最后一次失败的内容。\n\n\n\n\n\n * 给了一个代码片段，大概就是一个产生随机数的 for 循环，然后把这个随机数当作参数传到一个异步函数，问怎么保证输出顺序也是有序的，其实就是类似于同时发送几个 http 请求，怎么保证响应顺序也按照请求顺序依次返回\n * 写了个类型判断函数\n\n\n\n * 遍历根结点下所有子节点\n\n\n\n * 实现页脚在内容最底部\n\n\n\n\n# 智力题\n\n * 100 人教室 70 人喜欢足球，80 人喜欢篮球，问同时喜欢足球和篮球的人数\n * 试探玻璃杯破碎的楼层\n * 时针与分针夹角\n * 5.25 时针和分针夹角\n * 上一题拓展:X 时 Y 分夹角\n * 一个班里 60% 喜欢 A, 70% 喜欢 B, 80% 喜欢 C, 问同时喜欢 ABC 的\n * 一瓶汽水一块钱，俩空瓶可以换一瓶汽水，给你 20 块钱，最多喝多少瓶？\n * 给你一个 A4 纸张，随便剪掉一个随意位置宽高的矩形，给你一个没有刻度的尺子和笔，怎么一刀把剩下的 A4 纸张分成面积同样大小的两半。\n * 如何洗开一副扑克牌\n * a 和 b 两个人投掷硬币，朝上 a 得 1 分，反之 b 得分，现在 a8 分、b7 分，请问 a 和 b 先到 10 分的概率各是多少。\n * 一根不均匀绳子烧完一个小时，问怎么使用多根这种绳子来计算 15 分钟\n * 一个烤盘，每次最多烤两块肉，一面烤 10min，问要烤几分钟\n * 20 个瓶子，有 19 个瓶子每颗药 1g，有一个瓶子每颗药 1.1g，问怎么用一把称一次找出 1.1g 的瓶子\n\n\n# 拓展问题\n\n * excel 同步/冲突\n * OT 算法\n\n\n# 非技术相关\n\n * 讲一下你觉得最自豪的项目\n * 对该职位的学习方式（根据对方的回答，需要的人员应该是看过专业书籍，有去了解这一方面的大佬并针对其技术分享进行学习。而不只是用的时候再学，野网站学习。可以简洁为愿意并且会主动地学习）\n * 认为前端开发中比较难、比较重要的地方\n * 除了 react 还用了哪些技术\n * 遇到过的难点，如何解决的？\n * 有读英文文档的习惯吗？\n * ts 和 java 对比，ts 和 es6 对比，js 对比框架\n * 面试过其他什么公司\n * 什么时候开始学习前端的，学习前端的方式，平时都看过哪些书？\n * 平时学前端看什么书呀？说说学习路线吧\n * 你看书或者看博客学习的时候，是怎么做总结的\n * 最近都有再看什么书？\n * 写文章的时候总有个先后顺序或者一定的结构吧，你是怎么做的\n * 没有试过思维导图\n * 在前端上未来有什么打算？有没有什么想学的东西？是只想找个工作还是想怎么发展？\n * 为什么说自己擅长沟通和有抗压能力\n * 问了计算机组成，问我 cache 知道吗，我大概说了说，然后问为什么 cache 更快\n * 操作系统，银行家算法，死锁怎么解决\n * 为什么学习前端\n * 我在学习过程中遇到了哪些困难，怎么解决的。\n * 有没有关注前端的新技术\n * flutter 有了解吗\n * h5 有写过吗，移动端有了解吗\n * 了解过小程序吗\n * 如何衡量一个软件的质量？如何保证产品的质量？（软件工程的思想，敏捷中的测试驱动开发）\n * 找出不多于三个关键词形容自己\n * 怎么跟一个不懂前端的人介绍前端\n\n# HR问题\n\n * 自我介绍\n * 讲一讲最近收获最大的一个项目，在项目担任的角色\n * 有什么爱好，为什么喜欢\n * 是否为独生子女\n * 是否去过深圳\n * 是否考研\n * 什么专业，为什么不选择省外的高校\n * 是否有其它公司 offer\n * 入职时间，可实习多久\n * 说说自己性格的优点和缺点\n * 你怎么看我们部门\n * 你了解过我们是做什么的吗\n * 你平常怎么学习\n * 你的未来规划是什么\n * 你女朋友不让你来深圳怎么办\n * 什么时候能入职 能做多久\n * 参加过什么比赛，拿过什么奖\n * 老师和同学对自己评价的优缺点\n * 成绩在年级上的位置\n * 说下团队的规模，在团队的角色\n * 觉得自己技术怎么样\n * 什么时候开始用 GitHub，更新频率怎么样\n\n# 总监面\n\n * 如何学习全新的框架\n * 一个卡顿的项目交给你，怎么去进行优化\n * 周围有人拿到腾讯 offer 了吗？\n * 介绍了一下我的专业干啥的\n * 日常开发中遇到问题怎么解决\n * 建立中的项目有啥亮点\n * 前端处理耗时比较长的计算问题，如何防止页面卡顿的优化方案\n * bilibili 上面一键三连怎么实现\n * 自己的职业规划",normalizedContent:"# 计算机网络\n\n * 常见状态码知道哪些？304 403 405分别是什么\n * http 状态码 302 504分别代表什么意思\n * 响应状态码，200(from disk cache)，200（from memory cache），304 的区别。\n * post 和 get 的区别，除了长度，安全其他的\n * http 介绍一下，为什么 http2.0 不普及，websocket 的基本指令，性能\n * 爬虫，网站如何去做防止，如何判断\n * tcp 和 udp 区别\n * 那如果让你做一个视频聊天软件，你用 tcp 还是 udp ？为什么？\n * tcp 是怎么去保证可靠传输的？\n * tcp 三次握手\n * tcp 握手结束第一次的包有多大\n * tcp 的超时重传\n * tcp 为什么是三次握手呢？\n * tcp 如何去终止之前发送报文的？\n * tcp 拥塞控制（四部分）\n * cdn 的原理是什么\n * dns 过程\n * http 协议，1.1 和 2.0 的区别，了解哪些请求方法，请求/响应头部\n * 为什么项目不用 https 以及 http 与 https 的区别\n * https 的加密过程以及如何防止中间人攻击\n * 为什么 tcp 连接是可靠的（校验和重传）\n * 通过什么机制处理服务端接收数据乱序丢包等（滑动窗口和拥塞控制）\n * 在 tcp 建立连接后，路由器发生了什么变化\n * http 的 header 和 body 讲的很详细 请求方式 请求头内容 状态码\n * http2 相关问题。在 http1 的时代，会经常把很多资源部署在不同域名下，为什么？（有可能是减少 cookie 的传输量）\n * tcp 和 udp 的区别和场景，又问如果让你设计一个既保证准确性速度又快的协议，怎么做\n * osi7 层模型 每层大致用处及相关协议\n * https ,http2.0，websocket(提了一下)，tls握手，怎么知道数字证书的真假\n * http2.0 有了解吗？有抓包看看到底什么个情况吗？\n * cookie session 区别\n * session 怎么保存、有多台服务器，sessionid 怎么找\n * 为什么 cookie 可以用来保存登录状态\n * http 头部 chunk\n * get 发一个 tcp 包，post 发两个 tcp 包，这种情况是一定的吗，什么情况下不是这样\n * post 如何把数据放到 url 中\n * 一个 http 的报文的头和 body 之间有什么分隔\n * 出现 304 的场景，通过什么协议头来确认（304 的响应头）\n * websocket 原理，如何实现，和 http 报文结构有哪些不同（注意是结构不是特性）\n * cookie，localstorage，sessionstorage 使用和区别\n * ca 验证\n * wireshark 能抓包到 https 请求的内容吗\n * https 怎么预防中间人攻击\n * http 请求的过程中怎么知道数据已经发送完毕要断开连接，怎么断开\n * 网络的七层模型\n * get post head 这些请求方式有什么不同\n * 了解轮询和 websocket 吗？\n * 说一下 websocket 的四个阶段（websocket 不能使用时要怎么处理、使用什么方式来代替 websocket）\n\n\n# 操作系统\n\n * 进程和线程\n * 进程之间的通信知道吗？node 中自己实现过哪种通信？（说了管道，消息队列，套接字，信号量啥的，表示自己不会 node，没实现过，说了浏览器的多个 tag 之间也属于进程通信，表示不满意，不要说应用层上的东西）\n\n\n# 浏览器工作原理\n\n * 同源是什么意思，除了那三个没有了么\n * 事件冒泡和事件捕获，应用？注意？\n * 事件轮询 eventloop\n * promise、console.log、settimeout、执行顺序\n * 重绘和重排\n * url 到页面加载过程\n * 跨域问题，解决，jsonp 原理，不受跨域影响的标签\n * etag 是什么？\n * 浏览器储存 cookie，localstorage，sessionstorage 详细区别\n * http 缓存，如果缓存还在有效期内，但是资源变更了怎么办\n * jsonp 跨域的安全问题\n * cors 跨域，要支持两个域名怎么做\n * js 会阻塞加载，怎么阻塞的？\n * http 缓存更新静态文件的方式\n * postmessage\n * 浏览器卡顿，你怎么去排除？（服务器到后台都讲了一遍，他告诉我如果数据没问题，是浏览器的问题怎么排除，我说了代码中打断点调试，他不满意，说我 chrome 的调试工具台掌握很不好）\n * pc浏览器的分布？主流浏览器的版本\n * 缓存问题，etag 和 if-modify-since 是怎么来的？\n * 非同源 cookie 怎么访问\n * 如果要你缓存图片你怎么做？\n * 有多台服务器，sessionid 怎么找\n\n\n# 浏览器安全\n\n * 知道哪些前端危险？如何防御\n * xss 的原理，如何防御 xss？为什么换成实体字符就好了？\n * 假如说某链接获取到你的敏感信息，发送奇怪请求到服务器，你怎么去防御？\n * 讲一讲 cookie 是怎么发送到服务端，具体过程，尽量详细\n * csrf token 能存储在 cookie 里吗？其实是可以的，只要服务端不要去从 cookie 里面取 csrf token 就行\n * 黑客是怎么去利用 cookie 的？这个请求到底是怎么构造的？\n * http 请求中 option 主要是干什么的\n * xss 的原理和防御措施（讲了加强 cookie，过滤输入，过滤输出）\n * csrf 了解过吗，它的攻击流程是怎样的，如何防御（refencer 可不可以被修改、token 可不可以被窃取，既然有漏洞那不是白做了）\n\n\n# html\n\n * div 里面嵌套一个 tip，当 tip 改变的时候，div 会重新渲染吗，怎么样实现 div 不会重新渲染\n * html5 新特性\n * html 跟 html5 的区别（解释了本质区别，框架上的区别）\n * web 语义化、语义化标签有哪些、section 标签的作用\n\n\n# js\n\n\n# 基础问题\n\n * let,const,var 的区别。const 定义的对象是否可以修改\n * js 的原型和原型链，原型链的终点在哪里？\n * js 的基本数据类型\n * 事件委托，详细讲\n * es6 新特性，常用语法有哪些\n * this 的原理，call，apply，bind 的区别\n * 全等和弱等的区别\n * 构造函数的原型\n * 函数柯里化\n * 数组浅拷贝\n * 立即执行函数\n * 浏览器事件模型, ie的有什么特殊, 如何兼容(attachevent与addeventlistener)\n * js 宏任务和微任务\n * 数组查找的方法\n * 了解过 for...of 吗\n * class 继承和 js 继承的区别\n * {}的原型链\n * typeof null 是什么，为什么是这个结果。\n * typeof 和 instanceof 有什么区别，说说判断的原理\n * 数组里面新加的方法你有用过哪些？\n * 微任务有哪些？\n * 如何判断 array 和 object\n * js 精度问题（0.1+0.2==0.3的问题）\n * 讲一下 generator 生成器\n * 讲一下声明提升\n * 讲一下块作用域\n * 原型对象的 constructor 指向谁\n * dom 规范跟 js 规范有什么区别？\n * js 定时器，设置一个时间，会在那个时间之后准时执行吗？\n * transition 有什么需要注意的地方？\n * js 的错误监控机制有了解吗？\n\n\n# 进阶问题\n\n * 闭包，应用\n * 防抖，节流\n * settimeout 第二个参数为0时和匿名自执行函数区别\n * js 里堆和栈的区别\n * new 操作符之后的操作\n * this 指向\n * es6 的使用，相比es5的好处\n * 简单说一下 es6 的 symbol 属性\n * es6的新特性（变量声明，字符串模板，数组的新方法 flat，函数的默认值，箭头函数、class 继承，promise，await/async 讲的很详细）\n * 如果要同时启动两个异步任务，怎么做\n * 深拷贝/浅拷贝问题\n * 说一下链表的实现\n * bind(object).bind(windows) 后的 this 指向\n * 构造继承里 function.call(argu)里传进来的参数 argu 是什么\n * promise 介绍，你是怎么用 promise 的，怎么实现一个 promise\n * async 是什么的语法糖，generator 怎么用\n * ajax 有哪些状态，每个状态分别对应什么\n * 手动实现一个 ajax，这样实现的方法叫什么\n * require 和 import 的区别？amd、cmd、es6\n * callback 的缺点，promise 的状态有哪些，generator，async 和 await\n * js 溢出怎么解决\n * 如何实现私有的方法/属性\n * es5 实现继承的方法，构造继承，原型链继承，组合继承，寄生组合继承\n * 怎么用正则判断当前域名是否为 qq.com，或者 xxx.qq.com\n * try...catch...中如果异步代码出错怎么办？\n * js 怎么删除 cookie\n * cookie 的几个字段的功能\n * 怎么创建一个 promise，参数是什么，怎么中断一个 promise，除了抛异常和 return new promise()还有什么\n * 怎么判断一个空数组\n * 箭头函数跟普通函数的区别，普通函数的作用域\n * let const, babel 中的实现\n * fetch 的使用，考察通信是否了解\n * 事件机制，捕获和冒泡，如何阻止冒泡？\n * 阻塞、非阻塞和异步同步是对应的吗？一样的吗？\n * window.onload 和 document.ready，onload 是所有资源包括图片都加载完才执行\n * 如何给不存在的元素绑定事件监听\n * 可以在捕获阶段实现事件代理吗，为什么业界都用冒泡？（原因应该是，捕获和冒泡没有明显的优劣之分，但是冒泡事件流模型被大多数浏览器支持，兼容性更好）\n * promise 的 api：如果有10个调用请求，那么哪个api能查到最快调用的请求\n * promise 中不声明 async，可以用 await吗\n * 内存泄漏\n * 怎么判断一个元素有没有被引用\n * 全局变量为什么不会被垃圾处理\n * bom 和 dom 的区别,bom 的方法讲完整一点\n * 点击事件是宏任务还是微任务\n * class 定义类和 function 定义类的区别\n\n\n# 输出题\n\n * 以下代码执行结果\n\n\n\n * 输出 for 循环中定时器的输出语句结果\n * 打印结果是什么\n\n\n\n * 问如何改造，才能实现真正的效果，闭包可以吗，然后用闭包实现一下这个效果\n\n\n\n\n# ts\n\n * ts 声明文件\n * ts 可选属性\n\n\n# css\n\n * 介绍一下 css 盒模型\n * position 的值有哪些，区别是什么\n * bfc 是什么。怎么样形成 bfc，bfc 有哪些用\n * 实现一个垂直水平居中\n * 左右布局，sider + 右侧自适应如何实现\n * animation 的参数，怎样实现一个动画\n * 说说盒模型和怪异盒模型\n * 预处理器 sass 优点\n * 样式框架的原理，布局方法有哪些，flex，grid，还有吗\n * 为什么下面的 margin 可以居中？\n\n> “\n> \n> .outer { display: flex; } .inner { margin: auto; }\n> \n> ”\n\n * margin-top 为负值，除了绝对定位还有哪些地方碰到过？\n * 怎么使两个 div 并列\n * 父元素和子元素宽高不知道的情况如何居中子元素（这个问题其实和父元素高度知不知道无关，因为文档流中父元素默认包裹子元素，高度是由子元素撑开的。）\n * css 基础好么，知道 den 么？\n * css 中隐藏元素的方法，display:none, visibility:hidden,区别？还有什么方式\n * css 绝对定位和相对定位都是以谁为基准\n * css 弹性盒子\n * css 和 js 实现动画的方式\n * ease-in 怎么用 js 实现？\n * css 和 js 实现动画哪个好？为什么？\n * 实现一个块从左到右的移动\n * css 设置元素隐藏，两种有什么区别？\n * css 选择器有哪些？\n * css 怎么实现列表中隔一行变一个颜色\n * 实现一个自适应内容的正方形盒子\n * css 有哪些单位\n * 讲一下 css 的 flex 布局\n * px 和 rem 的区别，举个例子说明一下\n * 浮动布局和 flex 布局相比有什么优缺点\n * 写 css 喜欢用什么布局\n\n\n# node\n\n * node 用什么实现模块化管理\n * 说一下 node 的 nexttick\n * 说说浏览器和 node.js 里面捕获错误的方式\n * 谈谈你对 nodejs 的理解\n * node 和浏览器有什么区别吗\n\n\n# 移动端&小程序\n\n * 移动端 300ms 的问题，以及 fastclick 的原理\n * 小程序的话，你做了哪些优化？说说吧\n\n\n# webpack\n\n * 介绍一下 webpack，webpack 有哪些配置，loader 和 plugin 有什么区别\n * webpack 的原理机制、配置了入口之后发生了什么\n * webpack 用过么？里面的 tree-shaking 什么原理？（tree-shaking 是因为 import 静态引入的能力，得以对文件内容进行浅层比较，去掉未被使用的代码。）\n * webpack 的打包时间优化\n * webpack 的打包流程\n * require/import 如何解决循环引用 webpack 是怎么做的\n * webpack 异步加载路由需要怎么配置，问还有优化首屏渲染的其他方法吗\n * webpack loader 在什么时期起作用\n * 写一个 webpack 插件应该怎么写\n * webpack 中如何实现按需加载的\n * webpack 依赖 node 吗？\n * 有了解过 webpack 里面的拆包吗，说一下你的拆包策略\n * 你觉得拆包的意义在哪，结合 http 的缓存详细说下拆包你觉得拆包的意义在哪，结合 http 的缓存详细说下拆包\n * 拆包过程有遇到过什么坑吗，如何解决的（有个 webpack 的 bundle 和 module 的 id 自增导致缓存失效的问题）\n * 了解 pwa 吗，webpack 怎么做 pwa\n\n\n# 设计模式\n\n * 设计模型 策略模式，单例模式，工厂模式\n\n\n# 前端框架\n\n * 了解有哪些框架，脏数据检测的原理、数据劫持的原理、订阅者发布者\n * 用过哪些前端 router ，实现方式原理[hash、history]\n * 框架的好处，坏处，单页面应用，seo 如何解决\n * jquery 的 each\n * jquery 的 ready\n * ready 和 upload 区别\n\n\n# vue\n\n * vue 的生命周期，create 和 mounted 之间发生了什么\n * vue created 和 beforemount 之前会发生什么\n * vue 什么生命周期以后就不会被监听了\n * 钩子？\n * 让你实现一个弹窗组件需要注意什么？\n * vue 数据双项绑定 + diff 算法\n * 既然有双向绑定，为什么 vue 还有虚拟 dom 这个机制，以及这个机制的好处\n * vue 路由的实现原理\n * 怎么去实现 vue 的计算属性\n * vue 构建 v-dom 树过程\n * vue-cli 做了哪些代码的优化，在开发环境到生产环境\n * vue 的预渲染这个插件，具体是怎么去做的？\n * vue 的子组件与子组件之间的通信讲讲吧\n * 父子组件的通信和子父组件的通信是不是也可以实现呢？\n * 说说你对 vue 的总体看法，特点，以及与其他框架的不同的地方\n * vue 的 spa 首屏优化怎么做的，说具体思路\n * vue 中通过一个按钮控制 input 获得焦点，怎么实现，通过 ref 获取对象跟原生的 js 有什么不同\n * vue 的高级组件了解吗？\n * vue 的 computed 和 watch 有什么区别\n * 如果要计算页面渲染时间，应该在哪个阶段为止\n * vue 生命周期中的 mounted ,在原生 js 中怎么实现？\n * vue 的虚拟 dom 和 patch 算法\n * vue 跟 jquery 的不同，操作 dom,组件化，mvvm ,虚拟 dom\n * vuex 5个概念 为什么 mutations 不能异步？异步会怎样？\n * 对 vue 中 data 进行更新会发生什么（生命周期进行更新、渲染）\n * 如果要复用项目中的某一块逻辑，你怎么做\n * vue 中兄弟组件的通信方式（vuex，vue 组件传递分配 props）\n * 说说 v-if 和 v-show 的区别\n * 假设界面显示价格为 9.99 元，现在我去拉取了后台的价格，现在数据为 8.88 元。当你把数据设置为 8.88 后再到页面显示成 8.88 元。在这个期间你了不了解 vue 帮你做了什么事情？\n * 介绍 vuex 的各个模块和简单讲讲原理\n * dispatch 和 commit 的区别\n * vue 父组件先 mounted 还是子组件 mounted\n * vue 中的 nexttick 了解吗？\n * vue 里面的 key 有什么作用\n\n\n# react\n\n * 介绍一下 react 生命周期\n * react diff 有了解么\n * 介绍一下 redux\n * react 数据流传递\n * react 父组件子组件兄弟组件传递信息\n * react16 新特性\n * this.setstate 执行后干了什么\n * 为什么引进 redux\n * react 事件机制\n * render 在什么时候被调用\n * js 和 react 垃圾处理机制和回收\n * 为什么要用到 redux，redux 的原理\n\n\n# 项目工程\n\n * 登录功能，从前端到后台是怎么处理的\n * 用户登录怎么实现的，怎么知道是同一个用户（用 userid，那手机号不就没用了吗）\n * 手机号验证怎么做的，正则表达式的方法\n * 发送验证码功能，向同一个手机发送多次验证码（攻击），怎么处理\n * 项目前端怎么优化\n * 最近最熟悉的项目，遇到最难解决的问题\n * 搜索框优化，防抖节流，还有？\n * jquery 用过吗，token 如何实现验证登录\n * 如果我从前端要请求一张图片，你觉得从前端到后端的整个流程是怎样的，详细讲讲在后端的处理流程，随便扯了点路由匹配啥的\n * 很大的日志读取，ip 出现最多的十次，怎么分片\n * 你是怎么压缩图片的？\n * 项目上线之后，怎样排除 js 中存在的问题？\n * 如何上传文件，pc 端\n * 本地存储你有做什么特别处理吗？\n * 说一下缓加载怎么实现的\n * 有 50g 的 qq 号数据，一次只能运行 20g，想要找出出现次数最多的前十个 qq 号，怎么做？\n * 图片压缩后台怎么实现你知道吗？怎么牺牲图片的画质呢？\n * 输入 有做什么安全处理吗？（xss攻击，常见的字符转义处理有哪些？）\n * 知道 base64 吗\n * 如果说要展示一个十万的数据在移动端的网页上怎么做\n * 自己做一个登录系统从前端到后端需要注意什么\n * 介绍一下雅虎的性能优化原则\n * 海量日志中找 ip 最多出现次数\n * 超大的日志文件, 提取其中的ip地址\n * 前后端通信数据格式\n * 用什么实现离线应用：manifest，原理呢？\n * 如何提高首屏加载速度\n * 图片懒加载怎么实现\n * 博客的话，做过哪些方面的优化呢？\n * 场景题：现在手机 qq 要做个成语接龙，你怎么去做，说说思路吧\n * 你有什么较好的算法可以尽量减少成语库的数量吗？\n * 有没有想过前端如何去检测用户输入的是不是成语？\n * ssr\n * seo 怎么做的，说说技术细节\n * 用 ajax 上传图片\n * 预渲染 prerender 怎么做的，说说技术细节,具体说一下预渲染的原理\n * 如何减少白屏时间和首屏时间\n * 如果部署上去的项目有人打开后一直是白屏，怎么去收集这种情况\n * 用户第二次访问网页，会快很多，是什么原理？\n * 让你设计一个登录、注册、忘记密码的页面你会怎么设计？\n * 组件化开发是为了什么\n * 5000 条数据展示\n * 如何知道用户发生的错误（window.onerror）\n * 富文本编辑器怎么实现？（给标签设置 contenteditable 属性，然后使用浏览器支持的 document.execcommand 命令模式 api）\n * 富文本编辑器的安全问题\n * 如果要实现在离线情况下编辑且不丢失数据，怎么办？（先回答的是使用 localstorage，回答之后不断追问，还问了能否直接用对象存，后面扯到了引擎方面的问题。）\n * 从底层谈谈 map 数据结构的设计。如果容量不够了怎么办，扩容过程中可能会耗费比较多的时间，如果在扩容时要访问怎么办；\n * 微信附近的人这个功能，如何设计\n * severless 的优点\n * git 相关操作\n * 如何实现一个可编辑的可以无限延伸的表格？\n * 除了 websocket 外还有什么方法能实现后端推送？\n * 自动化测试是怎么做的，怎么判断输出是不是符合期望\n * 100ms 请求事件，有几种写法\n * 如何能只发送信息，不进行数据缓存\n * 前端要加载一个图片有哪些方式，然后还问到了 base64 是怎么实现的，有什么缺点，icon 是怎么实现的\n * 后端一下子给你几万条数据，你要怎么处理。（一开始我说，这种情况下后端一定会分页的，然后又问没分页怎么办。然后我说前端手动分页，然后讲了一下具体的实现方法。）\n * 有一个高频触发的请求，你会怎么处理，这个饶了好久，一开始没get到面试官的点，一开始谈到了节流和防抖，然后面试官说这样会影响用户体验，而且这个需求就是需要高频触发，然后又说了一下需要高频请求的场景，一开始说到表单，然后说到购物车抢购。然后我又说加个 16 位随机字符串的参数，然后面试官说这样只是可以区分请求，在网络传输过程中，请求不一定是按先后顺序到达服务器的，那么服务器怎么知道请求的先后顺序呢，其实答案很简单，就是加个时间戳参数。不过当时一下子没反应过来，还谈到了域名发散，面试官说太复杂，然后才谈到加表明各个请求之间关系的参数。\n * 性能优化（讲了雅虎军规（资源加载、代码规范、缓存、服务器）下次可以优化讲成通用性能优化的方案雅虎军规+vue项目的优化）\n * 怎么保证 token 的安全性，拿到你的token就可以做全部的事情了吗？\n * 弱类型语言的缺点，平时哪些地方让你抓狂\n * 封装统一的网络请求的好处\n * 说一下 babel 是怎么实现各个浏览器兼容的，讲了一下 babel 的工作流程和ast树\n * 垃圾回收，如何使用这个方法来优化，主流的浏览器垃圾回收的算法，具体流程\n * 标记清除为什么比引用清除好\n * 要在页面上实行一个特别慢的 js 代码，会遇到什么问题，假设页面已经加载好，用户点击之后开始计算，造成没有响应的现象的原因（被禁用还是被延迟）\n * 阻塞会造成什么后果\n * 很大的计算，会让页面卡顿，有什么办法可以使页面不卡顿，也让任务完成（我回答了异步的方法，面试官问还有没有其他的方式，例如 html5 的新特性）\n * 实现百度搜索,foucs 有下拉框，根据输入内容能模糊查询\n * 无限滚动列表优化问题\n * 假如说我们的网页有一个表单，有人模拟 http 的 post 绕过了表单将数据发送到了后台应该怎么办\n * 怎么去实现一个多人在线文档（从技术和需求说，来自腾讯文档，怎么做到数据的渲染、怎么获取到数据、网络上需要做什么处理）\n * 详细说明一下你是怎么通过设置请求头解决了缓存问题吗？\n * 图片懒加载原理（节流是什么）\n * 点击穿透\n * fastclick 原理\n * 说说不用 nuxt 框架怎么实现 ssr，数据预取怎么实现的\n\n\n# 可能会问到的后端问题\n\n * restful 的原理\n * 数据库百万条数据，有几种语文，数学，计算平均分，排序出来，如何解决\n * 后台有注解，前端有吗？装饰器用过吗？\n * 关系型和非关系型数据库\n * 数据库的索引的原理和用法\n * 数据库的事务知道吗？\n * 连接查询有哪些方式？\n * 你知道 java 为啥能够运行在几乎所有系统上吗？\n * linux 相关操作（查看进程用ps）\n * mysql 跟 mongondb 的不同\n * 数据库优化方法\n * pm2 查看日志的命令\n * koa 的底层原理\n * koa 的洋葱模型，和 express 有什么区别\n * 事务的原理了解吗\n * 什么是内外连接\n * 索引了解吗，为什么索引能加快速度\n * 同步和异步的区别\n * 如果有六百万名考生的高考成绩要排序应该怎么做\n * web服务用过哪些？\n * 你提到了nginx，有做过一些负载均衡吗？\n\n\n# 算法\n\n * 找出数组中 n 项，n 项的和为 m\n * 口述快速排序\n * 冒泡，及冒泡的优化\n * 讲讲迪杰斯特拉算法\n * 讲讲最小生成树算法\n * 讲讲 hash 算法\n * 堆排序\n * 数组三分，如果一个数组能够分成非空的三个部分，每个部分和相等，则返回 true\n * 查找算法应该用堆还是用栈\n * 数据结构有那些\n * 快排时间复杂度+快排什么时候最慢\n * 洗牌算法\n * dp 和二叉树\n * 二叉树根据一个节点查找下一个节点\n * 从一个数组的后十个数中找出 3 个和为 10 的数字\n * 找出两个字符串（str1,str2）的最大公共子长度\n * 一次可以跳一步，两步，三步，问n步的路有多少种到达终点方式？（斐波那契，写了个尾递归）\n * 大量数据的数组，怎么找出排名前n个数\n * 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1\n * 实现 string 的 indexof() 函数\n * \n * 大数相加\n * 链表反转\n * 二叉树排序\n * 二叉树的翻转\n * 出现最多的字母个数\n * 找一篇文章中出现最多的英文单词\n * 正则匹配字符串\n * 现在给你一个树状对象，{value:1,children:{value:2,children:{...}}}这样的结构，如何把所有value删去，返回一个新对象？\n * 如何判断一个对象中有没有叫value的属性？不要考虑代码的复杂性，能说几种说几种\n * 说说你知道的排序和查找算法吧\n * 堆排序是如何实现的？时间复杂度是多少？\n * 有 1000 步的台阶，每次只能选择走 1 步、2 步或者 3 步，走完台阶一共有多少种走法\n * 长度为 1 亿的字符串，寻找字符串包含 'tencent' 子串的数量\n * 无序数组中选择第 k 大的数，分析算法时间复杂度\n * 两个整数求和会超过 int 范围 怎么运算\n * dfs 非递归 先序遍历\n * 数组中超过一半的数是同一个数，找出那个数（分析复杂度，如何优化）\n * 手撕二叉树的题目，leetcode124\n * 生成一个 8*8 的 01 棋盘，每行每列不能多于 1 个 1，输出生成的棋盘和符不符合规定\n * 数组和链表随机访问的时间复杂度\n * o(n) 寻找最长的连续字符串\n * 小明从老板那里拿到了一个密码表，说是如果解开密码表中的秘密，就可以升职加薪，赢取白富美，走向人生巅峰。这个密码表是一个 csv 文件，里面的数据由数字（没有小数点）、字母组成。小明需要提取每个数据中的数字（例如 1a2b3c 提取后得到 123，提取后的数字整体看作一个十进制数），把数值为奇数的项相加，就可以解开这个秘密。请你实现一个函数 sum，帮小明完成这项工作。\n\n\n\n * 在一个字符串中找出连续重复的字符，这个字符可以是数字、字母和中文等\n * 有效括号 - 判断一个字符串中括号是否都能匹配\n * 一个字符串里面有一些不可见的字符，如\"\\n\"，写一个算法剔除它们\n\n\n# 手撕\n\n * 数据绑定实现【框架和抛开框架，手撕】\n * 排序数组，查询某个值，存在则返回索引，不存在返回插入位置；优化，for~二分 【手撕】\n * js实现阶乘\n * 创建一个 person 类，其包含公有属性 name 和私有属性 age 以及公有方法 setage ；创建一个 teacher 类，使其继承 person ，并包含私有属性 studentcount 和私有方法 setstudentcount\n * 实现一个类似百度输入框的功能，根据用户的输入，找出一个数组中匹配到的数显示出来\n * 一个输入框实现百度搜索那样的 autocomplete 效果\n * 请写一个函数，计算一篇英文文章中出现次数最多的单词及出现次数\n * 怎么用 js 实现队列\n * js 观察者模式\n * 数组扁平化\n * 实现一个实数的堆栈，使得其 push pop max 方法的时间复杂度为 o(1)\n * 有一个整数二维数组，每行的元素个数不同，输出它的全排列，同一行的数互斥。要求不使用递归完成\n * 实现一个函数，检查二叉树是否平衡。\n * 实现一个 http 请求池，需要能够限制并发数\n * 合并二叉树\n * 奇偶链表\n * 使用闭包实现变量自加一\n * 双向链表转二叉树，二叉树转双向链表\n * url 正则匹配\n * nlogn 排序算法有哪些，快排稳定么\n * 构建排序二叉树\n * 搜索二叉树找第 k 大的数\n * 手写原生 ajax，new xmlhttprequest()\n * 手写对象深拷贝\n * 获取标签名称为 div 的元素的个数，并且判断是不是数组，考察类型判断\n * 给两个构造函数 a 和 b ，如何实现 a 继承 b\n * 用户权限认证过程\n * 写个模块导出的案例\n * 说下异步的问题，写个 promise 的使用小案例\n * 拖拽代码 (手写)\n * 手撕代码：大数相乘\n * 手撕代码：函数无限柯里化（有n个参数，函数调用n+1次得到结果）\n * 手撕代码：实现一个轮询器，主要考察 promise\n * 用 es5 的 let 实现一个闭包\n * 继承（实现私有属性和私有方法）\n * 设计实现一个固定执行顺序的 script 加载\n * 手写代码题：找出字符串中出现次数最多的字符及出现次数\n * 编程题（对输入的一段字符串（有逗号 有回车，挑出其中的数字，然后求和，求和之后再把数中的奇数加） 1.正则做法 2.字符串遍历做法，挑出数字 ， 换行，再按换行分割，再按，号分割，数组扁平，求和，变字符串，遍历\n * 数组去重手写，越多越好\n * 将一个平铺的数组用 js 写成树的结构\n * 完成函数的实现，使得它可以实现达到 array.prototype.foreach 相同的功能\n * 看下面代码执行结果，说明原因\n\n\n\n * \n * token 过期怎么做\n * 怎么知道用户和 token 的对应关系\n * token 和 cookie 区别\n * token 为什么比 cookie 更不容易受到攻击，为什么要用 cookie\n * 手撕 event bus\n * 手撕函数组合\n * 手撕对象扁平化\n\n\n\n * 给列表中的 li（里面是a标签）绑定点击事件，点击时弹出其在列表中的顺序（页面不跳转）\n * js实现一个 json.stringify() 功能的函数\n * 三次重试：假设有一个函数名为 job,调用 job 后会执行一些异步任务，并返回一个 promise ,但 job 执行的异步任务任务有可能会失败\n * 请实现函数 retry ,把 job 作为 retry 函数的参数传入，当 retry 执行后会尝试调用 job,如果 job 返回成功（即 promise fulfilled），则 retry 函数返回job函数的返回内容；\n * 如果 job 返回失败（即 promise rejected ）,retry 函数会再次尝试调用 job 函数。\n * 如果 job 连续三次均返回失败，retry 则不再尝试调用，并返回其最后一次失败的内容。\n\n\n\n\n\n * 给了一个代码片段，大概就是一个产生随机数的 for 循环，然后把这个随机数当作参数传到一个异步函数，问怎么保证输出顺序也是有序的，其实就是类似于同时发送几个 http 请求，怎么保证响应顺序也按照请求顺序依次返回\n * 写了个类型判断函数\n\n\n\n * 遍历根结点下所有子节点\n\n\n\n * 实现页脚在内容最底部\n\n\n\n\n# 智力题\n\n * 100 人教室 70 人喜欢足球，80 人喜欢篮球，问同时喜欢足球和篮球的人数\n * 试探玻璃杯破碎的楼层\n * 时针与分针夹角\n * 5.25 时针和分针夹角\n * 上一题拓展:x 时 y 分夹角\n * 一个班里 60% 喜欢 a, 70% 喜欢 b, 80% 喜欢 c, 问同时喜欢 abc 的\n * 一瓶汽水一块钱，俩空瓶可以换一瓶汽水，给你 20 块钱，最多喝多少瓶？\n * 给你一个 a4 纸张，随便剪掉一个随意位置宽高的矩形，给你一个没有刻度的尺子和笔，怎么一刀把剩下的 a4 纸张分成面积同样大小的两半。\n * 如何洗开一副扑克牌\n * a 和 b 两个人投掷硬币，朝上 a 得 1 分，反之 b 得分，现在 a8 分、b7 分，请问 a 和 b 先到 10 分的概率各是多少。\n * 一根不均匀绳子烧完一个小时，问怎么使用多根这种绳子来计算 15 分钟\n * 一个烤盘，每次最多烤两块肉，一面烤 10min，问要烤几分钟\n * 20 个瓶子，有 19 个瓶子每颗药 1g，有一个瓶子每颗药 1.1g，问怎么用一把称一次找出 1.1g 的瓶子\n\n\n# 拓展问题\n\n * excel 同步/冲突\n * ot 算法\n\n\n# 非技术相关\n\n * 讲一下你觉得最自豪的项目\n * 对该职位的学习方式（根据对方的回答，需要的人员应该是看过专业书籍，有去了解这一方面的大佬并针对其技术分享进行学习。而不只是用的时候再学，野网站学习。可以简洁为愿意并且会主动地学习）\n * 认为前端开发中比较难、比较重要的地方\n * 除了 react 还用了哪些技术\n * 遇到过的难点，如何解决的？\n * 有读英文文档的习惯吗？\n * ts 和 java 对比，ts 和 es6 对比，js 对比框架\n * 面试过其他什么公司\n * 什么时候开始学习前端的，学习前端的方式，平时都看过哪些书？\n * 平时学前端看什么书呀？说说学习路线吧\n * 你看书或者看博客学习的时候，是怎么做总结的\n * 最近都有再看什么书？\n * 写文章的时候总有个先后顺序或者一定的结构吧，你是怎么做的\n * 没有试过思维导图\n * 在前端上未来有什么打算？有没有什么想学的东西？是只想找个工作还是想怎么发展？\n * 为什么说自己擅长沟通和有抗压能力\n * 问了计算机组成，问我 cache 知道吗，我大概说了说，然后问为什么 cache 更快\n * 操作系统，银行家算法，死锁怎么解决\n * 为什么学习前端\n * 我在学习过程中遇到了哪些困难，怎么解决的。\n * 有没有关注前端的新技术\n * flutter 有了解吗\n * h5 有写过吗，移动端有了解吗\n * 了解过小程序吗\n * 如何衡量一个软件的质量？如何保证产品的质量？（软件工程的思想，敏捷中的测试驱动开发）\n * 找出不多于三个关键词形容自己\n * 怎么跟一个不懂前端的人介绍前端\n\n# hr问题\n\n * 自我介绍\n * 讲一讲最近收获最大的一个项目，在项目担任的角色\n * 有什么爱好，为什么喜欢\n * 是否为独生子女\n * 是否去过深圳\n * 是否考研\n * 什么专业，为什么不选择省外的高校\n * 是否有其它公司 offer\n * 入职时间，可实习多久\n * 说说自己性格的优点和缺点\n * 你怎么看我们部门\n * 你了解过我们是做什么的吗\n * 你平常怎么学习\n * 你的未来规划是什么\n * 你女朋友不让你来深圳怎么办\n * 什么时候能入职 能做多久\n * 参加过什么比赛，拿过什么奖\n * 老师和同学对自己评价的优缺点\n * 成绩在年级上的位置\n * 说下团队的规模，在团队的角色\n * 觉得自己技术怎么样\n * 什么时候开始用 github，更新频率怎么样\n\n# 总监面\n\n * 如何学习全新的框架\n * 一个卡顿的项目交给你，怎么去进行优化\n * 周围有人拿到腾讯 offer 了吗？\n * 介绍了一下我的专业干啥的\n * 日常开发中遇到问题怎么解决\n * 建立中的项目有啥亮点\n * 前端处理耗时比较长的计算问题，如何防止页面卡顿的优化方案\n * bilibili 上面一键三连怎么实现\n * 自己的职业规划",charsets:{cjk:!0}},{title:"前端笔试题",frontmatter:{},regularPath:"/progress/interview4.html",relativePath:"progress/interview4.md",key:"v-53fa5556",path:"/progress/interview4.html",headers:[{level:2,title:"题目一：",slug:"题目一",normalizedTitle:"题目一：",charIndex:12},{level:2,title:"题目二：",slug:"题目二",normalizedTitle:"题目二：",charIndex:99},{level:2,title:"题目三：",slug:"题目三",normalizedTitle:"题目三：",charIndex:280},{level:2,title:"题目四：",slug:"题目四",normalizedTitle:"题目四：",charIndex:535},{level:2,title:"题目五：",slug:"题目五",normalizedTitle:"题目五：",charIndex:697},{level:2,title:"题目六：",slug:"题目六",normalizedTitle:"题目六：",charIndex:920}],headersStr:"题目一： 题目二： 题目三： 题目四： 题目五： 题目六：",content:"# 前端笔试题\n\n\n# 题目一：\n\nconsole.log(11+'1'-'1');\nconsole.log(11++'1'-'1');\n\n\n请问输出的值分别是多少？\n\n答：\n\n110\n\n\n\n\n# 题目二：\n\nlet a = {n:1},ref = a;\na.x = a = {n:2};\nconsole.log(a.x,ref);\n\n\n请问输出的值分别是多少？\n\n答：\n\na={n:1}\nref=a={n:1}\na.x = a = {n:2};\n==>a={n:2,x:{n:2}}\na.x = {n:2}\nref = {n:2,x:{n:2}}\n\n\n\n# 题目三：\n\nconst  length = 10;\nfunction fn(){\n    console.log(this.length)\n}\nconst obj = {\n    length:5;\n    method:function(fn){\n        console.log(this.length)\n        fn();\n        arguments[0]()\n    }\n}\nobj.method(fn,obj.length)\n\n\n请问输出的值分别是多少？\n\n答：\n\n\n\n\n\n# 题目四：\n\nconst fn = arr => arr.reduce((m,n)=>m.concat(Array.isArray(n)?fn(n):n),[]);\nconst a = fn([[1,2],[[3,4],[5,[6]]]]);\nconsole.log(a);\n\n\n请问输出的值分别是多少？\n\n答：\n\n\n\n\n# 题目五：\n\nconst fn = (n,o) => {\n    console.log(o);\n    return {\n        fn:m=>fn(m,n)\n    }\n}\nlet a = fn(0);a.fn(1);a.fn(2);a.fn(3);\nlet b = fn(0).fn(1).fn(2),fn(3);\nlet c = fn(0).fn(1);c.fn(2);c.fn(3);\n\n\n请问输出的值分别是多少？\n\n答：\n\n\n# 题目六：\n\n请按顺序列出下列代码输出的值\n\n(async()=>{\n    setTimeout(()=>{\n        console.log(1);\n        Promise.resolve().then(()=>{\n            console.log(2);\n        })\n    })\n    await new Promise(recolve => {\n        console.log(3);\n        recolve(4);\n    }).then(res=>{\n        console.log(res);\n        setTimeout(()=>{\n            console.log(5);\n        })\n    })\n    setTimeout(()=>{\n        console.log(6)\n    })\n    console.log(7)\n    setTimeout(()=>{\n        console.log(8)\n    })\n})();\n\n\n答：\n\n",normalizedContent:"# 前端笔试题\n\n\n# 题目一：\n\nconsole.log(11+'1'-'1');\nconsole.log(11++'1'-'1');\n\n\n请问输出的值分别是多少？\n\n答：\n\n110\n\n\n\n\n# 题目二：\n\nlet a = {n:1},ref = a;\na.x = a = {n:2};\nconsole.log(a.x,ref);\n\n\n请问输出的值分别是多少？\n\n答：\n\na={n:1}\nref=a={n:1}\na.x = a = {n:2};\n==>a={n:2,x:{n:2}}\na.x = {n:2}\nref = {n:2,x:{n:2}}\n\n\n\n# 题目三：\n\nconst  length = 10;\nfunction fn(){\n    console.log(this.length)\n}\nconst obj = {\n    length:5;\n    method:function(fn){\n        console.log(this.length)\n        fn();\n        arguments[0]()\n    }\n}\nobj.method(fn,obj.length)\n\n\n请问输出的值分别是多少？\n\n答：\n\n\n\n\n\n# 题目四：\n\nconst fn = arr => arr.reduce((m,n)=>m.concat(array.isarray(n)?fn(n):n),[]);\nconst a = fn([[1,2],[[3,4],[5,[6]]]]);\nconsole.log(a);\n\n\n请问输出的值分别是多少？\n\n答：\n\n\n\n\n# 题目五：\n\nconst fn = (n,o) => {\n    console.log(o);\n    return {\n        fn:m=>fn(m,n)\n    }\n}\nlet a = fn(0);a.fn(1);a.fn(2);a.fn(3);\nlet b = fn(0).fn(1).fn(2),fn(3);\nlet c = fn(0).fn(1);c.fn(2);c.fn(3);\n\n\n请问输出的值分别是多少？\n\n答：\n\n\n# 题目六：\n\n请按顺序列出下列代码输出的值\n\n(async()=>{\n    settimeout(()=>{\n        console.log(1);\n        promise.resolve().then(()=>{\n            console.log(2);\n        })\n    })\n    await new promise(recolve => {\n        console.log(3);\n        recolve(4);\n    }).then(res=>{\n        console.log(res);\n        settimeout(()=>{\n            console.log(5);\n        })\n    })\n    settimeout(()=>{\n        console.log(6)\n    })\n    console.log(7)\n    settimeout(()=>{\n        console.log(8)\n    })\n})();\n\n\n答：\n\n",charsets:{cjk:!0}},{title:"内容",frontmatter:{},regularPath:"/progress/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.html",relativePath:"progress/每日学习总结.md",key:"v-cdf217ce",path:"/progress/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.html",headers:[{level:2,title:"8月计划（把精讲视频快速过一遍）=20个小章节",slug:"_8月计划-把精讲视频快速过一遍-20个小章节",normalizedTitle:"8月计划（把精讲视频快速过一遍）=20个小章节",charIndex:2262},{level:2,title:"8月第二周8/9-8/15（==5%）",slug:"_8月第二周8-9-8-15-5",normalizedTitle:"8月第二周8/9-8/15（==5%）",charIndex:2551},{level:2,title:"8月第三周8/16-8/22",slug:"_8月第三周8-16-8-22",normalizedTitle:"8月第三周8/16-8/22",charIndex:2677},{level:2,title:"8月第四周8/23-8/29",slug:"_8月第四周8-23-8-29",normalizedTitle:"8月第四周8/23-8/29",charIndex:2938},{level:2,title:"9月第一周8/30-9/5",slug:"_9月第一周8-30-9-5",normalizedTitle:"9月第一周8/30-9/5",charIndex:3155},{level:2,title:"9月第二周9/6-9/12",slug:"_9月第二周9-6-9-12",normalizedTitle:"9月第二周9/6-9/12",charIndex:3462},{level:2,title:"9月第三周9/13-9/19",slug:"_9月第三周9-13-9-19",normalizedTitle:"9月第三周9/13-9/19",charIndex:3571},{level:2,title:"9月第四周9/20-9/26",slug:"_9月第四周9-20-9-26",normalizedTitle:"9月第四周9/20-9/26",charIndex:3685},{level:2,title:"9月第五周9/27-10/3",slug:"_9月第五周9-27-10-3",normalizedTitle:"9月第五周9/27-10/3",charIndex:3778},{level:2,title:"10月第一周10/4-10/10",slug:"_10月第一周10-4-10-10",normalizedTitle:"10月第一周10/4-10/10",charIndex:3856},{level:2,title:"10月第二周10/11-10/17",slug:"_10月第二周10-11-10-17",normalizedTitle:"10月第二周10/11-10/17",charIndex:3924},{level:2,title:"10月第三周10/18-10/24",slug:"_10月第三周10-18-10-24",normalizedTitle:"10月第三周10/18-10/24",charIndex:3999},{level:2,title:"10月第四周10/25-10/31",slug:"_10月第四周10-25-10-31",normalizedTitle:"10月第四周10/25-10/31",charIndex:4074}],headersStr:"8月计划（把精讲视频快速过一遍）=20个小章节 8月第二周8/9-8/15（==5%） 8月第三周8/16-8/22 8月第四周8/23-8/29 9月第一周8/30-9/5 9月第二周9/6-9/12 9月第三周9/13-9/19 9月第四周9/20-9/26 9月第五周9/27-10/3 10月第一周10/4-10/10 10月第二周10/11-10/17 10月第三周10/18-10/24 10月第四周10/25-10/31",content:"# 内容\n\n 1.  信息化知识\n     1. 信息与信息化\n     2. 国家信息化战略和规划\n     3. 电子政务\n     4. 企业信息化和两化深度融合\n     5. 商业智能\n     6. 数据库与数据仓库\n     7. 数据仓库Data Warehouse\n 2.  信息系统集成专业技术知识\n     1. 信息系统建设\n     2. 信息系统设计\n     3. 软件工程\n     4. 面对对象技术\n     5. 软件架构\n     6. 典型应用集成技术\n 3.  计算机网络基础\n     1. 网络技术标准与协议\n     2. 计算机网络分类\n     3. 网络交换、存储技术\n     4. 网络规划与设计\n 4.  信息系统安全管理\n     1. 数据加密与认证\n     2. 信息系统安全\n     3. 网络安全\n     4. 物理安全管理\n     5. 人员安全管理\n     6. 应用系统安全管理\n 5.  信息系统服务管理\n     1. 信息系统集成及服务\n     2. 信息系统集成及服务资质\n     3. IT服务管理及信息系统审计\n 6.  知识产权与标准化知识\n     1. 知识产权\n     2. 标准化基础知识\n 7.  新一代信息技术\n     1. 大数据\n     2. 人工智能AI\n     3. 物联网\n     4. 云计算\n     5. 5G\n     6. 互联网+\n     7. 移动互联网\n     8. 智慧城市\n 8.  项目管理基础知识\n     1. 项目与项目管理基本概念\n        1. 项目的定义与特点\n        2. 项目的目标\n        3. 项目管理-知识体系\n        4. 项目干系人\n        5. 项目经理\n        6. 事业环境因素和组织过资产\n     2. 项目组织方式\n        1. 组织结构\n        2. 项目管理办公室（PMO）\n     3. 项目生命周期\n     4. 项目管理过程\n 9.  项目立项管理\n     1. 项目建议\n     2. 项目可行性研究\n        1. 项目可行性研究内容\n        2. 项目可行性研究阶段\n     3. 项目招投标\n     4. 供应商项目立项\n     5. 案例分析\n 10. 项目整体管理\n     1. 基本情况、整体整理的过程\n     2. 制定项目章程\n     3. 制定项目管理计划\n     4. 指导和管理项目工作\n     5. 监控项目工作\n     6. 实施整体变更控制\n     7. 结束项目或阶段\n 11. 项目范围管理\n     1. 编制范围管理计划\n     2. 收集需求\n     3. 定义范围\n     4. 创建工作分解结构\n     5. 确认范围\n     6. 控制范围\n 12. 项目进度管理\n     1. 进度管理基本过程\n     2. 规划进度管理\n     3. 定义活动\n     4. 排列活动顺序\n     5. 估算活动资源\n     6. 估算活动持续时间\n     7. 制定进度计划\n        1. 制定进度计划-01\n        2. 制定进度计划-02\n     8. 控制进度\n     9. 案例分析\n 13. 项目成本管理\n     1. 基本概念\n     2. 规划成本管理\n     3. 估算成本\n     4. 制定预算\n     5. 控制成本\n     6. 案例分析\n 14. 项目质量管理\n     1. 质量管理的概念\n     2. 质量管理发展史\n     3. 规划质量管理\n     4. 实施质量保证\n     5. 控制质量\n     6. 案例分析\n 15. 项目人力资源管理\n     1. 编制项目人力资源计划\n     2. 组建项目团队\n     3. 项目团队建设\n     4. 管理项目团队\n     5. 案例分析\n 16. 项目沟通管理\n     1. 沟通管理基础知识\n     2. 规划沟通管理\n     3. 管理沟通\n     4. 控制沟通\n     5. 案例分析\n 17. 项目干系人管理\n     1. 干系人管理的过程\n     2. 识别干系人\n     3. 编辑干系人管理计划\n     4. 规划干系人管理\n     5. 管理干系人参与\n     6. 控制干系人参与\n     7. 案例分析\n 18. 项目风险管理\n     1.  风险管理的过程\n     2.  风险的分类\n     3.  风险基础概念\n     4.  规划风险管理\n     5.  识别风险\n     6.  实施定性风险分析\n     7.  实施定量风险分析\n     8.  规划风险应对\n     9.  控制风险\n     10. 案例分析\n 19. 项目采购管理\n     1. 采购管理的过程\n     2. 规划采购管理\n     3. 实施采购\n     4. 控制采购\n     5. 结束采购\n 20. 项目配置管理\n     1. 配置管理概念\n     2. 配置管理活动\n\n\n# 8月\n\n\n# 定下目标（11/6-7考软考集成中级）\n\n\n# 8月计划（把精讲视频快速过一遍）=20个小章节\n\n 1.  信息化知识\n 2.  信息系统集成专业技术知识\n 3.  计算机网络基础\n 4.  信息系统安全管理\n 5.  信息系统服务管理\n 6.  知识产权与标准化知识\n 7.  新一代信息技术\n 8.  项目管理基础知识\n 9.  项目立项管理\n 10. 项目整体管理\n 11. 项目范围管理\n 12. 项目进度管理\n 13. 项目成本管理\n 14. 项目质量管理\n 15. 项目人力资源管理\n 16. 项目沟通管理\n 17. 项目干系人管理\n 18. 项目风险管理\n 19. 项目采购管理\n 20. 项目配置管理\n\n\n# 8月第二周8/9-8/15（==5%）\n\n8/9（下单视频+教程）\n\n 1. 信息化知识-信息与信息化\n\n8/10（发货）\n\n8/11\n\n8/12（==5%）\n\n 1. 信息化知识(1)（=7/7）\n\n8/13\n\n8/14\n\n8/15\n\n总结\n\n\n# 8月第三周8/16-8/22\n\n8/16（==10%）\n\n 1. 信息系统集成专业技术知识(2)（=6/6）\n\n8/17（==15%）\n\n 1. 开会\n 2. 计算机网络基础(3)（=4/4）\n\n8/18（==25%）\n\n 1. 信息系统安全管理(4)=6/6\n 2. 信息系统服务管理(5)=3/3\n\n8/19（==35%）\n\n 1. 知识产权与标准化知识(6)2/2\n 2. 新一代信息技术(7)8/8\n\n8/20（==35%）\n\n8/21（==40%）\n\n 1. 项目管理基础知识(8)=4/4\n\n8/22\n\n\n# 8月第四周8/23-8/29\n\n8/23（==45%）\n\n 1. 项目立项管理(9)=5/5\n\n8/24(==50%)\n\n 1. 项目整体管理(10)=7/7\n\n8/25(==55%)\n\n 1. 项目范围管理(11)=6/6\n\n8/26\n\n 1. 项目进度管理(12)=4/8\n\n8/27\n\n 1. 项目进度管理(12)=6/8\n\n8/28\n\n 1. 项目进度管理(12)=8/8\n\n8/29\n\n总结\n\n\n# 9月（30日）\n\n\n# 9月第一周8/30-9/5\n\n8/30\n\n 1. 项目成本管理(13)=6/6\n 2. 项目质量管理(14)=6/6\n 3. 项目人力资源管理(15)=3/5\n\n8/31\n\n 1. 项目人力资源管理(15)=5/5\n 2. 项目沟通管理(16)=5/5\n 3. 项目干系人管理(17)=1/7\n\n9/1\n\n 1. \n\n9/2\n\n 1. 项目干系人管理(17)=7/7\n 2. 项目风险管理(18)=1/10\n\n9/3\n\n 1. 项目风险管理(18)=10/10\n 2. 项目配置管理(19)=1/5\n\n9/4\n\n 1. 项目配置管理(19)=5/5\n 2. 项目采购管理(20)=2/2\n\n9/5\n\n总结\n\n\n# 9月第二周9/6-9/12\n\n9/6\n\n 1. 无\n\n9/7\n\n 1. 无\n\n9/8\n\n 1. 无\n\n9/9\n\n 1. 无\n\n9/10\n\n 1. 无\n\n9/11\n\n 1. 无\n\n9/12\n\n 1. 无\n\n总结\n\n\n# 9月第三周9/13-9/19\n\n9/13\n\n 1. 无\n\n9/14\n\n 1. 无\n\n9/15\n\n 1. 无\n\n9/16\n\n 1. 无\n\n9/17\n\n 1. 无\n\n9/18\n\n 1. 无\n\n9/19\n\n 1. 无\n\n总结\n\n\n# 9月第四周9/20-9/26\n\n9/20\n\n 1. 无\n\n9/21\n\n 1. 无\n\n9/22\n\n 1. 无\n\n9/23\n\n 1. 无\n\n9/24\n\n9/25\n\n9/26\n\n总结\n\n\n# 9月第五周9/27-10/3\n\n9/27\n\n9/28\n\n9/29\n\n9/30\n\n10/1\n\n10/2\n\n10/3\n\n总结\n\n\n# 10月（31日）\n\n\n# 10月第一周10/4-10/10\n\n10/4\n\n10/5\n\n10/6\n\n10/7\n\n10/8\n\n10/9\n\n10/10\n\n总结\n\n\n# 10月第二周10/11-10/17\n\n10/11\n\n10/12\n\n10/13\n\n10/14\n\n10/15\n\n10/16\n\n10/17\n\n总结\n\n\n# 10月第三周10/18-10/24\n\n10/18\n\n10/19\n\n10/20\n\n10/21\n\n10/22\n\n10/23\n\n10/24\n\n总结\n\n\n# 10月第四周10/25-10/31\n\n10/25\n\n10/26\n\n10/27\n\n10/28\n\n10/29\n\n10/30\n\n10/31\n\n总结\n\n\n# 11月（5日）\n\n11月第一周11/1-11/7\n\n11/1\n\n11/2\n\n11/3\n\n11/4\n\n11/5\n\n11/6=====考试",normalizedContent:"# 内容\n\n 1.  信息化知识\n     1. 信息与信息化\n     2. 国家信息化战略和规划\n     3. 电子政务\n     4. 企业信息化和两化深度融合\n     5. 商业智能\n     6. 数据库与数据仓库\n     7. 数据仓库data warehouse\n 2.  信息系统集成专业技术知识\n     1. 信息系统建设\n     2. 信息系统设计\n     3. 软件工程\n     4. 面对对象技术\n     5. 软件架构\n     6. 典型应用集成技术\n 3.  计算机网络基础\n     1. 网络技术标准与协议\n     2. 计算机网络分类\n     3. 网络交换、存储技术\n     4. 网络规划与设计\n 4.  信息系统安全管理\n     1. 数据加密与认证\n     2. 信息系统安全\n     3. 网络安全\n     4. 物理安全管理\n     5. 人员安全管理\n     6. 应用系统安全管理\n 5.  信息系统服务管理\n     1. 信息系统集成及服务\n     2. 信息系统集成及服务资质\n     3. it服务管理及信息系统审计\n 6.  知识产权与标准化知识\n     1. 知识产权\n     2. 标准化基础知识\n 7.  新一代信息技术\n     1. 大数据\n     2. 人工智能ai\n     3. 物联网\n     4. 云计算\n     5. 5g\n     6. 互联网+\n     7. 移动互联网\n     8. 智慧城市\n 8.  项目管理基础知识\n     1. 项目与项目管理基本概念\n        1. 项目的定义与特点\n        2. 项目的目标\n        3. 项目管理-知识体系\n        4. 项目干系人\n        5. 项目经理\n        6. 事业环境因素和组织过资产\n     2. 项目组织方式\n        1. 组织结构\n        2. 项目管理办公室（pmo）\n     3. 项目生命周期\n     4. 项目管理过程\n 9.  项目立项管理\n     1. 项目建议\n     2. 项目可行性研究\n        1. 项目可行性研究内容\n        2. 项目可行性研究阶段\n     3. 项目招投标\n     4. 供应商项目立项\n     5. 案例分析\n 10. 项目整体管理\n     1. 基本情况、整体整理的过程\n     2. 制定项目章程\n     3. 制定项目管理计划\n     4. 指导和管理项目工作\n     5. 监控项目工作\n     6. 实施整体变更控制\n     7. 结束项目或阶段\n 11. 项目范围管理\n     1. 编制范围管理计划\n     2. 收集需求\n     3. 定义范围\n     4. 创建工作分解结构\n     5. 确认范围\n     6. 控制范围\n 12. 项目进度管理\n     1. 进度管理基本过程\n     2. 规划进度管理\n     3. 定义活动\n     4. 排列活动顺序\n     5. 估算活动资源\n     6. 估算活动持续时间\n     7. 制定进度计划\n        1. 制定进度计划-01\n        2. 制定进度计划-02\n     8. 控制进度\n     9. 案例分析\n 13. 项目成本管理\n     1. 基本概念\n     2. 规划成本管理\n     3. 估算成本\n     4. 制定预算\n     5. 控制成本\n     6. 案例分析\n 14. 项目质量管理\n     1. 质量管理的概念\n     2. 质量管理发展史\n     3. 规划质量管理\n     4. 实施质量保证\n     5. 控制质量\n     6. 案例分析\n 15. 项目人力资源管理\n     1. 编制项目人力资源计划\n     2. 组建项目团队\n     3. 项目团队建设\n     4. 管理项目团队\n     5. 案例分析\n 16. 项目沟通管理\n     1. 沟通管理基础知识\n     2. 规划沟通管理\n     3. 管理沟通\n     4. 控制沟通\n     5. 案例分析\n 17. 项目干系人管理\n     1. 干系人管理的过程\n     2. 识别干系人\n     3. 编辑干系人管理计划\n     4. 规划干系人管理\n     5. 管理干系人参与\n     6. 控制干系人参与\n     7. 案例分析\n 18. 项目风险管理\n     1.  风险管理的过程\n     2.  风险的分类\n     3.  风险基础概念\n     4.  规划风险管理\n     5.  识别风险\n     6.  实施定性风险分析\n     7.  实施定量风险分析\n     8.  规划风险应对\n     9.  控制风险\n     10. 案例分析\n 19. 项目采购管理\n     1. 采购管理的过程\n     2. 规划采购管理\n     3. 实施采购\n     4. 控制采购\n     5. 结束采购\n 20. 项目配置管理\n     1. 配置管理概念\n     2. 配置管理活动\n\n\n# 8月\n\n\n# 定下目标（11/6-7考软考集成中级）\n\n\n# 8月计划（把精讲视频快速过一遍）=20个小章节\n\n 1.  信息化知识\n 2.  信息系统集成专业技术知识\n 3.  计算机网络基础\n 4.  信息系统安全管理\n 5.  信息系统服务管理\n 6.  知识产权与标准化知识\n 7.  新一代信息技术\n 8.  项目管理基础知识\n 9.  项目立项管理\n 10. 项目整体管理\n 11. 项目范围管理\n 12. 项目进度管理\n 13. 项目成本管理\n 14. 项目质量管理\n 15. 项目人力资源管理\n 16. 项目沟通管理\n 17. 项目干系人管理\n 18. 项目风险管理\n 19. 项目采购管理\n 20. 项目配置管理\n\n\n# 8月第二周8/9-8/15（==5%）\n\n8/9（下单视频+教程）\n\n 1. 信息化知识-信息与信息化\n\n8/10（发货）\n\n8/11\n\n8/12（==5%）\n\n 1. 信息化知识(1)（=7/7）\n\n8/13\n\n8/14\n\n8/15\n\n总结\n\n\n# 8月第三周8/16-8/22\n\n8/16（==10%）\n\n 1. 信息系统集成专业技术知识(2)（=6/6）\n\n8/17（==15%）\n\n 1. 开会\n 2. 计算机网络基础(3)（=4/4）\n\n8/18（==25%）\n\n 1. 信息系统安全管理(4)=6/6\n 2. 信息系统服务管理(5)=3/3\n\n8/19（==35%）\n\n 1. 知识产权与标准化知识(6)2/2\n 2. 新一代信息技术(7)8/8\n\n8/20（==35%）\n\n8/21（==40%）\n\n 1. 项目管理基础知识(8)=4/4\n\n8/22\n\n\n# 8月第四周8/23-8/29\n\n8/23（==45%）\n\n 1. 项目立项管理(9)=5/5\n\n8/24(==50%)\n\n 1. 项目整体管理(10)=7/7\n\n8/25(==55%)\n\n 1. 项目范围管理(11)=6/6\n\n8/26\n\n 1. 项目进度管理(12)=4/8\n\n8/27\n\n 1. 项目进度管理(12)=6/8\n\n8/28\n\n 1. 项目进度管理(12)=8/8\n\n8/29\n\n总结\n\n\n# 9月（30日）\n\n\n# 9月第一周8/30-9/5\n\n8/30\n\n 1. 项目成本管理(13)=6/6\n 2. 项目质量管理(14)=6/6\n 3. 项目人力资源管理(15)=3/5\n\n8/31\n\n 1. 项目人力资源管理(15)=5/5\n 2. 项目沟通管理(16)=5/5\n 3. 项目干系人管理(17)=1/7\n\n9/1\n\n 1. \n\n9/2\n\n 1. 项目干系人管理(17)=7/7\n 2. 项目风险管理(18)=1/10\n\n9/3\n\n 1. 项目风险管理(18)=10/10\n 2. 项目配置管理(19)=1/5\n\n9/4\n\n 1. 项目配置管理(19)=5/5\n 2. 项目采购管理(20)=2/2\n\n9/5\n\n总结\n\n\n# 9月第二周9/6-9/12\n\n9/6\n\n 1. 无\n\n9/7\n\n 1. 无\n\n9/8\n\n 1. 无\n\n9/9\n\n 1. 无\n\n9/10\n\n 1. 无\n\n9/11\n\n 1. 无\n\n9/12\n\n 1. 无\n\n总结\n\n\n# 9月第三周9/13-9/19\n\n9/13\n\n 1. 无\n\n9/14\n\n 1. 无\n\n9/15\n\n 1. 无\n\n9/16\n\n 1. 无\n\n9/17\n\n 1. 无\n\n9/18\n\n 1. 无\n\n9/19\n\n 1. 无\n\n总结\n\n\n# 9月第四周9/20-9/26\n\n9/20\n\n 1. 无\n\n9/21\n\n 1. 无\n\n9/22\n\n 1. 无\n\n9/23\n\n 1. 无\n\n9/24\n\n9/25\n\n9/26\n\n总结\n\n\n# 9月第五周9/27-10/3\n\n9/27\n\n9/28\n\n9/29\n\n9/30\n\n10/1\n\n10/2\n\n10/3\n\n总结\n\n\n# 10月（31日）\n\n\n# 10月第一周10/4-10/10\n\n10/4\n\n10/5\n\n10/6\n\n10/7\n\n10/8\n\n10/9\n\n10/10\n\n总结\n\n\n# 10月第二周10/11-10/17\n\n10/11\n\n10/12\n\n10/13\n\n10/14\n\n10/15\n\n10/16\n\n10/17\n\n总结\n\n\n# 10月第三周10/18-10/24\n\n10/18\n\n10/19\n\n10/20\n\n10/21\n\n10/22\n\n10/23\n\n10/24\n\n总结\n\n\n# 10月第四周10/25-10/31\n\n10/25\n\n10/26\n\n10/27\n\n10/28\n\n10/29\n\n10/30\n\n10/31\n\n总结\n\n\n# 11月（5日）\n\n11月第一周11/1-11/7\n\n11/1\n\n11/2\n\n11/3\n\n11/4\n\n11/5\n\n11/6=====考试",charsets:{cjk:!0}},{title:"react",frontmatter:{},regularPath:"/react/",relativePath:"react/README.md",key:"v-bda116b6",path:"/react/",headers:[{level:2,title:"React 的组件间通信都有哪些形式？",slug:"react-的组件间通信都有哪些形式",normalizedTitle:"react 的组件间通信都有哪些形式？",charIndex:12},{level:2,title:"React 中如何实现路由懒加载？",slug:"react-中如何实现路由懒加载",normalizedTitle:"react 中如何实现路由懒加载？",charIndex:280},{level:2,title:"React 的生命周期函数都有哪些，分别有什么作用？",slug:"react-的生命周期函数都有哪些-分别有什么作用",normalizedTitle:"react 的生命周期函数都有哪些，分别有什么作用？",charIndex:1001},{level:2,title:"说一下React Hooks在平时开发中需要注意的问题和原因?",slug:"说一下react-hooks在平时开发中需要注意的问题和原因",normalizedTitle:"说一下react hooks在平时开发中需要注意的问题和原因?",charIndex:1591},{level:2,title:"React 的 setState 方法是异步还是同步？",slug:"react-的-setstate-方法是异步还是同步",normalizedTitle:"react 的 setstate 方法是异步还是同步？",charIndex:2253},{level:2,title:"有没有写过 Koa 中间件，说下中 间件原理，介绍下自己写过的中间件?",slug:"有没有写过-koa-中间件-说下中-间件原理-介绍下自己写过的中间件",normalizedTitle:"有没有写过 koa 中间件，说下中 间件原理，介绍下自己写过的中间件?",charIndex:2484},{level:2,title:"在 React 项目中，想要进行逻辑复用,有哪些方案？",slug:"在-react-项目中-想要进行逻辑复用-有哪些方案",normalizedTitle:"在 react 项目中，想要进行逻辑复用,有哪些方案？",charIndex:3438},{level:2,title:"React中的diff是怎样的？",slug:"react中的diff是怎样的",normalizedTitle:"react中的diff是怎样的？",charIndex:5803},{level:2,title:"在 React 中，针对类组件 和 函数组件，分别怎么去进行性能优化？",slug:"在-react-中-针对类组件-和-函数组件-分别怎么去进行性能优化",normalizedTitle:"在 react 中，针对类组件 和 函数组件，分别怎么去进行性能优化？",charIndex:11890}],headersStr:"React 的组件间通信都有哪些形式？ React 中如何实现路由懒加载？ React 的生命周期函数都有哪些，分别有什么作用？ 说一下React Hooks在平时开发中需要注意的问题和原因? React 的 setState 方法是异步还是同步？ 有没有写过 Koa 中间件，说下中 间件原理，介绍下自己写过的中间件? 在 React 项目中，想要进行逻辑复用,有哪些方案？ React中的diff是怎样的？ 在 React 中，针对类组件 和 函数组件，分别怎么去进行性能优化？",content:'# react\n\n\n# React 的组件间通信都有哪些形式？\n\n 1. 父传子：在 React 中，父组件调用子组件时可以将要传递给子组件的数据添加在子组件的属性中，在子组件中通过 props 属性进行接收。这个就是父组件向子组件通信。\n 2. 子传父：React 是单向数据流，数据永远只能自上向下进行传递。当子组件中有些数据需要向父级进行通信时，需要在父级中定义好回调，将回调传递给子组件，子组件调用父级传递过来的回调方法进行通信。\n 3. 跨组件通信 - context。使用 context API，可以在组件中向其子孙级组件进行信息传递。\n\n\n# React 中如何实现路由懒加载？\n\n在 React 16 中，新增了 lazy 方法，通过 lazy 方法可以轻松实现组件懒加载，当然要实现路由懒加载的话，其实也只需要把路由组件结合 lazy 使用即可。 参考代码如下：\n\nimport {Route} from "react-router-dom";\nimport React,{Suspense} from \'react\';\nconst HomeView = React.lazy(()=>import("./home"));\nfunction App(){\n    return <div>\n        <h1>路由懒加载</h1>\n        <Route path="/" exact render={()=>{\n                return <Suspense fallback={<div>组件Loading进来之前的占位内容</div>}>\n                    <HomeView />\n                </Suspense>\n            }} />\n    </div>\n}\nexport default App;\n\n\n在上述代码中，我们使用 lazy 引入了一个动态组件，然后将该组件放入了根路由中。这样的话只有用户访问网站首页时，才会动态加载这个组件。 这里要注意，在 React 规范中，lazy 和 Suspense 必须配合使用，lazy 引入的动态组件必须要放入 Suspense 中，Suspense 的 fallback 属性是 lazy 的组件没有加载进来之前的占位内容。\n\n\n# React 的生命周期函数都有哪些，分别有什么作用？\n\nReact 的生命周期已经经历了3次改动，我们以最新的版本为准。 具体可以看下图： 挂载阶段： （1）constructor: 初始化组件，初始化组件的 state 等。 （2）static getDerivedStateFromProps()：该函数用于将 props 中的信息映射到 state 中。 （3）render: 生成虚拟DOM （4）componentDidMount：组件挂载完成，通过在该函数中去处理副作用 更新阶段： （5）static getDerivedStateFromProps() （6）shouldComponentUpdate()：该生命周期函数用于判断是否要进行组件更新。 （7）render()：生成虚拟DOM （8）getSnapshotBeforeUpdate()：组件已经完成 diff，即将更新真实 DOM，用户获取上一次的DOM快照。该函数必须搭配 componentDidUpdate 一块使用，返回值会变成 componentDidUpdate 第三个参数。 （9）componentDidUpdate()： 组件更新完成，通常在该函数中进行副作用处理。 即将卸载： componentWillUnmount：组件即将卸载，用于删除组件添加到全局的数据或事件。\n\n\n# 说一下React Hooks在平时开发中需要注意的问题和原因?\n\nReact Hooks 在使用时注意事项： （1） 只能在 React 函数中使用（函数式组件或自定义hook） （2） 只能在函数最外层调用 hook，不能包括在 if，for 等语句中或者子函数中。 （3）useState 中存储的是引用类型的数据时，修改 state 时，一定要返回新的引用。 原因： 面试时关于框架的问题一般问到问题的产生原因，更多考察的就是学员对框架原理的理解。\n以这个问题为例，如果不了解原理，我们会得出以下答案：\n\n1. Hooks 专为函数组件的逻辑复用而设计所以只能用在函数式组件和自定义hooks \n2. hooks 在调用的时候，需要确保先后调用顺序，一个顺序出问题，会导致整个程序的混乱。 \n3. 如果在 `useState` 中存储的是引用类型，更新时不更新引用地址时的话，React 会认为我们没有更新数据，则不进行组件更新。  如果在面试时只回答到整个层面，并不会引起面试官的高度注意，也没有办法拉开和普通候选人的区别。这道题在解答的时候，最好结合到原理源码上，在原理实现的层面去深入说明为什么会出现这个问题。当然涉及到原理源码，这道题我们通过文字就不太好表述，所以基于原理源码层次的讲解，我们会放在视频里专门去讲解。\n\n\n（讲师视频版解析， 有效期30天，大家记得及时观看学习）： 链接：https://pan.baidu.com/s/1OJ8TEAHoGKeF7mBuTo7gTQ 提取码：0826\n\n\n# React 的 setState 方法是异步还是同步？\n\nsetState 在 React 方法中或者 React 事件中是异步的。但是在原生事件，或者异步程序中是同步的。想要更好的解答这个问题 batchedUpdates 的机制。这一点还我们还是通过视频详细的说明。\n\n（讲师视频版解析， 有效期30天，大家记得及时观看学习）： 链接：https://pan.baidu.com/s/1pWLDFenzvrsjVY63llWaIQ 提取码：0826\n\n\n# 有没有写过 Koa 中间件，说下中 间件原理，介绍下自己写过的中间件?\n\n# -koa\n\nkoa 本来就是一个轻量级框架，本身支持的功能并不多，功能都是通过中间件来实现不同的需求。开发者可以通过不同的中间件来按需求扩展不同的功能。 koa中中间件本质上就是函数，可以是一个async函数，也可以是一个普通的函数。如下代码：\n\n// 普通函数\nconst middleWare1 = function (ctx, next) {\n    return next().then(() => {\n        console.log("I am middleWare1");\n    })\n}\n// async 函数\nconst middleWare2 = async function(ctx,next){\n    console.log("I am middleWare2")\n    await next();\n}\napp.use(middleWare1);app.use(middleWare2);\n\n\n# -中间件原理：\n\n中间件会遵循洋葱模型，中间件执行循序并不是会 从头执行到尾，而是会先执行最外层中间件，当调取next()函数后进入下一个中间件执行，一路执行到最里层中间件，然后在从最里层执行到最外层。\n\n# -编写中间件\n\n例如log中间件:通过日志中间件记录网络请求类型及日志，记录请求ip、方式、地址及请求时间。\n\nconst fs = require("fs");\nmodule.exports = async (ctx,next) =>{\n    const startTime = Date.now();\n    const requestTime = new Date();\n    await next();\n    const ms = Date.now() -  startTime;\n    const logout = `${ctx.request.ip}--${requestTime}--${ctx.method}--${ctx.url}--${ms}ms`\n    fs.appendFileSync("./log.txt",logout+"\\n")\n}\n\n\n\n# 在 React 项目中，想要进行逻辑复用,有哪些方案？\n\n到了这个阶段基本确定给候选人的基本功是没有问题的，然后就来看看候选人的一些项目经验怎么样？ 所以可以看到这周的题基本都是与实际开发的积累有一定关联性。 先来看第一道题，在 React 项目中，想要进行逻辑复用，有哪些方案？\n\n逻辑复用首先我们应该想到的是组件，但是组件的话除了逻辑的复用之外，还有视图的复用。 很多时候我们只想进行逻辑的复用而不想进行视图的复用，可以怎么处理呢？ 如果只想进行逻辑的复用，而不想进行视图的复用，常用方案如下：\n\nHOC（高阶组件）、render props、hooks\n\nHOC（高阶组件）类似于高阶函数，在使用高阶组件时，传入一个组件，会返回一个组件。 举个我们使用频率比较多的例子 - withRouter。\n\nfunction Acmp(props){\n    const {history,location,match} = props;\n    return <div>视图</div>\n}\nconst Bcmp = withRouter(Acmp)\n\n\n在上例中，我们有一个普通组件 Acmp ，本身并不具有路由相关信息。但是，在 Acmp 中，由想要使用路由相关的信息。 这时就可以使用 withRouter 使 Acmp 拥有路由信息。\n\nwithRouter 这个高阶组件的作用就是复用传递给视图组件路由信息这个逻辑。具体使用如下：\n\n调用 withRouter 将 Acmp 传递进去，withRouter 会返回一个 Bcmp 。调用 Bcmp 时，会调用Acmp，并将路由信息传递给 Acmp。\n\n简易原理如下：\n\nconst withRouter = (Cmp) => {\n\treturn () => {\n        return <Router component={Cmp} />\n    }\n}\n\n\n看完了高阶组件之后，我们再来看一下 hooks。\n\nhooks的出现，主要目的就是解决逻辑复用问题。相比于高阶组件，hooks 的使用更灵活，更自由。 已 Router 的 hooks 对比 withRouter 。使用 withRouter 时，会一次性将路由所有相关数据导入组件， 而 hooks 我们按照需求只导入 location或 history等。 另外一个组件中，要复用多个逻辑时，高阶组件明显使用起来就比较不便。 比如在 Acmp 组件中，我们既需要使用 Redux 相关数据，又需要路由信息时，结果如下：\n\nfunction Acmp(props){\n    const {history,location,match} = props;\n    return <div>视图<div>\n}\nconst Bcmp = withRouter(Acmp);\nconst Ccmp = connect(state => state)(Bcmp);\n\n\n我们可以看到每复用一个逻辑就需要包一层，极其不方便。\n\n总结一下，高阶组件可以做的事情，hooks 都可以去做，而且 hooks的使用比高级组件更灵活也更方便，但是hooks 只能用在函数组件下。\n\n看完了 hooks 和 HOC之后，我们再来看看 render props。\n\nrender props 同样是react 中，复用逻辑的小技巧，并不是标准定义的 API。 简单来说，就是组件具有一个render 属性，该属性接收的是一个函数，该组件中要渲染的视图是render属性的返回值。 举一个我们使用最多的常见，Route 组件的render属性。\n\n<Router path=\'/home\' render={()=>{\n    return <HomeView />\n    }}>\n\n\nRoute 组件中的这个render 属性就是一个关于 render props的实际应用。 将组件内要渲染的视图放在 render属性的返回值中，而组件本身是一个路由逻辑的共用。 这样就做到了功能复用而视图自定义。\n\nRoute 简易原理如下：\n\nfunction Route(props){\n    const {path,render} = props;\n    if(matchPath(path)){\n        return <RouterContext.Consumer>\n            (context)=>{\n                return render(context);\n            }\n            </RouterContext.Consumer>\n    }\n\treturn null\n}\n\n\n在这里我们看到了render props 、HOC和 hooks，那在使用场景上，三者有什么差异呢?\n\nHOC 和 hooks刚刚我们说过，这里主要来看 render props 和其他两项的差异。\n\n大家可能在网上找过，网上也给出了很多答案，比如设计模式上，比如对视图的控制上，但是这些都没有说到根上。已经到了二面，面试官更关心的是使用经验，而非理论知识。下面是我个人的一些开发经验总结：\n\n高阶组件或hook，通常用在单一的逻辑复用，比如实时获取当前滚动条位置，或定义state，副作用处理等，都是单一的逻辑。 而 render props 通常是一个完整的功能复用，只是该功能中视图或部分视图需要由使用者定义，比如，弹窗功能，路由功能 等，项目中使用到这些功能的地方有很多，但是使用时，视图可能有差异。\n\n关于 React 的逻辑复用问题，就解析到这里。\n\n\n# React中的diff是怎样的？\n\n来看一下，React diff这道题。\n\nReact diff用于等比新旧 DOM树 的差异，简单来说也可以说是对比两个 Object tree之间的差异。如下例：\n\n更新前：\n\n{\t\n    "type": "ul",    \n    "props":{        \n        "className": "list",        \n        //...    \n    },   \n    "children": [\n        {     \n            // ... \n        },{    \n            //... \n        }\n    ]\n}\n\n\n更新后：\n\n{\t\n    "type": "ul",  \n    "props":{      \n        "className": "list",  \n        // ...  \n    },   \n    "children": [\n        {     \n            //  ... \n        },{    \n            //  ... \n        },{    \n            //  ... \n        }\n    ]\n}\n\n\n这里为了方便展示对结构虚拟DOM的结构稍稍调整了一下，但是意思和 React原本的结构其实是一致的对结构了解之后，我们就来分析一下，一个虚拟DOM，会做处理哪些更新，对哪些更新清晰之后，我们就比较好直观认识 diff的过程。\n\n对视图的操作，我们统计下来一共有 6 种，分别是:\n\n 1. 替换节点\n 2. 替换属性\n 3. 添加新节点\n 4. 移动节点或者说插入节点\n 5. 删除节点\n 6. 修改文本节点内容\n\n明确了我们要对比出哪些差异之后，我们来看看 diff的实现过程。在 React Diff中，考虑到平时在进行节点操作时，跨层移动节点的需求会比较小，所以采取了同层比较的策略。\n\n什么是跨层，可以看下图：\n\n\n\n在不考虑跨层对比的情况下，diff的性能会有一个很大提升，另外我们的实现逻辑也会简化很多。 只考虑同层对比，我们在实现 diff的时候，只需要一层层向下递归我们的 diff即可。 接下来具体来看看 diff 的实现\n\nfunction diff(oldTree,newTree){\t\n    diffNode(oldTree,newTree)\n}\n\n\n第一步实现 diff 方法，来开始 diff，调用时需要传入oldTree （更新前的 虚拟DOM树），newTree 更新后的DOM 树 在 diff中，先进行顶层节点的对比，接下来就是一层一层的递归向下。\n\n现在看看 diffNode 的实现过程。\n\nfunction diffNode(oldNode,newNode) {\t\n    if(oldVNode.type != newNode.type){ \n        // 第一步判断更新前后的节点类型是否不一致\t\t\n        // 如果节点类型不一致了，那就不用再往下对比，直接替换节点即可\t\n    }else if(判断当前节点是否是文本节点){\t\t\n        if(对比新旧文本节点的内容是否发生了变化){\t\t\n            // 如果文本节点的内容发生了变化，则直接替换文本内容\t\n        }\t\n    }else if(typeof oldVNode.type === "function"){\n        // 判断当前是否是一个组件\t\n        diffCmp(oldNode,newNode) \n        //进行组件对比\t\n    }else {\t\t\n        // 当前如果是一个普通的元素节点\t\n        // 对比属性有没有变化\t\t\n        diffProps(oldNode.props,newNode.props)\t\n        // 对比子元素\t\t\n        diffChildren(oldNode.children,newNode.children)\n    }\n}\n\n\n上述是对单个节点的对比过程，在对比单个节点时，最后通过 diffCmp组件对比，或者 diffChildren 子元素对比，接着向下递归。\n\n接下来先来看看 diffCmp\n\nfunction dissCmp(oldCmp,newCmp){    \n    /*    在这里我们忽略掉生命周期的部分，    \n    主要就是调用组件组件自身的更新，    \n    组件更新时。render之后，会再次调用diff方法，    \n    去对比这个组件下的虚拟DOM的不同    */\n    oldCmp.update(newVCmp.props)\n}\n\n\n看完了 diffCmp 之后，我们先来看 diffProps 属性对比，了解属性对比的过程之后，再学习 diffChildren 会更直观一些。\n\n虚拟DOM 中的属性，其实就是一个普通的 object 对象，在其中会有三种不同的操作，需要我们在对比时进行考虑：\n\n 1. 新增属性\n 2. 删除属性\n 3. 属性值有变动\n\nfunction diffProps(prevProps,nextProps){   \n    for(let s in nextProps) {     \n        if(prevProps[s] !== undefined){ \n            //该属性在更新前后都存在       \n            if(prevProps[s] !== nextProps[s]){ \n                //检测概述值是否有变化             \n                console.log(s, \'属性值发生变化\')    \n            }     \n        }else { \n            // 该属性只存在于更新之后    \n            console.log(s, \'新建的属性\')   \n        }  \n    }  \n    for(let s in prevProps) {   \n        if(nextProps[s] === undefined) { \n            // 该属性只存在新增之前   \n            console.log(s, \'被删除了\')   \n        }  \n    }\n}\n\n\n从上述代码中，我们可以通过两个循环，我们就可以将属性中有差异的内容给找出来。\n\n第一步，先循环更新后的 props ，如果在更新的 props 中也有对应属性，则比较属性值是否有变化。如果在更新前的 props 中，不存在对应属性，则该项为新增属性。\n\n第二步。循环更新前的props，如果在更新后的 props 不存在对应属性，则该项属性需要被删除。看完了属性对比之后，我们来看一下最复杂的子元素对比。这里我将 children 做了简化，React 中 children 有可能存在 单个数据、数组、复合数组多种情况。我们这里主要看最麻烦的数组的形式。还是来分析在一组子元素对比时，我们要做哪些对比。\n\n * 新增元素\n\n * 删除元素\n\n * 元素位置变化\n\n * 递归对比单个元素\n\n明确了要做哪些对比之后，我们再来思考一个问题，如何将更新前后的元素进行对应，prevChildren[0]否就是nextChildren[0]呢？\n\n这种情况下，我们可以参考上边 diffProps ，如果这些子元素是存在对象中的，并且更新前后，对象的属性名保持统一，那我们对比起来将极其方便。\n\n这种情况下，我们的 key 属性的作用就明确了。观看下列代码：\n\nfunction setKeys(children) {   \n    let keys = {};   \n    children.forEach((item,index) => {   \n        let key = item[\'key\'] === undefined ? index : item[\'key\'];      \n        key = "key-" + key     \n        keys[key] = item  \n    })  \n    return keys;\n}\n\n\n在这个函数中，我们利用 key 属性，将 children 转成 对象，这样的话，就可以将 diffProps 的逻辑嵌套入diffChildren 中来。具体代码如下：\n\nfunction diffChildren (prevChildren,nextChildren) {   \n    const prevKeys = setKeys(prevChildren);  \n    const nextKeys = setKeys(nextChildren); \n    for(let k in nextKeys){      \n        if(prevKeys[k]){ \n            // 更新前的列表中存在该节点    \n            diffNode(prevKeys[k],nextKeys[k]); \n            // 进一步进行节点对比    \n        }else { \n            // 更新前的列表中不存在该节点  \n            console.log(nextKeys[k], \'新增节点\')   \n        }  \n    }  \n    for(let s in prevKeys){ \n        if(!nextKeys[k]) { \n            // 新列表中不存在该节点      \n            console.log(prevKeys[k], \'要删除项\')   \n        }  \n    }\n}\n\n\n现在我们还差最后一步，如何找到哪些元素的位置，发生了变化。来看一个思路： 默认情况下，后一个的索引值，不小于前一个元素，如果元素的下标符合这个原则，那则代表元素的位置，没有发生变化。\n\n举个例子。 更新前的列表：a(0) b(1) c(2) d(3) 更新后的列表: b a d c\n\n这里有一个列表更新前后位置产生了变化，如果将发生移动的元素找出来，我们套用上边的思路，来看一下。\n\n第一步声明一个变量lastIndex = 0;\n\n使用 lastIndex 先和 b 元素进行对比，b 元素的下标为 1，lastIndex为 0. 1 不小于 0 ，符合规则，b 位置不变。\n\nlastIndex 变成 1，接着和下一个元素进行对比。\n\n使用 lastIndex 和 a 比较，a 下标为 0，lastIndex 为 1，不符合规则，记录 a 的位置发生了变化。接着对比下一个元素\n\n使用 lastIndex 和 d 比较，d 下标为 3，lastIndex 为 1，符合规则。 lastIndex 变成 3，继续比较下一个元素。\n\n使用lastIndex 和 c 比较，a 下标为 2，lastIndex 为 3，不符合规则，记录 c 的位置发生了变化。\n\n这样我们就可以将位置发生变化的 a 和 c 找了出来，基于这个原则，我们重新修改一下我们的代码：\n\nfunction setKeys(children) {  \n    let keys = {};   \n    children.forEach((item,index) => {  \n        let key = item[\'key\'] === undefined ? index : item[\'key\'];   \n        key = "key-" + key      \n        keys[key] = item      \n        keys[key]._index = index; \n        //这里新增属性，_index用于记录元素在数组中的下标（位置）\n    })   \n    return keys;\n}\nfunction diffChildren (prevChildren,nextChildren) { \n    const prevKeys = setKeys(prevChildren);   \n    const nextKeys = setKeys(nextChildren);   \n    let lastIndex = 0; \n    //声明变量lastIndex用于记录上一个元素的下标    \n    for(let k in nextKeys){     \n        if(prevKeys[k]){   \n            diffNode(prevKeys[k],nextKeys[k]);    \n            if(lastIndex > prevKeys[k]._index){      \n                console.log(nextKeys[k], \'位置变化\')   \n            }else {         \n                // 如果该元素位置没有发生变化，则更新lastIndex，以方便下一次进行对比     \n                lastIndex = prevKeys[k]._index;     \n            }     \n        }else {     \n            console.log(nextKeys[k], \'新增节点\')       \n        }  \n    }   \n    for(let s in prevKeys){  \n        if(!nextKeys[k]) {     \n            console.log(prevKeys[k], \'要删除项\')   \n        }  \n    }\n}\n\n\n到这一步，我们就完成了 diff 的整个流程的梳理。当然文字描述的话，有些问题描述的不是很直观，大家可以观看一下这道题的视频讲解的会更直观一些。\n\n\n# 在 React 中，针对类组件 和 函数组件，分别怎么去进行性能优化？\n\n接下来看优化的这道题, 在 React 中，针对类组件 和 函数组件，分别怎么去进行性能优化? 组件优化除了最基础的 key 之外，主要考察点，在于优化组件更新。\n\nReact 中，如果组件更新了，会携带它的子孙级组件一起进行更新，虽然组件更新时，会有diff约束DOM更新。 但组件更新时的 diff，也会消耗很多性能。 如何避免项目中不必要的组件更新就是我们必须要面对的问题。 如果是类组件我们可以使用 shouldComponentUpdate 或者PureComponent , 函数组件则可以使用 memo 具体的 API 使用我就不再复述了，大家可以看下视频， 或者看看\n\n官网手册React.memo https://reactjs.org/docs/react-api.html#reactmemo\n\nReact.PureComponent https://reactjs.org/docs/react-api.html#reactpurecomponent\n\n这里一定要注意，不管你使用的是哪种优化手段，state 一定是一个不可变值，否则拿不到组件更新前的数据， 也就没有办法进行对比，优化也就无从谈起。关于组件优化的问题，就到这里。',normalizedContent:'# react\n\n\n# react 的组件间通信都有哪些形式？\n\n 1. 父传子：在 react 中，父组件调用子组件时可以将要传递给子组件的数据添加在子组件的属性中，在子组件中通过 props 属性进行接收。这个就是父组件向子组件通信。\n 2. 子传父：react 是单向数据流，数据永远只能自上向下进行传递。当子组件中有些数据需要向父级进行通信时，需要在父级中定义好回调，将回调传递给子组件，子组件调用父级传递过来的回调方法进行通信。\n 3. 跨组件通信 - context。使用 context api，可以在组件中向其子孙级组件进行信息传递。\n\n\n# react 中如何实现路由懒加载？\n\n在 react 16 中，新增了 lazy 方法，通过 lazy 方法可以轻松实现组件懒加载，当然要实现路由懒加载的话，其实也只需要把路由组件结合 lazy 使用即可。 参考代码如下：\n\nimport {route} from "react-router-dom";\nimport react,{suspense} from \'react\';\nconst homeview = react.lazy(()=>import("./home"));\nfunction app(){\n    return <div>\n        <h1>路由懒加载</h1>\n        <route path="/" exact render={()=>{\n                return <suspense fallback={<div>组件loading进来之前的占位内容</div>}>\n                    <homeview />\n                </suspense>\n            }} />\n    </div>\n}\nexport default app;\n\n\n在上述代码中，我们使用 lazy 引入了一个动态组件，然后将该组件放入了根路由中。这样的话只有用户访问网站首页时，才会动态加载这个组件。 这里要注意，在 react 规范中，lazy 和 suspense 必须配合使用，lazy 引入的动态组件必须要放入 suspense 中，suspense 的 fallback 属性是 lazy 的组件没有加载进来之前的占位内容。\n\n\n# react 的生命周期函数都有哪些，分别有什么作用？\n\nreact 的生命周期已经经历了3次改动，我们以最新的版本为准。 具体可以看下图： 挂载阶段： （1）constructor: 初始化组件，初始化组件的 state 等。 （2）static getderivedstatefromprops()：该函数用于将 props 中的信息映射到 state 中。 （3）render: 生成虚拟dom （4）componentdidmount：组件挂载完成，通过在该函数中去处理副作用 更新阶段： （5）static getderivedstatefromprops() （6）shouldcomponentupdate()：该生命周期函数用于判断是否要进行组件更新。 （7）render()：生成虚拟dom （8）getsnapshotbeforeupdate()：组件已经完成 diff，即将更新真实 dom，用户获取上一次的dom快照。该函数必须搭配 componentdidupdate 一块使用，返回值会变成 componentdidupdate 第三个参数。 （9）componentdidupdate()： 组件更新完成，通常在该函数中进行副作用处理。 即将卸载： componentwillunmount：组件即将卸载，用于删除组件添加到全局的数据或事件。\n\n\n# 说一下react hooks在平时开发中需要注意的问题和原因?\n\nreact hooks 在使用时注意事项： （1） 只能在 react 函数中使用（函数式组件或自定义hook） （2） 只能在函数最外层调用 hook，不能包括在 if，for 等语句中或者子函数中。 （3）usestate 中存储的是引用类型的数据时，修改 state 时，一定要返回新的引用。 原因： 面试时关于框架的问题一般问到问题的产生原因，更多考察的就是学员对框架原理的理解。\n以这个问题为例，如果不了解原理，我们会得出以下答案：\n\n1. hooks 专为函数组件的逻辑复用而设计所以只能用在函数式组件和自定义hooks \n2. hooks 在调用的时候，需要确保先后调用顺序，一个顺序出问题，会导致整个程序的混乱。 \n3. 如果在 `usestate` 中存储的是引用类型，更新时不更新引用地址时的话，react 会认为我们没有更新数据，则不进行组件更新。  如果在面试时只回答到整个层面，并不会引起面试官的高度注意，也没有办法拉开和普通候选人的区别。这道题在解答的时候，最好结合到原理源码上，在原理实现的层面去深入说明为什么会出现这个问题。当然涉及到原理源码，这道题我们通过文字就不太好表述，所以基于原理源码层次的讲解，我们会放在视频里专门去讲解。\n\n\n（讲师视频版解析， 有效期30天，大家记得及时观看学习）： 链接：https://pan.baidu.com/s/1oj8teahogkef7mbuto7gtq 提取码：0826\n\n\n# react 的 setstate 方法是异步还是同步？\n\nsetstate 在 react 方法中或者 react 事件中是异步的。但是在原生事件，或者异步程序中是同步的。想要更好的解答这个问题 batchedupdates 的机制。这一点还我们还是通过视频详细的说明。\n\n（讲师视频版解析， 有效期30天，大家记得及时观看学习）： 链接：https://pan.baidu.com/s/1pwldfenzvrsjvy63llwaiq 提取码：0826\n\n\n# 有没有写过 koa 中间件，说下中 间件原理，介绍下自己写过的中间件?\n\n# -koa\n\nkoa 本来就是一个轻量级框架，本身支持的功能并不多，功能都是通过中间件来实现不同的需求。开发者可以通过不同的中间件来按需求扩展不同的功能。 koa中中间件本质上就是函数，可以是一个async函数，也可以是一个普通的函数。如下代码：\n\n// 普通函数\nconst middleware1 = function (ctx, next) {\n    return next().then(() => {\n        console.log("i am middleware1");\n    })\n}\n// async 函数\nconst middleware2 = async function(ctx,next){\n    console.log("i am middleware2")\n    await next();\n}\napp.use(middleware1);app.use(middleware2);\n\n\n# -中间件原理：\n\n中间件会遵循洋葱模型，中间件执行循序并不是会 从头执行到尾，而是会先执行最外层中间件，当调取next()函数后进入下一个中间件执行，一路执行到最里层中间件，然后在从最里层执行到最外层。\n\n# -编写中间件\n\n例如log中间件:通过日志中间件记录网络请求类型及日志，记录请求ip、方式、地址及请求时间。\n\nconst fs = require("fs");\nmodule.exports = async (ctx,next) =>{\n    const starttime = date.now();\n    const requesttime = new date();\n    await next();\n    const ms = date.now() -  starttime;\n    const logout = `${ctx.request.ip}--${requesttime}--${ctx.method}--${ctx.url}--${ms}ms`\n    fs.appendfilesync("./log.txt",logout+"\\n")\n}\n\n\n\n# 在 react 项目中，想要进行逻辑复用,有哪些方案？\n\n到了这个阶段基本确定给候选人的基本功是没有问题的，然后就来看看候选人的一些项目经验怎么样？ 所以可以看到这周的题基本都是与实际开发的积累有一定关联性。 先来看第一道题，在 react 项目中，想要进行逻辑复用，有哪些方案？\n\n逻辑复用首先我们应该想到的是组件，但是组件的话除了逻辑的复用之外，还有视图的复用。 很多时候我们只想进行逻辑的复用而不想进行视图的复用，可以怎么处理呢？ 如果只想进行逻辑的复用，而不想进行视图的复用，常用方案如下：\n\nhoc（高阶组件）、render props、hooks\n\nhoc（高阶组件）类似于高阶函数，在使用高阶组件时，传入一个组件，会返回一个组件。 举个我们使用频率比较多的例子 - withrouter。\n\nfunction acmp(props){\n    const {history,location,match} = props;\n    return <div>视图</div>\n}\nconst bcmp = withrouter(acmp)\n\n\n在上例中，我们有一个普通组件 acmp ，本身并不具有路由相关信息。但是，在 acmp 中，由想要使用路由相关的信息。 这时就可以使用 withrouter 使 acmp 拥有路由信息。\n\nwithrouter 这个高阶组件的作用就是复用传递给视图组件路由信息这个逻辑。具体使用如下：\n\n调用 withrouter 将 acmp 传递进去，withrouter 会返回一个 bcmp 。调用 bcmp 时，会调用acmp，并将路由信息传递给 acmp。\n\n简易原理如下：\n\nconst withrouter = (cmp) => {\n\treturn () => {\n        return <router component={cmp} />\n    }\n}\n\n\n看完了高阶组件之后，我们再来看一下 hooks。\n\nhooks的出现，主要目的就是解决逻辑复用问题。相比于高阶组件，hooks 的使用更灵活，更自由。 已 router 的 hooks 对比 withrouter 。使用 withrouter 时，会一次性将路由所有相关数据导入组件， 而 hooks 我们按照需求只导入 location或 history等。 另外一个组件中，要复用多个逻辑时，高阶组件明显使用起来就比较不便。 比如在 acmp 组件中，我们既需要使用 redux 相关数据，又需要路由信息时，结果如下：\n\nfunction acmp(props){\n    const {history,location,match} = props;\n    return <div>视图<div>\n}\nconst bcmp = withrouter(acmp);\nconst ccmp = connect(state => state)(bcmp);\n\n\n我们可以看到每复用一个逻辑就需要包一层，极其不方便。\n\n总结一下，高阶组件可以做的事情，hooks 都可以去做，而且 hooks的使用比高级组件更灵活也更方便，但是hooks 只能用在函数组件下。\n\n看完了 hooks 和 hoc之后，我们再来看看 render props。\n\nrender props 同样是react 中，复用逻辑的小技巧，并不是标准定义的 api。 简单来说，就是组件具有一个render 属性，该属性接收的是一个函数，该组件中要渲染的视图是render属性的返回值。 举一个我们使用最多的常见，route 组件的render属性。\n\n<router path=\'/home\' render={()=>{\n    return <homeview />\n    }}>\n\n\nroute 组件中的这个render 属性就是一个关于 render props的实际应用。 将组件内要渲染的视图放在 render属性的返回值中，而组件本身是一个路由逻辑的共用。 这样就做到了功能复用而视图自定义。\n\nroute 简易原理如下：\n\nfunction route(props){\n    const {path,render} = props;\n    if(matchpath(path)){\n        return <routercontext.consumer>\n            (context)=>{\n                return render(context);\n            }\n            </routercontext.consumer>\n    }\n\treturn null\n}\n\n\n在这里我们看到了render props 、hoc和 hooks，那在使用场景上，三者有什么差异呢?\n\nhoc 和 hooks刚刚我们说过，这里主要来看 render props 和其他两项的差异。\n\n大家可能在网上找过，网上也给出了很多答案，比如设计模式上，比如对视图的控制上，但是这些都没有说到根上。已经到了二面，面试官更关心的是使用经验，而非理论知识。下面是我个人的一些开发经验总结：\n\n高阶组件或hook，通常用在单一的逻辑复用，比如实时获取当前滚动条位置，或定义state，副作用处理等，都是单一的逻辑。 而 render props 通常是一个完整的功能复用，只是该功能中视图或部分视图需要由使用者定义，比如，弹窗功能，路由功能 等，项目中使用到这些功能的地方有很多，但是使用时，视图可能有差异。\n\n关于 react 的逻辑复用问题，就解析到这里。\n\n\n# react中的diff是怎样的？\n\n来看一下，react diff这道题。\n\nreact diff用于等比新旧 dom树 的差异，简单来说也可以说是对比两个 object tree之间的差异。如下例：\n\n更新前：\n\n{\t\n    "type": "ul",    \n    "props":{        \n        "classname": "list",        \n        //...    \n    },   \n    "children": [\n        {     \n            // ... \n        },{    \n            //... \n        }\n    ]\n}\n\n\n更新后：\n\n{\t\n    "type": "ul",  \n    "props":{      \n        "classname": "list",  \n        // ...  \n    },   \n    "children": [\n        {     \n            //  ... \n        },{    \n            //  ... \n        },{    \n            //  ... \n        }\n    ]\n}\n\n\n这里为了方便展示对结构虚拟dom的结构稍稍调整了一下，但是意思和 react原本的结构其实是一致的对结构了解之后，我们就来分析一下，一个虚拟dom，会做处理哪些更新，对哪些更新清晰之后，我们就比较好直观认识 diff的过程。\n\n对视图的操作，我们统计下来一共有 6 种，分别是:\n\n 1. 替换节点\n 2. 替换属性\n 3. 添加新节点\n 4. 移动节点或者说插入节点\n 5. 删除节点\n 6. 修改文本节点内容\n\n明确了我们要对比出哪些差异之后，我们来看看 diff的实现过程。在 react diff中，考虑到平时在进行节点操作时，跨层移动节点的需求会比较小，所以采取了同层比较的策略。\n\n什么是跨层，可以看下图：\n\n\n\n在不考虑跨层对比的情况下，diff的性能会有一个很大提升，另外我们的实现逻辑也会简化很多。 只考虑同层对比，我们在实现 diff的时候，只需要一层层向下递归我们的 diff即可。 接下来具体来看看 diff 的实现\n\nfunction diff(oldtree,newtree){\t\n    diffnode(oldtree,newtree)\n}\n\n\n第一步实现 diff 方法，来开始 diff，调用时需要传入oldtree （更新前的 虚拟dom树），newtree 更新后的dom 树 在 diff中，先进行顶层节点的对比，接下来就是一层一层的递归向下。\n\n现在看看 diffnode 的实现过程。\n\nfunction diffnode(oldnode,newnode) {\t\n    if(oldvnode.type != newnode.type){ \n        // 第一步判断更新前后的节点类型是否不一致\t\t\n        // 如果节点类型不一致了，那就不用再往下对比，直接替换节点即可\t\n    }else if(判断当前节点是否是文本节点){\t\t\n        if(对比新旧文本节点的内容是否发生了变化){\t\t\n            // 如果文本节点的内容发生了变化，则直接替换文本内容\t\n        }\t\n    }else if(typeof oldvnode.type === "function"){\n        // 判断当前是否是一个组件\t\n        diffcmp(oldnode,newnode) \n        //进行组件对比\t\n    }else {\t\t\n        // 当前如果是一个普通的元素节点\t\n        // 对比属性有没有变化\t\t\n        diffprops(oldnode.props,newnode.props)\t\n        // 对比子元素\t\t\n        diffchildren(oldnode.children,newnode.children)\n    }\n}\n\n\n上述是对单个节点的对比过程，在对比单个节点时，最后通过 diffcmp组件对比，或者 diffchildren 子元素对比，接着向下递归。\n\n接下来先来看看 diffcmp\n\nfunction disscmp(oldcmp,newcmp){    \n    /*    在这里我们忽略掉生命周期的部分，    \n    主要就是调用组件组件自身的更新，    \n    组件更新时。render之后，会再次调用diff方法，    \n    去对比这个组件下的虚拟dom的不同    */\n    oldcmp.update(newvcmp.props)\n}\n\n\n看完了 diffcmp 之后，我们先来看 diffprops 属性对比，了解属性对比的过程之后，再学习 diffchildren 会更直观一些。\n\n虚拟dom 中的属性，其实就是一个普通的 object 对象，在其中会有三种不同的操作，需要我们在对比时进行考虑：\n\n 1. 新增属性\n 2. 删除属性\n 3. 属性值有变动\n\nfunction diffprops(prevprops,nextprops){   \n    for(let s in nextprops) {     \n        if(prevprops[s] !== undefined){ \n            //该属性在更新前后都存在       \n            if(prevprops[s] !== nextprops[s]){ \n                //检测概述值是否有变化             \n                console.log(s, \'属性值发生变化\')    \n            }     \n        }else { \n            // 该属性只存在于更新之后    \n            console.log(s, \'新建的属性\')   \n        }  \n    }  \n    for(let s in prevprops) {   \n        if(nextprops[s] === undefined) { \n            // 该属性只存在新增之前   \n            console.log(s, \'被删除了\')   \n        }  \n    }\n}\n\n\n从上述代码中，我们可以通过两个循环，我们就可以将属性中有差异的内容给找出来。\n\n第一步，先循环更新后的 props ，如果在更新的 props 中也有对应属性，则比较属性值是否有变化。如果在更新前的 props 中，不存在对应属性，则该项为新增属性。\n\n第二步。循环更新前的props，如果在更新后的 props 不存在对应属性，则该项属性需要被删除。看完了属性对比之后，我们来看一下最复杂的子元素对比。这里我将 children 做了简化，react 中 children 有可能存在 单个数据、数组、复合数组多种情况。我们这里主要看最麻烦的数组的形式。还是来分析在一组子元素对比时，我们要做哪些对比。\n\n * 新增元素\n\n * 删除元素\n\n * 元素位置变化\n\n * 递归对比单个元素\n\n明确了要做哪些对比之后，我们再来思考一个问题，如何将更新前后的元素进行对应，prevchildren[0]否就是nextchildren[0]呢？\n\n这种情况下，我们可以参考上边 diffprops ，如果这些子元素是存在对象中的，并且更新前后，对象的属性名保持统一，那我们对比起来将极其方便。\n\n这种情况下，我们的 key 属性的作用就明确了。观看下列代码：\n\nfunction setkeys(children) {   \n    let keys = {};   \n    children.foreach((item,index) => {   \n        let key = item[\'key\'] === undefined ? index : item[\'key\'];      \n        key = "key-" + key     \n        keys[key] = item  \n    })  \n    return keys;\n}\n\n\n在这个函数中，我们利用 key 属性，将 children 转成 对象，这样的话，就可以将 diffprops 的逻辑嵌套入diffchildren 中来。具体代码如下：\n\nfunction diffchildren (prevchildren,nextchildren) {   \n    const prevkeys = setkeys(prevchildren);  \n    const nextkeys = setkeys(nextchildren); \n    for(let k in nextkeys){      \n        if(prevkeys[k]){ \n            // 更新前的列表中存在该节点    \n            diffnode(prevkeys[k],nextkeys[k]); \n            // 进一步进行节点对比    \n        }else { \n            // 更新前的列表中不存在该节点  \n            console.log(nextkeys[k], \'新增节点\')   \n        }  \n    }  \n    for(let s in prevkeys){ \n        if(!nextkeys[k]) { \n            // 新列表中不存在该节点      \n            console.log(prevkeys[k], \'要删除项\')   \n        }  \n    }\n}\n\n\n现在我们还差最后一步，如何找到哪些元素的位置，发生了变化。来看一个思路： 默认情况下，后一个的索引值，不小于前一个元素，如果元素的下标符合这个原则，那则代表元素的位置，没有发生变化。\n\n举个例子。 更新前的列表：a(0) b(1) c(2) d(3) 更新后的列表: b a d c\n\n这里有一个列表更新前后位置产生了变化，如果将发生移动的元素找出来，我们套用上边的思路，来看一下。\n\n第一步声明一个变量lastindex = 0;\n\n使用 lastindex 先和 b 元素进行对比，b 元素的下标为 1，lastindex为 0. 1 不小于 0 ，符合规则，b 位置不变。\n\nlastindex 变成 1，接着和下一个元素进行对比。\n\n使用 lastindex 和 a 比较，a 下标为 0，lastindex 为 1，不符合规则，记录 a 的位置发生了变化。接着对比下一个元素\n\n使用 lastindex 和 d 比较，d 下标为 3，lastindex 为 1，符合规则。 lastindex 变成 3，继续比较下一个元素。\n\n使用lastindex 和 c 比较，a 下标为 2，lastindex 为 3，不符合规则，记录 c 的位置发生了变化。\n\n这样我们就可以将位置发生变化的 a 和 c 找了出来，基于这个原则，我们重新修改一下我们的代码：\n\nfunction setkeys(children) {  \n    let keys = {};   \n    children.foreach((item,index) => {  \n        let key = item[\'key\'] === undefined ? index : item[\'key\'];   \n        key = "key-" + key      \n        keys[key] = item      \n        keys[key]._index = index; \n        //这里新增属性，_index用于记录元素在数组中的下标（位置）\n    })   \n    return keys;\n}\nfunction diffchildren (prevchildren,nextchildren) { \n    const prevkeys = setkeys(prevchildren);   \n    const nextkeys = setkeys(nextchildren);   \n    let lastindex = 0; \n    //声明变量lastindex用于记录上一个元素的下标    \n    for(let k in nextkeys){     \n        if(prevkeys[k]){   \n            diffnode(prevkeys[k],nextkeys[k]);    \n            if(lastindex > prevkeys[k]._index){      \n                console.log(nextkeys[k], \'位置变化\')   \n            }else {         \n                // 如果该元素位置没有发生变化，则更新lastindex，以方便下一次进行对比     \n                lastindex = prevkeys[k]._index;     \n            }     \n        }else {     \n            console.log(nextkeys[k], \'新增节点\')       \n        }  \n    }   \n    for(let s in prevkeys){  \n        if(!nextkeys[k]) {     \n            console.log(prevkeys[k], \'要删除项\')   \n        }  \n    }\n}\n\n\n到这一步，我们就完成了 diff 的整个流程的梳理。当然文字描述的话，有些问题描述的不是很直观，大家可以观看一下这道题的视频讲解的会更直观一些。\n\n\n# 在 react 中，针对类组件 和 函数组件，分别怎么去进行性能优化？\n\n接下来看优化的这道题, 在 react 中，针对类组件 和 函数组件，分别怎么去进行性能优化? 组件优化除了最基础的 key 之外，主要考察点，在于优化组件更新。\n\nreact 中，如果组件更新了，会携带它的子孙级组件一起进行更新，虽然组件更新时，会有diff约束dom更新。 但组件更新时的 diff，也会消耗很多性能。 如何避免项目中不必要的组件更新就是我们必须要面对的问题。 如果是类组件我们可以使用 shouldcomponentupdate 或者purecomponent , 函数组件则可以使用 memo 具体的 api 使用我就不再复述了，大家可以看下视频， 或者看看\n\n官网手册react.memo https://reactjs.org/docs/react-api.html#reactmemo\n\nreact.purecomponent https://reactjs.org/docs/react-api.html#reactpurecomponent\n\n这里一定要注意，不管你使用的是哪种优化手段，state 一定是一个不可变值，否则拿不到组件更新前的数据， 也就没有办法进行对比，优化也就无从谈起。关于组件优化的问题，就到这里。',charsets:{cjk:!0}},{title:"正则&git",frontmatter:{},regularPath:"/regular&git/",relativePath:"regular&git/README.md",key:"v-aec7c3da",path:"/regular&git/",headers:[{level:2,title:"正则&git",slug:"正则-git",normalizedTitle:"正则&amp;git",charIndex:null}],headersStr:"正则&git",content:"# 正则&git\n\nregular&git",normalizedContent:"# 正则&git\n\nregular&git",charsets:{cjk:!0}},{title:"git 命令",frontmatter:{},regularPath:"/regular&git/git/",relativePath:"regular&git/git/README.md",key:"v-18a8bd8d",path:"/regular&git/git/",headers:[{level:2,title:"新建代码库",slug:"新建代码库",normalizedTitle:"新建代码库",charIndex:19},{level:2,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:178},{level:2,title:"增加/删除文件",slug:"增加-删除文件",normalizedTitle:"增加/删除文件",charIndex:462},{level:2,title:"代码提交",slug:"代码提交",normalizedTitle:"代码提交",charIndex:893},{level:2,title:"分支",slug:"分支",normalizedTitle:"分支",charIndex:1274},{level:2,title:"标签",slug:"标签",normalizedTitle:"标签",charIndex:1976},{level:2,title:"查看信息",slug:"查看信息",normalizedTitle:"查看信息",charIndex:2326},{level:2,title:"远程同步",slug:"远程同步",normalizedTitle:"远程同步",charIndex:3262},{level:2,title:"撤销",slug:"撤销",normalizedTitle:"撤销",charIndex:3648},{level:2,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:4215},{level:2,title:"流程",slug:"流程",normalizedTitle:"流程",charIndex:4254},{level:2,title:"如何将某一个分支(A分支)的部分代码合并到另外一个分支(B分支)上面",slug:"如何将某一个分支-a分支-的部分代码合并到另外一个分支-b分支-上面",normalizedTitle:"如何将某一个分支(a分支)的部分代码合并到另外一个分支(b分支)上面",charIndex:4565}],headersStr:"新建代码库 配置 增加/删除文件 代码提交 分支 标签 查看信息 远程同步 撤销 其他 流程 如何将某一个分支(A分支)的部分代码合并到另外一个分支(B分支)上面",content:'# git 命令\n\n参考链接\n\n\n# 新建代码库\n\n # 在当前目录新建一个Git代码库       \n $ git init \n \n # 新建一个目录，将其初始化为Git代码库       \n $ git init [project-name]\n \n # 下载一个项目和它的整个代码历史       \n $ git clone [url]\n \n\n\n\n# 配置\n\nGit的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n\n # 显示当前的Git配置       \n $ git config --list    \n \n # 编辑Git配置文件 $ git config -e [--global]  \n \n # 设置提交代码时的用户信息       \n $ git config [--global] user.name "[name]"    \n $ git config [--global] user.email "[email address]" \n \n\n\n\n# 增加/删除文件\n\n# 添加指定文件到暂存区       \n$ git add [file1] [file2] ...   \n\n# 添加指定目录到暂存区，包括子目录       \n$ git add [dir]      \n\n# 添加当前目录的所有文件到暂存区       \n$ git add .      \n\n# 添加每个变化前，都会要求确认   \n\n# 对于同一个文件的多处变化，可以实现分次提交       \n$ git add -p      \n\n# 删除工作区文件，并且将这次删除放入暂存区       \n$ git rm [file1] [file2] ...      \n\n# 停止追踪指定文件，但该文件会保留在工作区        \n$ git rm --cached [file]     \n\n# 改名文件，并且将这个改名放入暂存区       \n$ git mv [file-original] [file-renamed]  \n\n\n\n\n# 代码提交\n\n # 提交暂存区到仓库区       \n $ git commit -m [message]\n \n # 提交暂存区的指定文件到仓库区\n $ git commit [file1] [file2] ... -m [message]\n \n # 提交工作区自上次commit之后的变化，直接到仓库区\n $ git commit -a\n \n # 提交时显示所有diff信息\n $ git commit -v\n \n # 使用一次新的commit，替代上一次提交\n \n # 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n $ git commit --amend -m [message]\n \n # 重做上一次commit，并包括指定文件的新变化\n $ git commit --amend [file1] [file2] …  \n \n\n\n\n# 分支\n\n# 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch] \n\n# 将本地分支与远程保持同步\n$ git fetch \n\n\n\n# 标签\n\n# 列出所有tag\n$ git tag\n\n# 新建一个tag在当前commit\n$ git tag [tag]   \n\n# 新建一个tag在指定commit\n$ git tag [tag] [commit]\n\n# 删除本地tag\n$ git tag -d [tag]\n\n# 删除远程tag\n$ git push origin :refs/tags/[tagName]\n\n# 查看tag信息\n$ git show [tag]\n\n# 提交指定tag\n$ git push [remote] [tag]\n\n# 提交所有tag\n$ git push [remote] --tags\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]  \n\n\n\n\n# 查看信息\n\n# 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -S [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] HEAD --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件\n$ git log [tag] HEAD --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff HEAD\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat "@{0 day ago}"\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog \n\n\n\n\n# 远程同步\n\n # 下载远程仓库的所有变动\n $ git fetch [remote]\n \n # 显示所有远程仓库\n $ git remote -v\n \n # 显示某个远程仓库的信息\n $ git remote show [remote]\n \n # 增加一个新的远程仓库，并命名\n $ git remote add [shortname] [url]\n \n # 取回远程仓库的变化，并与本地分支合并\n $ git pull [remote] [branch]\n \n # 上传本地指定分支到远程仓库\n $ git push [remote] [branch]\n \n # 强行推送当前分支到远程仓库，即使有冲突\n $ git push [remote] --force\n \n # 推送所有分支到远程仓库\n $ git push [remote] --all   \n \n\n\n\n# 撤销\n\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n# 暂时将未提交的变化移除，稍后再移入\n$ git stash$ git stash pop   \n\n\n\n\n# 其他\n\n# 生成一个可供发布的压缩包\n$ git archive\n\n\n\n\n# 流程\n\n//第一步：查看当前的git仓库状态，可以使用git status。\n\ngit status\n\n//第二步：把更新的代码添加到暂存区。\n\ngit add *\n\n//第三步：将暂存区的更新提交到仓库区。\n\ngit commit -m "更新说明" （更新说明，是本次推送代码的标识，写什么都可以，只要自己看得懂） \n\n//第四步：先git pull,拉取远程仓库所有分支更新并合并到本地。\n\ngit pull\n\n//第五步：将本地分支的更新全部推送到远程仓库。\n\ngit push origin master\n\n//第六步．再次使用git status查看当前的git仓库状态，已经没有改动，证明更新成功\n\n\n\n# 如何将某一个分支(A分支)的部分代码合并到另外一个分支(B分支)上面\n\n需求\n\n在A分支上面开发了一个功能，突然B分支说也需要这个功能，但是不想要合并A分支上所有的代码；只需要合并这一个功能对应的代码\n\n方案：\n\n 1. 在A分支上通过git log 查看日志；将自己提交的该功能对应的hash值整理出来；\n\ngit log\n\n\n 2. 如果本地没有B分支，需要先将B分支从远程仓库拉到本地仓库(如果本地有B分支，并且已与远程对应的B分支已关联；无需这一步，直接到下一步)\n\ngit checkout --track origin/B\n\n\n 3. 切换到B分支\n\ngit checkout B\n\n\n 4. 在B分支上操作：通过git cherry-pick <commit对应的hash值>将当前hash对应提交的代码合并到B分支上去\n\ngit cherry-pick b5dc0dd\n',normalizedContent:'# git 命令\n\n参考链接\n\n\n# 新建代码库\n\n # 在当前目录新建一个git代码库       \n $ git init \n \n # 新建一个目录，将其初始化为git代码库       \n $ git init [project-name]\n \n # 下载一个项目和它的整个代码历史       \n $ git clone [url]\n \n\n\n\n# 配置\n\ngit的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n\n # 显示当前的git配置       \n $ git config --list    \n \n # 编辑git配置文件 $ git config -e [--global]  \n \n # 设置提交代码时的用户信息       \n $ git config [--global] user.name "[name]"    \n $ git config [--global] user.email "[email address]" \n \n\n\n\n# 增加/删除文件\n\n# 添加指定文件到暂存区       \n$ git add [file1] [file2] ...   \n\n# 添加指定目录到暂存区，包括子目录       \n$ git add [dir]      \n\n# 添加当前目录的所有文件到暂存区       \n$ git add .      \n\n# 添加每个变化前，都会要求确认   \n\n# 对于同一个文件的多处变化，可以实现分次提交       \n$ git add -p      \n\n# 删除工作区文件，并且将这次删除放入暂存区       \n$ git rm [file1] [file2] ...      \n\n# 停止追踪指定文件，但该文件会保留在工作区        \n$ git rm --cached [file]     \n\n# 改名文件，并且将这个改名放入暂存区       \n$ git mv [file-original] [file-renamed]  \n\n\n\n\n# 代码提交\n\n # 提交暂存区到仓库区       \n $ git commit -m [message]\n \n # 提交暂存区的指定文件到仓库区\n $ git commit [file1] [file2] ... -m [message]\n \n # 提交工作区自上次commit之后的变化，直接到仓库区\n $ git commit -a\n \n # 提交时显示所有diff信息\n $ git commit -v\n \n # 使用一次新的commit，替代上一次提交\n \n # 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n $ git commit --amend -m [message]\n \n # 重做上一次commit，并包括指定文件的新变化\n $ git commit --amend [file1] [file2] …  \n \n\n\n\n# 分支\n\n# 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch] \n\n# 将本地分支与远程保持同步\n$ git fetch \n\n\n\n# 标签\n\n# 列出所有tag\n$ git tag\n\n# 新建一个tag在当前commit\n$ git tag [tag]   \n\n# 新建一个tag在指定commit\n$ git tag [tag] [commit]\n\n# 删除本地tag\n$ git tag -d [tag]\n\n# 删除远程tag\n$ git push origin :refs/tags/[tagname]\n\n# 查看tag信息\n$ git show [tag]\n\n# 提交指定tag\n$ git push [remote] [tag]\n\n# 提交所有tag\n$ git push [remote] --tags\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]  \n\n\n\n\n# 查看信息\n\n# 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -s [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] head --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件\n$ git log [tag] head --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff head\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat "@{0 day ago}"\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog \n\n\n\n\n# 远程同步\n\n # 下载远程仓库的所有变动\n $ git fetch [remote]\n \n # 显示所有远程仓库\n $ git remote -v\n \n # 显示某个远程仓库的信息\n $ git remote show [remote]\n \n # 增加一个新的远程仓库，并命名\n $ git remote add [shortname] [url]\n \n # 取回远程仓库的变化，并与本地分支合并\n $ git pull [remote] [branch]\n \n # 上传本地指定分支到远程仓库\n $ git push [remote] [branch]\n \n # 强行推送当前分支到远程仓库，即使有冲突\n $ git push [remote] --force\n \n # 推送所有分支到远程仓库\n $ git push [remote] --all   \n \n\n\n\n# 撤销\n\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的head为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前head为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n# 暂时将未提交的变化移除，稍后再移入\n$ git stash$ git stash pop   \n\n\n\n\n# 其他\n\n# 生成一个可供发布的压缩包\n$ git archive\n\n\n\n\n# 流程\n\n//第一步：查看当前的git仓库状态，可以使用git status。\n\ngit status\n\n//第二步：把更新的代码添加到暂存区。\n\ngit add *\n\n//第三步：将暂存区的更新提交到仓库区。\n\ngit commit -m "更新说明" （更新说明，是本次推送代码的标识，写什么都可以，只要自己看得懂） \n\n//第四步：先git pull,拉取远程仓库所有分支更新并合并到本地。\n\ngit pull\n\n//第五步：将本地分支的更新全部推送到远程仓库。\n\ngit push origin master\n\n//第六步．再次使用git status查看当前的git仓库状态，已经没有改动，证明更新成功\n\n\n\n# 如何将某一个分支(a分支)的部分代码合并到另外一个分支(b分支)上面\n\n需求\n\n在a分支上面开发了一个功能，突然b分支说也需要这个功能，但是不想要合并a分支上所有的代码；只需要合并这一个功能对应的代码\n\n方案：\n\n 1. 在a分支上通过git log 查看日志；将自己提交的该功能对应的hash值整理出来；\n\ngit log\n\n\n 2. 如果本地没有b分支，需要先将b分支从远程仓库拉到本地仓库(如果本地有b分支，并且已与远程对应的b分支已关联；无需这一步，直接到下一步)\n\ngit checkout --track origin/b\n\n\n 3. 切换到b分支\n\ngit checkout b\n\n\n 4. 在b分支上操作：通过git cherry-pick <commit对应的hash值>将当前hash对应提交的代码合并到b分支上去\n\ngit cherry-pick b5dc0dd\n',charsets:{cjk:!0}},{title:"react",frontmatter:{},regularPath:"/react/react.html",relativePath:"react/react.md",key:"v-2d66d4d4",path:"/react/react.html",headersStr:null,content:"# react\n\nreact官网 https://react.docschina.org/",normalizedContent:"# react\n\nreact官网 https://react.docschina.org/",charsets:{cjk:!0}},{title:"前言",frontmatter:{},regularPath:"/qiankun/",relativePath:"qiankun/README.md",key:"v-6fda4365",path:"/qiankun/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:2},{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:184},{level:3,title:"微前端",slug:"微前端",normalizedTitle:"微前端",charIndex:78},{level:3,title:"qiankun",slug:"qiankun",normalizedTitle:"qiankun",charIndex:196}],headersStr:"前言 介绍 微前端 qiankun",content:"# 前言\n\n随着技术栈越来越广泛，许多前端框架也层出不穷，使得我们在构建 web 应用时，由于技术栈之间的差异，难以协同开发。而目前其中一个主流方案就是使用微前端，让不同技术栈、框架能独立开发，独立部署子模块，再共同嵌入主模块，形成一个完整的大型 web 应用。微前端是一种多个团队通过独立发布功能的方式来共同构建现代化 web 应用的技术手段及方法策略。\n\n本文主要介绍微前端实现方案之一：qiankun。\n\n\n# 介绍\n\n\n# 微前端\n\n微前端是一种多个团队通过独立发布功能的方式来共同构建现代化 web 应用的技术手段及方法策略。\n\n微前端架构具备以下几个核心价值：\n\n * 技术栈无关\n   \n   * 主框架不限制接入应用的技术栈，微应用具备完全自主权\n\n * 独立开发、独立部署\n   \n   * 微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新\n\n * 增量升级\n   \n   * 在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略\n\n * 独立运行时\n   \n   * 每个微应用之间状态隔离，运行时状态不共享\n\n微前端架构旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个巨石应用(Frontend Monolith)后，随之而来的应用不可维护的问题。这类问题在企业级 Web 应用中尤其常见。\n\n\n# qiankun\n\nqiankun 是一个基于 single-spa 的微前端实现库，旨在帮助大家能更简单、无痛的构建一个生产可用微前端架构系统。\n\nqiankun 孵化自蚂蚁金融科技基于微前端架构的云产品统一接入平台，在经过一批线上应用的充分检验及打磨后，我们将其微前端内核抽取出来并开源，希望能同时帮助社区有类似需求的系统更方便的构建自己的微前端系统，同时也希望通过社区的帮助将 qiankun 打磨的更加成熟完善。\n\n目前 qiankun 已在蚂蚁内部服务了超过 2000+ 线上应用，在易用性及完备性上，绝对是值得信赖的。\n\n# qiankun 的核心理念：\n\n# 简单\n\n由于主应用微应用都能做到技术栈无关，qiankun 对于用户而言只是一个类似 jQuery 的库，你需要调用几个 qiankun 的 API 即可完成应用的微前端改造。同时由于 qiankun 的 HTML entry 及沙箱的设计，使得微应用的接入像使用 iframe 一样简单。\n\n# 解耦/技术栈无关\n\n微前端的核心目标是将巨石应用拆解成若干可以自治的松耦合微应用，而 qiankun 的诸多设计均是秉持这一原则，如 HTML entry、沙箱、应用间通信等。这样才能确保微应用真正具备 独立开发、独立运行 的能力。\n\n# 特性：\n\n * 基于 single-spa 封装，提供了更加开箱即用的 API。\n * 技术栈无关，任意技术栈的应用均可 使用/接入，不论是 React/Vue/Angular/JQuery 还是其他等框架。\n * HTML Entry 接入方式，让你接入微应用像使用 iframe 一样简单。\n * 样式隔离，确保微应用之间样式互相不干扰。\n * JS 沙箱，确保微应用之间 全局变量/事件 不冲突。\n * 资源预加载，在浏览器空闲时间预加载未打开的微应用资源，加速微应用打开速度。\n * umi 插件，提供了 @umijs/plugin-qiankun 供 umi 应用一键切换成微前端架构系统。",normalizedContent:"# 前言\n\n随着技术栈越来越广泛，许多前端框架也层出不穷，使得我们在构建 web 应用时，由于技术栈之间的差异，难以协同开发。而目前其中一个主流方案就是使用微前端，让不同技术栈、框架能独立开发，独立部署子模块，再共同嵌入主模块，形成一个完整的大型 web 应用。微前端是一种多个团队通过独立发布功能的方式来共同构建现代化 web 应用的技术手段及方法策略。\n\n本文主要介绍微前端实现方案之一：qiankun。\n\n\n# 介绍\n\n\n# 微前端\n\n微前端是一种多个团队通过独立发布功能的方式来共同构建现代化 web 应用的技术手段及方法策略。\n\n微前端架构具备以下几个核心价值：\n\n * 技术栈无关\n   \n   * 主框架不限制接入应用的技术栈，微应用具备完全自主权\n\n * 独立开发、独立部署\n   \n   * 微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新\n\n * 增量升级\n   \n   * 在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略\n\n * 独立运行时\n   \n   * 每个微应用之间状态隔离，运行时状态不共享\n\n微前端架构旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个巨石应用(frontend monolith)后，随之而来的应用不可维护的问题。这类问题在企业级 web 应用中尤其常见。\n\n\n# qiankun\n\nqiankun 是一个基于 single-spa 的微前端实现库，旨在帮助大家能更简单、无痛的构建一个生产可用微前端架构系统。\n\nqiankun 孵化自蚂蚁金融科技基于微前端架构的云产品统一接入平台，在经过一批线上应用的充分检验及打磨后，我们将其微前端内核抽取出来并开源，希望能同时帮助社区有类似需求的系统更方便的构建自己的微前端系统，同时也希望通过社区的帮助将 qiankun 打磨的更加成熟完善。\n\n目前 qiankun 已在蚂蚁内部服务了超过 2000+ 线上应用，在易用性及完备性上，绝对是值得信赖的。\n\n# qiankun 的核心理念：\n\n# 简单\n\n由于主应用微应用都能做到技术栈无关，qiankun 对于用户而言只是一个类似 jquery 的库，你需要调用几个 qiankun 的 api 即可完成应用的微前端改造。同时由于 qiankun 的 html entry 及沙箱的设计，使得微应用的接入像使用 iframe 一样简单。\n\n# 解耦/技术栈无关\n\n微前端的核心目标是将巨石应用拆解成若干可以自治的松耦合微应用，而 qiankun 的诸多设计均是秉持这一原则，如 html entry、沙箱、应用间通信等。这样才能确保微应用真正具备 独立开发、独立运行 的能力。\n\n# 特性：\n\n * 基于 single-spa 封装，提供了更加开箱即用的 api。\n * 技术栈无关，任意技术栈的应用均可 使用/接入，不论是 react/vue/angular/jquery 还是其他等框架。\n * html entry 接入方式，让你接入微应用像使用 iframe 一样简单。\n * 样式隔离，确保微应用之间样式互相不干扰。\n * js 沙箱，确保微应用之间 全局变量/事件 不冲突。\n * 资源预加载，在浏览器空闲时间预加载未打开的微应用资源，加速微应用打开速度。\n * umi 插件，提供了 @umijs/plugin-qiankun 供 umi 应用一键切换成微前端架构系统。",charsets:{cjk:!0}},{title:"快速上手",frontmatter:{},regularPath:"/qiankun/qiankun1.html",relativePath:"qiankun/qiankun1.md",key:"v-9519fc44",path:"/qiankun/qiankun1.html",headers:[{level:2,title:"快速上手",slug:"快速上手",normalizedTitle:"快速上手",charIndex:2},{level:3,title:"主应用",slug:"主应用",normalizedTitle:"主应用",charIndex:11},{level:3,title:"微应用",slug:"微应用",normalizedTitle:"微应用",charIndex:87},{level:2,title:"项目实战",slug:"项目实战",normalizedTitle:"项目实战",charIndex:1426},{level:3,title:"主应用",slug:"主应用-2",normalizedTitle:"主应用",charIndex:11},{level:3,title:"微应用",slug:"微应用-2",normalizedTitle:"微应用",charIndex:87},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:2747},{level:3,title:"hash 模式更改成history 模式",slug:"hash-模式更改成history-模式",normalizedTitle:"hash 模式更改成history 模式",charIndex:4473},{level:3,title:"为微应用添加路由",slug:"为微应用添加路由",normalizedTitle:"为微应用添加路由",charIndex:4579}],headersStr:"快速上手 主应用 微应用 项目实战 主应用 微应用 扩展 hash 模式更改成history 模式 为微应用添加路由",content:"# 快速上手\n\n\n# 主应用\n\n# ① 安装 qiankun\n\n$ npm i qiankun -S  # 或者 yarn add qiankun\n\n\n# ② 在主应用中注册微应用\n\nimport { registerMicroApps, start } from 'qiankun';\n\nregisterMicroApps([\n  {\n    name: 'vue-app',\n    entry: '//localhost:8080',\n    container: '#container',\n    activeRule: '/activeRule',\n  },\n]);\n\nstart();\n\n\n当微应用信息注册完之后，一旦浏览器的 url 发生变化，便会自动触发 qiankun 的匹配逻辑，所有 activeRule 规则匹配上的微应用就会被插入到指定的 container 中，同时依次调用微应用暴露出的生命周期钩子。\n\n\n# 微应用\n\n微应用不需要额外安装任何其他依赖即可接入 qiankun 主应用。\n\n# ① 导出相应的生命周期钩子\n\n微应用需要在自己的入口 js (通常就是你配置的 webpack 的 entry js) 导出 bootstrap、mount、unmount 三个生命周期钩子，以供主应用在适当的时机调用。\n\n/**\n\n   * bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。\n  * 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。\n    */\nexport async function bootstrap() {\n  console.log('app bootstraped');\n}\n\n/**\n\n  * 应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法\n    */\nexport async function mount(props) {\n  // 渲染方法等\n}\n\n/**\n\n  * 应用每次 切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例\n    */\nexport async function unmount(props) {\n\n}\n\n/**\n\n  * 可选生命周期钩子，仅使用 loadMicroApp 方式加载微应用时生效\n    */\nexport async function update(props) {\n  console.log('update props', props);\n}\n\n\n# ② 配置微应用的打包工具\n\n除了代码中暴露出相应的生命周期钩子之外，为了让主应用能正确识别微应用暴露出来的一些信息，微应用的打包工具需要增加如下配置：\n\n# webpack:\n\nconst packageName = require('./package.json').name;\n\nmodule.exports = {\n  output: {\n    library: `${packageName}-[name]`,\n    libraryTarget: 'umd',\n    jsonpFunction: `webpackJsonp_${packageName}`,\n  },\n};\n\n\n\n# 项目实战\n\n以下例子中我创建两个 vue2 项目，一个为主应用，一个为微应用（当然你也可以使用其他框架）。\n\n\n# 主应用\n\n主应用不限技术栈，只需要提供一个容器 DOM，然后注册微应用并 start 即可。这里我的主应用是 vue2 项目，项目的搭建过程不在此赘述，直接进入 qiankun 使用阶段。\n\n项目视图如下：\n\n\n\n# ① 安装 qiankun\n\nnpm i qiankun -S\n\n\n# ② 注册微应用并启动\n\n为了结构清晰，我在 /src 下新建一个 micro 目录，里面新建一个文件 index.js\n\n\n\n# index.js\n\nimport { registerMicroApps, start } from 'qiankun';\n// 注册微应用\nregisterMicroApps([\n  {\n    name: 'appVue2.7',   // 自定义微应用名称\n    entry: '//localhost:8081/',   // 微应用的入口地址，即微应用运行起来的地址\n    container: '#container',   // 挂载微应用内容的dom节点（此处为主应用的dom）\n    activeRule: '/#/app-vue',  \n    // 匹配微应用的路由前缀（/#/，主应用为hash模式，在url命中时，即加载对应的微应用）\n  },\n]);\n// 启动 qiankun\nstart();\n\n\n# ③ 主应用添加路由\n\n由于我们在主应用使用了左侧菜单栏，且设置了路由展示，因此我们需要在主应用中配置微应用对应的路由 path，确保点击菜单栏能切换到对应的路由地址。\n\n\n\n::: warnning 注意\n\n在注册微应用前，确保我们的微应用启动正常。\n\n:::\n\n此时我已经另外新建一个 vue2.7 的项目当成微应用（当然你也可以使用 react、angular 等框架）并且已经成功启动，地址为 localhost:8081（即主应用注册微应用配置中的 entry）。\n\n微应用视图展示：\n\n\n\n\n\n接下来就是微应用的配置。\n\n\n# 微应用\n\n微应用分为有 webpack 构建和无 webpack 构建项目，有 webpack 的微应用（主要是指 Vue、React、Angular）需要做的事情有：\n\n# ① 新增 public-path.js\n\n用于修改运行时的 publicPath。什么是运行时的 publicPath ？。\n\nif (window.__POWERED_BY_QIANKUN__) {\n  window.__webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;\n}\n\n\n\n\n::: warnning 注意\n\n运行时的 publicPath 和构建时的 publicPath 是不同的，两者不能等价替代。\n\n:::\n\n# ② 建议使用 history 模式\n\n需要设置路由 base，值和它的 activeRule 是一样的。该例子微应用暂不使用路由（本文“扩展”部分添加路由使用部分，不容错过哟）。\n\n# ③ 引入 public-path.js\n\n修改并导出三个生命周期函数。\n\n// main.js\nimport './public-path';   // 引入\nimport Vue from 'vue';\nimport App from './App.vue';\n\nVue.config.productionTip = false;\n\nlet instance = null;\nfunction render(props = {}) {\n  const { container } = props;\n  instance = new Vue({\n    render: (h) => h(App),\n  }).$mount(container ? container.querySelector('#app') : '#app');\n}\n\n// 独立运行时\nif (!window.__POWERED_BY_QIANKUN__) {\n  render();\n}\n\nexport async function bootstrap() {\n  console.log('[vue] vue app bootstraped');\n}\nexport async function mount(props) {\n  console.log('[vue] props from main framework', props);\n  render(props);\n}\nexport async function unmount() {\n  instance.$destroy();\n  instance.$el.innerHTML = '';\n  instance = null;\n}\n\n\n# ④ 修改 webpack\n\n允许开发环境跨域和 umd 打包。\n\n// vue.config.js\nconst { defineConfig } = require('@vue/cli-service')\nconst { name } = require('./package');\nmodule.exports = defineConfig({\n  transpileDependencies: true,\n  devServer: {\n    headers: {\n      'Access-Control-Allow-Origin': '*',\n    },\n  },\n  configureWebpack: {\n    output: {\n      library: `${name}-[name]`,\n      libraryTarget: 'umd', // 把微应用打包成 umd 库格式\n      //jsonpFunction: `webpackJsonp_${name}`,\n    },\n  },\n})\n\n\n主要的修改就是以上四个，可能会根据项目的不同情况而改变。例如，你的项目是 index.html 和其他的所有文件分开部署的，说明你们已经将构建时的 publicPath 设置为了完整路径，则不用修改运行时的 publicPath （第一步操作可省）。\n\n无 webpack 构建的微应用直接将 lifecycles 挂载到 window 上即可。\n\n# 整合效果\n\n在主应用、微应用都配置完毕之后，接下来就是见证奇迹的时刻了。\n\n我们在主应用切换到微应用匹配的 url，即在注册微应用时\n\nactiveRule: '/#/app-vue',\n\n\n我们在主应用切换菜单\n\n\n\n此时地址为 ’/#/app-vue’（hash 模式），但是子应用却没展示出来。经过排查，我们发现在注册微应用时，我们配置了一个容器用于展示微应用\n\ncontainer: '#container',\n\n\n但是在主应用中并没有找到对应容器，于是重新修改代码\n\n\n\n此时刷新，微应用成功展示\n\n\n\n主应用端口为 8080，微应用端口为 8081，且主应用顺利挂载微应用，微前端方案成功实现！\n\n\n# 扩展\n\n\n# hash 模式更改成history 模式\n\n其实很简单，只需要修改两处地方：\n\n# 修改主应用路由模式\n\n\n\n# 修改注册微应用配置\n\n\n\n修改完毕，回到页面，查看效果，history 模式显示正常\n\n\n\n\n# 为微应用添加路由\n\n前面我们提到，微应用路由建议使用 history 模式，并设置路由 base，值和它的 activeRule 是一样的。\n\nimport Vue from 'vue'\nimport Router from 'vue-router'\nimport HelloWorld from '@/components/HelloWorld'\nimport About from '@/components/About'\n\nVue.use(Router)\n\nexport default new Router({\n  // 路由模式\n  mode: 'history',\n  // 本项目为微应用时，基础路径为 /app-vue，即与注册微应用时的 activeRule 一致\n  base: window.__POWERED_BY_QIANKUN__ ? \"/app-vue\" : \"/\",\n  routes: [\n    {\n      path:'/',\n      redirect:'/home'\n    },\n    {\n      path: '/home',\n      name: 'HelloWorld',\n      component: HelloWorld\n    },\n    {\n      path: '/about',\n      name: 'About',\n      component: About\n    }\n  ]\n})\n\n\n在 mian.js 中注入路由\n\nimport './public-path';\nimport Vue from 'vue';\nimport App from './App.vue';\nimport router from './router';\n\nVue.config.productionTip = false;\n\nlet instance = null;\nfunction render(props = {}) {\n  const { container } = props;\n  instance = new Vue({\n    router,   // 添加此行，注入路由，其他配置不变\n    render: (h) => h(App),\n  }).$mount(container ? container.querySelector('#app') : '#app');\n}\n\n// 独立运行时\nif (!window.__POWERED_BY_QIANKUN__) {\n  render();\n}\n\nexport async function bootstrap() {\n  console.log('[vue] vue app bootstraped');\n}\nexport async function mount(props) {\n  console.log('[vue] props from main framework', props);\n  render(props);\n}\nexport async function unmount() {\n  instance.$destroy();\n  instance.$el.innerHTML = '';\n  instance = null;\n}\n\n\n到主应用查看效果\n\n\n\n微应用中 Home、About 顺利切换与展示，路由添加成功。至此，一个基础的微前端 web 项目搭建起来了，我们可以在这个的基础上继续进行迭代与开发。微应用不限制技术栈与框架，多人协同开发大型web项目，简直YYDS！",normalizedContent:"# 快速上手\n\n\n# 主应用\n\n# ① 安装 qiankun\n\n$ npm i qiankun -s  # 或者 yarn add qiankun\n\n\n# ② 在主应用中注册微应用\n\nimport { registermicroapps, start } from 'qiankun';\n\nregistermicroapps([\n  {\n    name: 'vue-app',\n    entry: '//localhost:8080',\n    container: '#container',\n    activerule: '/activerule',\n  },\n]);\n\nstart();\n\n\n当微应用信息注册完之后，一旦浏览器的 url 发生变化，便会自动触发 qiankun 的匹配逻辑，所有 activerule 规则匹配上的微应用就会被插入到指定的 container 中，同时依次调用微应用暴露出的生命周期钩子。\n\n\n# 微应用\n\n微应用不需要额外安装任何其他依赖即可接入 qiankun 主应用。\n\n# ① 导出相应的生命周期钩子\n\n微应用需要在自己的入口 js (通常就是你配置的 webpack 的 entry js) 导出 bootstrap、mount、unmount 三个生命周期钩子，以供主应用在适当的时机调用。\n\n/**\n\n   * bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。\n  * 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。\n    */\nexport async function bootstrap() {\n  console.log('app bootstraped');\n}\n\n/**\n\n  * 应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法\n    */\nexport async function mount(props) {\n  // 渲染方法等\n}\n\n/**\n\n  * 应用每次 切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例\n    */\nexport async function unmount(props) {\n\n}\n\n/**\n\n  * 可选生命周期钩子，仅使用 loadmicroapp 方式加载微应用时生效\n    */\nexport async function update(props) {\n  console.log('update props', props);\n}\n\n\n# ② 配置微应用的打包工具\n\n除了代码中暴露出相应的生命周期钩子之外，为了让主应用能正确识别微应用暴露出来的一些信息，微应用的打包工具需要增加如下配置：\n\n# webpack:\n\nconst packagename = require('./package.json').name;\n\nmodule.exports = {\n  output: {\n    library: `${packagename}-[name]`,\n    librarytarget: 'umd',\n    jsonpfunction: `webpackjsonp_${packagename}`,\n  },\n};\n\n\n\n# 项目实战\n\n以下例子中我创建两个 vue2 项目，一个为主应用，一个为微应用（当然你也可以使用其他框架）。\n\n\n# 主应用\n\n主应用不限技术栈，只需要提供一个容器 dom，然后注册微应用并 start 即可。这里我的主应用是 vue2 项目，项目的搭建过程不在此赘述，直接进入 qiankun 使用阶段。\n\n项目视图如下：\n\n\n\n# ① 安装 qiankun\n\nnpm i qiankun -s\n\n\n# ② 注册微应用并启动\n\n为了结构清晰，我在 /src 下新建一个 micro 目录，里面新建一个文件 index.js\n\n\n\n# index.js\n\nimport { registermicroapps, start } from 'qiankun';\n// 注册微应用\nregistermicroapps([\n  {\n    name: 'appvue2.7',   // 自定义微应用名称\n    entry: '//localhost:8081/',   // 微应用的入口地址，即微应用运行起来的地址\n    container: '#container',   // 挂载微应用内容的dom节点（此处为主应用的dom）\n    activerule: '/#/app-vue',  \n    // 匹配微应用的路由前缀（/#/，主应用为hash模式，在url命中时，即加载对应的微应用）\n  },\n]);\n// 启动 qiankun\nstart();\n\n\n# ③ 主应用添加路由\n\n由于我们在主应用使用了左侧菜单栏，且设置了路由展示，因此我们需要在主应用中配置微应用对应的路由 path，确保点击菜单栏能切换到对应的路由地址。\n\n\n\n::: warnning 注意\n\n在注册微应用前，确保我们的微应用启动正常。\n\n:::\n\n此时我已经另外新建一个 vue2.7 的项目当成微应用（当然你也可以使用 react、angular 等框架）并且已经成功启动，地址为 localhost:8081（即主应用注册微应用配置中的 entry）。\n\n微应用视图展示：\n\n\n\n\n\n接下来就是微应用的配置。\n\n\n# 微应用\n\n微应用分为有 webpack 构建和无 webpack 构建项目，有 webpack 的微应用（主要是指 vue、react、angular）需要做的事情有：\n\n# ① 新增 public-path.js\n\n用于修改运行时的 publicpath。什么是运行时的 publicpath ？。\n\nif (window.__powered_by_qiankun__) {\n  window.__webpack_public_path__ = window.__injected_public_path_by_qiankun__;\n}\n\n\n\n\n::: warnning 注意\n\n运行时的 publicpath 和构建时的 publicpath 是不同的，两者不能等价替代。\n\n:::\n\n# ② 建议使用 history 模式\n\n需要设置路由 base，值和它的 activerule 是一样的。该例子微应用暂不使用路由（本文“扩展”部分添加路由使用部分，不容错过哟）。\n\n# ③ 引入 public-path.js\n\n修改并导出三个生命周期函数。\n\n// main.js\nimport './public-path';   // 引入\nimport vue from 'vue';\nimport app from './app.vue';\n\nvue.config.productiontip = false;\n\nlet instance = null;\nfunction render(props = {}) {\n  const { container } = props;\n  instance = new vue({\n    render: (h) => h(app),\n  }).$mount(container ? container.queryselector('#app') : '#app');\n}\n\n// 独立运行时\nif (!window.__powered_by_qiankun__) {\n  render();\n}\n\nexport async function bootstrap() {\n  console.log('[vue] vue app bootstraped');\n}\nexport async function mount(props) {\n  console.log('[vue] props from main framework', props);\n  render(props);\n}\nexport async function unmount() {\n  instance.$destroy();\n  instance.$el.innerhtml = '';\n  instance = null;\n}\n\n\n# ④ 修改 webpack\n\n允许开发环境跨域和 umd 打包。\n\n// vue.config.js\nconst { defineconfig } = require('@vue/cli-service')\nconst { name } = require('./package');\nmodule.exports = defineconfig({\n  transpiledependencies: true,\n  devserver: {\n    headers: {\n      'access-control-allow-origin': '*',\n    },\n  },\n  configurewebpack: {\n    output: {\n      library: `${name}-[name]`,\n      librarytarget: 'umd', // 把微应用打包成 umd 库格式\n      //jsonpfunction: `webpackjsonp_${name}`,\n    },\n  },\n})\n\n\n主要的修改就是以上四个，可能会根据项目的不同情况而改变。例如，你的项目是 index.html 和其他的所有文件分开部署的，说明你们已经将构建时的 publicpath 设置为了完整路径，则不用修改运行时的 publicpath （第一步操作可省）。\n\n无 webpack 构建的微应用直接将 lifecycles 挂载到 window 上即可。\n\n# 整合效果\n\n在主应用、微应用都配置完毕之后，接下来就是见证奇迹的时刻了。\n\n我们在主应用切换到微应用匹配的 url，即在注册微应用时\n\nactiverule: '/#/app-vue',\n\n\n我们在主应用切换菜单\n\n\n\n此时地址为 ’/#/app-vue’（hash 模式），但是子应用却没展示出来。经过排查，我们发现在注册微应用时，我们配置了一个容器用于展示微应用\n\ncontainer: '#container',\n\n\n但是在主应用中并没有找到对应容器，于是重新修改代码\n\n\n\n此时刷新，微应用成功展示\n\n\n\n主应用端口为 8080，微应用端口为 8081，且主应用顺利挂载微应用，微前端方案成功实现！\n\n\n# 扩展\n\n\n# hash 模式更改成history 模式\n\n其实很简单，只需要修改两处地方：\n\n# 修改主应用路由模式\n\n\n\n# 修改注册微应用配置\n\n\n\n修改完毕，回到页面，查看效果，history 模式显示正常\n\n\n\n\n# 为微应用添加路由\n\n前面我们提到，微应用路由建议使用 history 模式，并设置路由 base，值和它的 activerule 是一样的。\n\nimport vue from 'vue'\nimport router from 'vue-router'\nimport helloworld from '@/components/helloworld'\nimport about from '@/components/about'\n\nvue.use(router)\n\nexport default new router({\n  // 路由模式\n  mode: 'history',\n  // 本项目为微应用时，基础路径为 /app-vue，即与注册微应用时的 activerule 一致\n  base: window.__powered_by_qiankun__ ? \"/app-vue\" : \"/\",\n  routes: [\n    {\n      path:'/',\n      redirect:'/home'\n    },\n    {\n      path: '/home',\n      name: 'helloworld',\n      component: helloworld\n    },\n    {\n      path: '/about',\n      name: 'about',\n      component: about\n    }\n  ]\n})\n\n\n在 mian.js 中注入路由\n\nimport './public-path';\nimport vue from 'vue';\nimport app from './app.vue';\nimport router from './router';\n\nvue.config.productiontip = false;\n\nlet instance = null;\nfunction render(props = {}) {\n  const { container } = props;\n  instance = new vue({\n    router,   // 添加此行，注入路由，其他配置不变\n    render: (h) => h(app),\n  }).$mount(container ? container.queryselector('#app') : '#app');\n}\n\n// 独立运行时\nif (!window.__powered_by_qiankun__) {\n  render();\n}\n\nexport async function bootstrap() {\n  console.log('[vue] vue app bootstraped');\n}\nexport async function mount(props) {\n  console.log('[vue] props from main framework', props);\n  render(props);\n}\nexport async function unmount() {\n  instance.$destroy();\n  instance.$el.innerhtml = '';\n  instance = null;\n}\n\n\n到主应用查看效果\n\n\n\n微应用中 home、about 顺利切换与展示，路由添加成功。至此，一个基础的微前端 web 项目搭建起来了，我们可以在这个的基础上继续进行迭代与开发。微应用不限制技术栈与框架，多人协同开发大型web项目，简直yyds！",charsets:{cjk:!0}},{title:"正则",frontmatter:{},regularPath:"/regular&git/regular/",relativePath:"regular&git/regular/README.md",key:"v-2e496bf9",path:"/regular&git/regular/",headers:[{level:2,title:"数字格式验证",slug:"数字格式验证",normalizedTitle:"数字格式验证",charIndex:132},{level:2,title:"自然数验证",slug:"自然数验证",normalizedTitle:"自然数验证",charIndex:252}],headersStr:"数字格式验证 自然数验证",content:"# 正则\n\n例子\n\nvar reg = /^[A-Za-z\\u4e00-\\u9fa5]+$/;\nif (!reg.test(str)) {\n    return false;\n} else {\n    return true;\n}\n\n\n常用数字正则表达式\n\n\n# 数字格式验证\n\n1、验证数字\n\n/^[0-9]*$/\n/^\\d+$/\n\n\n2、只能输入n个数字\n\n/^\\d{n}$/\n\n\n3、至少输入n个以上的数字\n\n/^\\d{n,}$/\n\n\n4、只能输入m到n个数字\n\n/^\\d{m,n}$/\n\n\n\n# 自然数验证\n\n1、数字（含零、正负实数）\n\n/^[+-]?(0|([1-9]\\d*))(\\.\\d+)?$/\n\n\n2、整数，含0\n\n/^(0|[1-9][0-9]*|-[1-9][0-9]*)$/\n\n\n3、整数，不含0\n\n/^((-)?[1-9]\\d*)$/\n/^([1-9][0-9]*|-[1-9][0-9]*)$/\n\n\n4、正整数，含0\n\n/^(0|[1-9][0-9]*)$/\n/^([1-9]\\d*|[0]{1,1})$/\n\n\n5、正整数，不含0\n\n/^([1-9][0-9]*)$/\n/^[1-9]+\\d*$/\n/^\\+?[1-9][0-9]*$/\n\n\n6、负整数，含0\n\n/^(0|-[1-9][0-9]*)$/\n\n\n7、负整数，不含0\n\n/^(-[1-9][0-9]*)$/\n\n\n8、正实数，含0\n\n/^(?:[1-9]\\d*|0)(?:\\.\\d+)?$/\n\n\n9、正实数，不含0\n\n/^(?:[1-9][0-9]*\\.[0-9]+|0\\.(?!0+$)[0-9]+|[1-9]+\\d*)$/\n\n\n10、负实数，含0\n\n/^(0|-([1-9]+\\d*|[1-9][0-9]*\\.[0-9]+|0\\.(?!0+$)[0-9]+))$/\n\n\n11、负实数，不含0\n\n/^-([1-9]+\\d*|[1-9][0-9]*\\.[0-9]+|0\\.(?!0+$)[0-9]+)$/\n\n\n12、浮点数，含0\n\n/^(0|[+-]?((0|([1-9]\\d*))\\.\\d+)?)$/\n\n\n13、浮点数，不含0\n\n/^[+-]?((0|([1-9]\\d*))\\.\\d+)?$/\n\n\n14、正浮点数，含0\n\n/^(?:[1-9][0-9]*\\.[0-9]+|0\\.(?!0+$)[0-9]+|0)$/\n\n\n15、正浮点数，不含0\n\n/^(?:[1-9][0-9]*\\.[0-9]+|0\\.(?!0+$)[0-9]+)$/\n\n\n16、正浮点数，保留n位小数，含0\n\n/^(0|(0|[1-9][0-9]*)+(\\.\\d{n}))$/\n\n\n17、正浮点数，保留m~n个位小数，含0\n\n/^(0|[1-9][0-9]*)+(\\.\\d{m,n})?$/\n\n\n18、负浮点数，含0\n\n/^(0|-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))$/\n\n\n19、负浮点数，不含0\n\n/^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$/\n\n\n20、负浮点数，保留n位小数，含0\n\n/^(0|-(0|[1-9][0-9]*)+(\\.\\d{n}))$/\n",normalizedContent:"# 正则\n\n例子\n\nvar reg = /^[a-za-z\\u4e00-\\u9fa5]+$/;\nif (!reg.test(str)) {\n    return false;\n} else {\n    return true;\n}\n\n\n常用数字正则表达式\n\n\n# 数字格式验证\n\n1、验证数字\n\n/^[0-9]*$/\n/^\\d+$/\n\n\n2、只能输入n个数字\n\n/^\\d{n}$/\n\n\n3、至少输入n个以上的数字\n\n/^\\d{n,}$/\n\n\n4、只能输入m到n个数字\n\n/^\\d{m,n}$/\n\n\n\n# 自然数验证\n\n1、数字（含零、正负实数）\n\n/^[+-]?(0|([1-9]\\d*))(\\.\\d+)?$/\n\n\n2、整数，含0\n\n/^(0|[1-9][0-9]*|-[1-9][0-9]*)$/\n\n\n3、整数，不含0\n\n/^((-)?[1-9]\\d*)$/\n/^([1-9][0-9]*|-[1-9][0-9]*)$/\n\n\n4、正整数，含0\n\n/^(0|[1-9][0-9]*)$/\n/^([1-9]\\d*|[0]{1,1})$/\n\n\n5、正整数，不含0\n\n/^([1-9][0-9]*)$/\n/^[1-9]+\\d*$/\n/^\\+?[1-9][0-9]*$/\n\n\n6、负整数，含0\n\n/^(0|-[1-9][0-9]*)$/\n\n\n7、负整数，不含0\n\n/^(-[1-9][0-9]*)$/\n\n\n8、正实数，含0\n\n/^(?:[1-9]\\d*|0)(?:\\.\\d+)?$/\n\n\n9、正实数，不含0\n\n/^(?:[1-9][0-9]*\\.[0-9]+|0\\.(?!0+$)[0-9]+|[1-9]+\\d*)$/\n\n\n10、负实数，含0\n\n/^(0|-([1-9]+\\d*|[1-9][0-9]*\\.[0-9]+|0\\.(?!0+$)[0-9]+))$/\n\n\n11、负实数，不含0\n\n/^-([1-9]+\\d*|[1-9][0-9]*\\.[0-9]+|0\\.(?!0+$)[0-9]+)$/\n\n\n12、浮点数，含0\n\n/^(0|[+-]?((0|([1-9]\\d*))\\.\\d+)?)$/\n\n\n13、浮点数，不含0\n\n/^[+-]?((0|([1-9]\\d*))\\.\\d+)?$/\n\n\n14、正浮点数，含0\n\n/^(?:[1-9][0-9]*\\.[0-9]+|0\\.(?!0+$)[0-9]+|0)$/\n\n\n15、正浮点数，不含0\n\n/^(?:[1-9][0-9]*\\.[0-9]+|0\\.(?!0+$)[0-9]+)$/\n\n\n16、正浮点数，保留n位小数，含0\n\n/^(0|(0|[1-9][0-9]*)+(\\.\\d{n}))$/\n\n\n17、正浮点数，保留m~n个位小数，含0\n\n/^(0|[1-9][0-9]*)+(\\.\\d{m,n})?$/\n\n\n18、负浮点数，含0\n\n/^(0|-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))$/\n\n\n19、负浮点数，不含0\n\n/^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$/\n\n\n20、负浮点数，保留n位小数，含0\n\n/^(0|-(0|[1-9][0-9]*)+(\\.\\d{n}))$/\n",charsets:{cjk:!0}},{title:"使用正则案例",frontmatter:{},regularPath:"/regular&git/regular/case.html",relativePath:"regular&git/regular/case.md",key:"v-929b2664",path:"/regular&git/regular/case.html",headers:[{level:2,title:"清空首尾为空",slug:"清空首尾为空",normalizedTitle:"清空首尾为空",charIndex:13},{level:2,title:"不能为空正则",slug:"不能为空正则",normalizedTitle:"不能为空正则",charIndex:96},{level:2,title:"字符串保留数字和小数点",slug:"字符串保留数字和小数点",normalizedTitle:"字符串保留数字和小数点",charIndex:243}],headersStr:"清空首尾为空 不能为空正则 字符串保留数字和小数点",content:'# 使用正则案例\n\n\n# 清空首尾为空\n\nfunction Trim(str) {\n    return str.replace(/(^\\s*)|(\\s*$)/g, "");\n},\n\n\n\n# 不能为空正则\n\nvar reg = /^\\s*$/g;\nif(reg.test(this.search) || this.search == null || this.search == ""){\n  // 搜索内容不能为空===提示处理\n}else{\n  // 符合条件的处理\n}\n\n\n\n# 字符串保留数字和小数点\n\nreplace详细介绍\n\nlet str = "sdf211.82"\nstr.replace(/[^\\d.]/g, \'\')\nconsole.log(str) \t// 211.82\n',normalizedContent:'# 使用正则案例\n\n\n# 清空首尾为空\n\nfunction trim(str) {\n    return str.replace(/(^\\s*)|(\\s*$)/g, "");\n},\n\n\n\n# 不能为空正则\n\nvar reg = /^\\s*$/g;\nif(reg.test(this.search) || this.search == null || this.search == ""){\n  // 搜索内容不能为空===提示处理\n}else{\n  // 符合条件的处理\n}\n\n\n\n# 字符串保留数字和小数点\n\nreplace详细介绍\n\nlet str = "sdf211.82"\nstr.replace(/[^\\d.]/g, \'\')\nconsole.log(str) \t// 211.82\n',charsets:{cjk:!0}},{title:"常用正则表达式",frontmatter:{},regularPath:"/regular&git/regular/commonUse.html",relativePath:"regular&git/regular/commonUse.md",key:"v-7961c576",path:"/regular&git/regular/commonUse.html",headers:[{level:2,title:"校验数字的表达式",slug:"校验数字的表达式",normalizedTitle:"校验数字的表达式",charIndex:14},{level:2,title:"校验字符的表达式",slug:"校验字符的表达式",normalizedTitle:"校验字符的表达式",charIndex:1033},{level:2,title:"特殊需求表达式",slug:"特殊需求表达式",normalizedTitle:"特殊需求表达式",charIndex:1619},{level:2,title:"新增",slug:"新增",normalizedTitle:"新增",charIndex:3891}],headersStr:"校验数字的表达式 校验字符的表达式 特殊需求表达式 新增",content:'# 常用正则表达式\n\n\n# 校验数字的表达式\n\n数字：\n\n^[0-9]*$\n\n\nn位的数字：\n\n^\\d{n}$\n\n\n至少n位的数字：\n\n^\\d{n,}$\n\n\nm-n位的数字：\n\n^\\d{m,n}$ \n\n\n零和非零开头的数字：\n\n^(0|[1-9][0-9]*)$\n\n\n非零开头的最多带两位小数的数字：\n\n^([1-9][0-9]*)+(.[0-9]{1,2})?$\n\n\n带1-2位小数的正数或负数：\n\n^(\\-)?\\d+(\\.\\d{1,2})?$\n\n\n正数、负数、和小数：\n\n^(\\-|\\+)?\\d+(\\.\\d+)?$\n\n\n有两位小数的正实数：\n\n^[0-9]+(.[0-9]{2})?$\n\n\n有1~3位小数的正实数：\n\n^[0-9]+(.[0-9]{1,3})?$\n\n\n非零的正整数：\n\n^[1-9]\\d*$ \n^([1-9][0-9]*){1,3}$ \n^\\+?[1-9][0-9]*$\n\n\n非零的负整数：\n\n^\\-[1-9][]0-9"*$  \n^-[1-9]\\d*$\n\n\n非负整数：\n\n^\\d+$\n^[1-9]\\d*|0$\n\n\n非正整数：\n\n^-[1-9]\\d*|0$        \n^((-\\d+)|(0+))$  \n\n\n非负浮点数：\n\n^\\d+(\\.\\d+)?$        \n^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$ \n\n\n非正浮点数：\n\n^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$        \n^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$   \n\n\n正浮点数：\n\n^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$        \n^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$  \n\n\n负浮点数：\n\n^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$       \n^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$\n\n\n浮点数：\n\n^(-?\\d+)(\\.\\d+)?$      \n^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$    \n\n\n\n# 校验字符的表达式\n\n汉字：\n\n^[\\u4e00-\\u9fa5]{0,}$\n\n\n英文和数字：\n\n^[A-Za-z0-9]+$        \n^[A-Za-z0-9]{4,40}$\n\n\n长度为3-20的所有字符：\n\n^.{3,20}$\n\n\n由26个英文字母组成的字符串：\n\n^[A-Za-z]+$\n\n\n由26个大写英文字母组成的字符串：\n\n^[A-Z]+$\n\n\n由26个小写英文字母组成的字符串：\n\n^[a-z]+$\n\n\n由数字和26个英文字母组成的字符串：\n\n^[A-Za-z0-9]+$\n\n\n由数字、26个英文字母或者下划线组成的字符串：\n\n^\\w+$ \n^\\w{3,20}$\n\n\n中文、英文、数字包括下划线：\n\n^[\\u4E00-\\u9FA5A-Za-z0-9_]+$\n\n\n中文、英文、数字但不包括下划线等符号：\n\n^[\\u4E00-\\u9FA5A-Za-z0-9]+$        \n^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$\n\n\n可以输入含有^%&\',;=?$"等字符：\n\n[^%&\',;=?$\\x22]+\n\n\n非法字符的字符：\n\n/^[\\s\\u4e00-\\u9fa5a-z0-9_-]{0,}$/\n\n\n禁止输入含有~的字符：\n\n[^~\\x22]+\n\n\n可以输入中文和英文\n\n/^[A-Za-z\\u4e00-\\u9fa5]+$/\n\n\n\n# 特殊需求表达式\n\nEmail地址：\n\n^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$      \n\n\n域名：\n\n[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?      \n\n\nInternetURL：\n\n[a-zA-z]+://[^\\s]*   \n^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&=]*)?$      \n\n\n手机号码：\n\n^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$      \n\n\n电话号码("XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX)：\n\n^(\\(\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$\n\n\n国内电话号码(0511-4405222、021-87888822)：\n\n\\d{3}-\\d{8}|\\d{4}-\\d{7}\n\n\n身份证号(15位、18位数字)：\n\n^\\d{15}|\\d{18}$\n\n\n短身份证号码(数字、字母x结尾)：\n\n^([0-9]){7,18}(x|X)?$ \n^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$\n\n\n帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：\n\n^[a-zA-Z][a-zA-Z0-9_]{4,15}$\n\n\n密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：\n\n^[a-zA-Z]\\w{5,17}$\n\n\n强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：\n\n^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$*\n\n\n日期格式：\n\n^\\d{4}-\\d{1,2}-\\d{1,2}\n\n\n一年的12个月(01～09和1～12)：\n\n^(0?[1-9]|1[0-2])$\n\n\n一个月的31天(01～09和1～31)：\n\n^((0?[1-9])|((1|2)[0-9])|30|31)$\n\n\n钱的输入格式：\n\n1.有四种钱的表示形式我们可以接受:"10000.00"和 "10,000.00", 和没有 "分" 的"10000" 和 "10,000"：\n\n^[1-9][0-9]*$*\n\n\n2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符"0"不通过,所以我们采用下面的形式：\n\n^(0|[1-9][0-9]*)$*\n\n\n3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：\n\n^(0|-?[1-9][0-9]*)$*\n\n\n4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：\n\n^[0-9]+(.[0-9]+)?$\n\n\n5.必须说明的是,小数点后面至少应该有1位数,所以"10."是不通过的,但是"10" 和 "10.2" 是通过的：\n\n^[0-9]+(.[0-9]{2})?$ \n\n\n6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：\n\n^[0-9]+(.[0-9]{1,2})?$\n\n\n7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：\n\n^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$\n\n\n8.到3个数字,后面跟着任意个逗号+3个数字,逗号成为可选,而不是必须：\n\n^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$\n\n\n备注：这就是最终结果了,别忘了"+"可以用"*"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里\n\nxml文件：\n\n^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$\n\n\n中文字符的正则表达式：\n\n[\\u4e00-\\u9fa5]\n\n\n双字节字符： (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))\n\n[^\\x00-\\xff]\n\n\n空白行的正则表达式：(可以用来删除空白行)\n\n\\n\\s*\\r\n\n\nHTML标记的正则表达式： (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)\n\n<(\\S*?)[^>]*>.*?</\\1>|<.*?/>\n\n\n首尾空白字符的正则表达式：(可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)\n\n^\\s*|\\s*$\n(^\\s*)|(\\s*$)       \n\n\n腾讯QQ号：(腾讯QQ号从10000开始)\n\n[1-9][0-9]{4,}  \n\n\n中国邮政编码：(中国邮政编码为6位数字)\n\n[1-9]\\d{5}(?!\\d)\n\n\nIP地址： (提取IP地址时有用)\n\n\\d+\\.\\d+\\.\\d+\\.\\d+ \n\n\nIP地址：\n\n((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d))    \n\n\n\n# 新增\n\n限制7位数的金额：\n\n/(^[1-9]([0-9]{0,6})?(\\.[0-9]{0,2})?$)|(^(0){1}$)|(^[0-9]\\.[0-9]([0-9])?$)/\n',normalizedContent:'# 常用正则表达式\n\n\n# 校验数字的表达式\n\n数字：\n\n^[0-9]*$\n\n\nn位的数字：\n\n^\\d{n}$\n\n\n至少n位的数字：\n\n^\\d{n,}$\n\n\nm-n位的数字：\n\n^\\d{m,n}$ \n\n\n零和非零开头的数字：\n\n^(0|[1-9][0-9]*)$\n\n\n非零开头的最多带两位小数的数字：\n\n^([1-9][0-9]*)+(.[0-9]{1,2})?$\n\n\n带1-2位小数的正数或负数：\n\n^(\\-)?\\d+(\\.\\d{1,2})?$\n\n\n正数、负数、和小数：\n\n^(\\-|\\+)?\\d+(\\.\\d+)?$\n\n\n有两位小数的正实数：\n\n^[0-9]+(.[0-9]{2})?$\n\n\n有1~3位小数的正实数：\n\n^[0-9]+(.[0-9]{1,3})?$\n\n\n非零的正整数：\n\n^[1-9]\\d*$ \n^([1-9][0-9]*){1,3}$ \n^\\+?[1-9][0-9]*$\n\n\n非零的负整数：\n\n^\\-[1-9][]0-9"*$  \n^-[1-9]\\d*$\n\n\n非负整数：\n\n^\\d+$\n^[1-9]\\d*|0$\n\n\n非正整数：\n\n^-[1-9]\\d*|0$        \n^((-\\d+)|(0+))$  \n\n\n非负浮点数：\n\n^\\d+(\\.\\d+)?$        \n^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$ \n\n\n非正浮点数：\n\n^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$        \n^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$   \n\n\n正浮点数：\n\n^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$        \n^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$  \n\n\n负浮点数：\n\n^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$       \n^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$\n\n\n浮点数：\n\n^(-?\\d+)(\\.\\d+)?$      \n^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$    \n\n\n\n# 校验字符的表达式\n\n汉字：\n\n^[\\u4e00-\\u9fa5]{0,}$\n\n\n英文和数字：\n\n^[a-za-z0-9]+$        \n^[a-za-z0-9]{4,40}$\n\n\n长度为3-20的所有字符：\n\n^.{3,20}$\n\n\n由26个英文字母组成的字符串：\n\n^[a-za-z]+$\n\n\n由26个大写英文字母组成的字符串：\n\n^[a-z]+$\n\n\n由26个小写英文字母组成的字符串：\n\n^[a-z]+$\n\n\n由数字和26个英文字母组成的字符串：\n\n^[a-za-z0-9]+$\n\n\n由数字、26个英文字母或者下划线组成的字符串：\n\n^\\w+$ \n^\\w{3,20}$\n\n\n中文、英文、数字包括下划线：\n\n^[\\u4e00-\\u9fa5a-za-z0-9_]+$\n\n\n中文、英文、数字但不包括下划线等符号：\n\n^[\\u4e00-\\u9fa5a-za-z0-9]+$        \n^[\\u4e00-\\u9fa5a-za-z0-9]{2,20}$\n\n\n可以输入含有^%&\',;=?$"等字符：\n\n[^%&\',;=?$\\x22]+\n\n\n非法字符的字符：\n\n/^[\\s\\u4e00-\\u9fa5a-z0-9_-]{0,}$/\n\n\n禁止输入含有~的字符：\n\n[^~\\x22]+\n\n\n可以输入中文和英文\n\n/^[a-za-z\\u4e00-\\u9fa5]+$/\n\n\n\n# 特殊需求表达式\n\nemail地址：\n\n^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$      \n\n\n域名：\n\n[a-za-z0-9][-a-za-z0-9]{0,62}(/.[a-za-z0-9][-a-za-z0-9]{0,62})+/.?      \n\n\ninterneturl：\n\n[a-za-z]+://[^\\s]*   \n^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&=]*)?$      \n\n\n手机号码：\n\n^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$      \n\n\n电话号码("xxx-xxxxxxx"、"xxxx-xxxxxxxx"、"xxx-xxxxxxx"、"xxx-xxxxxxxx"、"xxxxxxx"和"xxxxxxxx)：\n\n^(\\(\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$\n\n\n国内电话号码(0511-4405222、021-87888822)：\n\n\\d{3}-\\d{8}|\\d{4}-\\d{7}\n\n\n身份证号(15位、18位数字)：\n\n^\\d{15}|\\d{18}$\n\n\n短身份证号码(数字、字母x结尾)：\n\n^([0-9]){7,18}(x|x)?$ \n^\\d{8,18}|[0-9x]{8,18}|[0-9x]{8,18}?$\n\n\n帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：\n\n^[a-za-z][a-za-z0-9_]{4,15}$\n\n\n密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：\n\n^[a-za-z]\\w{5,17}$\n\n\n强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：\n\n^(?=.*\\d)(?=.*[a-z])(?=.*[a-z]).{8,10}$*\n\n\n日期格式：\n\n^\\d{4}-\\d{1,2}-\\d{1,2}\n\n\n一年的12个月(01～09和1～12)：\n\n^(0?[1-9]|1[0-2])$\n\n\n一个月的31天(01～09和1～31)：\n\n^((0?[1-9])|((1|2)[0-9])|30|31)$\n\n\n钱的输入格式：\n\n1.有四种钱的表示形式我们可以接受:"10000.00"和 "10,000.00", 和没有 "分" 的"10000" 和 "10,000"：\n\n^[1-9][0-9]*$*\n\n\n2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符"0"不通过,所以我们采用下面的形式：\n\n^(0|[1-9][0-9]*)$*\n\n\n3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：\n\n^(0|-?[1-9][0-9]*)$*\n\n\n4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：\n\n^[0-9]+(.[0-9]+)?$\n\n\n5.必须说明的是,小数点后面至少应该有1位数,所以"10."是不通过的,但是"10" 和 "10.2" 是通过的：\n\n^[0-9]+(.[0-9]{2})?$ \n\n\n6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：\n\n^[0-9]+(.[0-9]{1,2})?$\n\n\n7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：\n\n^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$\n\n\n8.到3个数字,后面跟着任意个逗号+3个数字,逗号成为可选,而不是必须：\n\n^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$\n\n\n备注：这就是最终结果了,别忘了"+"可以用"*"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里\n\nxml文件：\n\n^([a-za-z]+-?)+[a-za-z0-9]+\\\\.[x|x][m|m][l|l]$\n\n\n中文字符的正则表达式：\n\n[\\u4e00-\\u9fa5]\n\n\n双字节字符： (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ascii字符计1))\n\n[^\\x00-\\xff]\n\n\n空白行的正则表达式：(可以用来删除空白行)\n\n\\n\\s*\\r\n\n\nhtml标记的正则表达式： (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)\n\n<(\\s*?)[^>]*>.*?</\\1>|<.*?/>\n\n\n首尾空白字符的正则表达式：(可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)\n\n^\\s*|\\s*$\n(^\\s*)|(\\s*$)       \n\n\n腾讯qq号：(腾讯qq号从10000开始)\n\n[1-9][0-9]{4,}  \n\n\n中国邮政编码：(中国邮政编码为6位数字)\n\n[1-9]\\d{5}(?!\\d)\n\n\nip地址： (提取ip地址时有用)\n\n\\d+\\.\\d+\\.\\d+\\.\\d+ \n\n\nip地址：\n\n((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d))    \n\n\n\n# 新增\n\n限制7位数的金额：\n\n/(^[1-9]([0-9]{0,6})?(\\.[0-9]{0,2})?$)|(^(0){1}$)|(^[0-9]\\.[0-9]([0-9])?$)/\n',charsets:{cjk:!0}},{title:"介绍",frontmatter:{},regularPath:"/three.js/",relativePath:"three.js/README.md",key:"v-344dc095",path:"/three.js/",headersStr:null,content:"algorithm+README",normalizedContent:"algorithm+readme",charsets:{}},{title:"001-生成英文字体",frontmatter:{},regularPath:"/three.js/SimpleFont.html",relativePath:"three.js/SimpleFont.md",key:"v-36c7ff96",path:"/three.js/SimpleFont.html",headers:[{level:2,title:"001-生成英文字体",slug:"_001-生成英文字体",normalizedTitle:"001-生成英文字体",charIndex:2},{level:3,title:"绘制的字母",slug:"绘制的字母",normalizedTitle:"绘制的字母",charIndex:17},{level:3,title:"FontLoader-加载器",slug:"fontloader-加载器",normalizedTitle:"fontloader-加载器",charIndex:1377},{level:3,title:"文本缓冲几何体（TextGeometry）",slug:"文本缓冲几何体-textgeometry",normalizedTitle:"文本缓冲几何体（textgeometry）",charIndex:2518},{level:2,title:"002-生成斜角英文字体",slug:"_002-生成斜角英文字体",normalizedTitle:"002-生成斜角英文字体",charIndex:4437},{level:3,title:"绘制斜角字母",slug:"绘制斜角字母",normalizedTitle:"绘制斜角字母",charIndex:4454},{level:2,title:"003-生成中文字体",slug:"_003-生成中文字体",normalizedTitle:"003-生成中文字体",charIndex:5155},{level:3,title:"加载中文字体并绘制斜角汉字",slug:"加载中文字体并绘制斜角汉字",normalizedTitle:"加载中文字体并绘制斜角汉字",charIndex:5170},{level:2,title:"004-多种颜色的字体",slug:"_004-多种颜色的字体",normalizedTitle:"004-多种颜色的字体",charIndex:6415},{level:2,title:"005-",slug:"_005",normalizedTitle:"005-",charIndex:7403},{level:2,title:"006-",slug:"_006",normalizedTitle:"006-",charIndex:7415},{level:2,title:"007-",slug:"_007",normalizedTitle:"007-",charIndex:7424},{level:2,title:"008-",slug:"_008",normalizedTitle:"008-",charIndex:7433},{level:2,title:"009-",slug:"_009",normalizedTitle:"009-",charIndex:7442},{level:2,title:"010-",slug:"_010",normalizedTitle:"010-",charIndex:7451}],headersStr:"001-生成英文字体 绘制的字母 FontLoader-加载器 文本缓冲几何体（TextGeometry） 002-生成斜角英文字体 绘制斜角字母 003-生成中文字体 加载中文字体并绘制斜角汉字 004-多种颜色的字体 005- 006- 007- 008- 009- 010-",content:"# 001-生成英文字体\n\n\n# 绘制的字母\n\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer({antialias: true});\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\n$(\"#myContainer\").append(myRenderer.domElement);\nvar myScene = new THREE.Scene();\nmyScene.background = new THREE.Color('white');\nvar myCamera = new THREE.PerspectiveCamera(\n  45,\n  window.innerWidth / window.innerHeight, \n  0.1, \n  1000\n);\nmyCamera.position.set(0, 40, 700);\nmyScene.add(myCamera);\n//加载字库并绘制字母\nvar myFontLoader = new THREE.FontLoader();\nmyFontLoader.load('Data/optimer_bold.typeface.json', function (font) {\n  var myGeometry = new THREE.TextGeometry('three.js',{\n    font: font, \n    size: 160\n  });\n  //计算当前几何体的范围\n  myGeometry.computeBoundingBox();\n  //计算字母(几何体)当前中心的偏移量\n  var myOffsetX = (myGeometry.boundingBox.max.x - myGeometry.boundingBox.min.x) / 2;\n  var myOffsetY = (myGeometry.boundingBox.max.y - myGeometry.boundingBox.min.y) / 2;\n  var myMaterial = new THREE.MeshBasicMaterial({color: 0x0000ff});\n  var myTextMesh = new THREE.Mesh(myGeometry, myMaterial);\n  myTextMesh.position.x = myGeometry.boundingBox.min.x - myOffsetX;\n  myTextMesh.position.y = myGeometry.boundingBox.min.y + myOffsetY;\n  myScene.add(myTextMesh);\n});\n//渲染绘制的字母\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myCamera.lookAt(new THREE.Vector3(0, 150, 0));\n  myRenderer.render(myScene, myCamera);\n}\n\n\n\n\n\n# FontLoader-加载器\n\n一个用于加载JSON格式的字体的类。。返回font, 返回值是表示字体的Shape类型的数组。 其内部使用FileLoader来加载文件。\n\n你可以使用facetype.js来在线转换字体。\n\n# 代码示例\n\nconst loader = new FontLoader(); \nconst font = loader.load( \n  // 资源URL \n  'fonts/helvetiker_bold.typeface.json', \t\n  // onLoad回调 \n  function ( font ) { \t\n    // do something with the font \t\n    console.log( font ); \n  }, \t\n  // onProgress回调 \n  function ( xhr ) { \t\n    console.log( (xhr.loaded / xhr.total * 100) + '% loaded' ); \n  }, \t\n  // onError回调 \n  function ( err ) { \t\n    console.log( 'An error happened' ); \n  } \n);\n\n\n# 构造函数\n\n * FontLoader( manager : LoadingManager )\n   * manager — 加载器所使用的loadingManager。默认值为THREE.DefaultLoadingManager.\n   * 创建一个新的FontLoader.\n\n# 方法\n\n * .load ( url : String, onLoad : Function, onProgress : Function, onError : Function ) : undefined\n   * url — 文件的URL或者路径，也可以为 Data URI。\n   * onLoad — 将在加载完成时调用。参数是将要被加载的font。\n   * onProgress — 将在加载过程中调用。参数是包含total和loaded字节的XMLHttpRequest实例。如果server没有设置header的Content-Length，则total值为0。\n   * onError — 将在加载错误时调用。\n   * 开始加载url，并将加载的font传递给onLoad。\n * .parse ( json : Object ) : Font\n   * json — 用于解析的JSON格式的对象。\n   * 解析一个JSON格式的对象，并返回一个font。\n\n\n# 文本缓冲几何体（TextGeometry）\n\n一个用于将文本生成为单一的几何体的类。 它是由一串给定的文本，以及由加载的font（字体）和该几何体ExtrudeGeometry父类中的设置所组成的参数来构造的。\n\n# 代码示例\n\nconst loader = new FontLoader(); \nloader.load( 'fonts/helvetiker_regular.typeface.json', function ( font ) { \t\n  const geometry = new TextGeometry( 'Hello three.js!', { \t\n    font: font, \t\n    size: 80, \t\n    height: 5, \t\n    curveSegments: 12, \n    bevelEnabled: true, \n    bevelThickness: 10, \n    bevelSize: 8, \t\n    bevelSegments: 5 \n  } ); \n} );\n\n\n# 构造器\n\nTextGeometry(text : String, parameters : Object)\n\n * text — 将要显示的文本。\n * parameters — 包含有下列参数的对象：\n   * font — THREE.Font的实例。\n   * size — Float。字体大小，默认值为100。\n   * height — Float。挤出文本的厚度。默认值为50。\n   * curveSegments — Integer。（表示文本的）曲线上点的数量。默认值为12。\n   * bevelEnabled — Boolean。是否开启斜角，默认为false。\n   * bevelThickness — Float。文本上斜角的深度，默认值为20。\n   * bevelSize — Float。斜角与原始文本轮廓之间的延伸距离。默认值为8。\n   * bevelSegments — Integer。斜角的分段数。默认值为3。\n\n# 可用的字体\n\n文本几何体使用 typeface.json所生成的字体。 一些已有的字体可以在**/examples/fonts**中找到，且必须在页面中引入。\n\n字体            字重       风格       文件路径\nhelvetiker    normal   normal   /examples/fonts/helvetiker_regular.typeface.json\nhelvetiker    bold     normal   /examples/fonts/helvetiker_bold.typeface.json\noptimer       normal   normal   /examples/fonts/optimer_regular.typeface.json\noptimer       bold     normal   /examples/fonts/optimer_bold.typeface.json\ngentilis      normal   normal   /examples/fonts/gentilis_regular.typeface.json\ngentilis      bold     normal   /examples/fonts/gentilis_bold.typeface.json\ndroid sans    normal   normal   /examples/fonts/droid/droid_sans_regular.typeface.json\ndroid sans    bold     normal   /examples/fonts/droid/droid_sans_bold.typeface.json\ndroid serif   normal   normal   /examples/fonts/droid/droid_serif_regular.typeface.json\ndroid serif   bold     normal   /examples/fonts/droid/droid_serif_bold.typeface.json\n\n# 属性\n\n * .parameters : Object\n   * 一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。\n\n\n# 002-生成斜角英文字体\n\n\n# 绘制斜角字母\n\n//加载字体并绘制斜角字母\nvar myFontLoader = new THREE.FontLoader();\nmyFontLoader.load('Data/helvetiker_regular.typeface.js', function (font) {\n  var myTextGeometry = new THREE.TextGeometry('THREE', {\n    font: font, \n    size: 1, \n    height: 1, \n    curveSegments: 120,\n    bevelEnabled: true, \n    bevelThickness: 1.5,\n    bevelSize: 0.05, \n    bevelSegments: 3\n  });\n  //创建金属发亮材质\n  var myMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00 });\n  var myTextMesh = new THREE.Mesh(myTextGeometry, myMaterial);\n  myTextMesh.position.y = 0.5;\n  myScene.add(myTextMesh);\n});\n//渲染绘制的斜角字母\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myRenderer.render(myScene, myCamera);\n}\n\n\n\n\n\n# 003-生成中文字体\n\n\n# 加载中文字体并绘制斜角汉字\n\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer({antialias: true});\nmyRenderer.setSize(window.innerWidth,window.innerHeight);\n$(\"#myContainer\").append(myRenderer.domElement);\nvar myScene = new THREE.Scene();\nmyScene.background = new THREE.Color('white');\nvar myCamera = new THREE.OrthographicCamera(-2.5,2.5,1.875,-1.875,1,100);\nmyCamera.position.set(3, 3, 20);\nmyCamera.lookAt(new THREE.Vector3(2, 1, 0));\nmyScene.add(myCamera);\n//创建方向光\nvar myLight = new THREE.DirectionalLight('white');\nmyLight.position.set(-5, 10, 5);\nmyScene.add(myLight);\n//加载中文字体并绘制斜角汉字\nvar myFontLoader = new THREE.FontLoader();\nmyFontLoader.load('Data/MicrosoftYaHei_Regular.json', function(font) {\n  var myTextGeometry=new THREE.TextGeometry('代码集锦', {\n    font: font, \n    size: 0.8, \n    height: 1, \n    curveSegments: 120,\n    bevelEnabled: true,\n    bevelThickness:1.5,\n    bevelSize: 0.05, \n    bevelSegments: 3 \n  });\n  //创建金属发亮材质\n  var myMaterial =new THREE.MeshPhongMaterial({color: 0x00ff00 });\n  var myTextMesh = new THREE.Mesh(myTextGeometry, myMaterial);\n  myTextMesh.position.y=0.5;\n  myScene.add(myTextMesh);\n});\n//渲染绘制的斜角汉字\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myRenderer.render(myScene, myCamera);\n}\n\n\n\n\n\n# 004-多种颜色的字体\n\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer({ antialias: true });\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\nmyRenderer.setClearColor(\"white\");\n$(\"#myContainer\").append(myRenderer.domElement);\nvar myScene = new THREE.Scene();\nvar myCamera = new THREE.PerspectiveCamera(\n  45,\n  window.innerWidth / window.innerHeight,\n  1, \n  10000\n);\nmyCamera.position.set(-24.39, 85.19, 384.14);\nmyScene.add(myCamera);\n//创建字母\nvar myFontLoader = new THREE.FontLoader();\nmyFontLoader.load(\"Data/gentilis_regular.typeface.json\", function (myfont) {\n  var myGeometry = new THREE.TextBufferGeometry(\"luobin\", { \n    font: myfont, \n    size: 100, \n    height: 60 \n  });\n  myGeometry.center();\n  var myMaterial = new THREE.MeshNormalMaterial();\n  var myMesh = new THREE.Mesh(myGeometry, myMaterial);\n  myMesh.position.y = 100;\n  myScene.add(myMesh);\n});\n//渲染字母\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myRenderer.render(myScene, myCamera);\n}\n\n\n\n\n\n# 005-\n\n\n\n\n\n# 006-\n\n\n# 007-\n\n\n# 008-\n\n\n# 009-\n\n\n# 010-",normalizedContent:"# 001-生成英文字体\n\n\n# 绘制的字母\n\n//创建渲染器\nvar myrenderer = new three.webglrenderer({antialias: true});\nmyrenderer.setsize(window.innerwidth, window.innerheight);\n$(\"#mycontainer\").append(myrenderer.domelement);\nvar myscene = new three.scene();\nmyscene.background = new three.color('white');\nvar mycamera = new three.perspectivecamera(\n  45,\n  window.innerwidth / window.innerheight, \n  0.1, \n  1000\n);\nmycamera.position.set(0, 40, 700);\nmyscene.add(mycamera);\n//加载字库并绘制字母\nvar myfontloader = new three.fontloader();\nmyfontloader.load('data/optimer_bold.typeface.json', function (font) {\n  var mygeometry = new three.textgeometry('three.js',{\n    font: font, \n    size: 160\n  });\n  //计算当前几何体的范围\n  mygeometry.computeboundingbox();\n  //计算字母(几何体)当前中心的偏移量\n  var myoffsetx = (mygeometry.boundingbox.max.x - mygeometry.boundingbox.min.x) / 2;\n  var myoffsety = (mygeometry.boundingbox.max.y - mygeometry.boundingbox.min.y) / 2;\n  var mymaterial = new three.meshbasicmaterial({color: 0x0000ff});\n  var mytextmesh = new three.mesh(mygeometry, mymaterial);\n  mytextmesh.position.x = mygeometry.boundingbox.min.x - myoffsetx;\n  mytextmesh.position.y = mygeometry.boundingbox.min.y + myoffsety;\n  myscene.add(mytextmesh);\n});\n//渲染绘制的字母\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  mycamera.lookat(new three.vector3(0, 150, 0));\n  myrenderer.render(myscene, mycamera);\n}\n\n\n\n\n\n# fontloader-加载器\n\n一个用于加载json格式的字体的类。。返回font, 返回值是表示字体的shape类型的数组。 其内部使用fileloader来加载文件。\n\n你可以使用facetype.js来在线转换字体。\n\n# 代码示例\n\nconst loader = new fontloader(); \nconst font = loader.load( \n  // 资源url \n  'fonts/helvetiker_bold.typeface.json', \t\n  // onload回调 \n  function ( font ) { \t\n    // do something with the font \t\n    console.log( font ); \n  }, \t\n  // onprogress回调 \n  function ( xhr ) { \t\n    console.log( (xhr.loaded / xhr.total * 100) + '% loaded' ); \n  }, \t\n  // onerror回调 \n  function ( err ) { \t\n    console.log( 'an error happened' ); \n  } \n);\n\n\n# 构造函数\n\n * fontloader( manager : loadingmanager )\n   * manager — 加载器所使用的loadingmanager。默认值为three.defaultloadingmanager.\n   * 创建一个新的fontloader.\n\n# 方法\n\n * .load ( url : string, onload : function, onprogress : function, onerror : function ) : undefined\n   * url — 文件的url或者路径，也可以为 data uri。\n   * onload — 将在加载完成时调用。参数是将要被加载的font。\n   * onprogress — 将在加载过程中调用。参数是包含total和loaded字节的xmlhttprequest实例。如果server没有设置header的content-length，则total值为0。\n   * onerror — 将在加载错误时调用。\n   * 开始加载url，并将加载的font传递给onload。\n * .parse ( json : object ) : font\n   * json — 用于解析的json格式的对象。\n   * 解析一个json格式的对象，并返回一个font。\n\n\n# 文本缓冲几何体（textgeometry）\n\n一个用于将文本生成为单一的几何体的类。 它是由一串给定的文本，以及由加载的font（字体）和该几何体extrudegeometry父类中的设置所组成的参数来构造的。\n\n# 代码示例\n\nconst loader = new fontloader(); \nloader.load( 'fonts/helvetiker_regular.typeface.json', function ( font ) { \t\n  const geometry = new textgeometry( 'hello three.js!', { \t\n    font: font, \t\n    size: 80, \t\n    height: 5, \t\n    curvesegments: 12, \n    bevelenabled: true, \n    bevelthickness: 10, \n    bevelsize: 8, \t\n    bevelsegments: 5 \n  } ); \n} );\n\n\n# 构造器\n\ntextgeometry(text : string, parameters : object)\n\n * text — 将要显示的文本。\n * parameters — 包含有下列参数的对象：\n   * font — three.font的实例。\n   * size — float。字体大小，默认值为100。\n   * height — float。挤出文本的厚度。默认值为50。\n   * curvesegments — integer。（表示文本的）曲线上点的数量。默认值为12。\n   * bevelenabled — boolean。是否开启斜角，默认为false。\n   * bevelthickness — float。文本上斜角的深度，默认值为20。\n   * bevelsize — float。斜角与原始文本轮廓之间的延伸距离。默认值为8。\n   * bevelsegments — integer。斜角的分段数。默认值为3。\n\n# 可用的字体\n\n文本几何体使用 typeface.json所生成的字体。 一些已有的字体可以在**/examples/fonts**中找到，且必须在页面中引入。\n\n字体            字重       风格       文件路径\nhelvetiker    normal   normal   /examples/fonts/helvetiker_regular.typeface.json\nhelvetiker    bold     normal   /examples/fonts/helvetiker_bold.typeface.json\noptimer       normal   normal   /examples/fonts/optimer_regular.typeface.json\noptimer       bold     normal   /examples/fonts/optimer_bold.typeface.json\ngentilis      normal   normal   /examples/fonts/gentilis_regular.typeface.json\ngentilis      bold     normal   /examples/fonts/gentilis_bold.typeface.json\ndroid sans    normal   normal   /examples/fonts/droid/droid_sans_regular.typeface.json\ndroid sans    bold     normal   /examples/fonts/droid/droid_sans_bold.typeface.json\ndroid serif   normal   normal   /examples/fonts/droid/droid_serif_regular.typeface.json\ndroid serif   bold     normal   /examples/fonts/droid/droid_serif_bold.typeface.json\n\n# 属性\n\n * .parameters : object\n   * 一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。\n\n\n# 002-生成斜角英文字体\n\n\n# 绘制斜角字母\n\n//加载字体并绘制斜角字母\nvar myfontloader = new three.fontloader();\nmyfontloader.load('data/helvetiker_regular.typeface.js', function (font) {\n  var mytextgeometry = new three.textgeometry('three', {\n    font: font, \n    size: 1, \n    height: 1, \n    curvesegments: 120,\n    bevelenabled: true, \n    bevelthickness: 1.5,\n    bevelsize: 0.05, \n    bevelsegments: 3\n  });\n  //创建金属发亮材质\n  var mymaterial = new three.meshphongmaterial({ color: 0x00ff00 });\n  var mytextmesh = new three.mesh(mytextgeometry, mymaterial);\n  mytextmesh.position.y = 0.5;\n  myscene.add(mytextmesh);\n});\n//渲染绘制的斜角字母\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  myrenderer.render(myscene, mycamera);\n}\n\n\n\n\n\n# 003-生成中文字体\n\n\n# 加载中文字体并绘制斜角汉字\n\n//创建渲染器\nvar myrenderer = new three.webglrenderer({antialias: true});\nmyrenderer.setsize(window.innerwidth,window.innerheight);\n$(\"#mycontainer\").append(myrenderer.domelement);\nvar myscene = new three.scene();\nmyscene.background = new three.color('white');\nvar mycamera = new three.orthographiccamera(-2.5,2.5,1.875,-1.875,1,100);\nmycamera.position.set(3, 3, 20);\nmycamera.lookat(new three.vector3(2, 1, 0));\nmyscene.add(mycamera);\n//创建方向光\nvar mylight = new three.directionallight('white');\nmylight.position.set(-5, 10, 5);\nmyscene.add(mylight);\n//加载中文字体并绘制斜角汉字\nvar myfontloader = new three.fontloader();\nmyfontloader.load('data/microsoftyahei_regular.json', function(font) {\n  var mytextgeometry=new three.textgeometry('代码集锦', {\n    font: font, \n    size: 0.8, \n    height: 1, \n    curvesegments: 120,\n    bevelenabled: true,\n    bevelthickness:1.5,\n    bevelsize: 0.05, \n    bevelsegments: 3 \n  });\n  //创建金属发亮材质\n  var mymaterial =new three.meshphongmaterial({color: 0x00ff00 });\n  var mytextmesh = new three.mesh(mytextgeometry, mymaterial);\n  mytextmesh.position.y=0.5;\n  myscene.add(mytextmesh);\n});\n//渲染绘制的斜角汉字\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  myrenderer.render(myscene, mycamera);\n}\n\n\n\n\n\n# 004-多种颜色的字体\n\n//创建渲染器\nvar myrenderer = new three.webglrenderer({ antialias: true });\nmyrenderer.setsize(window.innerwidth, window.innerheight);\nmyrenderer.setclearcolor(\"white\");\n$(\"#mycontainer\").append(myrenderer.domelement);\nvar myscene = new three.scene();\nvar mycamera = new three.perspectivecamera(\n  45,\n  window.innerwidth / window.innerheight,\n  1, \n  10000\n);\nmycamera.position.set(-24.39, 85.19, 384.14);\nmyscene.add(mycamera);\n//创建字母\nvar myfontloader = new three.fontloader();\nmyfontloader.load(\"data/gentilis_regular.typeface.json\", function (myfont) {\n  var mygeometry = new three.textbuffergeometry(\"luobin\", { \n    font: myfont, \n    size: 100, \n    height: 60 \n  });\n  mygeometry.center();\n  var mymaterial = new three.meshnormalmaterial();\n  var mymesh = new three.mesh(mygeometry, mymaterial);\n  mymesh.position.y = 100;\n  myscene.add(mymesh);\n});\n//渲染字母\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  myrenderer.render(myscene, mycamera);\n}\n\n\n\n\n\n# 005-\n\n\n\n\n\n# 006-\n\n\n# 007-\n\n\n# 008-\n\n\n# 009-\n\n\n# 010-",charsets:{cjk:!0}},{title:"001-轨道轨道控制器（OrbitControls）",frontmatter:{},regularPath:"/three.js/SimpleInteraction.html",relativePath:"three.js/SimpleInteraction.md",key:"v-f8b85b64",path:"/three.js/SimpleInteraction.html",headers:[{level:2,title:"001-轨道轨道控制器（OrbitControls）",slug:"_001-轨道轨道控制器-orbitcontrols",normalizedTitle:"001-轨道轨道控制器（orbitcontrols）",charIndex:2},{level:2,title:"002-启用SVG/WebGL渲染器",slug:"_002-启用svg-webgl渲染器",normalizedTitle:"002-启用svg/webgl渲染器",charIndex:1003},{level:3,title:"启用SVG渲染器",slug:"启用svg渲染器",normalizedTitle:"启用svg渲染器",charIndex:1026},{level:3,title:"SVG渲染器（SVGRenderer）",slug:"svg渲染器-svgrenderer",normalizedTitle:"svg渲染器（svgrenderer）",charIndex:1368},{level:3,title:"启用WebGL渲染器",slug:"启用webgl渲染器",normalizedTitle:"启用webgl渲染器",charIndex:1688},{level:3,title:"生成图形",slug:"生成图形",normalizedTitle:"生成图形",charIndex:2053},{level:3,title:"线（Line）",slug:"线-line",normalizedTitle:"线（line）",charIndex:3088},{level:3,title:"基础线条材质（LineBasicMaterial）",slug:"基础线条材质-linebasicmaterial",normalizedTitle:"基础线条材质（linebasicmaterial）",charIndex:3701},{level:3,title:"BufferGeometry",slug:"buffergeometry",normalizedTitle:"buffergeometry",charIndex:2259},{level:3,title:"效果",slug:"效果",normalizedTitle:"效果",charIndex:9254},{level:2,title:"003-多个立方体，鼠标悬浮变更颜色",slug:"_003-多个立方体-鼠标悬浮变更颜色",normalizedTitle:"003-多个立方体，鼠标悬浮变更颜色",charIndex:10397},{level:2,title:"004-",slug:"_004",normalizedTitle:"004-",charIndex:12199},{level:2,title:"005-",slug:"_005",normalizedTitle:"005-",charIndex:12208},{level:2,title:"006-",slug:"_006",normalizedTitle:"006-",charIndex:12217},{level:2,title:"007-",slug:"_007",normalizedTitle:"007-",charIndex:12226},{level:2,title:"008-",slug:"_008",normalizedTitle:"008-",charIndex:12235},{level:2,title:"009-",slug:"_009",normalizedTitle:"009-",charIndex:12244},{level:2,title:"010-",slug:"_010",normalizedTitle:"010-",charIndex:12253}],headersStr:"001-轨道轨道控制器（OrbitControls） 002-启用SVG/WebGL渲染器 启用SVG渲染器 SVG渲染器（SVGRenderer） 启用WebGL渲染器 生成图形 线（Line） 基础线条材质（LineBasicMaterial） BufferGeometry 效果 003-多个立方体，鼠标悬浮变更颜色 004- 005- 006- 007- 008- 009- 010-",content:"# 001-轨道轨道控制器（OrbitControls）\n\nOrbit controls（轨道控制器）可以使得相机围绕目标进行轨道运动。\n\n要使用这一功能，就像在/examples（示例）目录中的所有文件一样， 您必须在HTML中包含这个文件。\n\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer({ antialias: true });\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\nmyRenderer.setClearColor('white', 1.0);\n$(\"#myContainer\").append(myRenderer.domElement);\nvar myScene = new THREE.Scene();\nvar myCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);\nmyCamera.position.set(40.06, 20.92, 42.68);\nmyCamera.lookAt(new THREE.Vector3(0, 0, 0));\t\t \t       \n//创建轨道控制器\nvar myOrbitControls = new THREE.OrbitControls(myCamera, myRenderer.domElement);\t\t\n//监听鼠标、键盘事件\nmyOrbitControls.addEventListener('change', animate); \n//创建立方体\nvar myGeometry = new THREE.BoxGeometry(16, 16, 16);\nvar myMaterial = new THREE.MeshNormalMaterial();\nvar myMesh = new THREE.Mesh(myGeometry, myMaterial);\nmyScene.add(myMesh);\n//渲染立方体\nanimate();\nfunction animate() {\n  myRenderer.render(myScene, myCamera);\n}\n\n\n\n# 002-启用SVG/WebGL渲染器\n\n\n# 启用SVG渲染器\n\n//创建渲染器myRenderer1\nvar myRenderer1 = new THREE.SVGRenderer();\nmyRenderer1.setSize(window.innerWidth, window.innerHeight);\nvar myCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);\nmyCamera.position.z = 4;\nvar myScene = new THREE.Scene();\nmyScene.background = new THREE.Color(0xffffff);\n\n\n\n# SVG渲染器（SVGRenderer）\n\nSVGRenderer被用于使用SVG来渲染几何数据，所产生的矢量图形在以下几个方面十分有用：\n\n * 动画标志（logo）或者图标（icon）\n * 可交互的2D或3D图表或图形\n * 交互式地图\n * 复杂的或包含动画的用户界面\n\nSVGRenderer具有很多优势。它产生清晰并且锐利的图像输出，它和实际视口分辨率无关。\n\nSVG元素可以通过CSS来控制样式；并且由于它可以添加诸如标题或者描述文字之类的元数据（对于搜索引擎或者屏幕阅读器十分有用），因此它具有十分良好的可访问性。\n\n然而，SVG也有一些十分重要的限制：\n\n * 没有高级的着色器\n * 不支持纹理\n * 不支持阴影\n\n\n# 启用WebGL渲染器\n\n//创建渲染器myRenderer1\nvar myRenderer1 = new THREE.WebGLRenderer({ antialias: true });\nmyRenderer1.setSize(window.innerWidth, window.innerHeight);\nvar myCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);\nmyCamera.position.z = 4;\nvar myScene = new THREE.Scene();\nmyScene.background = new THREE.Color(0xffffff);\n\n\n\n# 生成图形\n\n//创建图形\nvar myVertices = ];\nfor (var i = 0; i <= 150; i++) {\n  var v = (i / 150) * (Math.PI * 2);\n  var x = Math.sin(v);\n  var z = Math.cos(v);\n  myVertices.push(x, 0, z);\n}\nvar myGeometry = new THREE.BufferGeometry();\nmyGeometry.setAttribute('position', new THREE.Float32BufferAttribute(myVertices, 3));\nfor (var i = 1; i <= 3; i++) {\n  // 基础线的材质\n  var myMaterial = new THREE.LineBasicMaterial({\n    color: Math.random() * 0xffffff,\n    linewidth: 20\n  });\n  // 生成线\n  var myLine = new THREE.Line(myGeometry, myMaterial);\n  myLine.scale.setScalar(i / 3);\n  myScene.add(myLine);\n}\n//渲染图形\nanimate();\nfunction animate() {\n  var myOffset = 0;\n  var myTime = performance.now() / 1000;\n  myScene.traverse(function (child) {\n    child.rotation.x = myOffset + (myTime / 3);\n    child.rotation.z = myOffset + (myTime / 4);\n    myOffset++;\n  });\n  var myRenderer = myRenderer1;\n  $(\"#myContainer\").html('');\n  $(\"#myContainer\").append(myRenderer.domElement);\n  myRenderer.render(myScene, myCamera);\n  requestAnimationFrame(animate);\n}\n\n\n\n# 线（Line）\n\n一条连续的线。\n\n它几乎和LineSegments是一样的，唯一的区别是它在渲染时使用的是gl.LINE_STRIP， 而不是gl.LINES。\n\n# 代码示例\n\nconst material = new THREE.LineBasicMaterial({ color: 0x0000ff }); \nconst points = ]; \npoints.push(new THREE.Vector3(- 10, 0, 0)); \npoints.push(new THREE.Vector3(0, 10, 0)); \npoints.push(new THREE.Vector3(10, 0, 0)); \nconst geometry = new THREE.BufferGeometry().setFromPoints(points); \nconst line = new THREE.Line(geometry, material); \nscene.add(line);\n\n\n# 构造器\n\nLine( geometry : BufferGeometry, material : Material)\n\n * geometry —— 表示线段的顶点，默认值是一个新的BufferGeometry。\n * material —— 线的材质，默认值是一个新的具有随机颜色的LineBasicMaterial。\n\n\n# 基础线条材质（LineBasicMaterial）\n\n一种用于绘制线框样式几何体的材质。\n\n# 代码示例\n\nconst material = new THREE.LineBasicMaterial({\n  color: 0xffffff,\n  linewidth: 1,\n  linecap: 'round',//ignored by WebGLRenderer \n  linejoin: 'round' //ignored by WebGLRenderer \n});\n\n\n# 构造函数(Constructor)\n\nLineBasicMaterial( parameters : Object )\n\nparameters - (可选)用于定义材质外观的对象，具有一个或多个属性。材质的任何属性都可以从此处传入(包括从Material继承的任何属性)。\n\n属性color例外，其可以作为十六进制字符串传递，默认情况下为 0xffffff（白色），内部调用Color.set(color)。\n\n# 属性(Properties)\n\n * color : Color\n   \n   * 材质的颜色(Color)，默认值为白色 (0xffffff)。\n\n * fog: Boolean\n   \n   * 材质是否受雾影响。默认为true。\n\n * linewidth : Float\n   \n   * 控制线宽。默认值为 1。\n   \n   * 由于OpenGL Core Profile与 大多数平台上WebGL渲染器的限制，无论如何设置该值，线宽始终为1。\n\n * linecap : String\n   \n   * 定义线两端的样式。可选值为 'butt', 'round' 和 'square'。默认值为 'round'。\n   \n   * 该属性对应2D Canvas lineCap属性， 并且会被WebGL渲染器忽略。\n\n * linejoin : String\n   \n   * 定义线连接节点的样式。可选值为 'round', 'bevel' 和 'miter'。默认值为 'round'。\n   \n   * 该属性对应2D Canvas lineJoin属性， 并且会被WebGL渲染器忽略。\n\n\n# BufferGeometry\n\n是面片、线或点几何体的有效表述。包括顶点位置，面片索引、法相量、颜色值、UV 坐标和自定义缓存属性值。使用 BufferGeometry 可以有效减少向 GPU 传输上述数据所需的开销。\n\n# 代码示例\n\n// 创建一个简单的矩形. 在这里我们左上和右下顶点被复制了两次。 \nconst geometry = new THREE.BufferGeometry();\n// 因为在两个三角面片里，这两个顶点都需要被用到。 \nvar myVertices = [-1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0];\nconst vertices = new Float32Array(myVertices);\n// itemSize = 3 因为每个顶点都是一个三元组。 \ngeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));\nconst material = new THREE.MeshBasicMaterial({ color: 0xff0000 });\nconst mesh = new THREE.Mesh(geometry, material);\n\n\n# 构造函数\n\nBufferGeometry()\n\n创建一个新的 BufferGeometry. 同时将预置属性设置为默认值.\n\n# 属性\n\n * .attributes : Object\n   \n   * 通过 hashmap 存储该几何体相关的属性，hashmap 的 id 是当前 attribute 的名称，值是相应的 buffer你可以通过 .setAttribute 和 .getAttribute 添加和访问与当前几何体有关的 attribute。\n\n * .boundingBox : Box\n   \n   * 当前 bufferGeometry 的外边界矩形。可以通过 .computeBoundingBox() 计算。默认值是 null。\n\n * .boundingSphere : Spher\n   \n   * 当前 bufferGeometry 的外边界球形。可以通过 .computeBoundingSphere() 计算。默认值是 null。\n\n * .drawRange : Object\n   \n   * 用于判断几何体的哪个部分需要被渲染。该值不应该直接被设置，而需要通过 .setDrawRange 进行设置。 默认值为{ start: 0, count: Infinity }\n\n * .groups : Array\n   \n   * 将当前几何体分割成组进行渲染，每个部分都会在单独的 WebGL 的 draw call 中进行绘制。该方法可以让当前的 bufferGeometry 可以使用一个材质队列进行描述。\n   \n   * 分割后的每个部分都是一个如下的表单：{ start: Integer, count: Integer, materialIndex: Integer }start 表明当前 draw call 中的没有索引的几何体的几何体的第一个顶点；或者第一个三角面片的索引。 count 指明当前分割包含多少顶点（或 indices）。 materialIndex 指出当前用到的材质队列的索引。\n   \n   * 通过 .addGroup 来增加组，而不是直接更改当前队列。\n\n * .id : Integer\n   \n   * 当前 bufferGeometry 的唯一编号。\n\n * .index : BufferAttribut\n   \n   * 允许顶点在多个三角面片间可以重用。这样的顶点被称为\"已索引的三角面片（indexed triangles)。 每个三角面片都和三个顶点的索引相关。该 attribute 因此所存储的是每个三角面片的三个顶点的索引。 如果该 attribute 没有设置过，则 rendere假设每三个连续的位置代表一个三角面片。 默认值是 null。\n\n * .isBufferGeometry : Boolean\n   \n   * Read-only flag to check if a given object is of type BufferGeometry.\n\n * .morphAttributes : Object\n   \n   * 存储 BufferAttribut的 Hashmap，存储了几何体 morph targets 的细节信息。 Note: Once the geometry has been rendered, the morph attribute data cannot be changed. You will have to call .dispose(), and create a new instance of BufferGeometry.\n\n * .morphTargetsRelative : Boolean\n   \n   * Used to control the morph target behavior; when set to true, the morph target data is treated as relative offsets, rather than as absolute positions/normals. Default is false.\n\n * .name : String\n   \n   * 当前 bufferGeometry 实例的可选别名。默认值是空字符串。\n\n * .userData : Object\n   \n   * 存储 BufferGeometry 的自定义数据的对象。为保持对象在克隆时完整，该对象不应该包括任何函数的引用。\n\n * .uuid : String\n   \n   * 当前对象实例的 UUID，该值会自动被分配，且不应被修改。\n\n# 方法\n\nEventDispatche在该类上可用的所有方法。\n\n * .setAttribute ( name : String, attribute : BufferAttribut) : this\n   \n   * 为当前几何体设置一个 attribute 属性。在类的内部，有一个存储 .attributes 的 hashmap， 通过该 hashmap，遍历 attributes 的速度会更快。而使用该方法，可以向 hashmap 内部增加 attribute。 所以，你需要使用该方法来添加 attributes。\n\n * .addGroup ( start : Integer, count : Integer, materialIndex : Integer ) : undefined\n   \n   * 为当前几何体增加一个 group，详见 groups 属性。\n\n * .applyMatrix4 ( matrix : Matrix) : this\n   \n   * 用给定矩阵转换几何体的顶点坐标。\n\n * .center () : this\n   \n   * 根据边界矩形将几何体居中。\n\n * .clone () : BufferGeometr\n   \n   * 克隆当前的 BufferGeometry。\n\n * .copy ( bufferGeometry : BufferGeometr) : this\n   \n   * 将参数指定的 BufferGeometry 的值拷贝到当前 BufferGeometry 中。\n\n * .clearGroups ( ) : undefined\n   \n   * 清空所有的 groups。\n\n * .computeBoundingBox () : undefined\n   \n   * 计算当前几何体的的边界矩形，该操作会更新已有 param:.boundingBox]。 边界矩形不会默认计算，需要调用该接口指定计算边界矩形，否则保持默认值 null。\n\n * .computeBoundingSphere () : undefined\n   \n   * 计算当前几何体的的边界球形，该操作会更新已有 param:.boundingSphere]。 边界球形不会默认计算，需要调用该接口指定计算边界球形，否则保持默认值 null。\n\n * .computeTangents () : undefined\n   \n   * Calculates and adds a tangent attribute to this geometry. The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by BufferGeometryUtils.computeMikkTSpaceTangents instead.\n\n * .computeVertexNormals () : undefined\n   \n   * 通过面片法向量的平均值计算每个顶点的法向量。\n\n * .dispose () : undefined\n   \n   * 从内存中销毁对象。 如果在运行是需要从内存中删除 BufferGeometry，则需要调用该函数。\n\n * .getAttribute ( name : String ) : BufferAttribut\n   \n   * 返回指定名称的 attribute\n\n * .getIndex () : BufferAttribut\n   \n   * 返回缓存相关的 .index。\n\n * .hasAttribute ( name : String ) : Boolean\n   \n   * Returns true if the attribute with the specified name exists.\n\n * .lookAt ( vector : Vector) : this\n\n * vector - 几何体所朝向的世界坐标。\n   \n   * 旋转几何体朝向控件中的一点。该过程通常在一次处理中完成，不会循环处理。典型的用法是过通过调用 Object3D.lookAt 实时改变 mesh 朝向。\n\n * .normalizeNormals () : undefined\n   \n   * 几何体中的每个法向量长度将会为 1。这样操作会更正光线在表面的效果。\n   \n   * .deleteAttribute ( name : String ) : BufferAttribut 删除具有指定名称的 attribute\n\n * .rotateX ( radians : Float ) : this\n   \n   * 在 X 轴上旋转几何体。该操作一般在一次处理中完成，不会循环处理。典型的用法是通过调用 Object3D.rotation 实时旋转几何体。\n\n * .rotateY ( radians : Float ) : this\n   \n   * 在 Y 轴上旋转几何体。该操作一般在一次处理中完成，不会循环处理。典型的用法是通过调用 Object3D.rotation 实时旋转几何体。\n\n * .rotateZ ( radians : Float ) : this\n   \n   * 在 Z 轴上旋转几何体。该操作一般在一次处理中完成，不会循环处理。典型的用法是通过调用 Object3D.rotation 实时旋转几何体。\n\n * .scale ( x : Float, y : Float, z : Float ) : this\n   \n   * 缩放几何体。该操作一般在一次处理中完成，不会循环处理。典型的用法是通过调用 Object3D.scale 实时旋转几何体。\n\n * .setIndex ( index : BufferAttribut) : this\n   \n   * 设置缓存的 .index。\n\n * .setDrawRange ( start : Integer, count : Integer ) : undefined\n   \n   * 设置缓存的 .drawRange。详见相关属性说明。\n\n * .setFromPoints ( points : Array ) : this\n   \n   * 通过点队列设置该 BufferGeometry 的 attribute。\n\n * .toJSON () : Object\n   \n   * 返回代表该 BufferGeometry 的 JSON 对象。\n\n * .toNonIndexed () : BufferGeometr\n   \n   * 返回已索引的 BufferGeometry 的非索引版本。\n\n * .translate ( x : Float, y : Float, z : Float ) : this\n   \n   * 移动几何体。该操作一般在一次处理中完成，不会循环处理。典型的用法是通过调用 Object3D.rotation实时旋转几何体。\n\n\n# 效果\n\n# SVG渲染器\n\n\n\n# WebGL渲染器\n\n\n\n\n# 003-多个立方体，鼠标悬浮变更颜色\n\n\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer({ antialias: true });\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\nmyRenderer.setClearColor('white', 1.0);\n$('#myContainer')[0].appendChild(myRenderer.domElement);\nvar myScene = new THREE.Scene();\nmyScene.add(new THREE.AmbientLight(0xffffff));\nvar myCamera = new THREE.PerspectiveCamera(45,\n                                           window.innerWidth / window.innerHeight, 0.1, 1000);\nmyCamera.position.set(622, 342, 443);\nmyCamera.lookAt(new THREE.Vector3(0, 0, 0));\n//用于保存多个立方体\nvar myArray = [];\n//创建多个立方体\nvar myGeometry = new THREE.BoxGeometry(80, 80, 80);\nfor (var i = 0; i < 10; i++) {\n  var myMaterial = new THREE.MeshBasicMaterial({\n    color: Math.random() * 0xffffff, opacity: 0.5\n  });\n  var myMesh = new THREE.Mesh(myGeometry, myMaterial);\n  myMesh.position.x = Math.random() * 480 - 140;\n  myMesh.position.y = Math.random() * 480 - 140;\n  myMesh.position.z = Math.random() * 480 - 140;\n  myScene.add(myMesh);\n  myArray.push(myMesh);\n}\n//渲染多个立方体\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myRenderer.render(myScene, myCamera);\n}\n//添加鼠标移动事件监听器，检测鼠标的移动\ndocument.addEventListener('mousemove', onDocumentMouseMove);\nfunction onDocumentMouseMove(event) {\n  var myMouse = new THREE.Vector2();\n  myMouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n  myMouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\n  var myRaycaster = new THREE.Raycaster();\n  myRaycaster.setFromCamera(myMouse, myCamera);\n  //获取与射线相交的myArray[]的所有图形\n  var myIntersectObjects = myRaycaster.intersectObjects(myArray);\n  //这里操作第一个相交图形(使用鼠标选择的图形)\n  if (myIntersectObjects.length > 0) {\n    //设置该选择的立方体颜色为红色\n    var myObject = myIntersectObjects[0].object;\n    myObject.material.color.set(0xff0000);\n  }\n}\n\n\n\n# 004-\n\n\n# 005-\n\n\n# 006-\n\n\n# 007-\n\n\n# 008-\n\n\n# 009-\n\n\n# 010-",normalizedContent:"# 001-轨道轨道控制器（orbitcontrols）\n\norbit controls（轨道控制器）可以使得相机围绕目标进行轨道运动。\n\n要使用这一功能，就像在/examples（示例）目录中的所有文件一样， 您必须在html中包含这个文件。\n\n//创建渲染器\nvar myrenderer = new three.webglrenderer({ antialias: true });\nmyrenderer.setsize(window.innerwidth, window.innerheight);\nmyrenderer.setclearcolor('white', 1.0);\n$(\"#mycontainer\").append(myrenderer.domelement);\nvar myscene = new three.scene();\nvar mycamera = new three.perspectivecamera(45, window.innerwidth / window.innerheight, 0.1, 1000);\nmycamera.position.set(40.06, 20.92, 42.68);\nmycamera.lookat(new three.vector3(0, 0, 0));\t\t \t       \n//创建轨道控制器\nvar myorbitcontrols = new three.orbitcontrols(mycamera, myrenderer.domelement);\t\t\n//监听鼠标、键盘事件\nmyorbitcontrols.addeventlistener('change', animate); \n//创建立方体\nvar mygeometry = new three.boxgeometry(16, 16, 16);\nvar mymaterial = new three.meshnormalmaterial();\nvar mymesh = new three.mesh(mygeometry, mymaterial);\nmyscene.add(mymesh);\n//渲染立方体\nanimate();\nfunction animate() {\n  myrenderer.render(myscene, mycamera);\n}\n\n\n\n# 002-启用svg/webgl渲染器\n\n\n# 启用svg渲染器\n\n//创建渲染器myrenderer1\nvar myrenderer1 = new three.svgrenderer();\nmyrenderer1.setsize(window.innerwidth, window.innerheight);\nvar mycamera = new three.perspectivecamera(45, window.innerwidth / window.innerheight, 0.1, 1000);\nmycamera.position.z = 4;\nvar myscene = new three.scene();\nmyscene.background = new three.color(0xffffff);\n\n\n\n# svg渲染器（svgrenderer）\n\nsvgrenderer被用于使用svg来渲染几何数据，所产生的矢量图形在以下几个方面十分有用：\n\n * 动画标志（logo）或者图标（icon）\n * 可交互的2d或3d图表或图形\n * 交互式地图\n * 复杂的或包含动画的用户界面\n\nsvgrenderer具有很多优势。它产生清晰并且锐利的图像输出，它和实际视口分辨率无关。\n\nsvg元素可以通过css来控制样式；并且由于它可以添加诸如标题或者描述文字之类的元数据（对于搜索引擎或者屏幕阅读器十分有用），因此它具有十分良好的可访问性。\n\n然而，svg也有一些十分重要的限制：\n\n * 没有高级的着色器\n * 不支持纹理\n * 不支持阴影\n\n\n# 启用webgl渲染器\n\n//创建渲染器myrenderer1\nvar myrenderer1 = new three.webglrenderer({ antialias: true });\nmyrenderer1.setsize(window.innerwidth, window.innerheight);\nvar mycamera = new three.perspectivecamera(45, window.innerwidth / window.innerheight, 0.1, 1000);\nmycamera.position.z = 4;\nvar myscene = new three.scene();\nmyscene.background = new three.color(0xffffff);\n\n\n\n# 生成图形\n\n//创建图形\nvar myvertices = ];\nfor (var i = 0; i <= 150; i++) {\n  var v = (i / 150) * (math.pi * 2);\n  var x = math.sin(v);\n  var z = math.cos(v);\n  myvertices.push(x, 0, z);\n}\nvar mygeometry = new three.buffergeometry();\nmygeometry.setattribute('position', new three.float32bufferattribute(myvertices, 3));\nfor (var i = 1; i <= 3; i++) {\n  // 基础线的材质\n  var mymaterial = new three.linebasicmaterial({\n    color: math.random() * 0xffffff,\n    linewidth: 20\n  });\n  // 生成线\n  var myline = new three.line(mygeometry, mymaterial);\n  myline.scale.setscalar(i / 3);\n  myscene.add(myline);\n}\n//渲染图形\nanimate();\nfunction animate() {\n  var myoffset = 0;\n  var mytime = performance.now() / 1000;\n  myscene.traverse(function (child) {\n    child.rotation.x = myoffset + (mytime / 3);\n    child.rotation.z = myoffset + (mytime / 4);\n    myoffset++;\n  });\n  var myrenderer = myrenderer1;\n  $(\"#mycontainer\").html('');\n  $(\"#mycontainer\").append(myrenderer.domelement);\n  myrenderer.render(myscene, mycamera);\n  requestanimationframe(animate);\n}\n\n\n\n# 线（line）\n\n一条连续的线。\n\n它几乎和linesegments是一样的，唯一的区别是它在渲染时使用的是gl.line_strip， 而不是gl.lines。\n\n# 代码示例\n\nconst material = new three.linebasicmaterial({ color: 0x0000ff }); \nconst points = ]; \npoints.push(new three.vector3(- 10, 0, 0)); \npoints.push(new three.vector3(0, 10, 0)); \npoints.push(new three.vector3(10, 0, 0)); \nconst geometry = new three.buffergeometry().setfrompoints(points); \nconst line = new three.line(geometry, material); \nscene.add(line);\n\n\n# 构造器\n\nline( geometry : buffergeometry, material : material)\n\n * geometry —— 表示线段的顶点，默认值是一个新的buffergeometry。\n * material —— 线的材质，默认值是一个新的具有随机颜色的linebasicmaterial。\n\n\n# 基础线条材质（linebasicmaterial）\n\n一种用于绘制线框样式几何体的材质。\n\n# 代码示例\n\nconst material = new three.linebasicmaterial({\n  color: 0xffffff,\n  linewidth: 1,\n  linecap: 'round',//ignored by webglrenderer \n  linejoin: 'round' //ignored by webglrenderer \n});\n\n\n# 构造函数(constructor)\n\nlinebasicmaterial( parameters : object )\n\nparameters - (可选)用于定义材质外观的对象，具有一个或多个属性。材质的任何属性都可以从此处传入(包括从material继承的任何属性)。\n\n属性color例外，其可以作为十六进制字符串传递，默认情况下为 0xffffff（白色），内部调用color.set(color)。\n\n# 属性(properties)\n\n * color : color\n   \n   * 材质的颜色(color)，默认值为白色 (0xffffff)。\n\n * fog: boolean\n   \n   * 材质是否受雾影响。默认为true。\n\n * linewidth : float\n   \n   * 控制线宽。默认值为 1。\n   \n   * 由于opengl core profile与 大多数平台上webgl渲染器的限制，无论如何设置该值，线宽始终为1。\n\n * linecap : string\n   \n   * 定义线两端的样式。可选值为 'butt', 'round' 和 'square'。默认值为 'round'。\n   \n   * 该属性对应2d canvas linecap属性， 并且会被webgl渲染器忽略。\n\n * linejoin : string\n   \n   * 定义线连接节点的样式。可选值为 'round', 'bevel' 和 'miter'。默认值为 'round'。\n   \n   * 该属性对应2d canvas linejoin属性， 并且会被webgl渲染器忽略。\n\n\n# buffergeometry\n\n是面片、线或点几何体的有效表述。包括顶点位置，面片索引、法相量、颜色值、uv 坐标和自定义缓存属性值。使用 buffergeometry 可以有效减少向 gpu 传输上述数据所需的开销。\n\n# 代码示例\n\n// 创建一个简单的矩形. 在这里我们左上和右下顶点被复制了两次。 \nconst geometry = new three.buffergeometry();\n// 因为在两个三角面片里，这两个顶点都需要被用到。 \nvar myvertices = [-1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0];\nconst vertices = new float32array(myvertices);\n// itemsize = 3 因为每个顶点都是一个三元组。 \ngeometry.setattribute('position', new three.bufferattribute(vertices, 3));\nconst material = new three.meshbasicmaterial({ color: 0xff0000 });\nconst mesh = new three.mesh(geometry, material);\n\n\n# 构造函数\n\nbuffergeometry()\n\n创建一个新的 buffergeometry. 同时将预置属性设置为默认值.\n\n# 属性\n\n * .attributes : object\n   \n   * 通过 hashmap 存储该几何体相关的属性，hashmap 的 id 是当前 attribute 的名称，值是相应的 buffer你可以通过 .setattribute 和 .getattribute 添加和访问与当前几何体有关的 attribute。\n\n * .boundingbox : box\n   \n   * 当前 buffergeometry 的外边界矩形。可以通过 .computeboundingbox() 计算。默认值是 null。\n\n * .boundingsphere : spher\n   \n   * 当前 buffergeometry 的外边界球形。可以通过 .computeboundingsphere() 计算。默认值是 null。\n\n * .drawrange : object\n   \n   * 用于判断几何体的哪个部分需要被渲染。该值不应该直接被设置，而需要通过 .setdrawrange 进行设置。 默认值为{ start: 0, count: infinity }\n\n * .groups : array\n   \n   * 将当前几何体分割成组进行渲染，每个部分都会在单独的 webgl 的 draw call 中进行绘制。该方法可以让当前的 buffergeometry 可以使用一个材质队列进行描述。\n   \n   * 分割后的每个部分都是一个如下的表单：{ start: integer, count: integer, materialindex: integer }start 表明当前 draw call 中的没有索引的几何体的几何体的第一个顶点；或者第一个三角面片的索引。 count 指明当前分割包含多少顶点（或 indices）。 materialindex 指出当前用到的材质队列的索引。\n   \n   * 通过 .addgroup 来增加组，而不是直接更改当前队列。\n\n * .id : integer\n   \n   * 当前 buffergeometry 的唯一编号。\n\n * .index : bufferattribut\n   \n   * 允许顶点在多个三角面片间可以重用。这样的顶点被称为\"已索引的三角面片（indexed triangles)。 每个三角面片都和三个顶点的索引相关。该 attribute 因此所存储的是每个三角面片的三个顶点的索引。 如果该 attribute 没有设置过，则 rendere假设每三个连续的位置代表一个三角面片。 默认值是 null。\n\n * .isbuffergeometry : boolean\n   \n   * read-only flag to check if a given object is of type buffergeometry.\n\n * .morphattributes : object\n   \n   * 存储 bufferattribut的 hashmap，存储了几何体 morph targets 的细节信息。 note: once the geometry has been rendered, the morph attribute data cannot be changed. you will have to call .dispose(), and create a new instance of buffergeometry.\n\n * .morphtargetsrelative : boolean\n   \n   * used to control the morph target behavior; when set to true, the morph target data is treated as relative offsets, rather than as absolute positions/normals. default is false.\n\n * .name : string\n   \n   * 当前 buffergeometry 实例的可选别名。默认值是空字符串。\n\n * .userdata : object\n   \n   * 存储 buffergeometry 的自定义数据的对象。为保持对象在克隆时完整，该对象不应该包括任何函数的引用。\n\n * .uuid : string\n   \n   * 当前对象实例的 uuid，该值会自动被分配，且不应被修改。\n\n# 方法\n\neventdispatche在该类上可用的所有方法。\n\n * .setattribute ( name : string, attribute : bufferattribut) : this\n   \n   * 为当前几何体设置一个 attribute 属性。在类的内部，有一个存储 .attributes 的 hashmap， 通过该 hashmap，遍历 attributes 的速度会更快。而使用该方法，可以向 hashmap 内部增加 attribute。 所以，你需要使用该方法来添加 attributes。\n\n * .addgroup ( start : integer, count : integer, materialindex : integer ) : undefined\n   \n   * 为当前几何体增加一个 group，详见 groups 属性。\n\n * .applymatrix4 ( matrix : matrix) : this\n   \n   * 用给定矩阵转换几何体的顶点坐标。\n\n * .center () : this\n   \n   * 根据边界矩形将几何体居中。\n\n * .clone () : buffergeometr\n   \n   * 克隆当前的 buffergeometry。\n\n * .copy ( buffergeometry : buffergeometr) : this\n   \n   * 将参数指定的 buffergeometry 的值拷贝到当前 buffergeometry 中。\n\n * .cleargroups ( ) : undefined\n   \n   * 清空所有的 groups。\n\n * .computeboundingbox () : undefined\n   \n   * 计算当前几何体的的边界矩形，该操作会更新已有 param:.boundingbox]。 边界矩形不会默认计算，需要调用该接口指定计算边界矩形，否则保持默认值 null。\n\n * .computeboundingsphere () : undefined\n   \n   * 计算当前几何体的的边界球形，该操作会更新已有 param:.boundingsphere]。 边界球形不会默认计算，需要调用该接口指定计算边界球形，否则保持默认值 null。\n\n * .computetangents () : undefined\n   \n   * calculates and adds a tangent attribute to this geometry. the computation is only supported for indexed geometries and if position, normal, and uv attributes are defined. when using a tangent space normal map, prefer the mikktspace algorithm provided by buffergeometryutils.computemikktspacetangents instead.\n\n * .computevertexnormals () : undefined\n   \n   * 通过面片法向量的平均值计算每个顶点的法向量。\n\n * .dispose () : undefined\n   \n   * 从内存中销毁对象。 如果在运行是需要从内存中删除 buffergeometry，则需要调用该函数。\n\n * .getattribute ( name : string ) : bufferattribut\n   \n   * 返回指定名称的 attribute\n\n * .getindex () : bufferattribut\n   \n   * 返回缓存相关的 .index。\n\n * .hasattribute ( name : string ) : boolean\n   \n   * returns true if the attribute with the specified name exists.\n\n * .lookat ( vector : vector) : this\n\n * vector - 几何体所朝向的世界坐标。\n   \n   * 旋转几何体朝向控件中的一点。该过程通常在一次处理中完成，不会循环处理。典型的用法是过通过调用 object3d.lookat 实时改变 mesh 朝向。\n\n * .normalizenormals () : undefined\n   \n   * 几何体中的每个法向量长度将会为 1。这样操作会更正光线在表面的效果。\n   \n   * .deleteattribute ( name : string ) : bufferattribut 删除具有指定名称的 attribute\n\n * .rotatex ( radians : float ) : this\n   \n   * 在 x 轴上旋转几何体。该操作一般在一次处理中完成，不会循环处理。典型的用法是通过调用 object3d.rotation 实时旋转几何体。\n\n * .rotatey ( radians : float ) : this\n   \n   * 在 y 轴上旋转几何体。该操作一般在一次处理中完成，不会循环处理。典型的用法是通过调用 object3d.rotation 实时旋转几何体。\n\n * .rotatez ( radians : float ) : this\n   \n   * 在 z 轴上旋转几何体。该操作一般在一次处理中完成，不会循环处理。典型的用法是通过调用 object3d.rotation 实时旋转几何体。\n\n * .scale ( x : float, y : float, z : float ) : this\n   \n   * 缩放几何体。该操作一般在一次处理中完成，不会循环处理。典型的用法是通过调用 object3d.scale 实时旋转几何体。\n\n * .setindex ( index : bufferattribut) : this\n   \n   * 设置缓存的 .index。\n\n * .setdrawrange ( start : integer, count : integer ) : undefined\n   \n   * 设置缓存的 .drawrange。详见相关属性说明。\n\n * .setfrompoints ( points : array ) : this\n   \n   * 通过点队列设置该 buffergeometry 的 attribute。\n\n * .tojson () : object\n   \n   * 返回代表该 buffergeometry 的 json 对象。\n\n * .tononindexed () : buffergeometr\n   \n   * 返回已索引的 buffergeometry 的非索引版本。\n\n * .translate ( x : float, y : float, z : float ) : this\n   \n   * 移动几何体。该操作一般在一次处理中完成，不会循环处理。典型的用法是通过调用 object3d.rotation实时旋转几何体。\n\n\n# 效果\n\n# svg渲染器\n\n\n\n# webgl渲染器\n\n\n\n\n# 003-多个立方体，鼠标悬浮变更颜色\n\n\n//创建渲染器\nvar myrenderer = new three.webglrenderer({ antialias: true });\nmyrenderer.setsize(window.innerwidth, window.innerheight);\nmyrenderer.setclearcolor('white', 1.0);\n$('#mycontainer')[0].appendchild(myrenderer.domelement);\nvar myscene = new three.scene();\nmyscene.add(new three.ambientlight(0xffffff));\nvar mycamera = new three.perspectivecamera(45,\n                                           window.innerwidth / window.innerheight, 0.1, 1000);\nmycamera.position.set(622, 342, 443);\nmycamera.lookat(new three.vector3(0, 0, 0));\n//用于保存多个立方体\nvar myarray = [];\n//创建多个立方体\nvar mygeometry = new three.boxgeometry(80, 80, 80);\nfor (var i = 0; i < 10; i++) {\n  var mymaterial = new three.meshbasicmaterial({\n    color: math.random() * 0xffffff, opacity: 0.5\n  });\n  var mymesh = new three.mesh(mygeometry, mymaterial);\n  mymesh.position.x = math.random() * 480 - 140;\n  mymesh.position.y = math.random() * 480 - 140;\n  mymesh.position.z = math.random() * 480 - 140;\n  myscene.add(mymesh);\n  myarray.push(mymesh);\n}\n//渲染多个立方体\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  myrenderer.render(myscene, mycamera);\n}\n//添加鼠标移动事件监听器，检测鼠标的移动\ndocument.addeventlistener('mousemove', ondocumentmousemove);\nfunction ondocumentmousemove(event) {\n  var mymouse = new three.vector2();\n  mymouse.x = (event.clientx / window.innerwidth) * 2 - 1;\n  mymouse.y = -(event.clienty / window.innerheight) * 2 + 1;\n  var myraycaster = new three.raycaster();\n  myraycaster.setfromcamera(mymouse, mycamera);\n  //获取与射线相交的myarray[]的所有图形\n  var myintersectobjects = myraycaster.intersectobjects(myarray);\n  //这里操作第一个相交图形(使用鼠标选择的图形)\n  if (myintersectobjects.length > 0) {\n    //设置该选择的立方体颜色为红色\n    var myobject = myintersectobjects[0].object;\n    myobject.material.color.set(0xff0000);\n  }\n}\n\n\n\n# 004-\n\n\n# 005-\n\n\n# 006-\n\n\n# 007-\n\n\n# 008-\n\n\n# 009-\n\n\n# 010-",charsets:{cjk:!0}},{title:"001-立方体旋转",frontmatter:{},regularPath:"/three.js/SimpleDynamicEffect.html",relativePath:"three.js/SimpleDynamicEffect.md",key:"v-548eae12",path:"/three.js/SimpleDynamicEffect.html",headers:[{level:2,title:"001-立方体旋转",slug:"_001-立方体旋转",normalizedTitle:"001-立方体旋转",charIndex:2},{level:3,title:"创建立方体",slug:"创建立方体",normalizedTitle:"创建立方体",charIndex:16},{level:3,title:"使用定时器实现间隔渲染立方体",slug:"使用定时器实现间隔渲染立方体",normalizedTitle:"使用定时器实现间隔渲染立方体",charIndex:206},{level:2,title:"002-球体旋转",slug:"_002-球体旋转",normalizedTitle:"002-球体旋转",charIndex:375},{level:3,title:"创建球体",slug:"创建球体",normalizedTitle:"创建球体",charIndex:388},{level:3,title:"渲染(旋转)球体",slug:"渲染-旋转-球体",normalizedTitle:"渲染(旋转)球体",charIndex:617},{level:2,title:"003-圆柱体旋转",slug:"_003-圆柱体旋转",normalizedTitle:"003-圆柱体旋转",charIndex:788},{level:3,title:"创建圆柱体",slug:"创建圆柱体",normalizedTitle:"创建圆柱体",charIndex:802},{level:3,title:"渲染(旋转)圆柱体",slug:"渲染-旋转-圆柱体",normalizedTitle:"渲染(旋转)圆柱体",charIndex:1036},{level:2,title:"004-根据纹理创建立方体旋转",slug:"_004-根据纹理创建立方体旋转",normalizedTitle:"004-根据纹理创建立方体旋转",charIndex:1534},{level:3,title:"创建纹理立方体",slug:"创建纹理立方体",normalizedTitle:"创建纹理立方体",charIndex:1554},{level:2,title:"005-救生圈旋转",slug:"_005-救生圈旋转",normalizedTitle:"005-救生圈旋转",charIndex:2039},{level:3,title:"创建救生圈",slug:"创建救生圈",normalizedTitle:"创建救生圈",charIndex:2053},{level:2,title:"006-平面旋转",slug:"_006-平面旋转",normalizedTitle:"006-平面旋转",charIndex:2989},{level:3,title:"创建平面",slug:"创建平面",normalizedTitle:"创建平面",charIndex:3002},{level:2,title:"007-曲面旋转",slug:"_007-曲面旋转",normalizedTitle:"007-曲面旋转",charIndex:3433},{level:3,title:"创建完整曲面",slug:"创建完整曲面",normalizedTitle:"创建完整曲面",charIndex:3446},{level:3,title:"创建半面曲面",slug:"创建半面曲面",normalizedTitle:"创建半面曲面",charIndex:4473},{level:2,title:"008-圆环",slug:"_008-圆环",normalizedTitle:"008-圆环",charIndex:5529},{level:3,title:"圆环",slug:"圆环",normalizedTitle:"圆环",charIndex:2370},{level:3,title:"扇形",slug:"扇形",normalizedTitle:"扇形",charIndex:6925},{level:3,title:"AmbientLight-环境光",slug:"ambientlight-环境光",normalizedTitle:"ambientlight-环境光",charIndex:7142},{level:2,title:"009-柱状图浮动",slug:"_009-柱状图浮动",normalizedTitle:"009-柱状图浮动",charIndex:7635},{level:2,title:"010-圆柱上下浮动",slug:"_010-圆柱上下浮动",normalizedTitle:"010-圆柱上下浮动",charIndex:9389},{level:2,title:"011-旋转球体",slug:"_011-旋转球体",normalizedTitle:"011-旋转球体",charIndex:11190},{level:2,title:"012-球体在平面上的弹跳动画",slug:"_012-球体在平面上的弹跳动画",normalizedTitle:"012-球体在平面上的弹跳动画",charIndex:12310},{level:2,title:"013-模拟日照房子效果",slug:"_013-模拟日照房子效果",normalizedTitle:"013-模拟日照房子效果",charIndex:14306},{level:2,title:"014-模拟长大",slug:"_014-模拟长大",normalizedTitle:"014-模拟长大",charIndex:16756},{level:2,title:"015-球体在太阳下的移动",slug:"_015-球体在太阳下的移动",normalizedTitle:"015-球体在太阳下的移动",charIndex:18488},{level:2,title:"016-加载模型并旋转",slug:"_016-加载模型并旋转",normalizedTitle:"016-加载模型并旋转",charIndex:20226},{level:2,title:"017-球体在x方向重复2次，在y方向重复1次",slug:"_017-球体在x方向重复2次-在y方向重复1次",normalizedTitle:"017-球体在x方向重复2次，在y方向重复1次",charIndex:21571},{level:2,title:"018-动态波浪",slug:"_018-动态波浪",normalizedTitle:"018-动态波浪",charIndex:22432},{level:3,title:"法向量贴图创建动态波浪",slug:"法向量贴图创建动态波浪",normalizedTitle:"法向量贴图创建动态波浪",charIndex:22445},{level:3,title:"使用更新平面顶点坐标达到波浪效果",slug:"使用更新平面顶点坐标达到波浪效果",normalizedTitle:"使用更新平面顶点坐标达到波浪效果",charIndex:23879},{level:2,title:"019-下雪效果",slug:"_019-下雪效果",normalizedTitle:"019-下雪效果",charIndex:25859},{level:2,title:"020-按轨迹运动",slug:"_020-按轨迹运动",normalizedTitle:"020-按轨迹运动",charIndex:28013},{level:2,title:"021-镜像平铺",slug:"_021-镜像平铺",normalizedTitle:"021-镜像平铺",charIndex:29829},{level:2,title:"022-重复平铺",slug:"_022-重复平铺",normalizedTitle:"022-重复平铺",charIndex:31490},{level:2,title:"023-移动单个模型",slug:"_023-移动单个模型",normalizedTitle:"023-移动单个模型",charIndex:32524},{level:2,title:"024-点击(选择)的图形变更颜色",slug:"_024-点击-选择-的图形变更颜色",normalizedTitle:"024-点击(选择)的图形变更颜色",charIndex:33564},{level:2,title:"025-添加鼠标事件监听器",slug:"_025-添加鼠标事件监听器",normalizedTitle:"025-添加鼠标事件监听器",charIndex:34859},{level:2,title:"026-着色器",slug:"_026-着色器",normalizedTitle:"026-着色器",charIndex:35554},{level:2,title:"027-拖拽查看全景图",slug:"_027-拖拽查看全景图",normalizedTitle:"027-拖拽查看全景图",charIndex:38103},{level:2,title:"028-动态设置立方体的发光颜色，实现发光效果",slug:"_028-动态设置立方体的发光颜色-实现发光效果",normalizedTitle:"028-动态设置立方体的发光颜色，实现发光效果",charIndex:40204},{level:2,title:"029-动态拉伸或压缩立方体",slug:"_029-动态拉伸或压缩立方体",normalizedTitle:"029-动态拉伸或压缩立方体",charIndex:40885},{level:2,title:"030-渲染GLB汽车模型",slug:"_030-渲染glb汽车模型",normalizedTitle:"030-渲染glb汽车模型",charIndex:41161},{level:2,title:"031-剪裁平面",slug:"_031-剪裁平面",normalizedTitle:"031-剪裁平面",charIndex:43241},{level:2,title:"032-动态消失",slug:"_032-动态消失",normalizedTitle:"032-动态消失",charIndex:44103},{level:2,title:"033-",slug:"_033",normalizedTitle:"033-",charIndex:45875},{level:2,title:"034-",slug:"_034",normalizedTitle:"034-",charIndex:45887},{level:2,title:"035-",slug:"_035",normalizedTitle:"035-",charIndex:45899},{level:2,title:"036-",slug:"_036",normalizedTitle:"036-",charIndex:45911},{level:2,title:"037-",slug:"_037",normalizedTitle:"037-",charIndex:45923},{level:2,title:"038-",slug:"_038",normalizedTitle:"038-",charIndex:45935},{level:2,title:"039-",slug:"_039",normalizedTitle:"039-",charIndex:45947},{level:2,title:"040-",slug:"_040",normalizedTitle:"040-",charIndex:45959}],headersStr:"001-立方体旋转 创建立方体 使用定时器实现间隔渲染立方体 002-球体旋转 创建球体 渲染(旋转)球体 003-圆柱体旋转 创建圆柱体 渲染(旋转)圆柱体 004-根据纹理创建立方体旋转 创建纹理立方体 005-救生圈旋转 创建救生圈 006-平面旋转 创建平面 007-曲面旋转 创建完整曲面 创建半面曲面 008-圆环 圆环 扇形 AmbientLight-环境光 009-柱状图浮动 010-圆柱上下浮动 011-旋转球体 012-球体在平面上的弹跳动画 013-模拟日照房子效果 014-模拟长大 015-球体在太阳下的移动 016-加载模型并旋转 017-球体在x方向重复2次，在y方向重复1次 018-动态波浪 法向量贴图创建动态波浪 使用更新平面顶点坐标达到波浪效果 019-下雪效果 020-按轨迹运动 021-镜像平铺 022-重复平铺 023-移动单个模型 024-点击(选择)的图形变更颜色 025-添加鼠标事件监听器 026-着色器 027-拖拽查看全景图 028-动态设置立方体的发光颜色，实现发光效果 029-动态拉伸或压缩立方体 030-渲染GLB汽车模型 031-剪裁平面 032-动态消失 033- 034- 035- 036- 037- 038- 039- 040-",content:"# 001-立方体旋转\n\n\n# 创建立方体\n\nvar myGeometry = new THREE.BoxGeometry(100, 100, 100);\nvar myMaterial = new THREE.MeshNormalMaterial();\nvar myMesh = new THREE.Mesh(myGeometry, myMaterial);\nmyScene.add(myMesh);\n\n\n\n# 使用定时器实现间隔渲染立方体\n\n//使用定时器实现间隔渲染立方体\nsetInterval(function () {\n  myMesh.rotateX(0.01);        //按照指定的弧度围绕x轴旋转网格(立方体)\n  myRenderer.render(myScene, myCamera);\n}, 120);\n\n\n\n\n\n# 002-球体旋转\n\n\n# 创建球体\n\nvar myGeometry = new THREE.SphereGeometry(80, 32, 32);\nvar myMaterial = new THREE.MeshNormalMaterial({\n  wireframe: true, transparent: true\n});\nvar myMesh = new THREE.Mesh(myGeometry, myMaterial);\nmyScene.add(myMesh);\n\n\n\n# 渲染(旋转)球体\n\nanimate();\nfunction animate() {\n  myMesh.rotateY(0.01);\t\t\t\t\t\t//每次绕y轴旋转0.01弧度\n  myRenderer.render(myScene, myCamera);\n  requestAnimationFrame(animate);\n};\n\n\n\n\n\n# 003-圆柱体旋转\n\n\n# 创建圆柱体\n\nvar myGeometry = new THREE.CylinderGeometry(80, 80, 100, 25);\nvar myMaterial = new THREE.MeshBasicMaterial({\n  color: 'gray',\n  wireframe: true\n});\nvar myMesh = new THREE.Mesh(myGeometry, myMaterial);\nmyScene.add(myMesh);\n\n\n\n# 渲染(旋转)圆柱体\n\nvar T0 = new Date();                                       //上次时间\nanimate();\nfunction animate() {\n  var T1 = new Date();                                     //本次时间\n  var t = T1 - T0;                                         //两次时间差\n  T0 = T1;                                 //把本次时间赋值给上次时间\n  myMesh.rotateY(0.001 * t);               //旋转角速度0.001弧度每毫秒\n  myRenderer.render(myScene, myCamera);                 //执行渲染操作\n  window.requestAnimationFrame(animate);           //请求再次执行渲染\n};\n\n\n\n\n\n# 004-根据纹理创建立方体旋转\n\n\n# 创建纹理立方体\n\n//创建纹理图像(贴图)\nvar myMap = THREE.ImageUtils.loadTexture(\"images/img001.jpg\");\n//根据纹理图像(贴图)创建材质\nvar myMaterial = new THREE.MeshPhongMaterial({map: myMap});\n//使用图像材质创建立方体\nvar myGeometry = new THREE.CubeGeometry(1, 1, 1);\nvar myMesh = new THREE.Mesh(myGeometry, myMaterial);\nmyScene.add(myMesh);\n//渲染(旋转)立方体\nanimate();\nfunction animate() {\n  myRenderer.render(myScene, myCamera);\n  myMesh.rotation.x += 0.02;\n  myMesh.rotation.y += 0.02;\n  requestAnimationFrame(animate);\n}\n\n\n\n\n\n# 005-救生圈旋转\n\n\n# 创建救生圈\n\n//加载图像生成纹理\nvar myMap = new THREE.TextureLoader().load(\"images/img002.jpg\");\nmyMap.wrapS = myMap.wrapT = THREE.RepeatWrapping;\nmyMap.anisotropy = 16;\n//创建材质\nvar myMaterial = new THREE.MeshLambertMaterial({ map: myMap, side: THREE.DoubleSide });\n//var myMaterial = new THREE.MeshPhongMaterial({map: myMap});\n//创建圆环(救生圈)\nvar myGeometry = new THREE.TorusGeometry(50, 20, 20, 20);\nvar myMesh = new THREE.Mesh(myGeometry, myMaterial);\nmyMesh.position.set(0, 0, 200);\nmyScene.add(myMesh);\n//渲染救生圈\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  var myTimer = Date.now() * 0.0001;\n  myCamera.position.x = Math.cos(myTimer) * 400;\n  myCamera.position.y = Math.cos(myTimer) * 400;\n  myCamera.position.z = Math.sin(myTimer) * 400;\n  myCamera.lookAt(myScene.position);\n  myMesh.rotation.x = myTimer * 5;\n  myMesh.rotation.y = myTimer * 3;\n  myMesh.rotation.z = myTimer * 2;\n  myRenderer.render(myScene, myCamera);\n}\n\n\n\n# 006-平面旋转\n\n\n# 创建平面\n\n//创建平面\nvar myPlaneGeometry = new THREE.PlaneGeometry(160, 240, 5, 5);\nvar myMap = THREE.ImageUtils.loadTexture(\"images/img137.jpg\");\nvar myPlane = new THREE.Mesh(myPlaneGeometry, new THREE.MeshPhongMaterial({\n  map: myMap,\n  side: THREE.DoubleSide\n}));\nmyScene.add(myPlane);\n//渲染平面\nanimate();\nfunction animate() {\n  myRenderer.render(myScene, myCamera);\n  myPlane.rotation.y += 0.01;\n  requestAnimationFrame(animate);\n}\n\n\n\n# 007-曲面旋转\n\n\n# 创建完整曲面\n\n//根据三角函数设置样条曲线的点\nvar myPoints = [];\nfor (var i = 0; i < 90; i++) {\n  myPoints.push(new THREE.Vector2(Math.sin(i * 0.2) * Math.sin(i * 0.1) * 15 + 50, (i - 5) * 2));\n}\n//创建整周样条曲线图形\nvar myGeometry = new THREE.LatheGeometry(myPoints, 400);\nvar myMap = new THREE.TextureLoader().load(\"images/img002.jpg\");\nmyMap.wrapS = myMap.wrapT = THREE.RepeatWrapping;\nmyMap.anisotropy = 16;\nvar myMaterial = new THREE.MeshBasicMaterial({ map: myMap, side: THREE.DoubleSide });\nvar myMesh = new THREE.Mesh(myGeometry, myMaterial);\nmyMesh.position.set(0, 0, 0);\nmyScene.add(myMesh);\n//渲染整周样条曲线图形\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  var myTimer = Date.now() * 0.0001;\n  myCamera.position.x = Math.cos(myTimer) * 340;\n  myCamera.position.y = Math.cos(myTimer) * 340;\n  myCamera.position.z = Math.sin(myTimer) * 340;\n  myCamera.lookAt(myScene.position);\n  myMesh.rotation.x = myTimer * 5;\n  myMesh.rotation.y = myTimer * 3;\n  myMesh.rotation.z = myTimer * 2;\n  myRenderer.render(myScene, myCamera);\n}\n\n\n\n\n\n# 创建半面曲面\n\n//根据三角函数设置样条曲线的点\nvar myPoints = [];\nfor ( var i = 0; i < 90; i ++ ) {\n  myPoints.push( new THREE.Vector2( Math.sin( i * 0.2 ) * Math.sin( i * 0.1 ) * 15 + 50, ( i - 5 ) * 2 ) );\n}\n//创建半周样条曲线图形\nvar myGeometry =new THREE.LatheGeometry(myPoints, 400,0,Math.PI);\nvar myMap = new THREE.TextureLoader().load(\"images/img002.jpg\");\nmyMap.wrapS = myMap.wrapT = THREE.RepeatWrapping;\nmyMap.anisotropy = 16;\nvar myMaterial =new THREE.MeshBasicMaterial(\n  {map:myMap,side:THREE.DoubleSide});\nvar myMesh = new THREE.Mesh(myGeometry,myMaterial);\nmyMesh.position.set( 0, 0, 0 );\nmyScene.add(myMesh);\n//渲染半周样条曲线图形\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate );\n  var myTimer = Date.now() * 0.0001;\n  myCamera.position.x = Math.cos( myTimer ) *340;\n  myCamera.position.y = Math.cos( myTimer ) * 340;\n  myCamera.position.z = Math.sin( myTimer ) *340;\n  myCamera.lookAt( myScene.position );\n  myMesh.rotation.x = myTimer * 5;\n  myMesh.rotation.y = myTimer * 3;\n  myMesh.rotation.z = myTimer * 2;\n  myRenderer.render( myScene, myCamera );\n}\n\n\n\n\n\n# 008-圆环\n\n\n# 圆环\n\n//创建渲染器\nvar myRenderer= new THREE.WebGLRenderer({antialias: true});\nmyRenderer.setSize(window.innerWidth,window.innerHeight);\nmyRenderer.setClearColor('white', 1.0);\n$(\"#myContainer\").append(myRenderer.domElement);\nvar myCamera= new THREE.PerspectiveCamera( 45,window.innerWidth / window.innerHeight, 1, 1000 );\nvar myScene = new THREE.Scene();\n// 添加环境光\nmyScene.add(new THREE.AmbientLight('yellow'));\nvar myLight = new THREE.DirectionalLight('white' );\nmyLight.position.set(0,1,0);\nmyScene.add(myLight);\n//加载图像生成纹理(贴图)\nvar myMap = new THREE.TextureLoader().load(\"images/img006.jpg\");\nmyMap.wrapS = myMap.wrapT = THREE.RepeatWrapping;\nmyMap.anisotropy = 16;\n//创建贴图材质\nvar myMaterial=new THREE.MeshLambertMaterial({\n  map:myMap,\n  side:THREE.DoubleSide\n});\n//创建圆环面\nvar myGeometry=new THREE.RingGeometry(40, 180, 1000);\nvar myMesh = new THREE.Mesh(myGeometry,myMaterial);\nmyMesh.position.set( 0, 0, 0 );\nmyScene.add(myMesh);\n//渲染圆环面\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate );\n  var myTimer = Date.now() * 0.0001;\n  myCamera.position.x = Math.cos( myTimer ) * 400;\n  myCamera.position.y = Math.cos( myTimer ) * 400;\n  myCamera.position.z = Math.sin( myTimer ) * 400;\n  myCamera.lookAt( myScene.position );\n  myMesh.rotation.x = myTimer * 5;\n  myMesh.rotation.y = myTimer * 3;\n  myMesh.rotation.z = myTimer * 2;\n  myRenderer.render( myScene, myCamera );\n}\n\n\n\n\n\n# 扇形\n\n// 把 创建圆环面 更改成 创建扇面图形\nvar myGeometry=new THREE.RingGeometry(40, 180, 200,8,Math.PI/4,Math.PI*2/8*6);\nvar myMesh = new THREE.Mesh(myGeometry,myMaterial);\nmyMesh.position.set( 0, 0, 0 );\nmyScene.add(myMesh);\n\n\n\n\n\n# AmbientLight-环境光\n\n环境光会均匀的照亮场景中的所有物体。\n\n环境光不能用来投射阴影，因为它没有方向。\n\n# 代码示例\n\nconst light = new THREE.AmbientLight( 0x404040 );\n// soft white light scene.add( light );\n\n\n# 构造函数\n\nAmbientLight( color : Integer, intensity : Float )\n\n * color - (参数可选）颜色的rgb数值。缺省值为 0xffffff。\n * intensity - (参数可选)光照的强度。缺省值为 1。\n\n创建一个环境光对象。\n\n# 属性\n\n * .castShadow : Boolean\n   * 这个参数在对象构造的时候就被设置成了 undefined 。因为环境光不能投射阴影。\n * .isAmbientLight : Boolean\n   * Read-only flag to check if a given object is of type AmbientLight.\n\n\n# 009-柱状图浮动\n\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer({ antialias: true });\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\nmyRenderer.setClearColor('white', 1.0);\n$(\"#myContainer\").append(myRenderer.domElement);\nvar myCamera = new THREE.PerspectiveCamera(45, 1, 1, 1000);\nmyCamera.position.set(200, 200, 200);\nmyCamera.lookAt({ x: 0, y: 0, z: 0 });\nvar myScene = new THREE.Scene();\nvar myPointLight = new THREE.PointLight('white');\nmyPointLight.position.set(20, 200, 30);\nmyScene.add(myPointLight);\n//创建矩形\nvar myShape = new THREE.Shape();\n//四条直线(线条)绘制一个矩形\nmyShape.moveTo(-10, -10);\t\t\t\t\t\t          //绘制起点\nmyShape.lineTo(-10, 10);\t\t\t\t\t\t\t\t//第2个顶点\nmyShape.lineTo(10, 10);\t\t\t\t\t\t\t\t\t//第3个顶点\nmyShape.lineTo(10, -10);\t\t\t\t\t\t\t\t//第4个顶点\nmyShape.lineTo(-10, -10);\t\t\t\t\t\t\t\t//第5个顶点\n//设置在y轴方向拉伸矩形\nvar myCurve = new THREE.CatmullRomCurve3([\n  new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 40, 0)]);\nvar myGeometry = new THREE.ExtrudeGeometry(myShape, { extrudePath: myCurve });\nvar myMaterial = new THREE.MeshPhongMaterial({ color: 'cyan' });\n//创建多个矩形\nvar myArray = [];\nfor (var i = 0; i < 6; i++) {\n  var myMeshes = [];\n  for (var j = 0; j < 6; j++) {\n    var myMesh = new THREE.Mesh(myGeometry, myMaterial);\n    myScene.add(myMesh);\n    myMesh.translateX(-100 + 30 * i);\n    myMesh.translateZ(-100 + 30 * j);\n    myMesh.translateY(-50);\n    myMeshes.push(myMesh);\n  }\n  myArray.push(myMeshes);\n}\n//渲染图形\nanimate();\nvar z = 0;\nfunction animate() {\n  myRenderer.render(myScene, myCamera);\n  z = z + 0.01;\n  for (var u = 0; u < myArray.length; u++) {\n    for (var v = 0; v < myArray[u].length; v++) {\n      var myScale = 2 * Math.sin(z + 100 / u - 100 / v) + 2;\n      myArray[u][v].scale.y = myScale;\n    }\n  }\n  requestAnimationFrame(animate);\n}\n\n\n\n\n\n# 010-圆柱上下浮动\n\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer({ antialias: true });\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\nmyRenderer.setClearColor('white', 1.0);\n$(\"#myContainer\").append(myRenderer.domElement);\nvar myCamera = new THREE.PerspectiveCamera(45, 1, 1, 1000);\nmyCamera.position.set(200, 200, 200);\nmyCamera.lookAt({ x: 0, y: 0, z: 0 });\nvar myScene = new THREE.Scene();\nvar myPointLight = new THREE.PointLight('white');\nmyPointLight.position.set(320, 200, 400);\nmyScene.add(myPointLight);\n//创建圆角矩形\nvar myShape = new THREE.Shape();\nvar x = 0, y = 0, myWidth = 30, myHeight = 40, myRadius = 6\nmyShape.moveTo(x, y + myRadius);\nmyShape.lineTo(x, y + myHeight - myRadius);\nmyShape.quadraticCurveTo(x, y + myHeight, x + myRadius, y + myHeight);\nmyShape.lineTo(x + myWidth - myRadius, y + myHeight);\nmyShape.quadraticCurveTo(x + myWidth, y + myHeight, x + myWidth, y + myHeight - myRadius);\nmyShape.lineTo(x + myWidth, y + myRadius);\nmyShape.quadraticCurveTo(x + myWidth, y, x + myWidth - myRadius, y);\nmyShape.lineTo(x + myRadius, y);\nmyShape.quadraticCurveTo(x, y, x, y + myRadius);\n//设置拉伸圆角矩形的路径\nvar myCurve = new THREE.CatmullRomCurve3([\n  new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 30, 0)]);\n//创建拉伸之后的圆角矩形\nvar myGeometry = new THREE.ExtrudeGeometry(myShape, { extrudePath: myCurve });\nvar myMaterial = new THREE.MeshPhongMaterial({ color: 'cyan' });\nvar myMesh = new THREE.Mesh(myGeometry, myMaterial);\nmyMesh.translateX(100);\nmyMesh.translateZ(100);\nmyMesh.translateY(0);\nmyScene.add(myMesh);\n//渲染圆角矩形\nanimate();\nvar step = 0;\nfunction animate() {\n  myRenderer.render(myScene, myCamera);\n  step = step + 0.01;\n  var myScale = 2 * Math.sin(step) + 2;\n  myMesh.scale.y = myScale;\n  myMesh.scale.x = 2;\n  myMesh.scale.z = 2;\n  requestAnimationFrame(animate);\n}\n\n\n\n\n\n# 011-旋转球体\n\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer({ antialias: true });\nmyRenderer.setPixelRatio(window.devicePixelRatio);\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\n$(\"#myContainer\").append(myRenderer.domElement);\nvar myClock = new THREE.Clock();\nvar myCamera = new THREE.PerspectiveCamera(60,\n                                           window.innerWidth / window.innerHeight, 1, 10000);\nmyCamera.position.set(0, 100, 300);\nmyCamera.lookAt(new THREE.Vector3(0, 0, 0))\nvar myScene = new THREE.Scene();\nmyScene.background = new THREE.Color('white');\nmyScene.add(new THREE.AmbientLight('lightgreen'));\n//创建球体(地球)\nvar myGeometry = new THREE.SphereBufferGeometry(120, 64, 64);\nvar myMap = new THREE.TextureLoader().load('images/img007.png');\nvar myMaterial = new THREE.MeshPhongMaterial({ map: myMap });\nvar myMesh = new THREE.Mesh(myGeometry, myMaterial);\nmyScene.add(myMesh);\n//渲染(旋转)球体(地球)\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  var delta = myClock.getDelta();\n  myRenderer.render(myScene, myCamera);\n  //按照设置的角度增量实现绕y轴旋转地球\n  myMesh.rotation.y += delta / 5;\n}\n\n\n\n\n\n# 012-球体在平面上的弹跳动画\n\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer({ antialias: true });\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\nmyRenderer.setClearColor('white', 1.0);\nmyRenderer.shadowMapEnabled = true;\n$(\"#myContainer\").append(myRenderer.domElement);\nvar myScene = new THREE.Scene();\nvar myCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);\nmyCamera.position.set(64.7, 15.1, 17.8);\nmyCamera.lookAt(myScene.position);\nvar mySpotLight = new THREE.SpotLight(0xffffff);\nmySpotLight.position.set(-40, 40, -15);\nmySpotLight.castShadow = true;\nmySpotLight.shadow.mapSize = new THREE.Vector2(1024, 1024);\nmySpotLight.shadow.camera.far = 130;\nmySpotLight.shadow.camera.near = 40;\nmyScene.add(mySpotLight);\nmyScene.add(new THREE.AmbientLight(0x353535));\n//在场景中绘制XYZ坐标轴的轴线(红线是X轴，绿线是Y轴，蓝线是Z轴)\nmyScene.add(new THREE.AxesHelper(120));\n//在场景中绘制网格线\nmyScene.add(new THREE.GridHelper(100, 30, 0x2C2C2C, 0x888888));\n//创建平面\nvar myPlaneGeometry = new THREE.PlaneGeometry(60, 100, 1, 1);\nvar myPlaneMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });\nvar myPlaneMesh = new THREE.Mesh(myPlaneGeometry, myPlaneMaterial);\nmyPlaneMesh.rotation.x = -0.5 * Math.PI;\nmyPlaneMesh.position.x = 26;\nmyPlaneMesh.position.y = 0;\nmyPlaneMesh.position.z = 0;\nmyPlaneMesh.receiveShadow = true;\nmyScene.add(myPlaneMesh);\n//创建球体\nvar mySphereGeometry = new THREE.SphereGeometry(4, 20, 20);\nvar mySphereMaterial = new THREE.MeshLambertMaterial({ color: 'red' });\nvar mySphereMesh = new THREE.Mesh(mySphereGeometry, mySphereMaterial);\nmySphereMesh.position.x = 20;\nmySphereMesh.position.y = 4;\nmySphereMesh.position.z = 2;\nmySphereMesh.castShadow = true;\nmyScene.add(mySphereMesh);\n//渲染球体在平面上的弹跳动画\nanimate();\nvar step = 0;\nfunction animate() {\n  step += 0.05;\n  mySphereMesh.position.x = 20 + (10 * Math.cos(step));\n  mySphereMesh.position.y = 2 + (10 * Math.abs(Math.sin(step)));\n  requestAnimationFrame(animate);\n  myRenderer.render(myScene, myCamera);\n}\n\n\n\n\n\n# 013-模拟日照房子效果\n\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer({ antialias: true });\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\nmyRenderer.shadowMap.enabled = true;\n$(\"#myContainer\").append(myRenderer.domElement);\nvar myScene = new THREE.Scene();\nvar myCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);\nmyCamera.position.x = -30;\nmyCamera.position.y = 40;\nmyCamera.position.z = 40;\nmyCamera.lookAt(myScene.position);\nmyScene.add(myCamera);\n//创建THREE.PointLight光源\nvar myPointLight = new THREE.PointLight(0xffffff);\nmyPointLight.castShadow = true;\nmyPointLight.shadow.mapSize.set(2048, 2048);\nmyPointLight.decay = 0.1\nmyScene.add(myPointLight);\n//添加光源图形(被圆球代替)\nvar myPointLightHelper = new THREE.PointLightHelper(myPointLight);\n//var myPointLightHelper=new THREE.PointLightHelper(myPointLight,5,'green');\nmyScene.add(myPointLightHelper);\n//绘制(拍摄)光线阴影\nvar myCameraHelper = new THREE.CameraHelper(myPointLight.shadow.camera)\nmyScene.add(myCameraHelper)\nmyScene.add(new THREE.AmbientLight(0x353535, 1));\n//创建圆球模拟光源\nvar mySphereLight = new THREE.SphereGeometry(3, 40, 40);\nvar mySphereLightMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });\nvar mySphereLightMesh = new THREE.Mesh(mySphereLight, mySphereLightMaterial);\nmySphereLightMesh.position.set(0, 8, 2);\nmyScene.add(mySphereLightMesh);\n//创建接收阴影的平面\nvar myPlaneGeomerty = new THREE.PlaneGeometry(60, 40, 1, 1);\nvar myPlaneMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });\nvar myPlaneMesh = new THREE.Mesh(myPlaneGeomerty, myPlaneMaterial);\nmyPlaneMesh.rotation.x = -0.5 * Math.PI;\nmyPlaneMesh.receiveShadow = true;\nmyScene.add(myPlaneMesh);\n//创建立方体\nvar myBoxGeometry = new THREE.BoxGeometry(6, 6, 6);\nvar myBoxMaterial = new THREE.MeshLambertMaterial({ color: 0x00ffff });\nvar myBoxMesh = new THREE.Mesh(myBoxGeometry, myBoxMaterial);\nmyBoxMesh.castShadow = true;\nmyBoxMesh.position.x = 2;\nmyBoxMesh.position.y = 2;\nmyBoxMesh.position.z = 2;\nmyScene.add(myBoxMesh);\n//渲染所有图形\nvar step = 0;\nanimate();\nfunction animate() {\n  myPointLightHelper.update();\n  myCameraHelper.update();\n  step += 0.01;\n  mySphereLightMesh.position.x = 20 + (10 * Math.cos(step));\n  mySphereLightMesh.position.y = 12 + (10 * Math.abs(Math.sin(step)));\n  mySphereLightMesh.translateX(-22);\n  //使用圆球的位置作为光源位置\n  myPointLight.position.copy(mySphereLightMesh.position);\n  requestAnimationFrame(animate);\n  myRenderer.render(myScene, myCamera);\n}\n\n\n\n# 014-模拟长大\n\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer({ antialias: true });\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\nmyRenderer.setClearColor('white', 1.0);\nmyRenderer.shadowMap.enabled = true;\nmyRenderer.shadowMap.type = THREE.PCFSoftShadowMap;\n$(\"#myContainer\").append(myRenderer.domElement);\nvar myCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);\nmyCamera.position.set(0, 40, 50);\nmyCamera.lookAt(new THREE.Vector3(0, 0, 0));\nvar myScene = new THREE.Scene();\nmyScene.add(new THREE.AmbientLight(0x444444));\nvar myLight = new THREE.PointLight(0xffffff);\nmyLight.position.set(-40, 30, -20);\nmyLight.castShadow = true;\nmyScene.add(myLight);\n//创建投影(阴影)平面\nvar myPlaneGeometry = new THREE.PlaneGeometry(100, 100);\nvar myPlaneMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });\nvar myPlaneMesh = new THREE.Mesh(myPlaneGeometry, myPlaneMaterial);\nmyPlaneMesh.rotation.x = - 0.5 * Math.PI;\nmyPlaneMesh.position.y = -10;\nmyPlaneMesh.receiveShadow = true;\nmyScene.add(myPlaneMesh);\n//创建圆柱体\nvar myCylinderGeometry = new THREE.CylinderGeometry(10, 10, 60, 40, 20);\nvar myCylinderMaterial = new THREE.MeshPhongMaterial({ color: 0xff5f4d });\nvar myCylinderMesh = new THREE.Mesh(myCylinderGeometry, myCylinderMaterial);\nmyCylinderMesh.position.set(-10, -14, -10);\nmyCylinderMesh.castShadow = true;\nmyScene.add(myCylinderMesh);\n//渲染投影圆柱体\nanimate();\nvar myStep = 0;\nfunction animate() {\n  myRenderer.render(myScene, myCamera);\n  //在xyz方向缩放圆柱体\n  myStep += 0.01;\n  myCylinderMesh.scale.x = Math.abs(Math.sin(myStep));\n  myCylinderMesh.scale.y = Math.abs(Math.cos(myStep));\n  myCylinderMesh.scale.z = Math.abs(Math.sin(myStep));\n  requestAnimationFrame(animate);\n}\n\n\n\n\n\n# 015-球体在太阳下的移动\n\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer({ antialias: true });\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\nmyRenderer.setClearColor('white', 1.0);\nmyRenderer.shadowMap.enabled = true;\nmyRenderer.shadowMap.type = THREE.PCFSoftShadowMap;\n$(\"#myContainer\").append(myRenderer.domElement);\nvar myCamera = new THREE.PerspectiveCamera(45,\n                                           window.innerWidth / window.innerHeight, 0.1, 1000);\nmyCamera.position.set(0, 40, 50);\nmyCamera.lookAt(new THREE.Vector3(0, 0, 0));\nvar myScene = new THREE.Scene();\nmyScene.add(new THREE.AmbientLight(0x444444));\nvar myLight = new THREE.PointLight(0xffffff);\nmyLight.position.set(-10, 200, -20);\nmyLight.castShadow = true;\nmyScene.add(myLight);\n//创建投影(阴影)平面\nvar myPlaneGeometry = new THREE.PlaneGeometry(100, 100);\nvar myPlaneMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });\nvar myPlaneMesh = new THREE.Mesh(myPlaneGeometry, myPlaneMaterial);\nmyPlaneMesh.rotation.x = - 0.5 * Math.PI;\nmyPlaneMesh.receiveShadow = true;\nmyScene.add(myPlaneMesh);\n//创建球体\nvar mySphereGeometry = new THREE.SphereGeometry(5, 60, 60);\nvar mySphereMaterial = new THREE.MeshLambertMaterial({ color: 0x00ff00 });\nmySphereMesh = new THREE.Mesh(mySphereGeometry, mySphereMaterial);\nmySphereMesh.position.x = 40;\nmySphereMesh.position.y = 20;\nmySphereMesh.position.z = 10;\n//设置球体需要投射阴影\nmySphereMesh.castShadow = true;\nmyScene.add(mySphereMesh);\n//渲染投影球体\nanimate();\nvar myStep = 0;\nfunction animate() {\n  myRenderer.render(myScene, myCamera);\n  //处理位置变化的球体的移动\n  myStep += 0.05;\n  mySphereMesh.position.x = 10 * Math.cos(myStep) - 10;\n  mySphereMesh.position.y = 5 + Math.abs(Math.sin(myStep)) * 10;\n  requestAnimationFrame(animate);\n}\n\n\n\n\n\n# 016-加载模型并旋转\n\nvar myRenderer, myCamera, myScene, myOrbitControls;\n//创建渲染器\nfunction initRender() {\n  myRenderer = new THREE.WebGLRenderer({ antialias: true });\n  myRenderer.setSize(window.innerWidth, window.innerHeight);\n  myRenderer.setClearColor(0xffffff);\n  document.body.appendChild(myRenderer.domElement);\n  myCamera = new THREE.PerspectiveCamera(45,\n                                         window.innerWidth / window.innerHeight, 0.1, 1000);\n  myCamera.position.set(0, 4, 5);\n  myCamera.lookAt(new THREE.Vector3(0, 0, 0));\n  myScene = new THREE.Scene();\n  myScene.add(new THREE.AmbientLight(0x444444));\n  var myLight = new THREE.PointLight(0xffffff);\n  myLight.position.set(0, 10, 10);\n  myScene.add(myLight);\n}\n//加载并创建Blender生成的JSON格式的模型\nfunction initModel() {\n  var myObjectLoader = new THREE.ObjectLoader();\n  myObjectLoader.load(\"Data/misc_chair01.json\", function (obj) {\n    obj.position.y = -1.25;\n    obj.scale.set(1.5, 1.5, 1.5);\n    myScene.add(obj);\n  });\n}\n//创建轨道控制器(允许自动旋转)\nfunction initControls() {\n  myOrbitControls = new THREE.OrbitControls(myCamera);\n  myOrbitControls.autoRotate = true;\n  myOrbitControls.autoRotateSpeed = 3.5;\n}\n//渲染模型\nfunction animate() {\n  myRenderer.render(myScene, myCamera);\n  myOrbitControls.update();\n  requestAnimationFrame(animate);\n}\ninitRender();\ninitModel();\ninitControls();\nanimate();\n\n\n\n\n\n# 017-球体在x方向重复2次，在y方向重复1次\n\n//根据贴图创建球体\nvar myTexture = THREE.ImageUtils.loadTexture(\"images/img089.jpg\");\nmyTexture.wrapS = THREE.RepeatWrapping;\nmyTexture.wrapT = THREE.RepeatWrapping;\n//设置在x方向重复2次，在y方向重复1次贴图\nmyTexture.repeat.set(2, 1);\nvar myMaterial = new THREE.MeshLambertMaterial();\nmyMaterial.map = myTexture;\nvar myGeometry = new THREE.SphereGeometry(60, 50, 50);\nvar myMesh = new THREE.Mesh(myGeometry, myMaterial);\nmyMesh.position.x = 1;\nmyScene.add(myMesh);\n//渲染球体\nanimate();\nvar step = 0;\nfunction animate() {\n  step += 0.01;\n  myMesh.rotation.y = step;\n  myMesh.rotation.x = step;\n  requestAnimationFrame(animate);\n  myRenderer.render(myScene, myCamera);\n}\n//响应单击“在X方向重复2次”按钮\n$(\"#myButton1\").click(function () {\n  myMaterial.map.repeat.set(2, 1);\n});\n//响应单击“在X方向重复10次”按钮\n$(\"#myButton2\").click(function () {\n  myMaterial.map.repeat.set(10, 1);\n});\n\n\n\n# 018-动态波浪\n\n\n# 法向量贴图创建动态波浪\n\n<script src=\"ThreeJS/Reflector.js\"><\/script>\n<script src=\"ThreeJS/Refractor.js\"><\/script>\n<script src=\"ThreeJS/Water2.js\"><\/script>\n\n\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer({ antialias: true });\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\nmyRenderer.setClearColor('white', 1.0);\n$(\"#myContainer\").append(myRenderer.domElement);\nvar myScene = new THREE.Scene();\nvar myCamera = new THREE.PerspectiveCamera(45,\n                                           window.innerWidth / window.innerHeight, 0.1, 1000);\nmyCamera.position.set(0, 25, 0);\nmyCamera.lookAt(myScene.position);\n//创建动态波浪平面\nvar myTextureLoader = new THREE.TextureLoader();\nvar myMap = myTextureLoader.load('images/img111.jpg');\nvar myGeometry = new THREE.PlaneBufferGeometry(\n  window.innerWidth / 10, window.innerHeight / 10);\nvar myMaterial = new THREE.MeshBasicMaterial({ map: myMap });\nvar myPlaneMesh = new THREE.Mesh(myGeometry, myMaterial);\nmyPlaneMesh.rotation.x = Math.PI * -0.5;\nmyScene.add(myPlaneMesh);\n//使用法向量贴图创建动态波浪\nvar myWaterWave = new THREE.Water(myGeometry, {\n  normalMap0: myTextureLoader.load(\"images/img112.jpg\"),\n  normalMap1: myTextureLoader.load(\"images/img113.jpg\")\n});\n//使水波层的旋转角度与平面层保持一致\nmyWaterWave.rotation.x = Math.PI * -0.5;\nmyWaterWave.position.y = 0.05;\nmyScene.add(myWaterWave);\n//渲染动态波浪\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myRenderer.render(myScene, myCamera);\n}\n\n\n\n\n\n# 使用更新平面顶点坐标达到波浪效果\n\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer({ antialias: true });\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\n$(\"#myContainer\").append(myRenderer.domElement);\nvar myScene = new THREE.Scene();\nmyScene.background = new THREE.Color('white');\nvar myCamera = new THREE.PerspectiveCamera(45,\n                                           window.innerWidth / window.innerHeight, 0.01, 1000);\nmyScene.add(new THREE.AmbientLight(0xffffff));\nmyCamera.position.set(0, 90, 300);\nmyCamera.lookAt(myScene.position);\n$(\"#myContainer\").append(myRenderer.domElement);\n//创建贴图平面(平面图形)\nvar myGeometry = new THREE.PlaneGeometry(window.innerWidth,\n                                         window.innerHeight, 100, 100);\nvar myTexture = THREE.ImageUtils.loadTexture(\"images/img111.jpg\");\nvar myMaterial = new THREE.MeshPhongMaterial({ map: myTexture });\nvar myPlaneMesh = new THREE.Mesh(myGeometry, myMaterial);\nmyPlaneMesh.rotation.x = -Math.PI / 4;\nmyScene.add(myPlaneMesh);\n//渲染在平面上实现的波浪效果\nvar isWave = true;\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  if (isWave) {\n    //获取平面图形的顶点数\n    var myVerticesLength = myPlaneMesh.geometry.vertices.length;\n    for (var i = 0; i < myVerticesLength; i++) {\n      //以迭代方式获取顶点坐标\n      var v = myPlaneMesh.geometry.vertices[i];\n      //根据正弦波算法动态设置顶点的z坐标，从而实现波浪效果\n      v.z = Math.sin(Date.now() / 200 + (v.x * (myVerticesLength / 2)) *\n                     (v.y / (myVerticesLength / 2))) * 3;\n    }\n    //更新平面顶点坐标\n    myPlaneMesh.geometry.verticesNeedUpdate = true;\n  }\n  myRenderer.render(myScene, myCamera);\n}\n//响应单击“添加波浪效果”按钮\n$(\"#myButton1\").click(function () {\n  isWave = true;\n});\n//响应单击“删除波浪效果”按钮\n$(\"#myButton2\").click(function () {\n  isWave = false;\n  var myVerticesLength = myPlaneMesh.geometry.vertices.length;\n  for (var i = 0; i < myVerticesLength; i++) {\n    //重置平面顶点的z坐标，使平面以默认样式显示\n    myPlaneMesh.geometry.vertices[i].z = 0;\n  }\n  myPlaneMesh.geometry.verticesNeedUpdate = true;\n});\n\n\n\n# 019-下雪效果\n\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer({ antialias: true });\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\n$(\"#myContainer\").append(myRenderer.domElement);\nvar myScene = new THREE.Scene();\nvar myCamera = new THREE.PerspectiveCamera(45,\n                                           window.innerWidth / window.innerHeight, 2, 500);\nmyCamera.position.set(0, 0, 40);\nmyScene.add(myCamera);\nmyScene.background = new THREE.TextureLoader().load('images/img004.jpg');\n//创建多个雪花\nvar myMap = new THREE.TextureLoader().load('images/img109.png');\nvar myPointsMaterials = [];\nfor (var i = 0; i < 2; i++) {\n  var myPointsMaterial = new THREE.PointsMaterial({\n    size: 2, map: myMap, blending: THREE.AdditiveBlending\n  });\n  myPointsMaterial.map.offset = new THREE.Vector2(1 / 2 * i, 0);\n  myPointsMaterial.map.repeat = new THREE.Vector2(1 / 2, 1);\n  myPointsMaterials.push(myPointsMaterial);\n}\nvar myGeometries = [];\nfor (var k = 0; k < 2; k++) {\n  var myGeometry = new THREE.Geometry();\n  for (var i = 0; i < 100; i++) {\n    var myVector = new THREE.Vector3(Math.random() * 50 - 25,\n                                     Math.random() * 50 - 25, Math.random() * 50 - 25);\n    myVector.velocityY = 0.1 + Math.random() / 5;\n    myVector.velocityX = (Math.random() - 0.5) / 3;\n    myVector.velocityZ = (Math.random() - 0.5) / 3;\n    myGeometry.vertices.push(myVector);\n  }\n  myGeometries.push(myGeometry);\n}\nvar myGroup = [];\nfor (var i = 0; i < 2; i++) {\n  var myPoints = new THREE.Points(myGeometries[i], myPointsMaterials[i]);\n  myGroup.push(myPoints);\n  myScene.add(myPoints);\n}\n//渲染多个雪花\nanimate();\nfunction animate() {\n  myGroup.forEach(function (points, i) {\n    var myVertices = points.geometry.vertices;\n    myVertices.forEach(function (v, idx) {\n      v.y = v.y - (v.velocityY);\n      v.x = v.x - (v.velocityX);\n      v.z = v.z - (v.velocityZ);\n      if (v.y <= -25) v.y = 25;\n      if (v.x <= -25 || v.x >= 25) v.x = -v.x;\n      if (v.z <= -25 || v.z >= 25) v.velocityZ = -v.velocityZ;\n    });\n    points.geometry.verticesNeedUpdate = true;\n  });\n  myRenderer.render(myScene, myCamera);\n  requestAnimationFrame(animate);\n}\n\n\n\n\n\n# 020-按轨迹运动\n\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer({ antialias: true });\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\n$(\"#myContainer\").append(myRenderer.domElement);\nvar myScene = new THREE.Scene();\nmyScene.background = new THREE.Color('white');\nvar myCamera = new THREE.PerspectiveCamera(45,\n                                           window.innerWidth / window.innerHeight, 1, 1000);\nmyCamera.position.set(0, 0, 200);\nmyScene.add(myCamera);\nmyScene.add(new THREE.AmbientLight(0xffffff));\n//设置中心点坐标\nvar x = -20, y = -40;\n//使用贝塞尔曲线生成桃心\nvar myShape = new THREE.Shape().moveTo(x + 25, y + 25)\n.bezierCurveTo(x + 25, y + 25, x + 20, y, x, y)\n.bezierCurveTo(x - 30, y, x - 30, y + 35, x - 30, y + 35)\n.bezierCurveTo(x - 30, y + 55, x - 10, y + 77, x + 25, y + 95)\n.bezierCurveTo(x + 60, y + 77, x + 80, y + 55, x + 80, y + 35)\n.bezierCurveTo(x + 80, y + 35, x + 80, y, x + 50, y)\n.bezierCurveTo(x + 35, y, x + 25, y + 25, x + 25, y + 25);\nvar myPoints = myShape.getPoints();\nvar myGeometryPoints = new THREE.BufferGeometry().setFromPoints(myPoints);\nmyHeart = new THREE.Points(myGeometryPoints,\n                           new THREE.PointsMaterial({ color: 0xff0000, size: 6 }));\nmyScene.add(myHeart);\n//创建小球\nvar myGeometry = new THREE.SphereGeometry(10, 10, 10);\nvar myTexture = THREE.ImageUtils.loadTexture(\"images/img055.jpg\");\nvar myMaterial = new THREE.MeshBasicMaterial({ map: myTexture });\nvar mySphere = new THREE.Mesh(myGeometry, myMaterial);\nmyScene.add(mySphere);\n//渲染小球沿着桃心曲线移动\nvar myIndex = 0;\nvar mylength = myPoints.length;\nanimate();\nfunction animate() {\n  myRenderer.render(myScene, myCamera);\n  if (myIndex == mylength - 1) { myIndex = 0; }\n  else { myIndex += 1; }\n  mySphere.position.set(myPoints[myIndex].x, myPoints[myIndex].y, 0);\n  requestAnimationFrame(animate);\n}\n\n\n\n\n\n# 021-镜像平铺\n\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer({ antialias: true });\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\n$(\"#myContainer\").append(myRenderer.domElement);\nvar myScene = new THREE.Scene();\nmyScene.background = new THREE.Color('white');\nvar myCamera = new THREE.PerspectiveCamera(45,\n                                           window.innerWidth / window.innerHeight, 0.01, 1000);\nmyScene.add(new THREE.AmbientLight(0xffffff));\nmyCamera.position.set(-28.03, -10.96, 311.75);\nmyCamera.lookAt(myScene.position);\n$(\"#myContainer\").append(myRenderer.domElement);\n//创建平面图形\nvar myTextureLoader = new THREE.TextureLoader();\nvar myMap = myTextureLoader.load('images/img056.png');\n//设置纹理图像(贴图)在水平方向和垂直方向上的平铺模式为镜像平铺\nmyMap.wrapS = THREE.MirroredRepeatWrapping;\nmyMap.wrapT = THREE.MirroredRepeatWrapping;\nmyMap.matrixAutoUpdate = false;\nvar myMaterial = new THREE.MeshPhongMaterial({ map: myMap, transparent: true });\nvar myGeometry = new THREE.PlaneBufferGeometry(300, 200, 5, 5);\nvar myPlaneMesh = new THREE.Mesh(myGeometry, myMaterial);\nvar myMatrix = myPlaneMesh.material.map.matrix;\nmyMatrix.identity().scale(1, 1);\nmyScene.add(myPlaneMesh);\n//渲染平面图形\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myRenderer.render(myScene, myCamera);\n}\n//响应单击“设置2*2镜像平铺”按钮\n$(\"#myButton1\").click(function () {\n  //获取平面贴图所对应的矩阵\n  myMatrix = myPlaneMesh.material.map.matrix;\n  //通过矩阵设置水平方向和垂直方向的镜像重复次数\n  myMatrix.identity().scale(2, 2);\n});\n//响应单击“设置3*3镜像平铺”按钮\n$(\"#myButton2\").click(function () {\n  //获取平面贴图所对应的矩阵\n  myMatrix = myPlaneMesh.material.map.matrix;\n  //通过矩阵设置水平方向和垂直方向的镜像重复次数\n  myMatrix.identity().scale(3, 3);\n});\n\n\n\n\n\n# 022-重复平铺\n\n//创建平面图形\nvar myTextureLoader = new THREE.TextureLoader();\nvar myMap = myTextureLoader.load('images/img137.jpg');\n//设置纹理图像在水平方向和垂直方向上的平铺模式为重复平铺\nmyMap.wrapS = THREE.RepeatWrapping;\nmyMap.wrapT = THREE.RepeatWrapping;\nvar myMaterial = new THREE.MeshPhongMaterial({ map: myMap, transparent: true });\nvar myGeometry = new THREE.PlaneBufferGeometry(300, 200, 5, 5);\nvar myPlaneMesh = new THREE.Mesh(myGeometry, myMaterial);\nmyScene.add(myPlaneMesh);\n//渲染平面图形\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myRenderer.render(myScene, myCamera);\n}\n//响应单击“设置2*2重复平铺”按钮\n$(\"#myButton1\").click(function () {\n  // myMap.matrixAutoUpdate = false;\n  // myMatrix = myPlaneMesh.material.map.matrix;\n  // myMatrix.identity().scale(2, 2);\n  myPlaneMesh.material.map.repeat.set(2, 2);\n});\n//响应单击“设置3*3重复平铺”按钮\n$(\"#myButton2\").click(function () {\n  // myMap.matrixAutoUpdate = false;\n  // myMatrix = myPlaneMesh.material.map.matrix;\n  // myMatrix.identity().scale(3, 3);\n  myPlaneMesh.material.map.repeat.set(3, 3);\n});\n\n\n\n# 023-移动单个模型\n\nvar myMaterial = new THREE.MeshNormalMaterial();\n//创建圆环结\nvar myTorusKnotGeometry = new THREE.TorusKnotGeometry(8, 3, 200, 60);\nvar myTorusKnotMesh = new THREE.Mesh(myTorusKnotGeometry, myMaterial);\nmyTorusKnotMesh.translateX(-62);\nmyScene.add(myTorusKnotMesh);\n//创建立方体\nvar myBoxGeometry = new THREE.BoxGeometry(20, 20, 20);\nvar myBoxMesh = new THREE.Mesh(myBoxGeometry, myMaterial);\nmyBoxMesh.translateX(-20);\nmyScene.add(myBoxMesh);\n//创建球体\nvar mySphereGeometry = new THREE.SphereGeometry(20, 60, 60);\nvar mySphereMesh = new THREE.Mesh(mySphereGeometry, myMaterial);\nmySphereMesh.translateX(70);\nmyScene.add(mySphereMesh);\nvar myObjects = [];\nmyObjects.push(myTorusKnotMesh);\nmyObjects.push(myBoxMesh);\nmyObjects.push(mySphereMesh);\n//渲染圆环结、立方体、球体\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myRenderer.render(myScene, myCamera);\n}\n//根据将要拖拽的图形、照相机、渲染器创建DragControls\nvar myDragControls = new THREE.DragControls(myObjects,\n                                            myCamera, myRenderer.domElement);\n\n\n\n# 024-点击(选择)的图形变更颜色\n\nvar myOrbitControls = new THREE.OrbitControls(myCamera);\n//创建多个立方体\nvar myGeometry = new THREE.BoxGeometry(120, 120, 120);\nfor (var i = 0; i < 10; i++) {\n  var myMaterial = new THREE.MeshLambertMaterial({\n    color: Math.random() * 0xffffff\n  });\n  var myMesh = new THREE.Mesh(myGeometry, myMaterial);\n  myMesh.position.x = Math.random() * 580 - 140;\n  myMesh.position.y = Math.random() * 580 - 140;\n  myMesh.position.z = Math.random() * 580 - 140;\n  myScene.add(myMesh);\n}\n//渲染多个立方体\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myRenderer.render(myScene, myCamera);\n}\nvar myMouse = new THREE.Vector2();\n//THREE.Raycaster用于通过鼠标去获取在3D世界被选择的图形\nvar myRaycaster = new THREE.Raycaster();\n$(document.body).click(function (event) {\n  //拦截页面默认的点击事件\n  event.preventDefault();\n  //计算当前鼠标的坐标\n  myMouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n  myMouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\n  //根据当前鼠标和照相机重置Raycaster\n  myRaycaster.setFromCamera(myMouse, myCamera);\n  //获取被点击(选择)的图形\n  var myIntersects = myRaycaster.intersectObjects(myScene.children);\n  if (myIntersects.length > 0) {\n    //生成随机颜色值\n    var myColor = Math.random() * 0xffffff;\n    //动态更新该图形表面的颜色\n    myIntersects[0].object.material.color = new THREE.Color(myColor);\n  }\n});\n\n\n\n# 025-添加鼠标事件监听器\n\n\n//添加鼠标事件监听器\ndocument.addEventListener('mousedown', function (e) {\n  e.preventDefault();\n  document.addEventListener('mousemove', onMouseMove, false);\n  document.addEventListener('mouseup', onMouseUp, false);\n}, false);\ndocument.addEventListener('wheel', function (event) {\n  var myFOV = myCamera.fov + event.deltaY * 0.05;\n  myCamera.fov = THREE.MathUtils.clamp(myFOV, 10, 75);\n  myCamera.updateProjectionMatrix();\n}, false);\nfunction onMouseMove(event) {\n  myLongitude -= event.movementX * 0.1;\n  myLatitude += event.movementY * 0.1;\n}\nfunction onMouseUp() {\n  document.removeEventListener('mousemove', onMouseMove);\n  document.removeEventListener('mouseup', onMouseUp);\n}\n\n\n\n# 026-着色器\n\n<script type=\"x-shader/x-fragment\" id=\"myFragmentShader\">\n  //创建片元着色器\n  uniform sampler2D myTexture;\nuniform float saturation;\nvarying vec2 vUv;\nvoid main(){\n  //获取原始图像像素值\n  vec4 myColor=texture2D(myTexture,vUv);\n  //根据饱和度参数重新计算RGB分量值\n  float myR=0.213*(1.0-saturation);\n  float myG=0.715*(1.0-saturation);\n  float myB=0.072*(1.0-saturation);\n  //根据RGB分量值和饱和度参数值生成对应的颜色矩阵\n  mat4 myColorMatrix=mat4(myR+saturation,myG,myB,0.0,\n                          myR,myG+saturation,myB,0.0,\n                          myR,myG,myB+saturation,0.0,\n                          0.0,0.0,0.0,1.0);\n  //根据颜色矩阵计算最终颜色值\n  gl_FragColor=myColor*myColorMatrix;\n}\n<\/script>\n<script type=\"x-shader/x-vertex\" id=\"myVertexShader\">\n  //创建顶点着色器\n  varying vec2 vUv;\nvoid main(){\n  vUv=uv;\n  vec4 mvPosition=modelViewMatrix*vec4(position,1.0);\n  gl_Position=projectionMatrix*mvPosition;\n}\n<\/script>\n<script type=\"text/javascript\">\n  //创建渲染器\n  var myRenderer = new THREE.WebGLRenderer({ antialias: true });\n  myRenderer.setSize(window.innerWidth, window.innerHeight);\n  myRenderer.setClearColor('white', 1.0);\n  $('#myContainer')[0].appendChild(myRenderer.domElement);\n  var myScene = new THREE.Scene();\n  var myCamera = new THREE.PerspectiveCamera(45,\n                                             window.innerWidth / window.innerHeight, 0.1, 1000);\n  myCamera.position.set(100, 100, 400);\n  myCamera.lookAt(myScene.position);\n  var myTextureLoader = new THREE.TextureLoader();\n  var myTexture = myTextureLoader.load('images/img004.jpg');\n  //封装片元着色器所使用的参数\n  var myUniforms = { myTexture: { value: myTexture }, saturation: { value: 1 } };\n  //根据着色器及其参数创建THREE.ShaderMaterial\n  var myShaderMaterial = new THREE.ShaderMaterial({\n    uniforms: myUniforms,\n    vertexShader: $('#myVertexShader').text(),\n    fragmentShader: $('#myFragmentShader').text()\n  });\n  //使用THREE.ShaderMaterial创建立方体\n  var myBoxGeometry = new THREE.BoxGeometry(160, 160, 160);\n  var myMesh = new THREE.Mesh(myBoxGeometry, myShaderMaterial);\n  myScene.add(myMesh);\n  var myStep = 0;\n  //渲染(旋转)立方体\n  animate();\n  function animate() {\n    myMesh.rotation.y = myStep += 0.01;\n    myMesh.rotation.x = myStep;\n    myMesh.rotation.z = myStep;\n    requestAnimationFrame(animate);\n    myRenderer.render(myScene, myCamera);\n  }\n  //为滑块元素添加拖拽事件监听器\n  $(\"input\").on(\"input\", function () {\n    //获取滑块当前值\n    var mySaturation = parseFloat($(this).val() / 100);\n    //动态设置片元着色器的饱和度参数，同时更新材质对象\n    myMesh.material.uniforms.saturation = { value: mySaturation };\n    myMesh.material.needsUpdate = true;\n  });\n<\/script>\n\n\n\n# 027-拖拽查看全景图\n\n\nvar isMouse = false, myMouseX = 0, myMouseY = 0, myLongitude = 0, myLatitude = 0,\n    myTempLongitude = 0, myTempLatitude = 0, myPhi = 0, myTheta = 0;\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer();\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\n$(document.body).append(myRenderer.domElement);\nvar myCamera = new THREE.PerspectiveCamera(75,\n                                           window.innerWidth / window.innerHeight, 1, 1100);\nmyCamera.target = new THREE.Vector3(0, 0, 0);\nvar myScene = new THREE.Scene();\n//创建球体并设置全景图\nvar myGeometry = new THREE.SphereBufferGeometry(40, 30, 30);\nmyGeometry.scale(-1, 1, 1);\nvar myLoader = new THREE.TextureLoader();\nvar myTexture = myLoader.load('images/img129.jpg');\nvar myMaterial = new THREE.MeshBasicMaterial({ map: myTexture });\nvar mySphere = new THREE.Mesh(myGeometry, myMaterial);\nmyScene.add(mySphere);\n//渲染全景图(拖拽查看全景图)\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myLatitude = Math.max(-85, Math.min(85, myLatitude));\n  myPhi = THREE.MathUtils.degToRad(90 - myLatitude);\n  myTheta = THREE.MathUtils.degToRad(myLongitude);\n  myCamera.target.x = Math.sin(myPhi) * Math.cos(myTheta);\n  myCamera.target.y = Math.cos(myPhi);\n  myCamera.target.z = Math.sin(myPhi) * Math.sin(myTheta);\n  myCamera.lookAt(myCamera.target);\n  myRenderer.render(myScene, myCamera);\n}\ndocument.addEventListener('mousedown', function (event) {\n  isMouse = true;\n  //记录鼠标按下的位置\n  myMouseX = event.clientX;\n  myMouseY = event.clientY;\n  myTempLongitude = myLongitude;\n  myTempLatitude = myLatitude;\n});\ndocument.addEventListener('mousemove', function (event) {\n  if (isMouse) {\n    //根据鼠标当前位置和按下的位置重新计算经纬度\n    myLongitude = (myMouseX - event.clientX) * 0.1 + myTempLongitude;\n    myLatitude = (event.clientY - myMouseY) * 0.1 + myTempLatitude;\n  }\n});\ndocument.addEventListener('mouseup', function () { isMouse = false; });\ndocument.addEventListener('wheel', function (event) {\n  var myFOV = myCamera.fov + event.deltaY * 0.05;\n  myCamera.fov = THREE.MathUtils.clamp(myFOV, 10, 75);\n  myCamera.updateProjectionMatrix();\n});\n\n\n\n# 028-动态设置立方体的发光颜色，实现发光效果\n\n//创建立方体\nvar myTextureLoader = new THREE.TextureLoader();\nmyTextureLoader.load('images/img053.jpg', function (myTexture) {\n  var myMeshLambertMaterial = new THREE.MeshLambertMaterial({ map: myTexture });\n  var myGeometry = new THREE.BoxGeometry(24, 24, 24);\n  myMesh = new THREE.Mesh(myGeometry, myMeshLambertMaterial);\n  myScene.add(myMesh);\n});\n//渲染立方体\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  //动态设置立方体的发光颜色，实现发光效果\n  myMesh.material.emissive.setHSL(\n    0.54,\n    1, \n    0.35 * (0.5 + 0.5 * Math.sin(35 * 0.0001 * Date.now()))\n  );\n  //myMesh.material.emissive.setRGB(255,0,0);\n  myRenderer.render(myScene, myCamera);\n};\n\n\n\n# 029-动态拉伸或压缩立方体\n\n//动态拉伸或压缩立方体\nmyRenderer.setAnimationLoop(function () {\n  if (myStep < 1) { if (!isReversed) myStep += 0.02; }\n  if (myStep > 0) { if (isReversed) myStep -= 0.02; }\n  myBoxMesh.morphTargetInfluences[0] = myStep;\n  myRenderer.render(myScene, myCamera);\n});\n\n\n\n# 030-渲染GLB汽车模型\n\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer({ antialias: true });\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\n$(\"#myContainer\").append(myRenderer.domElement);\nmyRenderer.outputEncoding = THREE.sRGBEncoding;\nmyRenderer.toneMapping = THREE.ACESFilmicToneMapping;\nmyRenderer.toneMappingExposure = 0.85;\nvar myCamera = new THREE.PerspectiveCamera(40,\n                                           window.innerWidth / window.innerHeight, 0.1, 1000);\nmyCamera.position.set(4.25, 1.4, -4.5);\nvar myEnvironment = new RoomEnvironment();\nvar myGenerator = new THREE.PMREMGenerator(myRenderer);\nvar myScene = new THREE.Scene();\nmyScene.background = new THREE.Color(0xffffff);\nmyScene.environment = myGenerator.fromScene(myEnvironment).texture;\n//根据透视相机创建轨道控制器，并设置其目标所在位置\nvar myOrbitControls = new THREE.OrbitControls(myCamera);\nmyOrbitControls.target.set(0, 0.5, 0);\nmyOrbitControls.update();\n//初始化汽车车身、玻璃、轮胎等部位对应的材质\nvar myBodyMaterial = new THREE.MeshPhysicalMaterial({\n  color: 0x00ff00, metalness: 0.6, roughness: 0.4,\n  clearcoat: 0.05, clearcoatRoughness: 0.05\n});\nvar myDetailsMaterial = new THREE.MeshStandardMaterial({\n  color: 0x0000ff, metalness: 1.0, roughness: 0.5\n});\nvar myGlassMaterial = new THREE.MeshPhysicalMaterial({\n  color: 0xff0000, metalness: 0, roughness: 0.1,\n  transmission: 0.9, transparent: true\n});\n//创建DRACOLoader，并设置其解码目录\n//即draco_wasm_wrapper.js和draco_decoder.wasm文件所在位置\nvar myDRACOLoader = new THREE.DRACOLoader();\nmyDRACOLoader.setDecoderPath('Data/');\nvar myGLTFLoader = new THREE.GLTFLoader();\nmyGLTFLoader.setDRACOLoader(myDRACOLoader);\n//加载GLB汽车模型文件，并为汽车各部位设置自定义材质\nmyGLTFLoader.load('Data/MyFerrari.glb', function (glb) {\n  var myCar = glb.scene.children[0];\n  myCar.scale.set(1.5, 1.5, 1.5);\n  myCar.getObjectByName('body').material = myBodyMaterial;\n  myCar.getObjectByName('rim_fr').material = myDetailsMaterial;\n  myCar.getObjectByName('glass').material = myGlassMaterial;\n  myScene.add(myCar);\n});\n//渲染GLB汽车模型\nmyRenderer.setAnimationLoop(render);\nfunction render() {\n  myRenderer.render(myScene, myCamera);\n}\n\n\n\n\n\n# 031-剪裁平面\n\n//创建圆环结\nvar myGeometry = new THREE.TorusKnotBufferGeometry(10, 2, 200, 80, 2, 5);\n//创建剪裁平面\nvar myClippingPlane = new THREE.Plane(new THREE.Vector3(0, -1, 0), 0.8);\nvar myMaterial = new THREE.MeshPhongMaterial({\n  color: 0x80ee10,\n  shininess: 100, side: THREE.DoubleSide, clippingPlanes: [myClippingPlane]\n});\nmyMesh = new THREE.Mesh(myGeometry, myMaterial);\nmyScene.add(myMesh);\nvar myControls = new THREE.OrbitControls(myCamera, myContainer);\n//渲染圆环结\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myMesh.rotation.x += 0.01;\n  myMesh.rotation.y += 0.01;\n  myMesh.rotation.z += 0.01;\n  myRenderer.render(myScene, myCamera);\n}\n//响应单击“启用剪裁平面”按钮\n$(\"#myButton1\").click(function () {\n  myRenderer.localClippingEnabled = true;\n});\n//响应单击“禁用剪裁平面”按钮\n$(\"#myButton2\").click(function () {\n  myRenderer.localClippingEnabled = false;\n});\n\n\n\n# 032-动态消失\n\nvar myMouseX = 0, myMouseY = 0;\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer({ antialias: true, });\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\n$(\"#myContainer\").append(myRenderer.domElement);\nvar myScene = new THREE.Scene();\nmyScene.background = new THREE.Color(0xffffff);\nvar myCamera = new THREE.PerspectiveCamera(60,\n                                           window.innerWidth / window.innerHeight, 0.1, 1000);\nmyCamera.position.z = 500;\n//创建第一个球体\nvar myGeometry = new THREE.SphereBufferGeometry(50, 100, 100);\nvar myMaterial = new THREE.MeshNormalMaterial();\nvar myParentSphere = new THREE.Mesh(myGeometry, myMaterial);\nmyParentSphere.position.x = -400;\nmyScene.add(myParentSphere);\n//以嵌套方式连续创建8个球体\nfor (var i = 0; i < 8; i++) {\n  var myChildSphere = new THREE.Mesh(myGeometry, myMaterial);\n  myChildSphere.position.x = 100;\n  myParentSphere.add(myChildSphere);\n  myParentSphere = myChildSphere;\n}\ndocument.addEventListener('mousemove', function (event) {\n  myMouseX = (event.clientX - (window.innerWidth / 2)) * 10;\n  myMouseY = (event.clientY - (window.innerHeight / 2)) * 10;\n}, false);\n//渲染9个球体\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  var myTime = Date.now() * 0.001 + 10000;\n  var myRotationX = Math.sin(myTime * 0.7) * 0.2;\n  var myRotationY = Math.sin(myTime * 0.3) * 0.1;\n  var myRotationZ = Math.sin(myTime * 0.2) * 0.1;\n  myCamera.position.x += (myMouseX - myCamera.position.x) * 0.05;\n  myCamera.position.y -= (myMouseY + myCamera.position.y) * 0.05;\n  myCamera.lookAt(myScene.position);\n  myParentSphere.traverse(function (object) {\n    object.rotation.x = myRotationX;\n    object.rotation.y = myRotationY;\n    object.rotation.z = myRotationZ;\n  });\n  myRenderer.render(myScene, myCamera);\n}\n\n\n\n# 033-\n\n\n\n\n\n# 034-\n\n\n\n\n\n# 035-\n\n\n\n\n\n# 036-\n\n\n\n\n\n# 037-\n\n\n\n\n\n# 038-\n\n\n\n\n\n# 039-\n\n\n\n\n\n# 040-\n\n\n",normalizedContent:"# 001-立方体旋转\n\n\n# 创建立方体\n\nvar mygeometry = new three.boxgeometry(100, 100, 100);\nvar mymaterial = new three.meshnormalmaterial();\nvar mymesh = new three.mesh(mygeometry, mymaterial);\nmyscene.add(mymesh);\n\n\n\n# 使用定时器实现间隔渲染立方体\n\n//使用定时器实现间隔渲染立方体\nsetinterval(function () {\n  mymesh.rotatex(0.01);        //按照指定的弧度围绕x轴旋转网格(立方体)\n  myrenderer.render(myscene, mycamera);\n}, 120);\n\n\n\n\n\n# 002-球体旋转\n\n\n# 创建球体\n\nvar mygeometry = new three.spheregeometry(80, 32, 32);\nvar mymaterial = new three.meshnormalmaterial({\n  wireframe: true, transparent: true\n});\nvar mymesh = new three.mesh(mygeometry, mymaterial);\nmyscene.add(mymesh);\n\n\n\n# 渲染(旋转)球体\n\nanimate();\nfunction animate() {\n  mymesh.rotatey(0.01);\t\t\t\t\t\t//每次绕y轴旋转0.01弧度\n  myrenderer.render(myscene, mycamera);\n  requestanimationframe(animate);\n};\n\n\n\n\n\n# 003-圆柱体旋转\n\n\n# 创建圆柱体\n\nvar mygeometry = new three.cylindergeometry(80, 80, 100, 25);\nvar mymaterial = new three.meshbasicmaterial({\n  color: 'gray',\n  wireframe: true\n});\nvar mymesh = new three.mesh(mygeometry, mymaterial);\nmyscene.add(mymesh);\n\n\n\n# 渲染(旋转)圆柱体\n\nvar t0 = new date();                                       //上次时间\nanimate();\nfunction animate() {\n  var t1 = new date();                                     //本次时间\n  var t = t1 - t0;                                         //两次时间差\n  t0 = t1;                                 //把本次时间赋值给上次时间\n  mymesh.rotatey(0.001 * t);               //旋转角速度0.001弧度每毫秒\n  myrenderer.render(myscene, mycamera);                 //执行渲染操作\n  window.requestanimationframe(animate);           //请求再次执行渲染\n};\n\n\n\n\n\n# 004-根据纹理创建立方体旋转\n\n\n# 创建纹理立方体\n\n//创建纹理图像(贴图)\nvar mymap = three.imageutils.loadtexture(\"images/img001.jpg\");\n//根据纹理图像(贴图)创建材质\nvar mymaterial = new three.meshphongmaterial({map: mymap});\n//使用图像材质创建立方体\nvar mygeometry = new three.cubegeometry(1, 1, 1);\nvar mymesh = new three.mesh(mygeometry, mymaterial);\nmyscene.add(mymesh);\n//渲染(旋转)立方体\nanimate();\nfunction animate() {\n  myrenderer.render(myscene, mycamera);\n  mymesh.rotation.x += 0.02;\n  mymesh.rotation.y += 0.02;\n  requestanimationframe(animate);\n}\n\n\n\n\n\n# 005-救生圈旋转\n\n\n# 创建救生圈\n\n//加载图像生成纹理\nvar mymap = new three.textureloader().load(\"images/img002.jpg\");\nmymap.wraps = mymap.wrapt = three.repeatwrapping;\nmymap.anisotropy = 16;\n//创建材质\nvar mymaterial = new three.meshlambertmaterial({ map: mymap, side: three.doubleside });\n//var mymaterial = new three.meshphongmaterial({map: mymap});\n//创建圆环(救生圈)\nvar mygeometry = new three.torusgeometry(50, 20, 20, 20);\nvar mymesh = new three.mesh(mygeometry, mymaterial);\nmymesh.position.set(0, 0, 200);\nmyscene.add(mymesh);\n//渲染救生圈\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  var mytimer = date.now() * 0.0001;\n  mycamera.position.x = math.cos(mytimer) * 400;\n  mycamera.position.y = math.cos(mytimer) * 400;\n  mycamera.position.z = math.sin(mytimer) * 400;\n  mycamera.lookat(myscene.position);\n  mymesh.rotation.x = mytimer * 5;\n  mymesh.rotation.y = mytimer * 3;\n  mymesh.rotation.z = mytimer * 2;\n  myrenderer.render(myscene, mycamera);\n}\n\n\n\n# 006-平面旋转\n\n\n# 创建平面\n\n//创建平面\nvar myplanegeometry = new three.planegeometry(160, 240, 5, 5);\nvar mymap = three.imageutils.loadtexture(\"images/img137.jpg\");\nvar myplane = new three.mesh(myplanegeometry, new three.meshphongmaterial({\n  map: mymap,\n  side: three.doubleside\n}));\nmyscene.add(myplane);\n//渲染平面\nanimate();\nfunction animate() {\n  myrenderer.render(myscene, mycamera);\n  myplane.rotation.y += 0.01;\n  requestanimationframe(animate);\n}\n\n\n\n# 007-曲面旋转\n\n\n# 创建完整曲面\n\n//根据三角函数设置样条曲线的点\nvar mypoints = [];\nfor (var i = 0; i < 90; i++) {\n  mypoints.push(new three.vector2(math.sin(i * 0.2) * math.sin(i * 0.1) * 15 + 50, (i - 5) * 2));\n}\n//创建整周样条曲线图形\nvar mygeometry = new three.lathegeometry(mypoints, 400);\nvar mymap = new three.textureloader().load(\"images/img002.jpg\");\nmymap.wraps = mymap.wrapt = three.repeatwrapping;\nmymap.anisotropy = 16;\nvar mymaterial = new three.meshbasicmaterial({ map: mymap, side: three.doubleside });\nvar mymesh = new three.mesh(mygeometry, mymaterial);\nmymesh.position.set(0, 0, 0);\nmyscene.add(mymesh);\n//渲染整周样条曲线图形\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  var mytimer = date.now() * 0.0001;\n  mycamera.position.x = math.cos(mytimer) * 340;\n  mycamera.position.y = math.cos(mytimer) * 340;\n  mycamera.position.z = math.sin(mytimer) * 340;\n  mycamera.lookat(myscene.position);\n  mymesh.rotation.x = mytimer * 5;\n  mymesh.rotation.y = mytimer * 3;\n  mymesh.rotation.z = mytimer * 2;\n  myrenderer.render(myscene, mycamera);\n}\n\n\n\n\n\n# 创建半面曲面\n\n//根据三角函数设置样条曲线的点\nvar mypoints = [];\nfor ( var i = 0; i < 90; i ++ ) {\n  mypoints.push( new three.vector2( math.sin( i * 0.2 ) * math.sin( i * 0.1 ) * 15 + 50, ( i - 5 ) * 2 ) );\n}\n//创建半周样条曲线图形\nvar mygeometry =new three.lathegeometry(mypoints, 400,0,math.pi);\nvar mymap = new three.textureloader().load(\"images/img002.jpg\");\nmymap.wraps = mymap.wrapt = three.repeatwrapping;\nmymap.anisotropy = 16;\nvar mymaterial =new three.meshbasicmaterial(\n  {map:mymap,side:three.doubleside});\nvar mymesh = new three.mesh(mygeometry,mymaterial);\nmymesh.position.set( 0, 0, 0 );\nmyscene.add(mymesh);\n//渲染半周样条曲线图形\nanimate();\nfunction animate() {\n  requestanimationframe(animate );\n  var mytimer = date.now() * 0.0001;\n  mycamera.position.x = math.cos( mytimer ) *340;\n  mycamera.position.y = math.cos( mytimer ) * 340;\n  mycamera.position.z = math.sin( mytimer ) *340;\n  mycamera.lookat( myscene.position );\n  mymesh.rotation.x = mytimer * 5;\n  mymesh.rotation.y = mytimer * 3;\n  mymesh.rotation.z = mytimer * 2;\n  myrenderer.render( myscene, mycamera );\n}\n\n\n\n\n\n# 008-圆环\n\n\n# 圆环\n\n//创建渲染器\nvar myrenderer= new three.webglrenderer({antialias: true});\nmyrenderer.setsize(window.innerwidth,window.innerheight);\nmyrenderer.setclearcolor('white', 1.0);\n$(\"#mycontainer\").append(myrenderer.domelement);\nvar mycamera= new three.perspectivecamera( 45,window.innerwidth / window.innerheight, 1, 1000 );\nvar myscene = new three.scene();\n// 添加环境光\nmyscene.add(new three.ambientlight('yellow'));\nvar mylight = new three.directionallight('white' );\nmylight.position.set(0,1,0);\nmyscene.add(mylight);\n//加载图像生成纹理(贴图)\nvar mymap = new three.textureloader().load(\"images/img006.jpg\");\nmymap.wraps = mymap.wrapt = three.repeatwrapping;\nmymap.anisotropy = 16;\n//创建贴图材质\nvar mymaterial=new three.meshlambertmaterial({\n  map:mymap,\n  side:three.doubleside\n});\n//创建圆环面\nvar mygeometry=new three.ringgeometry(40, 180, 1000);\nvar mymesh = new three.mesh(mygeometry,mymaterial);\nmymesh.position.set( 0, 0, 0 );\nmyscene.add(mymesh);\n//渲染圆环面\nanimate();\nfunction animate() {\n  requestanimationframe(animate );\n  var mytimer = date.now() * 0.0001;\n  mycamera.position.x = math.cos( mytimer ) * 400;\n  mycamera.position.y = math.cos( mytimer ) * 400;\n  mycamera.position.z = math.sin( mytimer ) * 400;\n  mycamera.lookat( myscene.position );\n  mymesh.rotation.x = mytimer * 5;\n  mymesh.rotation.y = mytimer * 3;\n  mymesh.rotation.z = mytimer * 2;\n  myrenderer.render( myscene, mycamera );\n}\n\n\n\n\n\n# 扇形\n\n// 把 创建圆环面 更改成 创建扇面图形\nvar mygeometry=new three.ringgeometry(40, 180, 200,8,math.pi/4,math.pi*2/8*6);\nvar mymesh = new three.mesh(mygeometry,mymaterial);\nmymesh.position.set( 0, 0, 0 );\nmyscene.add(mymesh);\n\n\n\n\n\n# ambientlight-环境光\n\n环境光会均匀的照亮场景中的所有物体。\n\n环境光不能用来投射阴影，因为它没有方向。\n\n# 代码示例\n\nconst light = new three.ambientlight( 0x404040 );\n// soft white light scene.add( light );\n\n\n# 构造函数\n\nambientlight( color : integer, intensity : float )\n\n * color - (参数可选）颜色的rgb数值。缺省值为 0xffffff。\n * intensity - (参数可选)光照的强度。缺省值为 1。\n\n创建一个环境光对象。\n\n# 属性\n\n * .castshadow : boolean\n   * 这个参数在对象构造的时候就被设置成了 undefined 。因为环境光不能投射阴影。\n * .isambientlight : boolean\n   * read-only flag to check if a given object is of type ambientlight.\n\n\n# 009-柱状图浮动\n\n//创建渲染器\nvar myrenderer = new three.webglrenderer({ antialias: true });\nmyrenderer.setsize(window.innerwidth, window.innerheight);\nmyrenderer.setclearcolor('white', 1.0);\n$(\"#mycontainer\").append(myrenderer.domelement);\nvar mycamera = new three.perspectivecamera(45, 1, 1, 1000);\nmycamera.position.set(200, 200, 200);\nmycamera.lookat({ x: 0, y: 0, z: 0 });\nvar myscene = new three.scene();\nvar mypointlight = new three.pointlight('white');\nmypointlight.position.set(20, 200, 30);\nmyscene.add(mypointlight);\n//创建矩形\nvar myshape = new three.shape();\n//四条直线(线条)绘制一个矩形\nmyshape.moveto(-10, -10);\t\t\t\t\t\t          //绘制起点\nmyshape.lineto(-10, 10);\t\t\t\t\t\t\t\t//第2个顶点\nmyshape.lineto(10, 10);\t\t\t\t\t\t\t\t\t//第3个顶点\nmyshape.lineto(10, -10);\t\t\t\t\t\t\t\t//第4个顶点\nmyshape.lineto(-10, -10);\t\t\t\t\t\t\t\t//第5个顶点\n//设置在y轴方向拉伸矩形\nvar mycurve = new three.catmullromcurve3([\n  new three.vector3(0, 0, 0), new three.vector3(0, 40, 0)]);\nvar mygeometry = new three.extrudegeometry(myshape, { extrudepath: mycurve });\nvar mymaterial = new three.meshphongmaterial({ color: 'cyan' });\n//创建多个矩形\nvar myarray = [];\nfor (var i = 0; i < 6; i++) {\n  var mymeshes = [];\n  for (var j = 0; j < 6; j++) {\n    var mymesh = new three.mesh(mygeometry, mymaterial);\n    myscene.add(mymesh);\n    mymesh.translatex(-100 + 30 * i);\n    mymesh.translatez(-100 + 30 * j);\n    mymesh.translatey(-50);\n    mymeshes.push(mymesh);\n  }\n  myarray.push(mymeshes);\n}\n//渲染图形\nanimate();\nvar z = 0;\nfunction animate() {\n  myrenderer.render(myscene, mycamera);\n  z = z + 0.01;\n  for (var u = 0; u < myarray.length; u++) {\n    for (var v = 0; v < myarray[u].length; v++) {\n      var myscale = 2 * math.sin(z + 100 / u - 100 / v) + 2;\n      myarray[u][v].scale.y = myscale;\n    }\n  }\n  requestanimationframe(animate);\n}\n\n\n\n\n\n# 010-圆柱上下浮动\n\n//创建渲染器\nvar myrenderer = new three.webglrenderer({ antialias: true });\nmyrenderer.setsize(window.innerwidth, window.innerheight);\nmyrenderer.setclearcolor('white', 1.0);\n$(\"#mycontainer\").append(myrenderer.domelement);\nvar mycamera = new three.perspectivecamera(45, 1, 1, 1000);\nmycamera.position.set(200, 200, 200);\nmycamera.lookat({ x: 0, y: 0, z: 0 });\nvar myscene = new three.scene();\nvar mypointlight = new three.pointlight('white');\nmypointlight.position.set(320, 200, 400);\nmyscene.add(mypointlight);\n//创建圆角矩形\nvar myshape = new three.shape();\nvar x = 0, y = 0, mywidth = 30, myheight = 40, myradius = 6\nmyshape.moveto(x, y + myradius);\nmyshape.lineto(x, y + myheight - myradius);\nmyshape.quadraticcurveto(x, y + myheight, x + myradius, y + myheight);\nmyshape.lineto(x + mywidth - myradius, y + myheight);\nmyshape.quadraticcurveto(x + mywidth, y + myheight, x + mywidth, y + myheight - myradius);\nmyshape.lineto(x + mywidth, y + myradius);\nmyshape.quadraticcurveto(x + mywidth, y, x + mywidth - myradius, y);\nmyshape.lineto(x + myradius, y);\nmyshape.quadraticcurveto(x, y, x, y + myradius);\n//设置拉伸圆角矩形的路径\nvar mycurve = new three.catmullromcurve3([\n  new three.vector3(0, 0, 0), new three.vector3(0, 30, 0)]);\n//创建拉伸之后的圆角矩形\nvar mygeometry = new three.extrudegeometry(myshape, { extrudepath: mycurve });\nvar mymaterial = new three.meshphongmaterial({ color: 'cyan' });\nvar mymesh = new three.mesh(mygeometry, mymaterial);\nmymesh.translatex(100);\nmymesh.translatez(100);\nmymesh.translatey(0);\nmyscene.add(mymesh);\n//渲染圆角矩形\nanimate();\nvar step = 0;\nfunction animate() {\n  myrenderer.render(myscene, mycamera);\n  step = step + 0.01;\n  var myscale = 2 * math.sin(step) + 2;\n  mymesh.scale.y = myscale;\n  mymesh.scale.x = 2;\n  mymesh.scale.z = 2;\n  requestanimationframe(animate);\n}\n\n\n\n\n\n# 011-旋转球体\n\n//创建渲染器\nvar myrenderer = new three.webglrenderer({ antialias: true });\nmyrenderer.setpixelratio(window.devicepixelratio);\nmyrenderer.setsize(window.innerwidth, window.innerheight);\n$(\"#mycontainer\").append(myrenderer.domelement);\nvar myclock = new three.clock();\nvar mycamera = new three.perspectivecamera(60,\n                                           window.innerwidth / window.innerheight, 1, 10000);\nmycamera.position.set(0, 100, 300);\nmycamera.lookat(new three.vector3(0, 0, 0))\nvar myscene = new three.scene();\nmyscene.background = new three.color('white');\nmyscene.add(new three.ambientlight('lightgreen'));\n//创建球体(地球)\nvar mygeometry = new three.spherebuffergeometry(120, 64, 64);\nvar mymap = new three.textureloader().load('images/img007.png');\nvar mymaterial = new three.meshphongmaterial({ map: mymap });\nvar mymesh = new three.mesh(mygeometry, mymaterial);\nmyscene.add(mymesh);\n//渲染(旋转)球体(地球)\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  var delta = myclock.getdelta();\n  myrenderer.render(myscene, mycamera);\n  //按照设置的角度增量实现绕y轴旋转地球\n  mymesh.rotation.y += delta / 5;\n}\n\n\n\n\n\n# 012-球体在平面上的弹跳动画\n\n//创建渲染器\nvar myrenderer = new three.webglrenderer({ antialias: true });\nmyrenderer.setsize(window.innerwidth, window.innerheight);\nmyrenderer.setclearcolor('white', 1.0);\nmyrenderer.shadowmapenabled = true;\n$(\"#mycontainer\").append(myrenderer.domelement);\nvar myscene = new three.scene();\nvar mycamera = new three.perspectivecamera(45, window.innerwidth / window.innerheight, 0.1, 1000);\nmycamera.position.set(64.7, 15.1, 17.8);\nmycamera.lookat(myscene.position);\nvar myspotlight = new three.spotlight(0xffffff);\nmyspotlight.position.set(-40, 40, -15);\nmyspotlight.castshadow = true;\nmyspotlight.shadow.mapsize = new three.vector2(1024, 1024);\nmyspotlight.shadow.camera.far = 130;\nmyspotlight.shadow.camera.near = 40;\nmyscene.add(myspotlight);\nmyscene.add(new three.ambientlight(0x353535));\n//在场景中绘制xyz坐标轴的轴线(红线是x轴，绿线是y轴，蓝线是z轴)\nmyscene.add(new three.axeshelper(120));\n//在场景中绘制网格线\nmyscene.add(new three.gridhelper(100, 30, 0x2c2c2c, 0x888888));\n//创建平面\nvar myplanegeometry = new three.planegeometry(60, 100, 1, 1);\nvar myplanematerial = new three.meshlambertmaterial({ color: 0xffffff });\nvar myplanemesh = new three.mesh(myplanegeometry, myplanematerial);\nmyplanemesh.rotation.x = -0.5 * math.pi;\nmyplanemesh.position.x = 26;\nmyplanemesh.position.y = 0;\nmyplanemesh.position.z = 0;\nmyplanemesh.receiveshadow = true;\nmyscene.add(myplanemesh);\n//创建球体\nvar myspheregeometry = new three.spheregeometry(4, 20, 20);\nvar myspherematerial = new three.meshlambertmaterial({ color: 'red' });\nvar myspheremesh = new three.mesh(myspheregeometry, myspherematerial);\nmyspheremesh.position.x = 20;\nmyspheremesh.position.y = 4;\nmyspheremesh.position.z = 2;\nmyspheremesh.castshadow = true;\nmyscene.add(myspheremesh);\n//渲染球体在平面上的弹跳动画\nanimate();\nvar step = 0;\nfunction animate() {\n  step += 0.05;\n  myspheremesh.position.x = 20 + (10 * math.cos(step));\n  myspheremesh.position.y = 2 + (10 * math.abs(math.sin(step)));\n  requestanimationframe(animate);\n  myrenderer.render(myscene, mycamera);\n}\n\n\n\n\n\n# 013-模拟日照房子效果\n\n//创建渲染器\nvar myrenderer = new three.webglrenderer({ antialias: true });\nmyrenderer.setsize(window.innerwidth, window.innerheight);\nmyrenderer.shadowmap.enabled = true;\n$(\"#mycontainer\").append(myrenderer.domelement);\nvar myscene = new three.scene();\nvar mycamera = new three.perspectivecamera(45, window.innerwidth / window.innerheight, 0.1, 100);\nmycamera.position.x = -30;\nmycamera.position.y = 40;\nmycamera.position.z = 40;\nmycamera.lookat(myscene.position);\nmyscene.add(mycamera);\n//创建three.pointlight光源\nvar mypointlight = new three.pointlight(0xffffff);\nmypointlight.castshadow = true;\nmypointlight.shadow.mapsize.set(2048, 2048);\nmypointlight.decay = 0.1\nmyscene.add(mypointlight);\n//添加光源图形(被圆球代替)\nvar mypointlighthelper = new three.pointlighthelper(mypointlight);\n//var mypointlighthelper=new three.pointlighthelper(mypointlight,5,'green');\nmyscene.add(mypointlighthelper);\n//绘制(拍摄)光线阴影\nvar mycamerahelper = new three.camerahelper(mypointlight.shadow.camera)\nmyscene.add(mycamerahelper)\nmyscene.add(new three.ambientlight(0x353535, 1));\n//创建圆球模拟光源\nvar myspherelight = new three.spheregeometry(3, 40, 40);\nvar myspherelightmaterial = new three.meshbasicmaterial({ color: 0xffff00 });\nvar myspherelightmesh = new three.mesh(myspherelight, myspherelightmaterial);\nmyspherelightmesh.position.set(0, 8, 2);\nmyscene.add(myspherelightmesh);\n//创建接收阴影的平面\nvar myplanegeomerty = new three.planegeometry(60, 40, 1, 1);\nvar myplanematerial = new three.meshlambertmaterial({ color: 0xffffff });\nvar myplanemesh = new three.mesh(myplanegeomerty, myplanematerial);\nmyplanemesh.rotation.x = -0.5 * math.pi;\nmyplanemesh.receiveshadow = true;\nmyscene.add(myplanemesh);\n//创建立方体\nvar myboxgeometry = new three.boxgeometry(6, 6, 6);\nvar myboxmaterial = new three.meshlambertmaterial({ color: 0x00ffff });\nvar myboxmesh = new three.mesh(myboxgeometry, myboxmaterial);\nmyboxmesh.castshadow = true;\nmyboxmesh.position.x = 2;\nmyboxmesh.position.y = 2;\nmyboxmesh.position.z = 2;\nmyscene.add(myboxmesh);\n//渲染所有图形\nvar step = 0;\nanimate();\nfunction animate() {\n  mypointlighthelper.update();\n  mycamerahelper.update();\n  step += 0.01;\n  myspherelightmesh.position.x = 20 + (10 * math.cos(step));\n  myspherelightmesh.position.y = 12 + (10 * math.abs(math.sin(step)));\n  myspherelightmesh.translatex(-22);\n  //使用圆球的位置作为光源位置\n  mypointlight.position.copy(myspherelightmesh.position);\n  requestanimationframe(animate);\n  myrenderer.render(myscene, mycamera);\n}\n\n\n\n# 014-模拟长大\n\n//创建渲染器\nvar myrenderer = new three.webglrenderer({ antialias: true });\nmyrenderer.setsize(window.innerwidth, window.innerheight);\nmyrenderer.setclearcolor('white', 1.0);\nmyrenderer.shadowmap.enabled = true;\nmyrenderer.shadowmap.type = three.pcfsoftshadowmap;\n$(\"#mycontainer\").append(myrenderer.domelement);\nvar mycamera = new three.perspectivecamera(45, window.innerwidth / window.innerheight, 0.1, 1000);\nmycamera.position.set(0, 40, 50);\nmycamera.lookat(new three.vector3(0, 0, 0));\nvar myscene = new three.scene();\nmyscene.add(new three.ambientlight(0x444444));\nvar mylight = new three.pointlight(0xffffff);\nmylight.position.set(-40, 30, -20);\nmylight.castshadow = true;\nmyscene.add(mylight);\n//创建投影(阴影)平面\nvar myplanegeometry = new three.planegeometry(100, 100);\nvar myplanematerial = new three.meshstandardmaterial({ color: 0xaaaaaa });\nvar myplanemesh = new three.mesh(myplanegeometry, myplanematerial);\nmyplanemesh.rotation.x = - 0.5 * math.pi;\nmyplanemesh.position.y = -10;\nmyplanemesh.receiveshadow = true;\nmyscene.add(myplanemesh);\n//创建圆柱体\nvar mycylindergeometry = new three.cylindergeometry(10, 10, 60, 40, 20);\nvar mycylindermaterial = new three.meshphongmaterial({ color: 0xff5f4d });\nvar mycylindermesh = new three.mesh(mycylindergeometry, mycylindermaterial);\nmycylindermesh.position.set(-10, -14, -10);\nmycylindermesh.castshadow = true;\nmyscene.add(mycylindermesh);\n//渲染投影圆柱体\nanimate();\nvar mystep = 0;\nfunction animate() {\n  myrenderer.render(myscene, mycamera);\n  //在xyz方向缩放圆柱体\n  mystep += 0.01;\n  mycylindermesh.scale.x = math.abs(math.sin(mystep));\n  mycylindermesh.scale.y = math.abs(math.cos(mystep));\n  mycylindermesh.scale.z = math.abs(math.sin(mystep));\n  requestanimationframe(animate);\n}\n\n\n\n\n\n# 015-球体在太阳下的移动\n\n//创建渲染器\nvar myrenderer = new three.webglrenderer({ antialias: true });\nmyrenderer.setsize(window.innerwidth, window.innerheight);\nmyrenderer.setclearcolor('white', 1.0);\nmyrenderer.shadowmap.enabled = true;\nmyrenderer.shadowmap.type = three.pcfsoftshadowmap;\n$(\"#mycontainer\").append(myrenderer.domelement);\nvar mycamera = new three.perspectivecamera(45,\n                                           window.innerwidth / window.innerheight, 0.1, 1000);\nmycamera.position.set(0, 40, 50);\nmycamera.lookat(new three.vector3(0, 0, 0));\nvar myscene = new three.scene();\nmyscene.add(new three.ambientlight(0x444444));\nvar mylight = new three.pointlight(0xffffff);\nmylight.position.set(-10, 200, -20);\nmylight.castshadow = true;\nmyscene.add(mylight);\n//创建投影(阴影)平面\nvar myplanegeometry = new three.planegeometry(100, 100);\nvar myplanematerial = new three.meshstandardmaterial({ color: 0xaaaaaa });\nvar myplanemesh = new three.mesh(myplanegeometry, myplanematerial);\nmyplanemesh.rotation.x = - 0.5 * math.pi;\nmyplanemesh.receiveshadow = true;\nmyscene.add(myplanemesh);\n//创建球体\nvar myspheregeometry = new three.spheregeometry(5, 60, 60);\nvar myspherematerial = new three.meshlambertmaterial({ color: 0x00ff00 });\nmyspheremesh = new three.mesh(myspheregeometry, myspherematerial);\nmyspheremesh.position.x = 40;\nmyspheremesh.position.y = 20;\nmyspheremesh.position.z = 10;\n//设置球体需要投射阴影\nmyspheremesh.castshadow = true;\nmyscene.add(myspheremesh);\n//渲染投影球体\nanimate();\nvar mystep = 0;\nfunction animate() {\n  myrenderer.render(myscene, mycamera);\n  //处理位置变化的球体的移动\n  mystep += 0.05;\n  myspheremesh.position.x = 10 * math.cos(mystep) - 10;\n  myspheremesh.position.y = 5 + math.abs(math.sin(mystep)) * 10;\n  requestanimationframe(animate);\n}\n\n\n\n\n\n# 016-加载模型并旋转\n\nvar myrenderer, mycamera, myscene, myorbitcontrols;\n//创建渲染器\nfunction initrender() {\n  myrenderer = new three.webglrenderer({ antialias: true });\n  myrenderer.setsize(window.innerwidth, window.innerheight);\n  myrenderer.setclearcolor(0xffffff);\n  document.body.appendchild(myrenderer.domelement);\n  mycamera = new three.perspectivecamera(45,\n                                         window.innerwidth / window.innerheight, 0.1, 1000);\n  mycamera.position.set(0, 4, 5);\n  mycamera.lookat(new three.vector3(0, 0, 0));\n  myscene = new three.scene();\n  myscene.add(new three.ambientlight(0x444444));\n  var mylight = new three.pointlight(0xffffff);\n  mylight.position.set(0, 10, 10);\n  myscene.add(mylight);\n}\n//加载并创建blender生成的json格式的模型\nfunction initmodel() {\n  var myobjectloader = new three.objectloader();\n  myobjectloader.load(\"data/misc_chair01.json\", function (obj) {\n    obj.position.y = -1.25;\n    obj.scale.set(1.5, 1.5, 1.5);\n    myscene.add(obj);\n  });\n}\n//创建轨道控制器(允许自动旋转)\nfunction initcontrols() {\n  myorbitcontrols = new three.orbitcontrols(mycamera);\n  myorbitcontrols.autorotate = true;\n  myorbitcontrols.autorotatespeed = 3.5;\n}\n//渲染模型\nfunction animate() {\n  myrenderer.render(myscene, mycamera);\n  myorbitcontrols.update();\n  requestanimationframe(animate);\n}\ninitrender();\ninitmodel();\ninitcontrols();\nanimate();\n\n\n\n\n\n# 017-球体在x方向重复2次，在y方向重复1次\n\n//根据贴图创建球体\nvar mytexture = three.imageutils.loadtexture(\"images/img089.jpg\");\nmytexture.wraps = three.repeatwrapping;\nmytexture.wrapt = three.repeatwrapping;\n//设置在x方向重复2次，在y方向重复1次贴图\nmytexture.repeat.set(2, 1);\nvar mymaterial = new three.meshlambertmaterial();\nmymaterial.map = mytexture;\nvar mygeometry = new three.spheregeometry(60, 50, 50);\nvar mymesh = new three.mesh(mygeometry, mymaterial);\nmymesh.position.x = 1;\nmyscene.add(mymesh);\n//渲染球体\nanimate();\nvar step = 0;\nfunction animate() {\n  step += 0.01;\n  mymesh.rotation.y = step;\n  mymesh.rotation.x = step;\n  requestanimationframe(animate);\n  myrenderer.render(myscene, mycamera);\n}\n//响应单击“在x方向重复2次”按钮\n$(\"#mybutton1\").click(function () {\n  mymaterial.map.repeat.set(2, 1);\n});\n//响应单击“在x方向重复10次”按钮\n$(\"#mybutton2\").click(function () {\n  mymaterial.map.repeat.set(10, 1);\n});\n\n\n\n# 018-动态波浪\n\n\n# 法向量贴图创建动态波浪\n\n<script src=\"threejs/reflector.js\"><\/script>\n<script src=\"threejs/refractor.js\"><\/script>\n<script src=\"threejs/water2.js\"><\/script>\n\n\n//创建渲染器\nvar myrenderer = new three.webglrenderer({ antialias: true });\nmyrenderer.setsize(window.innerwidth, window.innerheight);\nmyrenderer.setclearcolor('white', 1.0);\n$(\"#mycontainer\").append(myrenderer.domelement);\nvar myscene = new three.scene();\nvar mycamera = new three.perspectivecamera(45,\n                                           window.innerwidth / window.innerheight, 0.1, 1000);\nmycamera.position.set(0, 25, 0);\nmycamera.lookat(myscene.position);\n//创建动态波浪平面\nvar mytextureloader = new three.textureloader();\nvar mymap = mytextureloader.load('images/img111.jpg');\nvar mygeometry = new three.planebuffergeometry(\n  window.innerwidth / 10, window.innerheight / 10);\nvar mymaterial = new three.meshbasicmaterial({ map: mymap });\nvar myplanemesh = new three.mesh(mygeometry, mymaterial);\nmyplanemesh.rotation.x = math.pi * -0.5;\nmyscene.add(myplanemesh);\n//使用法向量贴图创建动态波浪\nvar mywaterwave = new three.water(mygeometry, {\n  normalmap0: mytextureloader.load(\"images/img112.jpg\"),\n  normalmap1: mytextureloader.load(\"images/img113.jpg\")\n});\n//使水波层的旋转角度与平面层保持一致\nmywaterwave.rotation.x = math.pi * -0.5;\nmywaterwave.position.y = 0.05;\nmyscene.add(mywaterwave);\n//渲染动态波浪\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  myrenderer.render(myscene, mycamera);\n}\n\n\n\n\n\n# 使用更新平面顶点坐标达到波浪效果\n\n//创建渲染器\nvar myrenderer = new three.webglrenderer({ antialias: true });\nmyrenderer.setsize(window.innerwidth, window.innerheight);\n$(\"#mycontainer\").append(myrenderer.domelement);\nvar myscene = new three.scene();\nmyscene.background = new three.color('white');\nvar mycamera = new three.perspectivecamera(45,\n                                           window.innerwidth / window.innerheight, 0.01, 1000);\nmyscene.add(new three.ambientlight(0xffffff));\nmycamera.position.set(0, 90, 300);\nmycamera.lookat(myscene.position);\n$(\"#mycontainer\").append(myrenderer.domelement);\n//创建贴图平面(平面图形)\nvar mygeometry = new three.planegeometry(window.innerwidth,\n                                         window.innerheight, 100, 100);\nvar mytexture = three.imageutils.loadtexture(\"images/img111.jpg\");\nvar mymaterial = new three.meshphongmaterial({ map: mytexture });\nvar myplanemesh = new three.mesh(mygeometry, mymaterial);\nmyplanemesh.rotation.x = -math.pi / 4;\nmyscene.add(myplanemesh);\n//渲染在平面上实现的波浪效果\nvar iswave = true;\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  if (iswave) {\n    //获取平面图形的顶点数\n    var myverticeslength = myplanemesh.geometry.vertices.length;\n    for (var i = 0; i < myverticeslength; i++) {\n      //以迭代方式获取顶点坐标\n      var v = myplanemesh.geometry.vertices[i];\n      //根据正弦波算法动态设置顶点的z坐标，从而实现波浪效果\n      v.z = math.sin(date.now() / 200 + (v.x * (myverticeslength / 2)) *\n                     (v.y / (myverticeslength / 2))) * 3;\n    }\n    //更新平面顶点坐标\n    myplanemesh.geometry.verticesneedupdate = true;\n  }\n  myrenderer.render(myscene, mycamera);\n}\n//响应单击“添加波浪效果”按钮\n$(\"#mybutton1\").click(function () {\n  iswave = true;\n});\n//响应单击“删除波浪效果”按钮\n$(\"#mybutton2\").click(function () {\n  iswave = false;\n  var myverticeslength = myplanemesh.geometry.vertices.length;\n  for (var i = 0; i < myverticeslength; i++) {\n    //重置平面顶点的z坐标，使平面以默认样式显示\n    myplanemesh.geometry.vertices[i].z = 0;\n  }\n  myplanemesh.geometry.verticesneedupdate = true;\n});\n\n\n\n# 019-下雪效果\n\n//创建渲染器\nvar myrenderer = new three.webglrenderer({ antialias: true });\nmyrenderer.setsize(window.innerwidth, window.innerheight);\n$(\"#mycontainer\").append(myrenderer.domelement);\nvar myscene = new three.scene();\nvar mycamera = new three.perspectivecamera(45,\n                                           window.innerwidth / window.innerheight, 2, 500);\nmycamera.position.set(0, 0, 40);\nmyscene.add(mycamera);\nmyscene.background = new three.textureloader().load('images/img004.jpg');\n//创建多个雪花\nvar mymap = new three.textureloader().load('images/img109.png');\nvar mypointsmaterials = [];\nfor (var i = 0; i < 2; i++) {\n  var mypointsmaterial = new three.pointsmaterial({\n    size: 2, map: mymap, blending: three.additiveblending\n  });\n  mypointsmaterial.map.offset = new three.vector2(1 / 2 * i, 0);\n  mypointsmaterial.map.repeat = new three.vector2(1 / 2, 1);\n  mypointsmaterials.push(mypointsmaterial);\n}\nvar mygeometries = [];\nfor (var k = 0; k < 2; k++) {\n  var mygeometry = new three.geometry();\n  for (var i = 0; i < 100; i++) {\n    var myvector = new three.vector3(math.random() * 50 - 25,\n                                     math.random() * 50 - 25, math.random() * 50 - 25);\n    myvector.velocityy = 0.1 + math.random() / 5;\n    myvector.velocityx = (math.random() - 0.5) / 3;\n    myvector.velocityz = (math.random() - 0.5) / 3;\n    mygeometry.vertices.push(myvector);\n  }\n  mygeometries.push(mygeometry);\n}\nvar mygroup = [];\nfor (var i = 0; i < 2; i++) {\n  var mypoints = new three.points(mygeometries[i], mypointsmaterials[i]);\n  mygroup.push(mypoints);\n  myscene.add(mypoints);\n}\n//渲染多个雪花\nanimate();\nfunction animate() {\n  mygroup.foreach(function (points, i) {\n    var myvertices = points.geometry.vertices;\n    myvertices.foreach(function (v, idx) {\n      v.y = v.y - (v.velocityy);\n      v.x = v.x - (v.velocityx);\n      v.z = v.z - (v.velocityz);\n      if (v.y <= -25) v.y = 25;\n      if (v.x <= -25 || v.x >= 25) v.x = -v.x;\n      if (v.z <= -25 || v.z >= 25) v.velocityz = -v.velocityz;\n    });\n    points.geometry.verticesneedupdate = true;\n  });\n  myrenderer.render(myscene, mycamera);\n  requestanimationframe(animate);\n}\n\n\n\n\n\n# 020-按轨迹运动\n\n//创建渲染器\nvar myrenderer = new three.webglrenderer({ antialias: true });\nmyrenderer.setsize(window.innerwidth, window.innerheight);\n$(\"#mycontainer\").append(myrenderer.domelement);\nvar myscene = new three.scene();\nmyscene.background = new three.color('white');\nvar mycamera = new three.perspectivecamera(45,\n                                           window.innerwidth / window.innerheight, 1, 1000);\nmycamera.position.set(0, 0, 200);\nmyscene.add(mycamera);\nmyscene.add(new three.ambientlight(0xffffff));\n//设置中心点坐标\nvar x = -20, y = -40;\n//使用贝塞尔曲线生成桃心\nvar myshape = new three.shape().moveto(x + 25, y + 25)\n.beziercurveto(x + 25, y + 25, x + 20, y, x, y)\n.beziercurveto(x - 30, y, x - 30, y + 35, x - 30, y + 35)\n.beziercurveto(x - 30, y + 55, x - 10, y + 77, x + 25, y + 95)\n.beziercurveto(x + 60, y + 77, x + 80, y + 55, x + 80, y + 35)\n.beziercurveto(x + 80, y + 35, x + 80, y, x + 50, y)\n.beziercurveto(x + 35, y, x + 25, y + 25, x + 25, y + 25);\nvar mypoints = myshape.getpoints();\nvar mygeometrypoints = new three.buffergeometry().setfrompoints(mypoints);\nmyheart = new three.points(mygeometrypoints,\n                           new three.pointsmaterial({ color: 0xff0000, size: 6 }));\nmyscene.add(myheart);\n//创建小球\nvar mygeometry = new three.spheregeometry(10, 10, 10);\nvar mytexture = three.imageutils.loadtexture(\"images/img055.jpg\");\nvar mymaterial = new three.meshbasicmaterial({ map: mytexture });\nvar mysphere = new three.mesh(mygeometry, mymaterial);\nmyscene.add(mysphere);\n//渲染小球沿着桃心曲线移动\nvar myindex = 0;\nvar mylength = mypoints.length;\nanimate();\nfunction animate() {\n  myrenderer.render(myscene, mycamera);\n  if (myindex == mylength - 1) { myindex = 0; }\n  else { myindex += 1; }\n  mysphere.position.set(mypoints[myindex].x, mypoints[myindex].y, 0);\n  requestanimationframe(animate);\n}\n\n\n\n\n\n# 021-镜像平铺\n\n//创建渲染器\nvar myrenderer = new three.webglrenderer({ antialias: true });\nmyrenderer.setsize(window.innerwidth, window.innerheight);\n$(\"#mycontainer\").append(myrenderer.domelement);\nvar myscene = new three.scene();\nmyscene.background = new three.color('white');\nvar mycamera = new three.perspectivecamera(45,\n                                           window.innerwidth / window.innerheight, 0.01, 1000);\nmyscene.add(new three.ambientlight(0xffffff));\nmycamera.position.set(-28.03, -10.96, 311.75);\nmycamera.lookat(myscene.position);\n$(\"#mycontainer\").append(myrenderer.domelement);\n//创建平面图形\nvar mytextureloader = new three.textureloader();\nvar mymap = mytextureloader.load('images/img056.png');\n//设置纹理图像(贴图)在水平方向和垂直方向上的平铺模式为镜像平铺\nmymap.wraps = three.mirroredrepeatwrapping;\nmymap.wrapt = three.mirroredrepeatwrapping;\nmymap.matrixautoupdate = false;\nvar mymaterial = new three.meshphongmaterial({ map: mymap, transparent: true });\nvar mygeometry = new three.planebuffergeometry(300, 200, 5, 5);\nvar myplanemesh = new three.mesh(mygeometry, mymaterial);\nvar mymatrix = myplanemesh.material.map.matrix;\nmymatrix.identity().scale(1, 1);\nmyscene.add(myplanemesh);\n//渲染平面图形\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  myrenderer.render(myscene, mycamera);\n}\n//响应单击“设置2*2镜像平铺”按钮\n$(\"#mybutton1\").click(function () {\n  //获取平面贴图所对应的矩阵\n  mymatrix = myplanemesh.material.map.matrix;\n  //通过矩阵设置水平方向和垂直方向的镜像重复次数\n  mymatrix.identity().scale(2, 2);\n});\n//响应单击“设置3*3镜像平铺”按钮\n$(\"#mybutton2\").click(function () {\n  //获取平面贴图所对应的矩阵\n  mymatrix = myplanemesh.material.map.matrix;\n  //通过矩阵设置水平方向和垂直方向的镜像重复次数\n  mymatrix.identity().scale(3, 3);\n});\n\n\n\n\n\n# 022-重复平铺\n\n//创建平面图形\nvar mytextureloader = new three.textureloader();\nvar mymap = mytextureloader.load('images/img137.jpg');\n//设置纹理图像在水平方向和垂直方向上的平铺模式为重复平铺\nmymap.wraps = three.repeatwrapping;\nmymap.wrapt = three.repeatwrapping;\nvar mymaterial = new three.meshphongmaterial({ map: mymap, transparent: true });\nvar mygeometry = new three.planebuffergeometry(300, 200, 5, 5);\nvar myplanemesh = new three.mesh(mygeometry, mymaterial);\nmyscene.add(myplanemesh);\n//渲染平面图形\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  myrenderer.render(myscene, mycamera);\n}\n//响应单击“设置2*2重复平铺”按钮\n$(\"#mybutton1\").click(function () {\n  // mymap.matrixautoupdate = false;\n  // mymatrix = myplanemesh.material.map.matrix;\n  // mymatrix.identity().scale(2, 2);\n  myplanemesh.material.map.repeat.set(2, 2);\n});\n//响应单击“设置3*3重复平铺”按钮\n$(\"#mybutton2\").click(function () {\n  // mymap.matrixautoupdate = false;\n  // mymatrix = myplanemesh.material.map.matrix;\n  // mymatrix.identity().scale(3, 3);\n  myplanemesh.material.map.repeat.set(3, 3);\n});\n\n\n\n# 023-移动单个模型\n\nvar mymaterial = new three.meshnormalmaterial();\n//创建圆环结\nvar mytorusknotgeometry = new three.torusknotgeometry(8, 3, 200, 60);\nvar mytorusknotmesh = new three.mesh(mytorusknotgeometry, mymaterial);\nmytorusknotmesh.translatex(-62);\nmyscene.add(mytorusknotmesh);\n//创建立方体\nvar myboxgeometry = new three.boxgeometry(20, 20, 20);\nvar myboxmesh = new three.mesh(myboxgeometry, mymaterial);\nmyboxmesh.translatex(-20);\nmyscene.add(myboxmesh);\n//创建球体\nvar myspheregeometry = new three.spheregeometry(20, 60, 60);\nvar myspheremesh = new three.mesh(myspheregeometry, mymaterial);\nmyspheremesh.translatex(70);\nmyscene.add(myspheremesh);\nvar myobjects = [];\nmyobjects.push(mytorusknotmesh);\nmyobjects.push(myboxmesh);\nmyobjects.push(myspheremesh);\n//渲染圆环结、立方体、球体\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  myrenderer.render(myscene, mycamera);\n}\n//根据将要拖拽的图形、照相机、渲染器创建dragcontrols\nvar mydragcontrols = new three.dragcontrols(myobjects,\n                                            mycamera, myrenderer.domelement);\n\n\n\n# 024-点击(选择)的图形变更颜色\n\nvar myorbitcontrols = new three.orbitcontrols(mycamera);\n//创建多个立方体\nvar mygeometry = new three.boxgeometry(120, 120, 120);\nfor (var i = 0; i < 10; i++) {\n  var mymaterial = new three.meshlambertmaterial({\n    color: math.random() * 0xffffff\n  });\n  var mymesh = new three.mesh(mygeometry, mymaterial);\n  mymesh.position.x = math.random() * 580 - 140;\n  mymesh.position.y = math.random() * 580 - 140;\n  mymesh.position.z = math.random() * 580 - 140;\n  myscene.add(mymesh);\n}\n//渲染多个立方体\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  myrenderer.render(myscene, mycamera);\n}\nvar mymouse = new three.vector2();\n//three.raycaster用于通过鼠标去获取在3d世界被选择的图形\nvar myraycaster = new three.raycaster();\n$(document.body).click(function (event) {\n  //拦截页面默认的点击事件\n  event.preventdefault();\n  //计算当前鼠标的坐标\n  mymouse.x = (event.clientx / window.innerwidth) * 2 - 1;\n  mymouse.y = -(event.clienty / window.innerheight) * 2 + 1;\n  //根据当前鼠标和照相机重置raycaster\n  myraycaster.setfromcamera(mymouse, mycamera);\n  //获取被点击(选择)的图形\n  var myintersects = myraycaster.intersectobjects(myscene.children);\n  if (myintersects.length > 0) {\n    //生成随机颜色值\n    var mycolor = math.random() * 0xffffff;\n    //动态更新该图形表面的颜色\n    myintersects[0].object.material.color = new three.color(mycolor);\n  }\n});\n\n\n\n# 025-添加鼠标事件监听器\n\n\n//添加鼠标事件监听器\ndocument.addeventlistener('mousedown', function (e) {\n  e.preventdefault();\n  document.addeventlistener('mousemove', onmousemove, false);\n  document.addeventlistener('mouseup', onmouseup, false);\n}, false);\ndocument.addeventlistener('wheel', function (event) {\n  var myfov = mycamera.fov + event.deltay * 0.05;\n  mycamera.fov = three.mathutils.clamp(myfov, 10, 75);\n  mycamera.updateprojectionmatrix();\n}, false);\nfunction onmousemove(event) {\n  mylongitude -= event.movementx * 0.1;\n  mylatitude += event.movementy * 0.1;\n}\nfunction onmouseup() {\n  document.removeeventlistener('mousemove', onmousemove);\n  document.removeeventlistener('mouseup', onmouseup);\n}\n\n\n\n# 026-着色器\n\n<script type=\"x-shader/x-fragment\" id=\"myfragmentshader\">\n  //创建片元着色器\n  uniform sampler2d mytexture;\nuniform float saturation;\nvarying vec2 vuv;\nvoid main(){\n  //获取原始图像像素值\n  vec4 mycolor=texture2d(mytexture,vuv);\n  //根据饱和度参数重新计算rgb分量值\n  float myr=0.213*(1.0-saturation);\n  float myg=0.715*(1.0-saturation);\n  float myb=0.072*(1.0-saturation);\n  //根据rgb分量值和饱和度参数值生成对应的颜色矩阵\n  mat4 mycolormatrix=mat4(myr+saturation,myg,myb,0.0,\n                          myr,myg+saturation,myb,0.0,\n                          myr,myg,myb+saturation,0.0,\n                          0.0,0.0,0.0,1.0);\n  //根据颜色矩阵计算最终颜色值\n  gl_fragcolor=mycolor*mycolormatrix;\n}\n<\/script>\n<script type=\"x-shader/x-vertex\" id=\"myvertexshader\">\n  //创建顶点着色器\n  varying vec2 vuv;\nvoid main(){\n  vuv=uv;\n  vec4 mvposition=modelviewmatrix*vec4(position,1.0);\n  gl_position=projectionmatrix*mvposition;\n}\n<\/script>\n<script type=\"text/javascript\">\n  //创建渲染器\n  var myrenderer = new three.webglrenderer({ antialias: true });\n  myrenderer.setsize(window.innerwidth, window.innerheight);\n  myrenderer.setclearcolor('white', 1.0);\n  $('#mycontainer')[0].appendchild(myrenderer.domelement);\n  var myscene = new three.scene();\n  var mycamera = new three.perspectivecamera(45,\n                                             window.innerwidth / window.innerheight, 0.1, 1000);\n  mycamera.position.set(100, 100, 400);\n  mycamera.lookat(myscene.position);\n  var mytextureloader = new three.textureloader();\n  var mytexture = mytextureloader.load('images/img004.jpg');\n  //封装片元着色器所使用的参数\n  var myuniforms = { mytexture: { value: mytexture }, saturation: { value: 1 } };\n  //根据着色器及其参数创建three.shadermaterial\n  var myshadermaterial = new three.shadermaterial({\n    uniforms: myuniforms,\n    vertexshader: $('#myvertexshader').text(),\n    fragmentshader: $('#myfragmentshader').text()\n  });\n  //使用three.shadermaterial创建立方体\n  var myboxgeometry = new three.boxgeometry(160, 160, 160);\n  var mymesh = new three.mesh(myboxgeometry, myshadermaterial);\n  myscene.add(mymesh);\n  var mystep = 0;\n  //渲染(旋转)立方体\n  animate();\n  function animate() {\n    mymesh.rotation.y = mystep += 0.01;\n    mymesh.rotation.x = mystep;\n    mymesh.rotation.z = mystep;\n    requestanimationframe(animate);\n    myrenderer.render(myscene, mycamera);\n  }\n  //为滑块元素添加拖拽事件监听器\n  $(\"input\").on(\"input\", function () {\n    //获取滑块当前值\n    var mysaturation = parsefloat($(this).val() / 100);\n    //动态设置片元着色器的饱和度参数，同时更新材质对象\n    mymesh.material.uniforms.saturation = { value: mysaturation };\n    mymesh.material.needsupdate = true;\n  });\n<\/script>\n\n\n\n# 027-拖拽查看全景图\n\n\nvar ismouse = false, mymousex = 0, mymousey = 0, mylongitude = 0, mylatitude = 0,\n    mytemplongitude = 0, mytemplatitude = 0, myphi = 0, mytheta = 0;\n//创建渲染器\nvar myrenderer = new three.webglrenderer();\nmyrenderer.setsize(window.innerwidth, window.innerheight);\n$(document.body).append(myrenderer.domelement);\nvar mycamera = new three.perspectivecamera(75,\n                                           window.innerwidth / window.innerheight, 1, 1100);\nmycamera.target = new three.vector3(0, 0, 0);\nvar myscene = new three.scene();\n//创建球体并设置全景图\nvar mygeometry = new three.spherebuffergeometry(40, 30, 30);\nmygeometry.scale(-1, 1, 1);\nvar myloader = new three.textureloader();\nvar mytexture = myloader.load('images/img129.jpg');\nvar mymaterial = new three.meshbasicmaterial({ map: mytexture });\nvar mysphere = new three.mesh(mygeometry, mymaterial);\nmyscene.add(mysphere);\n//渲染全景图(拖拽查看全景图)\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  mylatitude = math.max(-85, math.min(85, mylatitude));\n  myphi = three.mathutils.degtorad(90 - mylatitude);\n  mytheta = three.mathutils.degtorad(mylongitude);\n  mycamera.target.x = math.sin(myphi) * math.cos(mytheta);\n  mycamera.target.y = math.cos(myphi);\n  mycamera.target.z = math.sin(myphi) * math.sin(mytheta);\n  mycamera.lookat(mycamera.target);\n  myrenderer.render(myscene, mycamera);\n}\ndocument.addeventlistener('mousedown', function (event) {\n  ismouse = true;\n  //记录鼠标按下的位置\n  mymousex = event.clientx;\n  mymousey = event.clienty;\n  mytemplongitude = mylongitude;\n  mytemplatitude = mylatitude;\n});\ndocument.addeventlistener('mousemove', function (event) {\n  if (ismouse) {\n    //根据鼠标当前位置和按下的位置重新计算经纬度\n    mylongitude = (mymousex - event.clientx) * 0.1 + mytemplongitude;\n    mylatitude = (event.clienty - mymousey) * 0.1 + mytemplatitude;\n  }\n});\ndocument.addeventlistener('mouseup', function () { ismouse = false; });\ndocument.addeventlistener('wheel', function (event) {\n  var myfov = mycamera.fov + event.deltay * 0.05;\n  mycamera.fov = three.mathutils.clamp(myfov, 10, 75);\n  mycamera.updateprojectionmatrix();\n});\n\n\n\n# 028-动态设置立方体的发光颜色，实现发光效果\n\n//创建立方体\nvar mytextureloader = new three.textureloader();\nmytextureloader.load('images/img053.jpg', function (mytexture) {\n  var mymeshlambertmaterial = new three.meshlambertmaterial({ map: mytexture });\n  var mygeometry = new three.boxgeometry(24, 24, 24);\n  mymesh = new three.mesh(mygeometry, mymeshlambertmaterial);\n  myscene.add(mymesh);\n});\n//渲染立方体\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  //动态设置立方体的发光颜色，实现发光效果\n  mymesh.material.emissive.sethsl(\n    0.54,\n    1, \n    0.35 * (0.5 + 0.5 * math.sin(35 * 0.0001 * date.now()))\n  );\n  //mymesh.material.emissive.setrgb(255,0,0);\n  myrenderer.render(myscene, mycamera);\n};\n\n\n\n# 029-动态拉伸或压缩立方体\n\n//动态拉伸或压缩立方体\nmyrenderer.setanimationloop(function () {\n  if (mystep < 1) { if (!isreversed) mystep += 0.02; }\n  if (mystep > 0) { if (isreversed) mystep -= 0.02; }\n  myboxmesh.morphtargetinfluences[0] = mystep;\n  myrenderer.render(myscene, mycamera);\n});\n\n\n\n# 030-渲染glb汽车模型\n\n//创建渲染器\nvar myrenderer = new three.webglrenderer({ antialias: true });\nmyrenderer.setsize(window.innerwidth, window.innerheight);\n$(\"#mycontainer\").append(myrenderer.domelement);\nmyrenderer.outputencoding = three.srgbencoding;\nmyrenderer.tonemapping = three.acesfilmictonemapping;\nmyrenderer.tonemappingexposure = 0.85;\nvar mycamera = new three.perspectivecamera(40,\n                                           window.innerwidth / window.innerheight, 0.1, 1000);\nmycamera.position.set(4.25, 1.4, -4.5);\nvar myenvironment = new roomenvironment();\nvar mygenerator = new three.pmremgenerator(myrenderer);\nvar myscene = new three.scene();\nmyscene.background = new three.color(0xffffff);\nmyscene.environment = mygenerator.fromscene(myenvironment).texture;\n//根据透视相机创建轨道控制器，并设置其目标所在位置\nvar myorbitcontrols = new three.orbitcontrols(mycamera);\nmyorbitcontrols.target.set(0, 0.5, 0);\nmyorbitcontrols.update();\n//初始化汽车车身、玻璃、轮胎等部位对应的材质\nvar mybodymaterial = new three.meshphysicalmaterial({\n  color: 0x00ff00, metalness: 0.6, roughness: 0.4,\n  clearcoat: 0.05, clearcoatroughness: 0.05\n});\nvar mydetailsmaterial = new three.meshstandardmaterial({\n  color: 0x0000ff, metalness: 1.0, roughness: 0.5\n});\nvar myglassmaterial = new three.meshphysicalmaterial({\n  color: 0xff0000, metalness: 0, roughness: 0.1,\n  transmission: 0.9, transparent: true\n});\n//创建dracoloader，并设置其解码目录\n//即draco_wasm_wrapper.js和draco_decoder.wasm文件所在位置\nvar mydracoloader = new three.dracoloader();\nmydracoloader.setdecoderpath('data/');\nvar mygltfloader = new three.gltfloader();\nmygltfloader.setdracoloader(mydracoloader);\n//加载glb汽车模型文件，并为汽车各部位设置自定义材质\nmygltfloader.load('data/myferrari.glb', function (glb) {\n  var mycar = glb.scene.children[0];\n  mycar.scale.set(1.5, 1.5, 1.5);\n  mycar.getobjectbyname('body').material = mybodymaterial;\n  mycar.getobjectbyname('rim_fr').material = mydetailsmaterial;\n  mycar.getobjectbyname('glass').material = myglassmaterial;\n  myscene.add(mycar);\n});\n//渲染glb汽车模型\nmyrenderer.setanimationloop(render);\nfunction render() {\n  myrenderer.render(myscene, mycamera);\n}\n\n\n\n\n\n# 031-剪裁平面\n\n//创建圆环结\nvar mygeometry = new three.torusknotbuffergeometry(10, 2, 200, 80, 2, 5);\n//创建剪裁平面\nvar myclippingplane = new three.plane(new three.vector3(0, -1, 0), 0.8);\nvar mymaterial = new three.meshphongmaterial({\n  color: 0x80ee10,\n  shininess: 100, side: three.doubleside, clippingplanes: [myclippingplane]\n});\nmymesh = new three.mesh(mygeometry, mymaterial);\nmyscene.add(mymesh);\nvar mycontrols = new three.orbitcontrols(mycamera, mycontainer);\n//渲染圆环结\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  mymesh.rotation.x += 0.01;\n  mymesh.rotation.y += 0.01;\n  mymesh.rotation.z += 0.01;\n  myrenderer.render(myscene, mycamera);\n}\n//响应单击“启用剪裁平面”按钮\n$(\"#mybutton1\").click(function () {\n  myrenderer.localclippingenabled = true;\n});\n//响应单击“禁用剪裁平面”按钮\n$(\"#mybutton2\").click(function () {\n  myrenderer.localclippingenabled = false;\n});\n\n\n\n# 032-动态消失\n\nvar mymousex = 0, mymousey = 0;\n//创建渲染器\nvar myrenderer = new three.webglrenderer({ antialias: true, });\nmyrenderer.setsize(window.innerwidth, window.innerheight);\n$(\"#mycontainer\").append(myrenderer.domelement);\nvar myscene = new three.scene();\nmyscene.background = new three.color(0xffffff);\nvar mycamera = new three.perspectivecamera(60,\n                                           window.innerwidth / window.innerheight, 0.1, 1000);\nmycamera.position.z = 500;\n//创建第一个球体\nvar mygeometry = new three.spherebuffergeometry(50, 100, 100);\nvar mymaterial = new three.meshnormalmaterial();\nvar myparentsphere = new three.mesh(mygeometry, mymaterial);\nmyparentsphere.position.x = -400;\nmyscene.add(myparentsphere);\n//以嵌套方式连续创建8个球体\nfor (var i = 0; i < 8; i++) {\n  var mychildsphere = new three.mesh(mygeometry, mymaterial);\n  mychildsphere.position.x = 100;\n  myparentsphere.add(mychildsphere);\n  myparentsphere = mychildsphere;\n}\ndocument.addeventlistener('mousemove', function (event) {\n  mymousex = (event.clientx - (window.innerwidth / 2)) * 10;\n  mymousey = (event.clienty - (window.innerheight / 2)) * 10;\n}, false);\n//渲染9个球体\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  var mytime = date.now() * 0.001 + 10000;\n  var myrotationx = math.sin(mytime * 0.7) * 0.2;\n  var myrotationy = math.sin(mytime * 0.3) * 0.1;\n  var myrotationz = math.sin(mytime * 0.2) * 0.1;\n  mycamera.position.x += (mymousex - mycamera.position.x) * 0.05;\n  mycamera.position.y -= (mymousey + mycamera.position.y) * 0.05;\n  mycamera.lookat(myscene.position);\n  myparentsphere.traverse(function (object) {\n    object.rotation.x = myrotationx;\n    object.rotation.y = myrotationy;\n    object.rotation.z = myrotationz;\n  });\n  myrenderer.render(myscene, mycamera);\n}\n\n\n\n# 033-\n\n\n\n\n\n# 034-\n\n\n\n\n\n# 035-\n\n\n\n\n\n# 036-\n\n\n\n\n\n# 037-\n\n\n\n\n\n# 038-\n\n\n\n\n\n# 039-\n\n\n\n\n\n# 040-\n\n\n",charsets:{cjk:!0}},{title:"001-立方体",frontmatter:{},regularPath:"/three.js/SimpleModel.html",relativePath:"three.js/SimpleModel.md",key:"v-54435360",path:"/three.js/SimpleModel.html",headers:[{level:2,title:"001-立方体",slug:"_001-立方体",normalizedTitle:"001-立方体",charIndex:2},{level:3,title:"单个立方体",slug:"单个立方体",normalizedTitle:"单个立方体",charIndex:14},{level:3,title:"渲染器WebGLRenderer",slug:"渲染器webglrenderer",normalizedTitle:"渲染器webglrenderer",charIndex:2865},{level:3,title:"立方缓冲几何体（BoxGeometry）",slug:"立方缓冲几何体-boxgeometry",normalizedTitle:"立方缓冲几何体（boxgeometry）",charIndex:4102},{level:3,title:"魔方（9x9个立方体）",slug:"魔方-9x9个立方体",normalizedTitle:"魔方（9x9个立方体）",charIndex:4585},{level:3,title:"一排立方体",slug:"一排立方体",normalizedTitle:"一排立方体",charIndex:6372},{level:3,title:"魔方(多个立方体)",slug:"魔方-多个立方体",normalizedTitle:"魔方(多个立方体)",charIndex:7295},{level:2,title:"002-圆",slug:"_002-圆",normalizedTitle:"002-圆",charIndex:9268},{level:3,title:"单个圆",slug:"单个圆",normalizedTitle:"单个圆",charIndex:9278},{level:3,title:"球缓冲几何体（SphereGeometry）",slug:"球缓冲几何体-spheregeometry",normalizedTitle:"球缓冲几何体（spheregeometry）",charIndex:9910},{level:3,title:"线性雾化的圆",slug:"线性雾化的圆",normalizedTitle:"线性雾化的圆",charIndex:10593},{level:2,title:"003-柱体",slug:"_003-柱体",normalizedTitle:"003-柱体",charIndex:11505},{level:3,title:"单个柱体",slug:"单个柱体",normalizedTitle:"单个柱体",charIndex:11516},{level:3,title:"圆柱缓冲几何体（CylinderGeometry)",slug:"圆柱缓冲几何体-cylindergeometry",normalizedTitle:"圆柱缓冲几何体（cylindergeometry)",charIndex:11845},{level:2,title:"004-扇形",slug:"_004-扇形",normalizedTitle:"004-扇形",charIndex:12497},{level:3,title:"空心扇形",slug:"空心扇形",normalizedTitle:"空心扇形",charIndex:12508},{level:3,title:"实心扇形",slug:"实心扇形",normalizedTitle:"实心扇形",charIndex:12795},{level:3,title:"圆形缓冲几何体（CircleGeometry）",slug:"圆形缓冲几何体-circlegeometry",normalizedTitle:"圆形缓冲几何体（circlegeometry）",charIndex:13082},{level:3,title:"基础网格材质(MeshBasicMaterial)",slug:"基础网格材质-meshbasicmaterial",normalizedTitle:"基础网格材质(meshbasicmaterial)",charIndex:13779},{level:2,title:"005-圆环",slug:"_005-圆环",normalizedTitle:"005-圆环",charIndex:15904},{level:3,title:"创建甜甜圈(单个圆环)",slug:"创建甜甜圈-单个圆环",normalizedTitle:"创建甜甜圈(单个圆环)",charIndex:15915},{level:3,title:"圆环缓冲几何体（TorusGeometry）",slug:"圆环缓冲几何体-torusgeometry",normalizedTitle:"圆环缓冲几何体（torusgeometry）",charIndex:16339},{level:3,title:"创建多次旋转的圆环结（圆环结）",slug:"创建多次旋转的圆环结-圆环结",normalizedTitle:"创建多次旋转的圆环结（圆环结）",charIndex:16969},{level:3,title:"圆环缓冲扭结几何体（TorusKnotGeometry）",slug:"圆环缓冲扭结几何体-torusknotgeometry",normalizedTitle:"圆环缓冲扭结几何体（torusknotgeometry）",charIndex:17299},{level:2,title:"006-圆台",slug:"_006-圆台",normalizedTitle:"006-圆台",charIndex:18024},{level:3,title:"创建圆台",slug:"创建圆台",normalizedTitle:"创建圆台",charIndex:18035},{level:3,title:"根据样条曲线图形绘制线框盒",slug:"根据样条曲线图形绘制线框盒",normalizedTitle:"根据样条曲线图形绘制线框盒",charIndex:18531},{level:3,title:"圆柱缓冲几何体（CylinderGeometry）",slug:"圆柱缓冲几何体-cylindergeometry-2",normalizedTitle:"圆柱缓冲几何体（cylindergeometry）",charIndex:18637},{level:2,title:"007-两个立方体",slug:"_007-两个立方体",normalizedTitle:"007-两个立方体",charIndex:19538},{level:3,title:"创建两个立方体",slug:"创建两个立方体",normalizedTitle:"创建两个立方体",charIndex:19552},{level:2,title:"008-圆形",slug:"_008-圆形",normalizedTitle:"008-圆形",charIndex:20279},{level:3,title:"空心圆",slug:"空心圆",normalizedTitle:"空心圆",charIndex:20290},{level:3,title:"实心圆",slug:"实心圆",normalizedTitle:"实心圆",charIndex:20525},{level:2,title:"009-桃心♥️",slug:"_009-桃心♥️",normalizedTitle:"009-桃心♥️",charIndex:20731},{level:2,title:"010-三角形",slug:"_010-三角形",normalizedTitle:"010-三角形",charIndex:22265},{level:3,title:"空心三角形",slug:"空心三角形",normalizedTitle:"空心三角形",charIndex:22277},{level:3,title:"实心三角形",slug:"实心三角形",normalizedTitle:"实心三角形",charIndex:22674},{level:3,title:"多色空心三角形",slug:"多色空心三角形",normalizedTitle:"多色空心三角形",charIndex:23042},{level:2,title:"011-多边形",slug:"_011-多边形",normalizedTitle:"011-多边形",charIndex:23766},{level:2,title:"012-矩形",slug:"_012-矩形",normalizedTitle:"012-矩形",charIndex:24295},{level:3,title:"虚线空心矩形",slug:"虚线空心矩形",normalizedTitle:"虚线空心矩形",charIndex:24306},{level:2,title:"013-四面体",slug:"_013-四面体",normalizedTitle:"013-四面体",charIndex:24986},{level:2,title:"014-多粒子",slug:"_014-多粒子",normalizedTitle:"014-多粒子",charIndex:25235},{level:3,title:"静态粒子",slug:"静态粒子",normalizedTitle:"静态粒子",charIndex:25247},{level:3,title:"旋转粒子",slug:"旋转粒子",normalizedTitle:"旋转粒子",charIndex:26545},{level:3,title:"粒子更换成贴图",slug:"粒子更换成贴图",normalizedTitle:"粒子更换成贴图",charIndex:27596},{level:2,title:"015-阿基米德螺线",slug:"_015-阿基米德螺线",normalizedTitle:"015-阿基米德螺线",charIndex:31170},{level:3,title:"平面螺旋线",slug:"平面螺旋线",normalizedTitle:"平面螺旋线",charIndex:31185},{level:3,title:"弹簧螺旋线",slug:"弹簧螺旋线",normalizedTitle:"弹簧螺旋线",charIndex:31850},{level:2,title:"016-沙漏",slug:"_016-沙漏",normalizedTitle:"016-沙漏",charIndex:32487},{level:2,title:"017-",slug:"_017",normalizedTitle:"017-",charIndex:33314},{level:2,title:"018-",slug:"_018",normalizedTitle:"018-",charIndex:33326},{level:2,title:"019-",slug:"_019",normalizedTitle:"019-",charIndex:33338},{level:2,title:"020-",slug:"_020",normalizedTitle:"020-",charIndex:33350}],headersStr:"001-立方体 单个立方体 渲染器WebGLRenderer 立方缓冲几何体（BoxGeometry） 魔方（9x9个立方体） 一排立方体 魔方(多个立方体) 002-圆 单个圆 球缓冲几何体（SphereGeometry） 线性雾化的圆 003-柱体 单个柱体 圆柱缓冲几何体（CylinderGeometry) 004-扇形 空心扇形 实心扇形 圆形缓冲几何体（CircleGeometry） 基础网格材质(MeshBasicMaterial) 005-圆环 创建甜甜圈(单个圆环) 圆环缓冲几何体（TorusGeometry） 创建多次旋转的圆环结（圆环结） 圆环缓冲扭结几何体（TorusKnotGeometry） 006-圆台 创建圆台 根据样条曲线图形绘制线框盒 圆柱缓冲几何体（CylinderGeometry） 007-两个立方体 创建两个立方体 008-圆形 空心圆 实心圆 009-桃心♥️ 010-三角形 空心三角形 实心三角形 多色空心三角形 011-多边形 012-矩形 虚线空心矩形 013-四面体 014-多粒子 静态粒子 旋转粒子 粒子更换成贴图 015-阿基米德螺线 平面螺旋线 弹簧螺旋线 016-沙漏 017- 018- 019- 020-",content:"# 001-立方体\n\n\n# 单个立方体\n\nvar myRenderer = new THREE.WebGLRenderer();              //创建渲染器\nvar myWidth = 480;                                      //设置窗口宽度\nvar myHeight = 320;                                    //设置窗口高度\nmyRenderer.setSize(myWidth, myHeight);                //设置渲染区域\nmyRenderer.setClearColor(\"white\", 1);                 //设置清空颜色\n$(\"#myContainer\").append(myRenderer.domElement);\nvar myScene = new THREE.Scene();                          //创建场景\nvar myLight = new THREE.PointLight(\"red\");           //创建红色光源\nmyLight.position.set(400, 800, 300);                   //设置光源位置\nmyScene.add(myLight);                            //在场景中添加光源\nvar k = myWidth / myHeight;                         //计算窗口宽高比\nvar s = 120;                              //三维场景显示范围控制系数\nvar myCamera = new THREE.OrthographicCamera(-s * k, s * k, s, -s, 1, 1000); //创建相机\nmyCamera.position.set(400, 300, 200);                //设置相机位置\nmyCamera.lookAt(myScene.position);\nvar myGeometry = new THREE.BoxGeometry(100, 100, 100); //创建立方体\nvar myMaterial = new THREE.MeshLambertMaterial({ color: 0xFFBF00 }); //创建材质\nvar myMesh = new THREE.Mesh(myGeometry, myMaterial);      //创建网格\nmyScene.add(myMesh);                      //在场景中添加网格(立方体)\nmyRenderer.render(myScene, myCamera);                  //渲染立方体\n\n\n\n\n# 更改立方体的面(有12个face)颜色\n\n//创建立方体\nvar myGeometry = new THREE.BoxGeometry(100, 100, 100);\n//var myGeometry = new THREE.TetrahedronGeometry(140, 0);\n//使用随机数创建立方体的面(有12个face)颜色\nfor (var i = 0; i < myGeometry.faces.length; i++) {\n  var myColor = Math.random() * 0xffffff;\n  myGeometry.faces[i].color.setHex(myColor);\n}\n//根据颜色创建材质\nvar myMaterial = new THREE.MeshBasicMaterial({ vertexColors: THREE.FaceColors });\nvar myMesh = new THREE.Mesh(myGeometry, myMaterial);\nmyScene.add(myMesh);\n\n\n\n\n# 更改立方体的6种颜色材质\n\n//创建立方体\nvar myGeometry = new THREE.BoxGeometry(30, 30, 30);\n//创建6种颜色的材质\nvar myMaterials = [];\nfor (var i = 0; i < 6; i++) {\n  var myMaterial = new THREE.MeshBasicMaterial({ color: new THREE.Color(Math.random() * 0xffffff) });\n  myMaterials.push(myMaterial);\n}\n//使用材质数组设置立方体表面颜色\nvar myMesh = new THREE.Mesh(myGeometry, myMaterials);\nmyScene.add(myMesh);\n\n\n\n\n# 混合更改颜色\n\n//创建立方体\nvar myGeometry = new THREE.BoxGeometry(30, 30, 30);\n//创建12种颜色的材质\nvar myMaterials = [];\nfor (var i = 0; i < 12; i++) {\n  var myMaterial = new THREE.MeshBasicMaterial({ color: new THREE.Color(Math.random() * 0xffffff) });\n  myMaterials.push(myMaterial);\n}\n//使用材质数组设置立方体表面颜色\nvar myMesh = new THREE.Mesh(myGeometry, myMaterials);\n//使用12种材质设置立方体的12个face\nfor (var j = 0; j < 12; j++) {\n  myGeometry.faces[j].materialIndex = j;\n}\nmyScene.add(myMesh);\n\n\n# 更改效果\n\n# 更改区域样式\n\nmyRenderer.setClearColor(\"green\", 1);   \n\n\n\n\n# 更改光源颜色\n\nvar myLight = new THREE.PointLight(\"yellow\"); \n\n\n\n\n# 更改物体\n\nvar myGeometry = new THREE.BoxGeometry(50, 50, 50); \n\n\n\n\n# 更改材质\n\nvar myMaterial = new THREE.MeshLambertMaterial({ color: 0xE954F1 }); \n\n\n\n\n\n\n\n# 渲染器WebGLRenderer\n\nWebGL Render 用WebGL渲染出你精心制作的场景。\n\n# 构造器\n\nnew THREE.WebGLRenderer({ antialias: true });\n\n\nWebGLRenderer( parameters : Object )\n\n * parameters - (可选) 该对象的属性定义了渲染器的行为。也可以完全不传参数。在所有情况下，当缺少参数时，它将采用合理的默认值。 以下是合法参数：\n * canvas - 一个供渲染器绘制其输出的canvas它和下面的domElement属性对应。 如果没有传这个参数，会创建一个新canvas\n * context - 可用于将渲染器附加到已有的渲染环境(RenderingContext)中。默认值是null\n * precision - 着色器精度. 可以是 \"highp\", \"mediump\" 或者 \"lowp\". 如果设备支持，默认为**\"highp\"** .\n * alpha - controls the default clear alpha value. When set to true, the value is 0. Otherwise it's 1. Default is false.\n * premultipliedAlpha - renderer是否假设颜色有 premultiplied alpha. 默认为true\n * antialias - 是否执行抗锯齿。默认为false.\n * stencil - 绘图缓存是否有一个至少8位的模板缓存(stencil buffer)。默认为true\n * preserveDrawingBuffer -是否保留缓直到手动清除或被覆盖。 默认false.\n * powerPreference - 提示用户代理怎样的配置更适用于当前WebGL环境。 可能是**\"high-performance\", \"low-power\" 或 \"default\"。默认是\"default\"**.\n * failIfMajorPerformanceCaveat - 检测渲染器是否会因性能过差而创建失败。默认为false。\n * depth - 绘图缓存是否有一个至少6位的深度缓存(depth buffer )。 默认是true.\n * logarithmicDepthBuffer - 是否使用对数深度缓存。如果要在单个场景中处理巨大的比例差异，就有必要使用。 Note that this setting uses gl_FragDepth if available which disables the Early Fragment Test optimization and can cause a decrease in performance. 默认是false。 示例：camera\n\n\n# 立方缓冲几何体（BoxGeometry）\n\nBoxGeometry是四边形的原始几何类，它通常使用构造函数所提供的“width”、“height”、“depth”参数来创建立方体或者不规则四边形。\n\n# 构造器\n\nnew THREE.BoxGeometry(100, 100, 100); \n\n\nBoxGeometry(width : Float, height : Float, depth : Float, widthSegments : Integer, heightSegments : Integer, depthSegments : Integer)\n\n * width — X轴上面的宽度，默认值为1。\n\n * height — Y轴上面的高度，默认值为1。\n\n * depth — Z轴上面的深度，默认值为1。\n\n * widthSegments — （可选）宽度的分段数，默认值是1。\n\n * heightSegments — （可选）高度的分段数，默认值是1。\n\n * depthSegments — （可选）深度的分段数，默认值是1。\n\n\n# 魔方（9x9个立方体）\n\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer({ antialias: true });\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\nmyRenderer.setClearColor('white', 1.0);\n$('#myContainer')[0].appendChild(myRenderer.domElement);\nvar myScene = new THREE.Scene();\nvar myCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 30, 1000);\nmyCamera.position.set(-50, 40, 50);\nmyCamera.lookAt(new THREE.Vector3(0, 0, 0));\n//创建立方体图形\nvar mySize = 9;\nvar myCubeGeometry = new THREE.BoxGeometry(mySize - 0.1, mySize - 0.1, mySize - 0.1);\n//创建材质数组\nvar myMaterials = [];\nmyMaterials.push(new THREE.MeshBasicMaterial({ color: 'red' }));\nmyMaterials.push(new THREE.MeshBasicMaterial({ color: 'green' }));\nmyMaterials.push(new THREE.MeshBasicMaterial({ color: 'blue' }));\nmyMaterials.push(new THREE.MeshBasicMaterial({ color: 'cyan' }));\nmyMaterials.push(new THREE.MeshBasicMaterial({ color: 'yellow' }));\nmyMaterials.push(new THREE.MeshBasicMaterial({ color: 'pink' }));\n//添加单个立方体\nmyCubeMesh = new THREE.Mesh(myCubeGeometry, myMaterials);\nmyCubeMesh.position.set(-mySize * 3 + mySize, mySize * 3 - mySize, -mySize * 3);\nmyScene.add(myCubeMesh);\n//添加魔方(27个立方体)\nmyGroupMesh = new THREE.Mesh();\nfor (var x = 0; x < 3; x++) {\n  for (var y = 0; y < 3; y++) {\n    for (var z = 0; z < 3; z++) {\n      var myMesh = new THREE.Mesh(myCubeGeometry, myMaterials);\n      myMesh.position.set(x * mySize - mySize, y * mySize - mySize, z * mySize - mySize);\n      myGroupMesh.add(myMesh);\n    }\n  }\n}\nmyScene.add(myGroupMesh);\n//渲染图形\nanimate();\nfunction animate() {\n  myRenderer.render(myScene, myCamera);\n}\nvar myOrbitControls = new THREE.OrbitControls(myCamera, myRenderer.domElement);           //创建轨道控制器\nmyOrbitControls.addEventListener('change', animate);  //监听鼠标、键盘事件\n\n\n\n\n\n# 一排立方体\n\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer({ antialias: true });\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\nmyRenderer.setClearColor('black', 1.0);\n$('#myContainer')[0].appendChild(myRenderer.domElement);\nvar myCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 30, 1000);\nmyCamera.position.set(-40.91020281125894,  12.522960007309857, 22.79661391601931);\nmyCamera.lookAt(new THREE.Vector3(0, 0, 0));\nvar myScene = new THREE.Scene();\n//创建100个立方体\nvar mySize = 9; \nvar myGeometry = new THREE.BoxGeometry(mySize, mySize, mySize);\nvar myMaterial = new THREE.MeshDepthMaterial();\nvar myGroupMesh = new THREE.Mesh();\nfor (var x = 0; x < 100; x++) {\n  var myMesh = new THREE.Mesh(myGeometry, myMaterial);\n  myMesh.position.set(x * mySize * 2 - mySize, 0, 0);\n  myGroupMesh.add(myMesh);\n}\nmyScene.add(myGroupMesh);\n//渲染100个立方体\nmyRenderer.render(myScene, myCamera);\n\n\n\n\n\n# 魔方(多个立方体)\n\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer({ antialias: true });\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\n$(\"#myContainer\").append(myRenderer.domElement);\nvar myScene = new THREE.Scene();\nmyScene.add(new THREE.AxesHelper(120));\nmyScene.background = new THREE.Color('white');\nmyScene.add(new THREE.AmbientLight(0xffffff));\nvar myCamera = new THREE.PerspectiveCamera(45,\n                                           window.innerWidth / window.innerHeight, 0.1, 1000);\nmyCamera.position.set(100, 100, 100);\nmyCamera.lookAt(myScene.position);\nvar myControls = new THREE.OrbitControls(myCamera, myRenderer.domElement);\n//创建魔方模型\nvar myMaterials = [];\nmyMaterials.push(new THREE.MeshPhongMaterial({ color: 0x009e60 }));\nmyMaterials.push(new THREE.MeshPhongMaterial({ color: 0x0051ba }));\nmyMaterials.push(new THREE.MeshPhongMaterial({ color: 0xffd500 }));\nmyMaterials.push(new THREE.MeshPhongMaterial({ color: 0xff5800 }));\nmyMaterials.push(new THREE.MeshPhongMaterial({ color: 0xc41e3a }));\nmyMaterials.push(new THREE.MeshPhongMaterial({ color: 0xffffff }));\nvar myGroup = new THREE.Group();\nfor (var x = 0; x < 6; x++) {\n  for (var y = 0; y < 6; y++) {\n    for (var z = 0; z < 6; z++) {\n      var myGeometry = new THREE.BoxGeometry(5.9, 5.9, 5.9);\n      var myMesh = new THREE.Mesh(myGeometry, myMaterials);\n      myMesh.position.set(x * 6 - 6, y * 6 + 6, z * 6 - 6);\n      myGroup.add(myMesh);\n    }\n  }\n}\nmyGroup.scale.set(2, 2, 2);\nmyScene.add(myGroup);\nvar myBox3 = new THREE.Box3();\nmyBox3.expandByObject(myGroup);\nvar myX = myBox3.max.x - myBox3.min.x;\nvar myY = myBox3.max.y - myBox3.min.y;\nvar myZ = myBox3.max.z - myBox3.min.z;\nvar myNewX = myBox3.min.x + myX / 2;\nvar myNewY = myBox3.min.y + myY / 2;\nvar myNewZ = myBox3.min.z + myZ / 2;\n//根据计算结果重新设置魔方位置，使其居中显示\nmyGroup.position.set(-myNewX, -myNewY, -myNewZ);\n//渲染魔方模型\nanimate();\nfunction animate() {\n  myRenderer.render(myScene, myCamera);\n  requestAnimationFrame(animate);\n}\n\n\n\n\n\n# 002-圆\n\n\n# 单个圆\n\n// 白色背景\nmyRenderer.setClearColor(\"white\", 1);     \n// 白色光源\nvar myLight = new THREE.PointLight(\"white\");  \n...\nvar mySphereGeometry = new THREE.SphereGeometry(60, 40, 40);\nvar mySphereMaterial = new THREE.MeshLambertMaterial({ color: \"blue\" });\nvar mySphereMesh = new THREE.Mesh(mySphereGeometry, mySphereMaterial);\nmySphereMesh.translateY(-100);\nmySphereMesh.translateX(-180);\nmyScene.add(mySphereMesh);\n\n\n\n\n# 更改效果\n\n# 更改大小\n\nnew THREE.SphereGeometry(30, 40, 40);\n\n\n\n\n# 更改位置\n\nmySphereMesh.translateY(-150);\nmySphereMesh.translateX(-180);\n\n\n\n\n# 更改颜色\n\nvar mySphereMaterial = new THREE.MeshLambertMaterial({ color: \"red\" });\n\n\n\n\n\n# 球缓冲几何体（SphereGeometry）\n\n一个用于生成球体的类。\n\n# 构造器\n\nnew THREE.SphereGeometry(60, 40, 40);\n\n\nSphereGeometry(radius : Float, widthSegments : Integer, heightSegments : Integer, phiStart : Float, phiLength : Float, thetaStart : Float, thetaLength : Float)\n\n * radius — 球体半径，默认为1。\n\n * widthSegments — 水平分段数（沿着经线分段），最小值为3，默认值为32。\n\n * heightSegments — 垂直分段数（沿着纬线分段），最小值为2，默认值为16。\n\n * phiStart — 指定水平（经线）起始角度，默认值为0。。\n\n * phiLength — 指定水平（经线）扫描角度的大小，默认值为 Math.PI * 2。\n\n * thetaStart — 指定垂直（纬线）起始角度，默认值为0。\n\n * thetaLength — 指定垂直（纬线）扫描角度大小，默认值为 Math.PI。\n\n该几何体是通过扫描并计算围绕着Y轴（水平扫描）和X轴（垂直扫描）的顶点来创建的。 因此，不完整的球体（类似球形切片）可以通过为phiStart，phiLength，thetaStart和thetaLength设置不同的值来创建， 以定义我们开始（或结束）计算这些顶点的起点（或终点）。\n\n\n# 线性雾化的圆\n\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer({ antialias: true });\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\nmyRenderer.setClearColor('white', 1.0);\n$('#myContainer')[0].appendChild(myRenderer.domElement);\nvar myScene = new THREE.Scene();\n//使用线性雾设置场景的fog雾化属性\nmyScene.fog = new THREE.Fog(0xffffff, 50, 60);\nvar myCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 30, 1000);\nmyCamera.position.set(-55, 17, 31);\nmyCamera.lookAt(new THREE.Vector3(0, 0, 0));\nvar mySpotLight = new THREE.SpotLight('white');\nmySpotLight.position.set(-30, 60, 60);\nmyScene.add(mySpotLight);\n//创建圆球\nvar myMaterial = new THREE.MeshPhongMaterial({ color: 0x7777ff });\nmyMaterial.shininess = 100;\nvar myGeometry = new THREE.SphereGeometry(16, 100, 100);\nvar myMesh = new THREE.Mesh(myGeometry, myMaterial);\nmyScene.add(myMesh);\n//渲染圆球\nmyRenderer.render(myScene, myCamera);\n\n\n\n\n\n# 003-柱体\n\n\n# 单个柱体\n\nvar myCylinderGeometry = new THREE.CylinderGeometry(50, 50, 100, 25);\nvar myCylinderMaterial = new THREE.MeshLambertMaterial({ color: \"green\" });\nvar myCylinderMesh = new THREE.Mesh(myCylinderGeometry, myCylinderMaterial);\nmyCylinderMesh.translateY(120);\nmyCylinderMesh.translateX(200);\nmyScene.add(myCylinderMesh);\n\n\n\n\n\n# 圆柱缓冲几何体（CylinderGeometry)\n\n一个用于生成圆柱几何体的类。\n\n# 构造器\n\nnew THREE.CylinderGeometry(50, 50, 100, 25);\n\n\nCylinderGeometry(radiusTop : Float, radiusBottom : Float, height : Float, radialSegments : Integer, heightSegments : Integer, openEnded : Boolean, thetaStart : Float, thetaLength : Float)\n\n * radiusTop — 圆柱的顶部半径，默认值是1。\n\n * radiusBottom — 圆柱的底部半径，默认值是1。\n\n * height — 圆柱的高度，默认值是1。\n\n * radialSegments — 圆柱侧面周围的分段数，默认为32。\n\n * heightSegments — 圆柱侧面沿着其高度的分段数，默认值为1。\n\n * openEnded — 一个Boolean值，指明该圆锥的底面是开放的还是封顶的。默认值为false，即其底面默认是封顶的。\n\n * thetaStart — 第一个分段的起始角度，默认为0。（three o'clock position）\n\n * thetaLength — 圆柱底面圆扇区的中心角，通常被称为“θ”（西塔）。默认值是2*Pi，这使其成为一个完整的圆柱。\n\n\n# 004-扇形\n\n\n# 空心扇形\n\nif (myCircle) myScene.remove(myCircle);\nvar myGeometry = new THREE.CircleGeometry(48, 600, 0, Math.PI * 2 * 2 / 3);\nvar myMaterial = new THREE.MeshBasicMaterial({ color: 'green', wireframe: false });\nmyCircle = new THREE.Line(myGeometry, myMaterial);\nmyScene.add(myCircle);\n\n\n\n\n\n# 实心扇形\n\nif (myCircle) myScene.remove(myCircle);\nvar myGeometry = new THREE.CircleGeometry(48, 600, 0, Math.PI * 2 * 2 / 3);\nvar myMaterial = new THREE.MeshBasicMaterial({ color: 'green', wireframe: false });;\nmyCircle = new THREE.Mesh(myGeometry, myMaterial)\nmyScene.add(myCircle);\n\n\n\n\n\n# 圆形缓冲几何体（CircleGeometry）\n\nCircleGeometry是欧式几何的一个简单形状，它由围绕着一个中心点的三角分段的数量所构造，由给定的半径来延展。 同时它也可以用于创建规则多边形，其分段数量取决于该规则多边形的边数。\n\n# 代码示例\n\nconst geometry = new THREE.CircleGeometry( 5, 32 ); \nconst material = new THREE.MeshBasicMaterial( { color: 0xffff00 } ); \nconst circle = new THREE.Mesh( geometry, material ); \nscene.add( circle );\n\n\n# 构造器\n\nCircleGeometry(radius : Float, segments : Integer, thetaStart : Float, thetaLength : Float)\n\n * radius — 圆形的半径，默认值为1\n * segments — 分段（三角面）的数量，最小值为3，默认值为32。\n * thetaStart — 第一个分段的起始角度，默认为0。（three o'clock position）\n * thetaLength — 圆形扇区的中心角，通常被称为“θ”（西塔）。默认值是2*Pi，这使其成为一个完整的圆。\n\n# 属性\n\n * .parameters: Object\n   * 一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。\n\n\n# 基础网格材质(MeshBasicMaterial)\n\n一个以简单着色（平面或线框）方式来绘制几何体的材质。\n\n这种材质不受光照的影响。\n\n# 构造函数(Constructor)\n\nMeshBasicMaterial( parameters : Object )\n\n * parameters - (可选)用于定义材质外观的对象，具有一个或多个属性。材质的任何属性都可以从此处传入(包括从Material继承的任何属性)。\n\n属性color例外，其可以作为十六进制字符串传递，默认情况下为 0xffffff（白色），内部调用Color.set(color)。\n\n# 属性(Properties)\n\n共有属性请参见其基类Material。\n\n * .alphaMap : Texture\n   \n   * alpha贴图是一张灰度纹理，用于控制整个表面的不透明度。（黑色：完全透明；白色：完全不透明）。 默认值为null。\n   \n   * 仅使用纹理的颜色，忽略alpha通道（如果存在）。 对于RGB和RGBA纹理，WebGL渲染器在采样此纹理时将使用绿色通道， 因为在DXT压缩和未压缩RGB 565格式中为绿色提供了额外的精度。 Luminance-only以及luminance/alpha纹理也仍然有效。\n\n * .aoMap: Texture\n   \n   * 该纹理的红色通道用作环境遮挡贴图。默认值为null。aoMap需要第二组UV。\n\n * .aoMapIntensity: Float\n   \n   * 环境遮挡效果的强度。默认值为1。零是不遮挡效果。\n\n * .color: Color\n   \n   * 材质的颜色(Color)，默认值为白色 (0xffffff)。\n\n * .combine : Integer\n   \n   * 如何将表面颜色的结果与环境贴图（如果有）结合起来。\n   \n   * 选项为THREE.MultiplyOperation（默认值），THREE.MixOperation， THREE.AddOperation。如果选择多个，则使用.reflectivity在两种颜色之间进行混合。\n\n * .envMap: Texture\n   \n   * 环境贴图。默认值为null。\n\n * .fog: Boolean\n   \n   * 材质是否受雾影响。默认为true。\n\n * .lightMap: Texture\n   \n   * 光照贴图。默认值为null。lightMap需要第二组UV。\n\n * .lightMapIntensity: Float\n   \n   * 烘焙光的强度。默认值为1。\n\n * .map : Texture\n   \n   * 颜色贴图。可以选择包括一个alpha通道，通常与.transparent或.alphaTest。默认为null。\n\n * .reflectivity: Float\n   \n   * 环境贴图对表面的影响程度; 见.combine。默认值为1，有效范围介于0（无反射）和1（完全反射）之间。\n\n * .refractionRatio: Float\n   \n   * 空气的折射率（IOR）（约为1）除以材质的折射率。它与环境映射模式THREE.CubeRefractionMapping和THREE.EquirectangularRefractionMapping一起使用。 The index of refraction (IOR) of air (approximately 1) divided by the index of refraction of the material. It is used with environment mapping mode THREE.CubeRefractionMapping 折射率不应超过1。默认值为0.98。\n\n * .specularMap: Texture\n   \n   * 材质使用的高光贴图。默认值为null。\n\n * .wireframe : Boolean\n   \n   * 将几何体渲染为线框。默认值为false（即渲染为平面多边形）。\n\n * .wireframeLinecap : String\n   \n   * 定义线两端的外观。可选值为 'butt'，'round' 和 'square'。默认为'round'。\n   \n   * 该属性对应2D Canvas lineJoin属性， 并且会被WebGL渲染器忽略。\n\n * .wireframeLinejoin : String\n   \n   * 定义线连接节点的样式。可选值为 'round', 'bevel' 和 'miter'。默认值为 'round'。\n\n * .wireframeLinewidth : Float\n   \n   * 控制线框宽度。默认值为1。\n   \n   * 由于OpenGL Core Profile与大多数平台上WebGL渲染器的限制， 无论如何设置该值，线宽始终为1。\n\n\n# 005-圆环\n\n\n# 创建甜甜圈(单个圆环)\n\n//THREE.TorusGeometry(radius, tube, radialSegments, tubularSegments)\n//创建圆环\nvar myGeometry = new THREE.TorusGeometry(3, 1, 5, 180);  \n//创建材质\nvar myMaterial = new THREE.MeshBasicMaterial({ color: 0xB18904, wireframe: true }); \n//根据圆环和材质创建网格\nvar myMesh = new THREE.Mesh(myGeometry, myMaterial);   \n//在场景中添加网格\nmyScene.add(myMesh);                              \n//渲染甜甜圈\nmyRenderer.render(myScene, myCamera);\n\n\n\n\n\n# 圆环缓冲几何体（TorusGeometry）\n\n一个用于生成圆环几何体的类。\n\n# 代码示例\n\nconst geometry = new THREE.TorusGeometry( 10, 3, 16, 100 );\nconst material = new THREE.MeshBasicMaterial( { color: 0xffff00 } ); \nconst torus = new THREE.Mesh( geometry, material ); \nscene.add( torus );\n\n\n# 构造器\n\nTorusGeometry(radius : Float, tube : Float, radialSegments : Integer, tubularSegments : Integer, arc : Float)\n\n * radius — 环面的半径，从环面的中心到管道横截面的中心。默认值是1。\n * tube — 管道的半径，默认值为0.4。\n * radialSegments — 管道横截面的分段数，默认值为12。\n * tubularSegments — 管道的分段数，默认值为48。\n * arc — 圆环的圆心角（单位是弧度），默认值为Math.PI * 2。\n\n# 属性\n\n * .parameters\n   * 一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。\n\n\n# 创建多次旋转的圆环结（圆环结）\n\n//创建多次旋转的圆环结\nvar myGeometry = new THREE.TorusKnotGeometry(2, 0.4, 100, 12, 3, 4);\nvar myMaterial = new THREE.MeshBasicMaterial({ color: 'green' });\n//创建线框材质\nmyMaterial.wireframe = true;\nvar myMesh = new THREE.Mesh(myGeometry, myMaterial);\nmyScene.add(myMesh);\n//渲染圆环结\nmyRenderer.render(myScene, myCamera);\n\n\n\n\n\n# 圆环缓冲扭结几何体（TorusKnotGeometry）\n\n创建一个圆环扭结，其特殊形状由一对互质的整数，p和q所定义。如果p和q不互质，创建出来的几何体将是一个环面链接。\n\n# 代码示例\n\nconst geometry = new THREE.TorusKnotGeometry( 10, 3, 100, 16 ); \nconst material = new THREE.MeshBasicMaterial( { color: 0xffff00 } ); \nconst torusKnot = new THREE.Mesh( geometry, material ); \nscene.add( torusKnot );\n\n\n# 构造器\n\nTorusKnotGeometry(radius : Float, tube : Float, tubularSegments : Integer, radialSegments : Integer, p : Integer, q : Integer)\n\n * radius - 圆环的半径，默认值为1。\n * tube — 管道的半径，默认值为0.4。\n * tubularSegments — 管道的分段数量，默认值为64。\n * radialSegments — 横截面分段数量，默认值为8。\n * p — 这个值决定了几何体将绕着其旋转对称轴旋转多少次，默认值是2。\n * q — 这个值决定了几何体将绕着其内部圆环旋转多少次，默认值是3。\n\n# 属性\n\n * .parameters\n   * 一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。\n\n\n# 006-圆台\n\n\n# 创建圆台\n\n//创建圆台\n/* CylinderGeometry(\n顶部半径（1），\n底部半径（1），\n圆柱高度（1），\n圆柱侧面周围分段数（32），\n圆柱侧面沿着其高度的分段数（1），\n是否开发（false封闭），\n起始角度（0），\n底面圆扇区的中心角（2*Pi）\n)*/\nvar myGeometry = new THREE.CylinderGeometry(40, 80, 100, 150, 20);\nvar myMaterial = new THREE.MeshNormalMaterial();\nvar myMesh = new THREE.Mesh(myGeometry, myMaterial);\n//在XYZ方向上放大几何体(圆台)\nmyMesh.scale.set(2, 2, 2);\nmyScene.add(myMesh);\n//渲染圆台\nanimate();\nfunction animate() {\n  myRenderer.render(myScene, myCamera);\n  requestAnimationFrame(animate);\n}\n\n\n\n\n\n# 根据样条曲线图形绘制线框盒\n\n//根据样条曲线图形绘制线框盒\nvar myBox = new THREE.BoxHelper(myMesh, 'red');\nmyScene.add(myBox);\n\n\n\n\n\n# 圆柱缓冲几何体（CylinderGeometry）\n\n一个用于生成圆柱几何体的类。\n\n# 代码示例\n\nconst geometry = new THREE.CylinderGeometry( 5, 5, 20, 32 ); \nconst material = new THREE.MeshBasicMaterial( {color: 0xffff00} ); \nconst cylinder = new THREE.Mesh( geometry, material ); \nscene.add( cylinder );\n\n\n# 构造器\n\nCylinderGeometry(radiusTop : Float, radiusBottom : Float, height : Float, radialSegments : Integer, heightSegments : Integer, openEnded : Boolean, thetaStart : Float, thetaLength : Float)\n\n * radiusTop — 圆柱的顶部半径，默认值是1。\n * radiusBottom — 圆柱的底部半径，默认值是1。\n * height — 圆柱的高度，默认值是1。\n * radialSegments — 圆柱侧面周围的分段数，默认为32。\n * heightSegments — 圆柱侧面沿着其高度的分段数，默认值为1。\n * openEnded — 一个Boolean值，指明该圆锥的底面是开放的还是封顶的。默认值为false，即其底面默认是封顶的。\n * thetaStart — 第一个分段的起始角度，默认为0。（three o'clock position）\n * thetaLength — 圆柱底面圆扇区的中心角，通常被称为“θ”（西塔）。默认值是2*Pi，这使其成为一个完整的圆柱。\n\n# 属性\n\n * .parameters : Object\n   * 一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。\n\n\n# 007-两个立方体\n\n\n# 创建两个立方体\n\n//创建正交照相机\nvar width=window.innerWidth;\nvar height=window.innerHeight;\nvar k=width / height;\nvar s=24;\nvar myCamera=new THREE.OrthographicCamera(-s*k,s*k,s,-s,1,1000);\nmyCamera.position.set(-1.66,2.21,18.1);\nmyCamera.lookAt(myScene.position);\n//创建第一个立方体\nvar myGeometry1=new THREE.BoxGeometry(16,16,16);\nvar myMaterial1=new THREE.MeshNormalMaterial();\nvar myMesh1=new THREE.Mesh(myGeometry1,myMaterial1);\nmyMesh1.translateX(-14);\nmyScene.add(myMesh1);\n//创建第二个立方体\nvar myGeometry2=new THREE.BoxGeometry(16,16,16);\nvar myMaterial2=new THREE.MeshNormalMaterial();\nvar myMesh2=new THREE.Mesh(myGeometry2,myMaterial2);\nmyMesh2.translateX(14);\nmyScene.add(myMesh2);\n//渲染两个相同大小的立方体图形\nmyRenderer.render(myScene,myCamera);\n\n\n\n\n\n# 008-圆形\n\n\n# 空心圆\n\nvar myMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });\nvar myGeometry = new THREE.CircleGeometry(50, 1000);\nmyGeometry.vertices.shift();\nmyCircle = new THREE.Line(myGeometry, myMaterial);\nmyScene.add(myCircle);\n\n\n\n\n\n# 实心圆\n\nvar myMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });\nvar myGeometry = new THREE.CircleGeometry(50, 1000);\nmyCircle = new THREE.Mesh(myGeometry, myMaterial);\nmyScene.add(myCircle);\n\n\n\n\n\n# 009-桃心♥️\n\n//创建渲染器\nvar myRenderer= new THREE.WebGLRenderer({antialias: true});\nmyRenderer.setSize(window.innerWidth,window.innerHeight);\nmyRenderer.setClearColor('white', 1.0);\n$(\"#myContainer\").append(myRenderer.domElement);\nvar myScene = new THREE.Scene();\nvar myCamera= new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );\nvar myParam =60;\nmyCamera.position.x = Math.cos( myParam ) * 400;\nmyCamera.position.y = Math.cos( myParam ) * 400;\nmyCamera.position.z = Math.sin( myParam ) * 400;\nmyCamera.lookAt( myScene.position );\nmyScene.add(new THREE.AmbientLight('white'));\n//创建桃心图形\nvar myShape = new THREE.Shape();\nvar x = 0, y = 0;\nmyShape.moveTo( x + 5, y + 5 );\nmyShape.bezierCurveTo( x + 5, y + 5, x + 4, y, x, y );\nmyShape.bezierCurveTo( x - 6, y, x - 6, y + 7,x - 6, y + 7 );\nmyShape.bezierCurveTo( x - 6, y + 11, x - 3, y + 15.4, x + 5, y + 19 );\nmyShape.bezierCurveTo( x + 12, y + 15.4, x + 16, y + 11, x + 16, y + 7 );\nmyShape.bezierCurveTo( x + 16, y + 7, x + 16, y, x + 10, y );\nmyShape.bezierCurveTo( x + 7, y, x + 5, y + 5, x + 5, y + 5 );\nvar myGeometry = new THREE.ShapeGeometry(myShape,30);\n//var myGeometry = myShape.makeGeometry();\nvar myMaterial =new THREE.MeshLambertMaterial({color:'red'});\nvar myMesh = new THREE.Mesh(myGeometry,myMaterial);\nmyMesh.scale.set(18,18,18);\nmyMesh.position.set(100, 110, 210);\nmyMesh.rotation.x = myParam * 5;\nmyMesh.rotation.y = myParam * 3;\nmyMesh.rotation.z = myParam * 2;\nmyScene.add(myMesh);\n//渲染桃心图形\nmyRenderer.render( myScene, myCamera );\n\n\n\n\n\n# 010-三角形\n\n\n# 空心三角形\n\nvar x = -30, y = -30,myPoints=[];\nmyPoints.push(new THREE.Vector2(x, y));\nmyPoints.push(new THREE.Vector2(x + 60, y + 60));\nmyPoints.push(new THREE.Vector2(x , y + 60));\nmyPoints.push(new THREE.Vector2(x , y));\nvar myGeometry=new THREE.Geometry().setFromPoints(myPoints);\nmyTriangle=new THREE.Line(myGeometry, new THREE.LineBasicMaterial({color:0xff0000}));\nmyScene.add(myTriangle);\n\n\n\n\n\n# 实心三角形\n\nvar myShape = new THREE.Shape();\nvar x = -30, y = -30;\nmyShape.moveTo( x, y);\nmyShape.lineTo( x + 60, y + 60);\nmyShape.lineTo( x , y + 60);\nmyShape.lineTo( x , y);\nvar myGeometry = new THREE.ShapeGeometry(myShape);\nvar myMaterial = new THREE.MeshLambertMaterial({color:'red'});\nmyTriangle= new THREE.Mesh(myGeometry,myMaterial);\nmyScene.add(myTriangle);\n\n\n\n\n\n# 多色空心三角形\n\nvar x = -30, y = -30, myPoints = [];\nmyPoints.push(new THREE.Vector2(x, y));\nmyPoints.push(new THREE.Vector2(x + 60, y + 60));\nmyPoints.push(new THREE.Vector2(x, y + 60));\nmyPoints.push(new THREE.Vector2(x, y));\nvar myGeometry = new THREE.Geometry().setFromPoints(myPoints);\n\n//Color对象表示顶点的颜色数据\nvar myColor1 = new THREE.Color('red');\nvar myColor2 = new THREE.Color('green');\nvar myColor3 = new THREE.Color('blue');\nvar myColor4 = new THREE.Color('red');\nmyGeometry.colors.push(myColor1, myColor2, myColor3, myColor4);\n//根据顶点颜色创建材质\nvar myMaterial = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors });\n//根据几何体和材质绘制渐变色的线条\nvar myLine = new THREE.Line(myGeometry, myMaterial);\nmyScene.add(myLine);\n\n\n\n\n\n# 011-多边形\n\n//创建自定义多面体\nvar myVertices = [1, 0, 1, 1, 0, -1, -1, 0, -1, -1, 0, 1, 0, 1, 0];\nvar myFaces = [0, 1, 2, 2, 3, 0, 0, 1, 4, 1, 2, 4, 2, 3, 4, 3, 0, 4];\nvar myGeometry = new THREE.PolyhedronGeometry(myVertices, myFaces, 1, 1);\nvar myMaterial = new THREE.MeshLambertMaterial({ color: 'cyan' });\nvar myMesh = new THREE.Mesh(myGeometry, myMaterial);\nmyMesh.scale.set(32, 32, 32);\nmyScene.add(myMesh);\n//渲染自定义多面体\nanimate();\nfunction animate() {\n  myRenderer.render(myScene, myCamera);\n  requestAnimationFrame(animate);\n}\n\n\n\n\n\n# 012-矩形\n\n\n# 虚线空心矩形\n\n//创建虚线空心矩形\nvar myPoints = [];\nmyPoints.push(new THREE.Vector3(- 50, 30, 0));\t\t\t\t//左上顶点\nmyPoints.push(new THREE.Vector3(50, 30, 0));  \t\t\t\t//右上顶点\nmyPoints.push(new THREE.Vector3(50, -20, 0));  \t\t\t\t//右下顶点\nmyPoints.push(new THREE.Vector3(- 50, -20, 0));\t\t\t\t//左下顶点\nmyPoints.push(new THREE.Vector3(- 50, 30, 0));\t\t\t\t//左上顶点\nvar myGeometry = new THREE.BufferGeometry().setFromPoints(myPoints);\nvar myMaterial = new THREE.LineDashedMaterial({ vertexColors: true, scale: 1.0 });\n//根据顶点绘制线条\nvar myLine = new THREE.Line(myGeometry, myMaterial);\nmyLine.computeLineDistances();\nmyLine.position.set(3, -5, 0);\nmyScene.add(myLine);\n//渲染虚线空心矩形\nmyRenderer.render(myScene, myCamera);\n\n\n\n\n\n# 013-四面体\n\n//创建四面体\nvar myGeometry = new THREE.TetrahedronGeometry(140, 0);\nvar myMaterial = new THREE.MeshNormalMaterial();\nvar myMesh = new THREE.Mesh(myGeometry, myMaterial);\nmyScene.add(myMesh);\n//渲染四面体\nmyRenderer.render(myScene, myCamera);\n\n\n\n\n\n# 014-多粒子\n\n\n# 静态粒子\n\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer({ antialias: true });\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\nmyRenderer.setClearColor('white', 1.0);\n$('#myContainer')[0].appendChild(myRenderer.domElement);\nvar myCamera = new THREE.PerspectiveCamera(45,\n                                           window.innerWidth / window.innerHeight, 1, 1000);\nvar myScene = new THREE.Scene();\n//使用THREE.Sprite和THREE.SpriteMaterial绘制多个随机粒子\nvar myGroup = new THREE.Group();\nmyScene.add(myGroup);\nfor (var i = 0; i < 10000; i++) {\n  var mySpriteMaterial = new THREE.SpriteMaterial({\n    color: new THREE.Color(+SetRandomColor())\n  });\n  var mySprite = new THREE.Sprite(mySpriteMaterial);\n  mySprite.position.x = THREE.Math.randFloatSpread(2000);\n  mySprite.position.y = THREE.Math.randFloatSpread(2000);\n  mySprite.position.z = THREE.Math.randFloatSpread(2000);\n  mySprite.scale.set(8, 8, 8);\n  myGroup.add(mySprite);\n}\n//渲染多个随机粒子\nmyRenderer.render(myScene, myCamera);\n//随机生成颜色\nfunction SetRandomColor() {\n  var arrHex = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\",\n                \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\"],\n      strHex = \"0x\",\n      index;\n  for (var i = 0; i < 6; i++) {\n    index = Math.round(Math.random() * 15);\n    strHex += arrHex[index];\n  }\n  return strHex;\n}\n\n\n\n\n\n# 旋转粒子\n\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer({ antialias: true });\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\nmyRenderer.setClearColor('white', 1.0);\n$('#myContainer')[0].appendChild(myRenderer.domElement);\nvar myCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 30, 1000);\nvar myScene = new THREE.Scene();\n//创建多个粒子\nvar myGeometry = new THREE.Geometry();\nfor (var i = 0; i < 10000; i++) {\n  var myPoint = new THREE.Vector3();\n  myPoint.x = THREE.Math.randFloatSpread(2000);\n  myPoint.y = THREE.Math.randFloatSpread(2000);\n  myPoint.z = THREE.Math.randFloatSpread(2000);\n  myGeometry.vertices.push(myPoint);\n}\nvar myPointsMaterial = new THREE.PointsMaterial({ size: 10, color: 'darkgreen' });\nvar myPoints = new THREE.Points(myGeometry, myPointsMaterial);\nmyScene.add(myPoints);\n//渲染多个粒子\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myPoints.rotation.x += 0.01;\n  myPoints.rotation.y += 0.01;\n  myPoints.rotation.z += 0.01;\n  myRenderer.render(myScene, myCamera);\n};\n\n\n\n# 粒子更换成贴图\n\n# 大小一样的多个粒子\n\n//使用普通贴图材质创建多个粒子\nvar myMap = new THREE.TextureLoader().load('images/img041.png');\nvar myGeometry = new THREE.Geometry();\nfor (var i = 0; i < 1000; i++) {\n  var myPoint = new THREE.Vector3();\n  myPoint.x = THREE.Math.randFloatSpread(2000);\n  myPoint.y = THREE.Math.randFloatSpread(2000);\n  myPoint.z = THREE.Math.randFloatSpread(2000);\n  myGeometry.vertices.push(myPoint);\n}\nvar myPointsMaterial = new THREE.PointsMaterial({\n  size: 200, alphaTest: 0.5, map: myMap\n});\nvar myPoints = new THREE.Points(myGeometry, myPointsMaterial);\nmyScene.add(myPoints);\n//渲染多个粒子\nmyRenderer.render(myScene, myCamera);\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myPoints.rotation.x += 0.006;\n  myPoints.rotation.y += 0.006;\n  myPoints.rotation.z += 0.006;\n  myRenderer.render(myScene, myCamera);\n};\n\n\n# 大小不一的多个粒子\n\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer({ antialias: true });\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\nmyRenderer.setClearColor('white', 1.0);\n$('#myContainer')[0].appendChild(myRenderer.domElement);\nvar myCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);\nvar myScene = new THREE.Scene();\n//使用THREE.Sprite和THREE.SpriteMaterial创建大小不一的多个粒子\nvar myGroup = new THREE.Group();\nmyScene.add(myGroup);\n//加载纹理图像\nvar myMap = new THREE.TextureLoader().load('images/img040.png');\n//根据纹理图像创建THREE.SpriteMaterial材质\nvar mySpriteMaterial = new THREE.SpriteMaterial({ map: myMap });\n//根据THREE.SpriteMaterial材质创建THREE.Sprite(粒子)\nfor (var i = 0; i < 3000; i++) {\n  var mySprite = new THREE.Sprite(mySpriteMaterial);\n  mySprite.position.x = THREE.Math.randFloatSpread(2000);\n  mySprite.position.y = THREE.Math.randFloatSpread(2000);\n  mySprite.position.z = THREE.Math.randFloatSpread(2000);\n  mySprite.scale.set(30, 30, 1);\n  myGroup.add(mySprite);\n}\nmyScene.add(myGroup);\n//渲染多个使用普通贴图创建的粒子\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myGroup.rotation.x += 0.006;\n  myGroup.rotation.y += 0.006;\n  myGroup.rotation.z += 0.006;\n  myRenderer.render(myScene, myCamera);\n}\n\n\n# 粒子是实心圆\n\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\nmyRenderer.setClearColor('white', 1.0);\n$('#myContainer')[0].appendChild(myRenderer.domElement);\nvar myCamera = new THREE.PerspectiveCamera(45,\n                                           window.innerWidth / window.innerHeight, 30, 1000);\nvar myScene = new THREE.Scene();\n//创建多个粒子\nvar myGeometry = new THREE.Geometry();\nfor (var i = 0; i < 10000; i++) {\n  var myPoint = new THREE.Vector3();\n  myPoint.x = THREE.Math.randFloatSpread(2000);\n  myPoint.y = THREE.Math.randFloatSpread(2000);\n  myPoint.z = THREE.Math.randFloatSpread(2000);\n  myGeometry.vertices.push(myPoint);\n}\n//在画布上绘制实心圆\nvar myCanvas = document.createElement(\"canvas\");\nmyCanvas.width = 100;\nmyCanvas.height = 100;\nvar myContext = myCanvas.getContext(\"2d\");\nmyContext.fillStyle = \"#ffff00\";\nmyContext.arc(50, 50, 45, 0, 2 * Math.PI);;\nmyContext.fill();\nvar myTexture = new THREE.Texture(myCanvas);\nmyTexture.needsUpdate = true;\n//使用在画布上绘制的实心圆(贴图)创建PointsMaterial\nvar myPointsMaterial = new THREE.PointsMaterial({\n  size: 30,\n  color: 'darkgreen',\n  map: myTexture\n});\nvar myPoints = new THREE.Points(myGeometry, myPointsMaterial);\nmyScene.add(myPoints);\n//渲染多个实心圆粒子\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myPoints.rotation.x += 0.01;\n  myPoints.rotation.y += 0.01;\n  myPoints.rotation.z += 0.01;\n  myRenderer.render(myScene, myCamera);\n};\n\n\n\n# 015-阿基米德螺线\n\n\n# 平面螺旋线\n\n//创建阿基米德螺线\nvar myPoints = [];\nfor (var i = 0; i < 360 * 10; i++) {\n  //根据阿基米德螺线方程计算坐标\n  var myX = i * Math.cos(i * Math.PI / 180) / 100;\n  var myY = i * Math.sin(i * Math.PI / 180) / 100;\n  //使用Vector2封装二维坐标\n  myPoints.push(new THREE.Vector2(myX, myY));\n}\nvar myCurve = new THREE.SplineCurve(myPoints);\nvar myGeometry = new THREE.BufferGeometry();\n//myGeometry.setFromPoints(myCurve.getPoints(60));\nmyGeometry.setFromPoints(myCurve.getPoints(600));\nvar myMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff00 });\nvar myCurveLine = new THREE.Line(myGeometry, myMaterial);\nmyScene.add(myCurveLine);\n//渲染阿基米德螺线\nmyRenderer.render(myScene, myCamera);\n\n\n\n\n\n# 弹簧螺旋线\n\n//创建阿基米德螺线\nvar myPoints = [];\nfor (var i = 0; i < 360 * 10; i++) {\n  //根据螺线方程计算点坐标\n  var myX = 30 * Math.cos(i * Math.PI / 180);\n  var myY = 30 * Math.sin(i * Math.PI / 180);\n  var myZ = 5 * i * Math.PI / 180;\n  //使用Vector3封装点坐标\n  myPoints.push(new THREE.Vector3(myX, myY, myZ));\n}\nvar myGeometry = new THREE.BufferGeometry();\nmyGeometry.setFromPoints(myPoints);\nvar myMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });\nvar myCurveLine = new THREE.Line(myGeometry, myMaterial);\nmyCurveLine.position.x = -80;\nmyCurveLine.position.y = 120;\nmyScene.add(myCurveLine);\n//渲染阿基米德螺线\nmyRenderer.render(myScene, myCamera);\n\n\n\n\n\n# 016-沙漏\n\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer({ antialias: true });\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\nmyRenderer.setClearColor('white', 1.0);\n$(\"#myContainer\").append(myRenderer.domElement);\nvar myCamera = new THREE.PerspectiveCamera(45,\n                                           window.innerWidth / window.innerHeight, 0.1, 1000);\nmyCamera.position.set(400, 300, 150);\nmyCamera.lookAt(new THREE.Vector3(0, 0, 0));\nvar myScene = new THREE.Scene();\n//创建沙漏\nvar myGeometry = new THREE.CylinderGeometry(50, -50, 150, 32);\nvar myMaterial = new THREE.MeshNormalMaterial();\nvar myMesh = new THREE.Mesh(myGeometry, myMaterial);\nmyMesh.scale.set(2, 2, 2);\nmyScene.add(myMesh);\n//渲染沙漏\nanimate();\nfunction animate() {\n  myRenderer.render(myScene, myCamera);\n  requestAnimationFrame(animate);\n}\n\n\n\n\n\n# 017-\n\n\n\n\n\n# 018-\n\n\n\n\n\n# 019-\n\n\n\n\n\n# 020-\n\n\n",normalizedContent:"# 001-立方体\n\n\n# 单个立方体\n\nvar myrenderer = new three.webglrenderer();              //创建渲染器\nvar mywidth = 480;                                      //设置窗口宽度\nvar myheight = 320;                                    //设置窗口高度\nmyrenderer.setsize(mywidth, myheight);                //设置渲染区域\nmyrenderer.setclearcolor(\"white\", 1);                 //设置清空颜色\n$(\"#mycontainer\").append(myrenderer.domelement);\nvar myscene = new three.scene();                          //创建场景\nvar mylight = new three.pointlight(\"red\");           //创建红色光源\nmylight.position.set(400, 800, 300);                   //设置光源位置\nmyscene.add(mylight);                            //在场景中添加光源\nvar k = mywidth / myheight;                         //计算窗口宽高比\nvar s = 120;                              //三维场景显示范围控制系数\nvar mycamera = new three.orthographiccamera(-s * k, s * k, s, -s, 1, 1000); //创建相机\nmycamera.position.set(400, 300, 200);                //设置相机位置\nmycamera.lookat(myscene.position);\nvar mygeometry = new three.boxgeometry(100, 100, 100); //创建立方体\nvar mymaterial = new three.meshlambertmaterial({ color: 0xffbf00 }); //创建材质\nvar mymesh = new three.mesh(mygeometry, mymaterial);      //创建网格\nmyscene.add(mymesh);                      //在场景中添加网格(立方体)\nmyrenderer.render(myscene, mycamera);                  //渲染立方体\n\n\n\n\n# 更改立方体的面(有12个face)颜色\n\n//创建立方体\nvar mygeometry = new three.boxgeometry(100, 100, 100);\n//var mygeometry = new three.tetrahedrongeometry(140, 0);\n//使用随机数创建立方体的面(有12个face)颜色\nfor (var i = 0; i < mygeometry.faces.length; i++) {\n  var mycolor = math.random() * 0xffffff;\n  mygeometry.faces[i].color.sethex(mycolor);\n}\n//根据颜色创建材质\nvar mymaterial = new three.meshbasicmaterial({ vertexcolors: three.facecolors });\nvar mymesh = new three.mesh(mygeometry, mymaterial);\nmyscene.add(mymesh);\n\n\n\n\n# 更改立方体的6种颜色材质\n\n//创建立方体\nvar mygeometry = new three.boxgeometry(30, 30, 30);\n//创建6种颜色的材质\nvar mymaterials = [];\nfor (var i = 0; i < 6; i++) {\n  var mymaterial = new three.meshbasicmaterial({ color: new three.color(math.random() * 0xffffff) });\n  mymaterials.push(mymaterial);\n}\n//使用材质数组设置立方体表面颜色\nvar mymesh = new three.mesh(mygeometry, mymaterials);\nmyscene.add(mymesh);\n\n\n\n\n# 混合更改颜色\n\n//创建立方体\nvar mygeometry = new three.boxgeometry(30, 30, 30);\n//创建12种颜色的材质\nvar mymaterials = [];\nfor (var i = 0; i < 12; i++) {\n  var mymaterial = new three.meshbasicmaterial({ color: new three.color(math.random() * 0xffffff) });\n  mymaterials.push(mymaterial);\n}\n//使用材质数组设置立方体表面颜色\nvar mymesh = new three.mesh(mygeometry, mymaterials);\n//使用12种材质设置立方体的12个face\nfor (var j = 0; j < 12; j++) {\n  mygeometry.faces[j].materialindex = j;\n}\nmyscene.add(mymesh);\n\n\n# 更改效果\n\n# 更改区域样式\n\nmyrenderer.setclearcolor(\"green\", 1);   \n\n\n\n\n# 更改光源颜色\n\nvar mylight = new three.pointlight(\"yellow\"); \n\n\n\n\n# 更改物体\n\nvar mygeometry = new three.boxgeometry(50, 50, 50); \n\n\n\n\n# 更改材质\n\nvar mymaterial = new three.meshlambertmaterial({ color: 0xe954f1 }); \n\n\n\n\n\n\n\n# 渲染器webglrenderer\n\nwebgl render 用webgl渲染出你精心制作的场景。\n\n# 构造器\n\nnew three.webglrenderer({ antialias: true });\n\n\nwebglrenderer( parameters : object )\n\n * parameters - (可选) 该对象的属性定义了渲染器的行为。也可以完全不传参数。在所有情况下，当缺少参数时，它将采用合理的默认值。 以下是合法参数：\n * canvas - 一个供渲染器绘制其输出的canvas它和下面的domelement属性对应。 如果没有传这个参数，会创建一个新canvas\n * context - 可用于将渲染器附加到已有的渲染环境(renderingcontext)中。默认值是null\n * precision - 着色器精度. 可以是 \"highp\", \"mediump\" 或者 \"lowp\". 如果设备支持，默认为**\"highp\"** .\n * alpha - controls the default clear alpha value. when set to true, the value is 0. otherwise it's 1. default is false.\n * premultipliedalpha - renderer是否假设颜色有 premultiplied alpha. 默认为true\n * antialias - 是否执行抗锯齿。默认为false.\n * stencil - 绘图缓存是否有一个至少8位的模板缓存(stencil buffer)。默认为true\n * preservedrawingbuffer -是否保留缓直到手动清除或被覆盖。 默认false.\n * powerpreference - 提示用户代理怎样的配置更适用于当前webgl环境。 可能是**\"high-performance\", \"low-power\" 或 \"default\"。默认是\"default\"**.\n * failifmajorperformancecaveat - 检测渲染器是否会因性能过差而创建失败。默认为false。\n * depth - 绘图缓存是否有一个至少6位的深度缓存(depth buffer )。 默认是true.\n * logarithmicdepthbuffer - 是否使用对数深度缓存。如果要在单个场景中处理巨大的比例差异，就有必要使用。 note that this setting uses gl_fragdepth if available which disables the early fragment test optimization and can cause a decrease in performance. 默认是false。 示例：camera\n\n\n# 立方缓冲几何体（boxgeometry）\n\nboxgeometry是四边形的原始几何类，它通常使用构造函数所提供的“width”、“height”、“depth”参数来创建立方体或者不规则四边形。\n\n# 构造器\n\nnew three.boxgeometry(100, 100, 100); \n\n\nboxgeometry(width : float, height : float, depth : float, widthsegments : integer, heightsegments : integer, depthsegments : integer)\n\n * width — x轴上面的宽度，默认值为1。\n\n * height — y轴上面的高度，默认值为1。\n\n * depth — z轴上面的深度，默认值为1。\n\n * widthsegments — （可选）宽度的分段数，默认值是1。\n\n * heightsegments — （可选）高度的分段数，默认值是1。\n\n * depthsegments — （可选）深度的分段数，默认值是1。\n\n\n# 魔方（9x9个立方体）\n\n//创建渲染器\nvar myrenderer = new three.webglrenderer({ antialias: true });\nmyrenderer.setsize(window.innerwidth, window.innerheight);\nmyrenderer.setclearcolor('white', 1.0);\n$('#mycontainer')[0].appendchild(myrenderer.domelement);\nvar myscene = new three.scene();\nvar mycamera = new three.perspectivecamera(45, window.innerwidth / window.innerheight, 30, 1000);\nmycamera.position.set(-50, 40, 50);\nmycamera.lookat(new three.vector3(0, 0, 0));\n//创建立方体图形\nvar mysize = 9;\nvar mycubegeometry = new three.boxgeometry(mysize - 0.1, mysize - 0.1, mysize - 0.1);\n//创建材质数组\nvar mymaterials = [];\nmymaterials.push(new three.meshbasicmaterial({ color: 'red' }));\nmymaterials.push(new three.meshbasicmaterial({ color: 'green' }));\nmymaterials.push(new three.meshbasicmaterial({ color: 'blue' }));\nmymaterials.push(new three.meshbasicmaterial({ color: 'cyan' }));\nmymaterials.push(new three.meshbasicmaterial({ color: 'yellow' }));\nmymaterials.push(new three.meshbasicmaterial({ color: 'pink' }));\n//添加单个立方体\nmycubemesh = new three.mesh(mycubegeometry, mymaterials);\nmycubemesh.position.set(-mysize * 3 + mysize, mysize * 3 - mysize, -mysize * 3);\nmyscene.add(mycubemesh);\n//添加魔方(27个立方体)\nmygroupmesh = new three.mesh();\nfor (var x = 0; x < 3; x++) {\n  for (var y = 0; y < 3; y++) {\n    for (var z = 0; z < 3; z++) {\n      var mymesh = new three.mesh(mycubegeometry, mymaterials);\n      mymesh.position.set(x * mysize - mysize, y * mysize - mysize, z * mysize - mysize);\n      mygroupmesh.add(mymesh);\n    }\n  }\n}\nmyscene.add(mygroupmesh);\n//渲染图形\nanimate();\nfunction animate() {\n  myrenderer.render(myscene, mycamera);\n}\nvar myorbitcontrols = new three.orbitcontrols(mycamera, myrenderer.domelement);           //创建轨道控制器\nmyorbitcontrols.addeventlistener('change', animate);  //监听鼠标、键盘事件\n\n\n\n\n\n# 一排立方体\n\n//创建渲染器\nvar myrenderer = new three.webglrenderer({ antialias: true });\nmyrenderer.setsize(window.innerwidth, window.innerheight);\nmyrenderer.setclearcolor('black', 1.0);\n$('#mycontainer')[0].appendchild(myrenderer.domelement);\nvar mycamera = new three.perspectivecamera(45, window.innerwidth / window.innerheight, 30, 1000);\nmycamera.position.set(-40.91020281125894,  12.522960007309857, 22.79661391601931);\nmycamera.lookat(new three.vector3(0, 0, 0));\nvar myscene = new three.scene();\n//创建100个立方体\nvar mysize = 9; \nvar mygeometry = new three.boxgeometry(mysize, mysize, mysize);\nvar mymaterial = new three.meshdepthmaterial();\nvar mygroupmesh = new three.mesh();\nfor (var x = 0; x < 100; x++) {\n  var mymesh = new three.mesh(mygeometry, mymaterial);\n  mymesh.position.set(x * mysize * 2 - mysize, 0, 0);\n  mygroupmesh.add(mymesh);\n}\nmyscene.add(mygroupmesh);\n//渲染100个立方体\nmyrenderer.render(myscene, mycamera);\n\n\n\n\n\n# 魔方(多个立方体)\n\n//创建渲染器\nvar myrenderer = new three.webglrenderer({ antialias: true });\nmyrenderer.setsize(window.innerwidth, window.innerheight);\n$(\"#mycontainer\").append(myrenderer.domelement);\nvar myscene = new three.scene();\nmyscene.add(new three.axeshelper(120));\nmyscene.background = new three.color('white');\nmyscene.add(new three.ambientlight(0xffffff));\nvar mycamera = new three.perspectivecamera(45,\n                                           window.innerwidth / window.innerheight, 0.1, 1000);\nmycamera.position.set(100, 100, 100);\nmycamera.lookat(myscene.position);\nvar mycontrols = new three.orbitcontrols(mycamera, myrenderer.domelement);\n//创建魔方模型\nvar mymaterials = [];\nmymaterials.push(new three.meshphongmaterial({ color: 0x009e60 }));\nmymaterials.push(new three.meshphongmaterial({ color: 0x0051ba }));\nmymaterials.push(new three.meshphongmaterial({ color: 0xffd500 }));\nmymaterials.push(new three.meshphongmaterial({ color: 0xff5800 }));\nmymaterials.push(new three.meshphongmaterial({ color: 0xc41e3a }));\nmymaterials.push(new three.meshphongmaterial({ color: 0xffffff }));\nvar mygroup = new three.group();\nfor (var x = 0; x < 6; x++) {\n  for (var y = 0; y < 6; y++) {\n    for (var z = 0; z < 6; z++) {\n      var mygeometry = new three.boxgeometry(5.9, 5.9, 5.9);\n      var mymesh = new three.mesh(mygeometry, mymaterials);\n      mymesh.position.set(x * 6 - 6, y * 6 + 6, z * 6 - 6);\n      mygroup.add(mymesh);\n    }\n  }\n}\nmygroup.scale.set(2, 2, 2);\nmyscene.add(mygroup);\nvar mybox3 = new three.box3();\nmybox3.expandbyobject(mygroup);\nvar myx = mybox3.max.x - mybox3.min.x;\nvar myy = mybox3.max.y - mybox3.min.y;\nvar myz = mybox3.max.z - mybox3.min.z;\nvar mynewx = mybox3.min.x + myx / 2;\nvar mynewy = mybox3.min.y + myy / 2;\nvar mynewz = mybox3.min.z + myz / 2;\n//根据计算结果重新设置魔方位置，使其居中显示\nmygroup.position.set(-mynewx, -mynewy, -mynewz);\n//渲染魔方模型\nanimate();\nfunction animate() {\n  myrenderer.render(myscene, mycamera);\n  requestanimationframe(animate);\n}\n\n\n\n\n\n# 002-圆\n\n\n# 单个圆\n\n// 白色背景\nmyrenderer.setclearcolor(\"white\", 1);     \n// 白色光源\nvar mylight = new three.pointlight(\"white\");  \n...\nvar myspheregeometry = new three.spheregeometry(60, 40, 40);\nvar myspherematerial = new three.meshlambertmaterial({ color: \"blue\" });\nvar myspheremesh = new three.mesh(myspheregeometry, myspherematerial);\nmyspheremesh.translatey(-100);\nmyspheremesh.translatex(-180);\nmyscene.add(myspheremesh);\n\n\n\n\n# 更改效果\n\n# 更改大小\n\nnew three.spheregeometry(30, 40, 40);\n\n\n\n\n# 更改位置\n\nmyspheremesh.translatey(-150);\nmyspheremesh.translatex(-180);\n\n\n\n\n# 更改颜色\n\nvar myspherematerial = new three.meshlambertmaterial({ color: \"red\" });\n\n\n\n\n\n# 球缓冲几何体（spheregeometry）\n\n一个用于生成球体的类。\n\n# 构造器\n\nnew three.spheregeometry(60, 40, 40);\n\n\nspheregeometry(radius : float, widthsegments : integer, heightsegments : integer, phistart : float, philength : float, thetastart : float, thetalength : float)\n\n * radius — 球体半径，默认为1。\n\n * widthsegments — 水平分段数（沿着经线分段），最小值为3，默认值为32。\n\n * heightsegments — 垂直分段数（沿着纬线分段），最小值为2，默认值为16。\n\n * phistart — 指定水平（经线）起始角度，默认值为0。。\n\n * philength — 指定水平（经线）扫描角度的大小，默认值为 math.pi * 2。\n\n * thetastart — 指定垂直（纬线）起始角度，默认值为0。\n\n * thetalength — 指定垂直（纬线）扫描角度大小，默认值为 math.pi。\n\n该几何体是通过扫描并计算围绕着y轴（水平扫描）和x轴（垂直扫描）的顶点来创建的。 因此，不完整的球体（类似球形切片）可以通过为phistart，philength，thetastart和thetalength设置不同的值来创建， 以定义我们开始（或结束）计算这些顶点的起点（或终点）。\n\n\n# 线性雾化的圆\n\n//创建渲染器\nvar myrenderer = new three.webglrenderer({ antialias: true });\nmyrenderer.setsize(window.innerwidth, window.innerheight);\nmyrenderer.setclearcolor('white', 1.0);\n$('#mycontainer')[0].appendchild(myrenderer.domelement);\nvar myscene = new three.scene();\n//使用线性雾设置场景的fog雾化属性\nmyscene.fog = new three.fog(0xffffff, 50, 60);\nvar mycamera = new three.perspectivecamera(45, window.innerwidth / window.innerheight, 30, 1000);\nmycamera.position.set(-55, 17, 31);\nmycamera.lookat(new three.vector3(0, 0, 0));\nvar myspotlight = new three.spotlight('white');\nmyspotlight.position.set(-30, 60, 60);\nmyscene.add(myspotlight);\n//创建圆球\nvar mymaterial = new three.meshphongmaterial({ color: 0x7777ff });\nmymaterial.shininess = 100;\nvar mygeometry = new three.spheregeometry(16, 100, 100);\nvar mymesh = new three.mesh(mygeometry, mymaterial);\nmyscene.add(mymesh);\n//渲染圆球\nmyrenderer.render(myscene, mycamera);\n\n\n\n\n\n# 003-柱体\n\n\n# 单个柱体\n\nvar mycylindergeometry = new three.cylindergeometry(50, 50, 100, 25);\nvar mycylindermaterial = new three.meshlambertmaterial({ color: \"green\" });\nvar mycylindermesh = new three.mesh(mycylindergeometry, mycylindermaterial);\nmycylindermesh.translatey(120);\nmycylindermesh.translatex(200);\nmyscene.add(mycylindermesh);\n\n\n\n\n\n# 圆柱缓冲几何体（cylindergeometry)\n\n一个用于生成圆柱几何体的类。\n\n# 构造器\n\nnew three.cylindergeometry(50, 50, 100, 25);\n\n\ncylindergeometry(radiustop : float, radiusbottom : float, height : float, radialsegments : integer, heightsegments : integer, openended : boolean, thetastart : float, thetalength : float)\n\n * radiustop — 圆柱的顶部半径，默认值是1。\n\n * radiusbottom — 圆柱的底部半径，默认值是1。\n\n * height — 圆柱的高度，默认值是1。\n\n * radialsegments — 圆柱侧面周围的分段数，默认为32。\n\n * heightsegments — 圆柱侧面沿着其高度的分段数，默认值为1。\n\n * openended — 一个boolean值，指明该圆锥的底面是开放的还是封顶的。默认值为false，即其底面默认是封顶的。\n\n * thetastart — 第一个分段的起始角度，默认为0。（three o'clock position）\n\n * thetalength — 圆柱底面圆扇区的中心角，通常被称为“θ”（西塔）。默认值是2*pi，这使其成为一个完整的圆柱。\n\n\n# 004-扇形\n\n\n# 空心扇形\n\nif (mycircle) myscene.remove(mycircle);\nvar mygeometry = new three.circlegeometry(48, 600, 0, math.pi * 2 * 2 / 3);\nvar mymaterial = new three.meshbasicmaterial({ color: 'green', wireframe: false });\nmycircle = new three.line(mygeometry, mymaterial);\nmyscene.add(mycircle);\n\n\n\n\n\n# 实心扇形\n\nif (mycircle) myscene.remove(mycircle);\nvar mygeometry = new three.circlegeometry(48, 600, 0, math.pi * 2 * 2 / 3);\nvar mymaterial = new three.meshbasicmaterial({ color: 'green', wireframe: false });;\nmycircle = new three.mesh(mygeometry, mymaterial)\nmyscene.add(mycircle);\n\n\n\n\n\n# 圆形缓冲几何体（circlegeometry）\n\ncirclegeometry是欧式几何的一个简单形状，它由围绕着一个中心点的三角分段的数量所构造，由给定的半径来延展。 同时它也可以用于创建规则多边形，其分段数量取决于该规则多边形的边数。\n\n# 代码示例\n\nconst geometry = new three.circlegeometry( 5, 32 ); \nconst material = new three.meshbasicmaterial( { color: 0xffff00 } ); \nconst circle = new three.mesh( geometry, material ); \nscene.add( circle );\n\n\n# 构造器\n\ncirclegeometry(radius : float, segments : integer, thetastart : float, thetalength : float)\n\n * radius — 圆形的半径，默认值为1\n * segments — 分段（三角面）的数量，最小值为3，默认值为32。\n * thetastart — 第一个分段的起始角度，默认为0。（three o'clock position）\n * thetalength — 圆形扇区的中心角，通常被称为“θ”（西塔）。默认值是2*pi，这使其成为一个完整的圆。\n\n# 属性\n\n * .parameters: object\n   * 一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。\n\n\n# 基础网格材质(meshbasicmaterial)\n\n一个以简单着色（平面或线框）方式来绘制几何体的材质。\n\n这种材质不受光照的影响。\n\n# 构造函数(constructor)\n\nmeshbasicmaterial( parameters : object )\n\n * parameters - (可选)用于定义材质外观的对象，具有一个或多个属性。材质的任何属性都可以从此处传入(包括从material继承的任何属性)。\n\n属性color例外，其可以作为十六进制字符串传递，默认情况下为 0xffffff（白色），内部调用color.set(color)。\n\n# 属性(properties)\n\n共有属性请参见其基类material。\n\n * .alphamap : texture\n   \n   * alpha贴图是一张灰度纹理，用于控制整个表面的不透明度。（黑色：完全透明；白色：完全不透明）。 默认值为null。\n   \n   * 仅使用纹理的颜色，忽略alpha通道（如果存在）。 对于rgb和rgba纹理，webgl渲染器在采样此纹理时将使用绿色通道， 因为在dxt压缩和未压缩rgb 565格式中为绿色提供了额外的精度。 luminance-only以及luminance/alpha纹理也仍然有效。\n\n * .aomap: texture\n   \n   * 该纹理的红色通道用作环境遮挡贴图。默认值为null。aomap需要第二组uv。\n\n * .aomapintensity: float\n   \n   * 环境遮挡效果的强度。默认值为1。零是不遮挡效果。\n\n * .color: color\n   \n   * 材质的颜色(color)，默认值为白色 (0xffffff)。\n\n * .combine : integer\n   \n   * 如何将表面颜色的结果与环境贴图（如果有）结合起来。\n   \n   * 选项为three.multiplyoperation（默认值），three.mixoperation， three.addoperation。如果选择多个，则使用.reflectivity在两种颜色之间进行混合。\n\n * .envmap: texture\n   \n   * 环境贴图。默认值为null。\n\n * .fog: boolean\n   \n   * 材质是否受雾影响。默认为true。\n\n * .lightmap: texture\n   \n   * 光照贴图。默认值为null。lightmap需要第二组uv。\n\n * .lightmapintensity: float\n   \n   * 烘焙光的强度。默认值为1。\n\n * .map : texture\n   \n   * 颜色贴图。可以选择包括一个alpha通道，通常与.transparent或.alphatest。默认为null。\n\n * .reflectivity: float\n   \n   * 环境贴图对表面的影响程度; 见.combine。默认值为1，有效范围介于0（无反射）和1（完全反射）之间。\n\n * .refractionratio: float\n   \n   * 空气的折射率（ior）（约为1）除以材质的折射率。它与环境映射模式three.cuberefractionmapping和three.equirectangularrefractionmapping一起使用。 the index of refraction (ior) of air (approximately 1) divided by the index of refraction of the material. it is used with environment mapping mode three.cuberefractionmapping 折射率不应超过1。默认值为0.98。\n\n * .specularmap: texture\n   \n   * 材质使用的高光贴图。默认值为null。\n\n * .wireframe : boolean\n   \n   * 将几何体渲染为线框。默认值为false（即渲染为平面多边形）。\n\n * .wireframelinecap : string\n   \n   * 定义线两端的外观。可选值为 'butt'，'round' 和 'square'。默认为'round'。\n   \n   * 该属性对应2d canvas linejoin属性， 并且会被webgl渲染器忽略。\n\n * .wireframelinejoin : string\n   \n   * 定义线连接节点的样式。可选值为 'round', 'bevel' 和 'miter'。默认值为 'round'。\n\n * .wireframelinewidth : float\n   \n   * 控制线框宽度。默认值为1。\n   \n   * 由于opengl core profile与大多数平台上webgl渲染器的限制， 无论如何设置该值，线宽始终为1。\n\n\n# 005-圆环\n\n\n# 创建甜甜圈(单个圆环)\n\n//three.torusgeometry(radius, tube, radialsegments, tubularsegments)\n//创建圆环\nvar mygeometry = new three.torusgeometry(3, 1, 5, 180);  \n//创建材质\nvar mymaterial = new three.meshbasicmaterial({ color: 0xb18904, wireframe: true }); \n//根据圆环和材质创建网格\nvar mymesh = new three.mesh(mygeometry, mymaterial);   \n//在场景中添加网格\nmyscene.add(mymesh);                              \n//渲染甜甜圈\nmyrenderer.render(myscene, mycamera);\n\n\n\n\n\n# 圆环缓冲几何体（torusgeometry）\n\n一个用于生成圆环几何体的类。\n\n# 代码示例\n\nconst geometry = new three.torusgeometry( 10, 3, 16, 100 );\nconst material = new three.meshbasicmaterial( { color: 0xffff00 } ); \nconst torus = new three.mesh( geometry, material ); \nscene.add( torus );\n\n\n# 构造器\n\ntorusgeometry(radius : float, tube : float, radialsegments : integer, tubularsegments : integer, arc : float)\n\n * radius — 环面的半径，从环面的中心到管道横截面的中心。默认值是1。\n * tube — 管道的半径，默认值为0.4。\n * radialsegments — 管道横截面的分段数，默认值为12。\n * tubularsegments — 管道的分段数，默认值为48。\n * arc — 圆环的圆心角（单位是弧度），默认值为math.pi * 2。\n\n# 属性\n\n * .parameters\n   * 一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。\n\n\n# 创建多次旋转的圆环结（圆环结）\n\n//创建多次旋转的圆环结\nvar mygeometry = new three.torusknotgeometry(2, 0.4, 100, 12, 3, 4);\nvar mymaterial = new three.meshbasicmaterial({ color: 'green' });\n//创建线框材质\nmymaterial.wireframe = true;\nvar mymesh = new three.mesh(mygeometry, mymaterial);\nmyscene.add(mymesh);\n//渲染圆环结\nmyrenderer.render(myscene, mycamera);\n\n\n\n\n\n# 圆环缓冲扭结几何体（torusknotgeometry）\n\n创建一个圆环扭结，其特殊形状由一对互质的整数，p和q所定义。如果p和q不互质，创建出来的几何体将是一个环面链接。\n\n# 代码示例\n\nconst geometry = new three.torusknotgeometry( 10, 3, 100, 16 ); \nconst material = new three.meshbasicmaterial( { color: 0xffff00 } ); \nconst torusknot = new three.mesh( geometry, material ); \nscene.add( torusknot );\n\n\n# 构造器\n\ntorusknotgeometry(radius : float, tube : float, tubularsegments : integer, radialsegments : integer, p : integer, q : integer)\n\n * radius - 圆环的半径，默认值为1。\n * tube — 管道的半径，默认值为0.4。\n * tubularsegments — 管道的分段数量，默认值为64。\n * radialsegments — 横截面分段数量，默认值为8。\n * p — 这个值决定了几何体将绕着其旋转对称轴旋转多少次，默认值是2。\n * q — 这个值决定了几何体将绕着其内部圆环旋转多少次，默认值是3。\n\n# 属性\n\n * .parameters\n   * 一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。\n\n\n# 006-圆台\n\n\n# 创建圆台\n\n//创建圆台\n/* cylindergeometry(\n顶部半径（1），\n底部半径（1），\n圆柱高度（1），\n圆柱侧面周围分段数（32），\n圆柱侧面沿着其高度的分段数（1），\n是否开发（false封闭），\n起始角度（0），\n底面圆扇区的中心角（2*pi）\n)*/\nvar mygeometry = new three.cylindergeometry(40, 80, 100, 150, 20);\nvar mymaterial = new three.meshnormalmaterial();\nvar mymesh = new three.mesh(mygeometry, mymaterial);\n//在xyz方向上放大几何体(圆台)\nmymesh.scale.set(2, 2, 2);\nmyscene.add(mymesh);\n//渲染圆台\nanimate();\nfunction animate() {\n  myrenderer.render(myscene, mycamera);\n  requestanimationframe(animate);\n}\n\n\n\n\n\n# 根据样条曲线图形绘制线框盒\n\n//根据样条曲线图形绘制线框盒\nvar mybox = new three.boxhelper(mymesh, 'red');\nmyscene.add(mybox);\n\n\n\n\n\n# 圆柱缓冲几何体（cylindergeometry）\n\n一个用于生成圆柱几何体的类。\n\n# 代码示例\n\nconst geometry = new three.cylindergeometry( 5, 5, 20, 32 ); \nconst material = new three.meshbasicmaterial( {color: 0xffff00} ); \nconst cylinder = new three.mesh( geometry, material ); \nscene.add( cylinder );\n\n\n# 构造器\n\ncylindergeometry(radiustop : float, radiusbottom : float, height : float, radialsegments : integer, heightsegments : integer, openended : boolean, thetastart : float, thetalength : float)\n\n * radiustop — 圆柱的顶部半径，默认值是1。\n * radiusbottom — 圆柱的底部半径，默认值是1。\n * height — 圆柱的高度，默认值是1。\n * radialsegments — 圆柱侧面周围的分段数，默认为32。\n * heightsegments — 圆柱侧面沿着其高度的分段数，默认值为1。\n * openended — 一个boolean值，指明该圆锥的底面是开放的还是封顶的。默认值为false，即其底面默认是封顶的。\n * thetastart — 第一个分段的起始角度，默认为0。（three o'clock position）\n * thetalength — 圆柱底面圆扇区的中心角，通常被称为“θ”（西塔）。默认值是2*pi，这使其成为一个完整的圆柱。\n\n# 属性\n\n * .parameters : object\n   * 一个包含着构造函数中每个参数的对象。在对象实例化之后，对该属性的任何修改都不会改变这个几何体。\n\n\n# 007-两个立方体\n\n\n# 创建两个立方体\n\n//创建正交照相机\nvar width=window.innerwidth;\nvar height=window.innerheight;\nvar k=width / height;\nvar s=24;\nvar mycamera=new three.orthographiccamera(-s*k,s*k,s,-s,1,1000);\nmycamera.position.set(-1.66,2.21,18.1);\nmycamera.lookat(myscene.position);\n//创建第一个立方体\nvar mygeometry1=new three.boxgeometry(16,16,16);\nvar mymaterial1=new three.meshnormalmaterial();\nvar mymesh1=new three.mesh(mygeometry1,mymaterial1);\nmymesh1.translatex(-14);\nmyscene.add(mymesh1);\n//创建第二个立方体\nvar mygeometry2=new three.boxgeometry(16,16,16);\nvar mymaterial2=new three.meshnormalmaterial();\nvar mymesh2=new three.mesh(mygeometry2,mymaterial2);\nmymesh2.translatex(14);\nmyscene.add(mymesh2);\n//渲染两个相同大小的立方体图形\nmyrenderer.render(myscene,mycamera);\n\n\n\n\n\n# 008-圆形\n\n\n# 空心圆\n\nvar mymaterial = new three.meshbasicmaterial({ color: 0x0000ff });\nvar mygeometry = new three.circlegeometry(50, 1000);\nmygeometry.vertices.shift();\nmycircle = new three.line(mygeometry, mymaterial);\nmyscene.add(mycircle);\n\n\n\n\n\n# 实心圆\n\nvar mymaterial = new three.meshbasicmaterial({ color: 0x0000ff });\nvar mygeometry = new three.circlegeometry(50, 1000);\nmycircle = new three.mesh(mygeometry, mymaterial);\nmyscene.add(mycircle);\n\n\n\n\n\n# 009-桃心♥️\n\n//创建渲染器\nvar myrenderer= new three.webglrenderer({antialias: true});\nmyrenderer.setsize(window.innerwidth,window.innerheight);\nmyrenderer.setclearcolor('white', 1.0);\n$(\"#mycontainer\").append(myrenderer.domelement);\nvar myscene = new three.scene();\nvar mycamera= new three.perspectivecamera( 45, window.innerwidth / window.innerheight, 1, 1000 );\nvar myparam =60;\nmycamera.position.x = math.cos( myparam ) * 400;\nmycamera.position.y = math.cos( myparam ) * 400;\nmycamera.position.z = math.sin( myparam ) * 400;\nmycamera.lookat( myscene.position );\nmyscene.add(new three.ambientlight('white'));\n//创建桃心图形\nvar myshape = new three.shape();\nvar x = 0, y = 0;\nmyshape.moveto( x + 5, y + 5 );\nmyshape.beziercurveto( x + 5, y + 5, x + 4, y, x, y );\nmyshape.beziercurveto( x - 6, y, x - 6, y + 7,x - 6, y + 7 );\nmyshape.beziercurveto( x - 6, y + 11, x - 3, y + 15.4, x + 5, y + 19 );\nmyshape.beziercurveto( x + 12, y + 15.4, x + 16, y + 11, x + 16, y + 7 );\nmyshape.beziercurveto( x + 16, y + 7, x + 16, y, x + 10, y );\nmyshape.beziercurveto( x + 7, y, x + 5, y + 5, x + 5, y + 5 );\nvar mygeometry = new three.shapegeometry(myshape,30);\n//var mygeometry = myshape.makegeometry();\nvar mymaterial =new three.meshlambertmaterial({color:'red'});\nvar mymesh = new three.mesh(mygeometry,mymaterial);\nmymesh.scale.set(18,18,18);\nmymesh.position.set(100, 110, 210);\nmymesh.rotation.x = myparam * 5;\nmymesh.rotation.y = myparam * 3;\nmymesh.rotation.z = myparam * 2;\nmyscene.add(mymesh);\n//渲染桃心图形\nmyrenderer.render( myscene, mycamera );\n\n\n\n\n\n# 010-三角形\n\n\n# 空心三角形\n\nvar x = -30, y = -30,mypoints=[];\nmypoints.push(new three.vector2(x, y));\nmypoints.push(new three.vector2(x + 60, y + 60));\nmypoints.push(new three.vector2(x , y + 60));\nmypoints.push(new three.vector2(x , y));\nvar mygeometry=new three.geometry().setfrompoints(mypoints);\nmytriangle=new three.line(mygeometry, new three.linebasicmaterial({color:0xff0000}));\nmyscene.add(mytriangle);\n\n\n\n\n\n# 实心三角形\n\nvar myshape = new three.shape();\nvar x = -30, y = -30;\nmyshape.moveto( x, y);\nmyshape.lineto( x + 60, y + 60);\nmyshape.lineto( x , y + 60);\nmyshape.lineto( x , y);\nvar mygeometry = new three.shapegeometry(myshape);\nvar mymaterial = new three.meshlambertmaterial({color:'red'});\nmytriangle= new three.mesh(mygeometry,mymaterial);\nmyscene.add(mytriangle);\n\n\n\n\n\n# 多色空心三角形\n\nvar x = -30, y = -30, mypoints = [];\nmypoints.push(new three.vector2(x, y));\nmypoints.push(new three.vector2(x + 60, y + 60));\nmypoints.push(new three.vector2(x, y + 60));\nmypoints.push(new three.vector2(x, y));\nvar mygeometry = new three.geometry().setfrompoints(mypoints);\n\n//color对象表示顶点的颜色数据\nvar mycolor1 = new three.color('red');\nvar mycolor2 = new three.color('green');\nvar mycolor3 = new three.color('blue');\nvar mycolor4 = new three.color('red');\nmygeometry.colors.push(mycolor1, mycolor2, mycolor3, mycolor4);\n//根据顶点颜色创建材质\nvar mymaterial = new three.linebasicmaterial({ vertexcolors: three.vertexcolors });\n//根据几何体和材质绘制渐变色的线条\nvar myline = new three.line(mygeometry, mymaterial);\nmyscene.add(myline);\n\n\n\n\n\n# 011-多边形\n\n//创建自定义多面体\nvar myvertices = [1, 0, 1, 1, 0, -1, -1, 0, -1, -1, 0, 1, 0, 1, 0];\nvar myfaces = [0, 1, 2, 2, 3, 0, 0, 1, 4, 1, 2, 4, 2, 3, 4, 3, 0, 4];\nvar mygeometry = new three.polyhedrongeometry(myvertices, myfaces, 1, 1);\nvar mymaterial = new three.meshlambertmaterial({ color: 'cyan' });\nvar mymesh = new three.mesh(mygeometry, mymaterial);\nmymesh.scale.set(32, 32, 32);\nmyscene.add(mymesh);\n//渲染自定义多面体\nanimate();\nfunction animate() {\n  myrenderer.render(myscene, mycamera);\n  requestanimationframe(animate);\n}\n\n\n\n\n\n# 012-矩形\n\n\n# 虚线空心矩形\n\n//创建虚线空心矩形\nvar mypoints = [];\nmypoints.push(new three.vector3(- 50, 30, 0));\t\t\t\t//左上顶点\nmypoints.push(new three.vector3(50, 30, 0));  \t\t\t\t//右上顶点\nmypoints.push(new three.vector3(50, -20, 0));  \t\t\t\t//右下顶点\nmypoints.push(new three.vector3(- 50, -20, 0));\t\t\t\t//左下顶点\nmypoints.push(new three.vector3(- 50, 30, 0));\t\t\t\t//左上顶点\nvar mygeometry = new three.buffergeometry().setfrompoints(mypoints);\nvar mymaterial = new three.linedashedmaterial({ vertexcolors: true, scale: 1.0 });\n//根据顶点绘制线条\nvar myline = new three.line(mygeometry, mymaterial);\nmyline.computelinedistances();\nmyline.position.set(3, -5, 0);\nmyscene.add(myline);\n//渲染虚线空心矩形\nmyrenderer.render(myscene, mycamera);\n\n\n\n\n\n# 013-四面体\n\n//创建四面体\nvar mygeometry = new three.tetrahedrongeometry(140, 0);\nvar mymaterial = new three.meshnormalmaterial();\nvar mymesh = new three.mesh(mygeometry, mymaterial);\nmyscene.add(mymesh);\n//渲染四面体\nmyrenderer.render(myscene, mycamera);\n\n\n\n\n\n# 014-多粒子\n\n\n# 静态粒子\n\n//创建渲染器\nvar myrenderer = new three.webglrenderer({ antialias: true });\nmyrenderer.setsize(window.innerwidth, window.innerheight);\nmyrenderer.setclearcolor('white', 1.0);\n$('#mycontainer')[0].appendchild(myrenderer.domelement);\nvar mycamera = new three.perspectivecamera(45,\n                                           window.innerwidth / window.innerheight, 1, 1000);\nvar myscene = new three.scene();\n//使用three.sprite和three.spritematerial绘制多个随机粒子\nvar mygroup = new three.group();\nmyscene.add(mygroup);\nfor (var i = 0; i < 10000; i++) {\n  var myspritematerial = new three.spritematerial({\n    color: new three.color(+setrandomcolor())\n  });\n  var mysprite = new three.sprite(myspritematerial);\n  mysprite.position.x = three.math.randfloatspread(2000);\n  mysprite.position.y = three.math.randfloatspread(2000);\n  mysprite.position.z = three.math.randfloatspread(2000);\n  mysprite.scale.set(8, 8, 8);\n  mygroup.add(mysprite);\n}\n//渲染多个随机粒子\nmyrenderer.render(myscene, mycamera);\n//随机生成颜色\nfunction setrandomcolor() {\n  var arrhex = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\",\n                \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\"],\n      strhex = \"0x\",\n      index;\n  for (var i = 0; i < 6; i++) {\n    index = math.round(math.random() * 15);\n    strhex += arrhex[index];\n  }\n  return strhex;\n}\n\n\n\n\n\n# 旋转粒子\n\n//创建渲染器\nvar myrenderer = new three.webglrenderer({ antialias: true });\nmyrenderer.setsize(window.innerwidth, window.innerheight);\nmyrenderer.setclearcolor('white', 1.0);\n$('#mycontainer')[0].appendchild(myrenderer.domelement);\nvar mycamera = new three.perspectivecamera(45, window.innerwidth / window.innerheight, 30, 1000);\nvar myscene = new three.scene();\n//创建多个粒子\nvar mygeometry = new three.geometry();\nfor (var i = 0; i < 10000; i++) {\n  var mypoint = new three.vector3();\n  mypoint.x = three.math.randfloatspread(2000);\n  mypoint.y = three.math.randfloatspread(2000);\n  mypoint.z = three.math.randfloatspread(2000);\n  mygeometry.vertices.push(mypoint);\n}\nvar mypointsmaterial = new three.pointsmaterial({ size: 10, color: 'darkgreen' });\nvar mypoints = new three.points(mygeometry, mypointsmaterial);\nmyscene.add(mypoints);\n//渲染多个粒子\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  mypoints.rotation.x += 0.01;\n  mypoints.rotation.y += 0.01;\n  mypoints.rotation.z += 0.01;\n  myrenderer.render(myscene, mycamera);\n};\n\n\n\n# 粒子更换成贴图\n\n# 大小一样的多个粒子\n\n//使用普通贴图材质创建多个粒子\nvar mymap = new three.textureloader().load('images/img041.png');\nvar mygeometry = new three.geometry();\nfor (var i = 0; i < 1000; i++) {\n  var mypoint = new three.vector3();\n  mypoint.x = three.math.randfloatspread(2000);\n  mypoint.y = three.math.randfloatspread(2000);\n  mypoint.z = three.math.randfloatspread(2000);\n  mygeometry.vertices.push(mypoint);\n}\nvar mypointsmaterial = new three.pointsmaterial({\n  size: 200, alphatest: 0.5, map: mymap\n});\nvar mypoints = new three.points(mygeometry, mypointsmaterial);\nmyscene.add(mypoints);\n//渲染多个粒子\nmyrenderer.render(myscene, mycamera);\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  mypoints.rotation.x += 0.006;\n  mypoints.rotation.y += 0.006;\n  mypoints.rotation.z += 0.006;\n  myrenderer.render(myscene, mycamera);\n};\n\n\n# 大小不一的多个粒子\n\n//创建渲染器\nvar myrenderer = new three.webglrenderer({ antialias: true });\nmyrenderer.setsize(window.innerwidth, window.innerheight);\nmyrenderer.setclearcolor('white', 1.0);\n$('#mycontainer')[0].appendchild(myrenderer.domelement);\nvar mycamera = new three.perspectivecamera(45, window.innerwidth / window.innerheight, 1, 1000);\nvar myscene = new three.scene();\n//使用three.sprite和three.spritematerial创建大小不一的多个粒子\nvar mygroup = new three.group();\nmyscene.add(mygroup);\n//加载纹理图像\nvar mymap = new three.textureloader().load('images/img040.png');\n//根据纹理图像创建three.spritematerial材质\nvar myspritematerial = new three.spritematerial({ map: mymap });\n//根据three.spritematerial材质创建three.sprite(粒子)\nfor (var i = 0; i < 3000; i++) {\n  var mysprite = new three.sprite(myspritematerial);\n  mysprite.position.x = three.math.randfloatspread(2000);\n  mysprite.position.y = three.math.randfloatspread(2000);\n  mysprite.position.z = three.math.randfloatspread(2000);\n  mysprite.scale.set(30, 30, 1);\n  mygroup.add(mysprite);\n}\nmyscene.add(mygroup);\n//渲染多个使用普通贴图创建的粒子\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  mygroup.rotation.x += 0.006;\n  mygroup.rotation.y += 0.006;\n  mygroup.rotation.z += 0.006;\n  myrenderer.render(myscene, mycamera);\n}\n\n\n# 粒子是实心圆\n\n//创建渲染器\nvar myrenderer = new three.webglrenderer({ antialias: true, alpha: true });\nmyrenderer.setsize(window.innerwidth, window.innerheight);\nmyrenderer.setclearcolor('white', 1.0);\n$('#mycontainer')[0].appendchild(myrenderer.domelement);\nvar mycamera = new three.perspectivecamera(45,\n                                           window.innerwidth / window.innerheight, 30, 1000);\nvar myscene = new three.scene();\n//创建多个粒子\nvar mygeometry = new three.geometry();\nfor (var i = 0; i < 10000; i++) {\n  var mypoint = new three.vector3();\n  mypoint.x = three.math.randfloatspread(2000);\n  mypoint.y = three.math.randfloatspread(2000);\n  mypoint.z = three.math.randfloatspread(2000);\n  mygeometry.vertices.push(mypoint);\n}\n//在画布上绘制实心圆\nvar mycanvas = document.createelement(\"canvas\");\nmycanvas.width = 100;\nmycanvas.height = 100;\nvar mycontext = mycanvas.getcontext(\"2d\");\nmycontext.fillstyle = \"#ffff00\";\nmycontext.arc(50, 50, 45, 0, 2 * math.pi);;\nmycontext.fill();\nvar mytexture = new three.texture(mycanvas);\nmytexture.needsupdate = true;\n//使用在画布上绘制的实心圆(贴图)创建pointsmaterial\nvar mypointsmaterial = new three.pointsmaterial({\n  size: 30,\n  color: 'darkgreen',\n  map: mytexture\n});\nvar mypoints = new three.points(mygeometry, mypointsmaterial);\nmyscene.add(mypoints);\n//渲染多个实心圆粒子\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  mypoints.rotation.x += 0.01;\n  mypoints.rotation.y += 0.01;\n  mypoints.rotation.z += 0.01;\n  myrenderer.render(myscene, mycamera);\n};\n\n\n\n# 015-阿基米德螺线\n\n\n# 平面螺旋线\n\n//创建阿基米德螺线\nvar mypoints = [];\nfor (var i = 0; i < 360 * 10; i++) {\n  //根据阿基米德螺线方程计算坐标\n  var myx = i * math.cos(i * math.pi / 180) / 100;\n  var myy = i * math.sin(i * math.pi / 180) / 100;\n  //使用vector2封装二维坐标\n  mypoints.push(new three.vector2(myx, myy));\n}\nvar mycurve = new three.splinecurve(mypoints);\nvar mygeometry = new three.buffergeometry();\n//mygeometry.setfrompoints(mycurve.getpoints(60));\nmygeometry.setfrompoints(mycurve.getpoints(600));\nvar mymaterial = new three.linebasicmaterial({ color: 0x0000ff00 });\nvar mycurveline = new three.line(mygeometry, mymaterial);\nmyscene.add(mycurveline);\n//渲染阿基米德螺线\nmyrenderer.render(myscene, mycamera);\n\n\n\n\n\n# 弹簧螺旋线\n\n//创建阿基米德螺线\nvar mypoints = [];\nfor (var i = 0; i < 360 * 10; i++) {\n  //根据螺线方程计算点坐标\n  var myx = 30 * math.cos(i * math.pi / 180);\n  var myy = 30 * math.sin(i * math.pi / 180);\n  var myz = 5 * i * math.pi / 180;\n  //使用vector3封装点坐标\n  mypoints.push(new three.vector3(myx, myy, myz));\n}\nvar mygeometry = new three.buffergeometry();\nmygeometry.setfrompoints(mypoints);\nvar mymaterial = new three.linebasicmaterial({ color: 0x00ff00 });\nvar mycurveline = new three.line(mygeometry, mymaterial);\nmycurveline.position.x = -80;\nmycurveline.position.y = 120;\nmyscene.add(mycurveline);\n//渲染阿基米德螺线\nmyrenderer.render(myscene, mycamera);\n\n\n\n\n\n# 016-沙漏\n\n//创建渲染器\nvar myrenderer = new three.webglrenderer({ antialias: true });\nmyrenderer.setsize(window.innerwidth, window.innerheight);\nmyrenderer.setclearcolor('white', 1.0);\n$(\"#mycontainer\").append(myrenderer.domelement);\nvar mycamera = new three.perspectivecamera(45,\n                                           window.innerwidth / window.innerheight, 0.1, 1000);\nmycamera.position.set(400, 300, 150);\nmycamera.lookat(new three.vector3(0, 0, 0));\nvar myscene = new three.scene();\n//创建沙漏\nvar mygeometry = new three.cylindergeometry(50, -50, 150, 32);\nvar mymaterial = new three.meshnormalmaterial();\nvar mymesh = new three.mesh(mygeometry, mymaterial);\nmymesh.scale.set(2, 2, 2);\nmyscene.add(mymesh);\n//渲染沙漏\nanimate();\nfunction animate() {\n  myrenderer.render(myscene, mycamera);\n  requestanimationframe(animate);\n}\n\n\n\n\n\n# 017-\n\n\n\n\n\n# 018-\n\n\n\n\n\n# 019-\n\n\n\n\n\n# 020-\n\n\n",charsets:{cjk:!0}},{title:"001-空间线",frontmatter:{},regularPath:"/three.js/SpaceModel.html",relativePath:"three.js/SpaceModel.md",key:"v-35c42dd6",path:"/three.js/SpaceModel.html",headers:[{level:2,title:"001-空间线",slug:"_001-空间线",normalizedTitle:"001-空间线",charIndex:2},{level:3,title:"自定义图形的线条宽度和颜色",slug:"自定义图形的线条宽度和颜色",normalizedTitle:"自定义图形的线条宽度和颜色",charIndex:14},{level:3,title:"CatmullRomCurve3-曲线",slug:"catmullromcurve3-曲线",normalizedTitle:"catmullromcurve3-曲线",charIndex:943},{level:3,title:"三维向量（Vector3）",slug:"三维向量-vector3",normalizedTitle:"三维向量（vector3）",charIndex:2012},{level:2,title:"002-球体阴影",slug:"_002-球体阴影",normalizedTitle:"002-球体阴影",charIndex:9893},{level:3,title:"DirectionalLight光源",slug:"directionallight光源",normalizedTitle:"directionallight光源",charIndex:9906},{level:3,title:"聚光灯光源",slug:"聚光灯光源",normalizedTitle:"聚光灯光源",charIndex:11600},{level:3,title:"阴影模糊状态",slug:"阴影模糊状态",normalizedTitle:"阴影模糊状态",charIndex:11965},{level:3,title:"多个光源",slug:"多个光源",normalizedTitle:"多个光源",charIndex:12133},{level:3,title:"THREE.PointLight光源",slug:"three-pointlight光源",normalizedTitle:"three.pointlight光源",charIndex:12670},{level:3,title:"半球光源",slug:"半球光源",normalizedTitle:"半球光源",charIndex:13051},{level:2,title:"003-全景图设置场景背景",slug:"_003-全景图设置场景背景",normalizedTitle:"003-全景图设置场景背景",charIndex:13402},{level:3,title:"单独全景图设置场景背景",slug:"单独全景图设置场景背景",normalizedTitle:"单独全景图设置场景背景",charIndex:13420},{level:3,title:"带THREE.CubeCamera相机的全景图设置场景背景",slug:"带three-cubecamera相机的全景图设置场景背景",normalizedTitle:"带three.cubecamera相机的全景图设置场景背景",charIndex:14594},{level:3,title:"创建2个光源",slug:"创建2个光源",normalizedTitle:"创建2个光源",charIndex:16396},{level:2,title:"004-带箭头",slug:"_004-带箭头",normalizedTitle:"004-带箭头",charIndex:18632},{level:3,title:"球体带箭头",slug:"球体带箭头",normalizedTitle:"球体带箭头",charIndex:18644},{level:3,title:"多边形带箭头",slug:"多边形带箭头",normalizedTitle:"多边形带箭头",charIndex:19912},{level:2,title:"005-自转和公转",slug:"_005-自转和公转",normalizedTitle:"005-自转和公转",charIndex:21136},{level:3,title:"中间大球自转，小球围着大球公转并且自转",slug:"中间大球自转-小球围着大球公转并且自转",normalizedTitle:"中间大球自转，小球围着大球公转并且自转",charIndex:21150},{level:3,title:"小球围着中心点公转并自转",slug:"小球围着中心点公转并自转",normalizedTitle:"小球围着中心点公转并自转",charIndex:22508},{level:3,title:"小球围着中心点公转并自转，光晕围着中心点转(使用相机自动旋转达到公转效果)",slug:"小球围着中心点公转并自转-光晕围着中心点转-使用相机自动旋转达到公转效果",normalizedTitle:"小球围着中心点公转并自转，光晕围着中心点转(使用相机自动旋转达到公转效果)",charIndex:23725},{level:3,title:"按轨道旋转（行星）",slug:"按轨道旋转-行星",normalizedTitle:"按轨道旋转（行星）",charIndex:26174},{level:2,title:"006-多个立方体只转动一个",slug:"_006-多个立方体只转动一个",normalizedTitle:"006-多个立方体只转动一个",charIndex:28057},{level:3,title:"myCube1的立方体旋转（2个立方体其中1个固定1个旋转）",slug:"mycube1的立方体旋转-2个立方体其中1个固定1个旋转",normalizedTitle:"mycube1的立方体旋转（2个立方体其中1个固定1个旋转）",charIndex:28076},{level:3,title:"mySecond的立方体旋转（3个立方体其中2个固定1个旋转）",slug:"mysecond的立方体旋转-3个立方体其中2个固定1个旋转",normalizedTitle:"mysecond的立方体旋转（3个立方体其中2个固定1个旋转）",charIndex:28773},{level:2,title:"007-光照区域",slug:"_007-光照区域",normalizedTitle:"007-光照区域",charIndex:30352},{level:2,title:"008-光照贴图到平面",slug:"_008-光照贴图到平面",normalizedTitle:"008-光照贴图到平面",charIndex:32175},{level:2,title:"009-三维的立方体（角度在大的立方体内）",slug:"_009-三维的立方体-角度在大的立方体内",normalizedTitle:"009-三维的立方体（角度在大的立方体内）",charIndex:33382},{level:2,title:"010-",slug:"_010",normalizedTitle:"010-",charIndex:34788}],headersStr:"001-空间线 自定义图形的线条宽度和颜色 CatmullRomCurve3-曲线 三维向量（Vector3） 002-球体阴影 DirectionalLight光源 聚光灯光源 阴影模糊状态 多个光源 THREE.PointLight光源 半球光源 003-全景图设置场景背景 单独全景图设置场景背景 带THREE.CubeCamera相机的全景图设置场景背景 创建2个光源 004-带箭头 球体带箭头 多边形带箭头 005-自转和公转 中间大球自转，小球围着大球公转并且自转 小球围着中心点公转并自转 小球围着中心点公转并自转，光晕围着中心点转(使用相机自动旋转达到公转效果) 按轨道旋转（行星） 006-多个立方体只转动一个 myCube1的立方体旋转（2个立方体其中1个固定1个旋转） mySecond的立方体旋转（3个立方体其中2个固定1个旋转） 007-光照区域 008-光照贴图到平面 009-三维的立方体（角度在大的立方体内） 010-",content:"# 001-空间线\n\n\n# 自定义图形的线条宽度和颜色\n\n//自定义图形的线条宽度和颜色\nvar myPositions = []; \t// 位置\nvar myColors = [];\t\t\t// 颜色\nvar myPoints = THREE.GeometryUtils.hilbert3D(new THREE.Vector3(0, 0, 0));\nvar myCurve = new THREE.CatmullRomCurve3(myPoints);\nvar divisions = Math.round(12 * myPoints.length);\nvar myPoint = new THREE.Vector3();\nvar myColor = new THREE.Color();\nfor (var i = 0, l = divisions; i < l; i++) {\n  var t = i / l;\n  myCurve.getPoint(t, myPoint);\n  myPositions.push(myPoint.x, myPoint.y, myPoint.z);\n  myColor.setHSL(t, 1.0, 0.5);\n  myColors.push(myColor.r, myColor.g, myColor.b);\n}\nvar myGeometry = new THREE.LineGeometry();\nmyGeometry.setPositions(myPositions);\nmyGeometry.setColors(myColors);\nvar myMaterial = new THREE.LineMaterial({ linewidth: 20, vertexColors: true });\nvar myLine = new THREE.Line2(myGeometry, myMaterial);\nmyLine.scale.set(2, 2, 2);\nmyMaterial.resolution.set(window.innerWidth, window.innerHeight);\nmyScene.add(myLine);\n\n\n\n\n\n# CatmullRomCurve3-曲线\n\n使用Catmull-Rom算法， 从一系列的点创建一条平滑的三维样条曲线。\n\n# 代码示例\n\n//Create a closed wavey loop \nconst curve = new THREE.CatmullRomCurve3( [ \n  new THREE.Vector3( -10, 0, 10 ), \n  new THREE.Vector3( -5, 5, 5 ), \n  new THREE.Vector3( 0, 0, 0 ), \n  new THREE.Vector3( 5, -5, 5 ), \n  new THREE.Vector3( 10, 0, 10 ) \n] ); \nconst points = curve.getPoints( 50 ); \nconst geometry = new THREE.BufferGeometry().setFromPoints( points ); \nconst material = new THREE.LineBasicMaterial( { color: 0xff0000 } ); \n// Create the final object to add to the scene \nconst curveObject = new THREE.Line( geometry, material );\n\n\n# 构造函数\n\nCatmullRomCurve3( points : Array, closed : Boolean, curveType : String, tension : Float )\n\n * points – Vector3点数组\n * curveType – 曲线的类型，默认值为centripetal。\n * closed – 该曲线是否闭合，默认值为false。\n * tension – 曲线的张力，默认为0.5。\n\n# 属性\n\n * .points : Array\n   * 定义了这一曲线的Vector3点数组，数组中至少需要两个点。\n * .closed: Boolean\n   * 当该值为true时，曲线将会闭合（环回自身）。\n * .curveType: String\n   * 可能的值为centripetal、chordal和catmullrom。\n * .tension: Float\n   * 当.curveType为catmullrom时，定义catmullrom的张力。\n\n\n# 三维向量（Vector3）\n\n该类表示的是一个三维向量（3D vector](https://en.wikipedia.org/wiki/Vector_space)）。 一个三维向量表示的是一个有顺序的、三个为一组的数字组合（标记为x、y和z）， 可被用来表示很多事物，例如：\n\n * 一个位于三维空间中的点。\n * 一个在三维空间中的方向与长度的定义。在three.js中，长度总是从(0, 0, 0)到(x, y, z)的 Euclidean distance](https://en.wikipedia.org/wiki/Euclidean_distance)（欧几里德距离，即直线距离）， 方向也是从(0, 0, 0)到(x, y, z)的方向。\n * 任意的、有顺序的、三个为一组的数字组合。\n\n其他的一些事物也可以使用二维向量进行表示，比如说动量矢量等等； 但以上这些是它在three.js中的常用用途。\n\n对 Vector3 实例进行遍历将按相应的顺序生成它的分量 (x, y, z)。\n\n# 代码示例\n\nconst a = new THREE.Vector3( 0, 1, 0 ); //no arguments; will be initialised to (0, 0, 0) const b = new THREE.Vector3( ); const d = a.distanceTo( b );\n\n\n# 构造函数\n\nVector3( x : Float, y : Float, z : Float )\n\n * x - 向量的x值，默认为0。\n * y - 向量的y值，默认为0。\n * z - 向量的z值，默认为0。\n\n创建一个新的Vector3。\n\n# 属性\n\n.isVector3: Boolean\n\nRead-only flag to check if a given object is of type Vector3.\n\n * .x: Float\n\n * .y : Float\n\n * .z : Float\n\n# 方法\n\n * .add ( v : Vector3) : this\n   \n   * 将传入的向量v和这个向量相加。\n\n * .addScalar ( s : Float ) : this\n   \n   * 将传入的标量s和这个向量的x值、y值以及z值相加。\n\n * .addScaledVector( v : Vector3, s : Float ) : this\n   \n   * 将所传入的v与s相乘所得的乘积和这个向量相加。\n\n * .addVectors ( a : Vector3, b : Vector3) : this\n   \n   * 将该向量设置为a + b。\n\n * .applyAxisAngle( axis : Vector3, angle : Float ) : this\n   \n   * axis - 一个被归一化的Vector3。\n   * angle - 以弧度表示的角度。\n   * 将轴和角度所指定的旋转应用到该向量上。\n\n * .applyEuler ( euler : Euler ) : this\n   \n   * 通过将Euler（欧拉）对象转换为Quaternion（四元数）并应用， 将欧拉变换应用到这一向量上。\n\n * .applyMatrix3( m : Matrix3 ) : this\n   \n   * 将该向量乘以三阶矩阵m。\n\n * .applyMatrix4 ( m : Matrix4 ) : this\n   \n   * 将该向量乘以四阶矩阵m（第四个维度隐式地为1），并按角度进行划分。\n\n * .applyNormalMatrix ( m : Matrix3 ) : this\n   \n   * 将该向量乘以正规矩阵 m，并将结果进行归一化。\n\n * .applyQuaternion ( quaternion : Quaternion-) : this\n   \n   * 将Quaternion变换应用到该向量。\n\n * .angleTo ( v : Vector3 ) : Float\n   \n   * 以弧度返回该向量与向量v\n\n * .ceil () : this\n   \n   * 将该向量x分量、 y分量以及z分量向上取整为最接近的整数。\n\n * .clamp ( min : Vector3, max : Vector3 : this\n   \n   * min - 在限制范围内，x值、y值和z的最小值。\n   \n   * max - 在限制范围内，x值、y值和z的最大值。\n   \n   * 如果该向量的x值、y值或z值大于限制范围内最大x值、y值或z值，则该值将会被所对应的值取代。\n   \n   * 如果该向量的x值、y值或z值小于限制范围内最小x值、y值或z值，则该值将会被所对应的值取代。\n\n * .clampLength ( min : Float, max : Float ) : this\n   \n   * min - 长度将被限制为的最小值\n   \n   * max - 长度将被限制为的最大值\n   \n   * 如果向量长度大于最大值，则它将会被最大值所取代。\n   \n   * 如果向量长度小于最小值，则它将会被最小值所取代。\n\n * .clampScalar ( min : Float, max : Float ) : this\n   \n   * min - 分量将被限制为的最小值\n   \n   * max - 分量将被限制为的最大值\n   \n   * 如果该向量的x值、y值或z值大于最大值，则它们将被最大值所取代。\n   \n   * 如果该向量的x值、y值或z值小于最小值，则它们将被最小值所取代。\n\n * .clone () : Vector3\n   \n   * 返回一个新的Vector3，其具有和当前这个向量相同的x、y 和z 。\n\n * .copy ( v : Vector3 ): this\n   \n   * 将所传入Vector3的x 、y和z属性复制给这一Vector3。\n\n * .cross ( v : Vector3 ) : this\n   \n   * 将该向量设置为它本身与传入的v -cross product）。\n\n * .crossVectors ( a : Vector3 , b : Vector3 ) : this\n   \n   * 将该向量设置为传入的a-b-cross product）。\n\n * .distanceTo ( v : Vector3 ) : Float\n   \n   * 计算该向量到所传入的v-\n\n * .manhattanDistanceTo ( v : Vector3 ) : Float\n   \n   * 计算该向量到所传入的v-Manhattan distance。\n\n * .distanceToSquared ( v : Vector3 ) : Float\n   \n   * 计算该向量到传入的v- 如果你只是将该距离和另一个距离进行比较，则应当比较的是距离的平方， 因为它的计算效率会更高一些。\n\n * .divide ( v : Vector3 ) : this\n   \n   * 将该向量除以向量v-\n\n * .divideScalar ( s : Float ) : this\n   \n   * 将该向量除以标量s。\n\n * .dot ( v : Vector3 ) : Float\n   \n   * 计算该vector和所传入v-dot product。\n\n * .equals ( v : Vector3 ) : Boolean\n   \n   * 检查该向量和v-\n\n * .floor () : this\n   \n   * 向量的分量向下取整为最接近的整数值。\n\n * .fromArray ( array : Array, offset : Integer ) : this\n   \n   * array - 来源矩阵。\n   \n   * offset - （可选）在数组中的元素偏移量，默认值为0。\n   \n   * 设置向量中的x 值为array[ offset + 0 ]，y 值为array[ offset + 1 ]， z 值为array[ offset + 2 ]。\n\n * .fromBufferAttribute ( attribute : BufferAttribute, index : Integer ) : this\n   \n   * attribute - 来源的attribute。\n   \n   * index - 在attribute中的索引。\n   \n   * 从attribute-x 值、y 值和z 值。\n\n * .getComponent ( index : Integer ) : Float\n   \n   * index - 0, 1 or 2.\n   \n   * 如果index值为0返回x 值。\n   \n   * 如果index值为1返回y 值。\n   \n   * 如果index值为2返回z 值。\n\n * .length () : Float\n   \n   * 计算从(0, 0, 0) 到 (x, y, z)的欧几里得长度 （Euclidean length，即直线长度）\n\n * .manhattanLength () : Float\n   \n   * 计算该向量的曼哈顿长度（Manhattan length）。\n\n * .lengthSq () : Float\n   \n   * 计算从(0, 0, 0)到(x, y, z)的欧几里得长度 （Euclidean length，即直线长度）的平方。 如果你正在比较向量的长度，应当比较的是长度的平方，因为它的计算效率更高一些。\n\n * .lerp ( v : Vector3, alpha : Float ) : this\n   \n   * v - 朝着进行插值的Vector3-\n   \n   * alpha - 插值因数，其范围通常在[0, 1]闭区间。\n   \n   * 在该向量与传入的向量v- —— alpha = 0 时表示的是当前向量，alpha = 1 时表示的是所传入的向量v-\n\n * .lerpVectors ( v1 : Vector3, v2 : Vector3, alpha : Float ) : this\n   \n   * v1 - 起始的Vector3-\n   \n   * v2 - 朝着进行插值的Vector3-\n   \n   * alpha - 插值因数，其范围通常在[0, 1]闭区间。\n   \n   * 将此向量设置为在v1-v2- 其中alpha为两个向量之间连线的长度的百分比 —— alpha = 0 时表示的是v1- = 1 时表示的是v2-\n\n * .max ( v : Vector3 ) : this\n   \n   * 如果该向量的x值、y值或z值小于所传入v- 则将该值替换为对应的最大值。\n\n * .min ( v : Vector3 ) : this\n   \n   * 如果该向量的x值、y值或z值大于所传入v- 则将该值替换为对应的最小值。\n\n * .multiply ( v : Vector3 ) : this\n   \n   * 将该向量与所传入的向量v-\n\n * .multiplyScalar ( s : Float ) : this\n   \n   * 将该向量与所传入的标量s进行相乘。\n\n * .multiplyVectors ( a : Vector3, b : Vector3 ) : this\n   \n   * 按照分量顺序，将该向量设置为和a * b-\n\n * .negate () : this\n   \n   * 向量取反，即： x = -x, y = -y , z = -z。\n\n * .normalize () : this\n   \n   * 将该向量转换为单位向量（unit vector）， 也就是说，将该向量的方向设置为和原向量相同，但是其长度（length ）为1。\n\n * .project ( camera : Camera ) : this\n   \n   * camera — 在投影中使用的摄像机。\n   \n   * 将此向量(坐标)从世界空间投影到相机的标准化设备坐标 (NDC) 空间。\n\n * .projectOnPlane ( planeNormal : Vector3 ) : this\n   \n   * planeNormal - 表示平面法线的向量\n   \n   * Projects 通过从该向量减去投影到平面法线上的向量，将该向量投影到平面上。\n\n * .projectOnVector ( v : Vector3 ) : this\n   \n   * 投影（Projects）该向量到向量v-\n\n * .reflect ( normal : Vector3 ) : this\n   \n   * normal - 反射面法线\n   \n   * 将该向量设置为对指定 normal 法线的表面的反射向量。假设法线具有单位长度。\n\n * .round () : this\n   \n   * 向量中的分量四舍五入取整为最接近的整数值。\n\n * .roundToZero () : this\n   \n   * 向量中的分量朝向0取整数（若分量为负数则向上取整，若为正数则向下取整）。\n\n * .set ( x : Float, y : Float, z : Float ) : this\n   \n   * 设置该向量的x 、y 和 z 分量。\n\n * .setComponent ( index : Integer, value : Float ) : this\n   \n   * index - 0、1 或 2。\n   \n   * value - Float\n   \n   * 若index为 0 则设置 x 值为 value。\n   \n   * 若index为 1 则设置 y 值为 value。\n   \n   * 若index为 2 则设置 z 值为 value。\n\n * .setFromCylindrical ( c : Cylindrical ) : this\n   \n   * 从圆柱坐标c-\n\n * .setFromCylindricalCoords ( radius : Float, theta : Float, y : Float ) : this\n   \n   * 从圆柱坐标中的radius-theta-y-\n\n * .setFromEuler ( euler : Euler ) : this\n   \n   * 根据指定的Euler Angle-x 、y 、z 分量。\n\n * .setFromMatrixColumn ( matrix : Matrix4, index : Integer ) : this\n   \n   * 从传入的四阶矩阵matrix- 设置该向量的x 值、y 值和z 值。\n\n * .setFromMatrix3Column ( matrix : Matrix3, index : Integer ) : this\n   \n   * 从传入的三阶矩阵 matrix 由 index 指定的列中，设置该向量的 x 值、y 值和 z 值。\n\n * .setFromMatrixPosition ( m : Matrix4 ) : this\n   \n   * 从变换矩阵（transformation matrix）m- 设置该向量为其中与位置相关的元素。\n\n * .setFromMatrixScale ( m : Matrix4 ) : this\n   \n   * 从变换矩阵（transformation matrix）m- 设置该向量为其中与缩放相关的元素。\n\n * .setFromSpherical ( s : Spherical ) : this\n   \n   * 从球坐标s-\n\n * .setFromSphericalCoords ( radius : Float, phi : Float, theta : Float ) : this\n   \n   * 从球坐标中的radius-phi-theta-\n\n * .setLength ( l : Float ) : this\n   \n   * 将该向量的方向设置为和原向量相同，但是长度（length ）为l。\n\n * .setScalar ( scalar : Float ) : this\n   \n   * 将该向量的x 、y 和z 值同时设置为等于传入的scalar。\n\n * .setX ( x : Float ) : this\n   \n   * 将向量中的x 值替换为x。\n\n * .setY ( y : Float ) : this\n   \n   * 将向量中的y 值替换为y。\n\n * .setZ ( z : Float ) : this\n   \n   * 将向量中的z 值替换为z。\n\n * .sub ( v : Vector3 ) : this\n   \n   * 从该向量减去向量v-\n\n * .subScalar ( s : Float ) : this\n   \n   * 从该向量的x 、y 和z 中减去标量s。\n\n * .subVectors ( a : Vector3, b : Vector3 ) : this\n   \n   * 将该向量设置为a - b-\n\n * .toArray ( array : Array, offset : Integer ) : Array\n   \n   * array - （可选）被用于存储向量的数组。如果这个值没有传入，则将创建一个新的数组。\n   \n   * offset - （可选） 数组中元素的偏移量。\n   \n   * 返回一个数组x, y ,z]，或者将x、y和z复制到所传入的array中。\n\n * .transformDirection ( m : Matrix4 ) : this\n   \n   * 通过传入的矩阵（m- x 3子矩阵）变换向量的方向， 并将结果进行normalizes （归一化）。\n\n * .unproject ( camera : Camera ) : this\n   \n   * camera — 在投影中使用的摄像机。\n   \n   * 将此向量(坐标)从相机的标准化设备坐标 (NDC) 空间投影到世界空间。\n\n * .random () : this\n   \n   * 将该向量的每个分量(x、y、z)设置为介于 0 和 1 之间的伪随机数，不包括 1。\n\n\n# 002-球体阴影\n\n\n# DirectionalLight光源\n\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer();\nmyRenderer.setPixelRatio( window.devicePixelRatio );\nmyRenderer.setSize(480,320);\nmyRenderer.setClearColor('white', 1);\n//设置为true才能看到阴影\nmyRenderer.shadowMap.enabled = true;\n$(\"#myContainer\").append(myRenderer.domElement);\nvar myScene = new THREE.Scene();\nvar myCamera=new THREE.PerspectiveCamera(45,480/320, 0.1, 1000);\nmyCamera.position.set(4, 4, 2);\nmyCamera.position.multiplyScalar(2);\nmyCamera.lookAt(new THREE.Vector3(0, 0, 0));\n//创建DirectionalLight光源\nvar myLight = new THREE.DirectionalLight('white', 1 );\n//设置为true才能看到阴影\nmyLight.castShadow = true;\nmyLight.position.set( 0, 14, 0 );\nmyScene.add( myLight );\n/* \n//创建DirectionalLight光源辅助线\nvar myDirectionalLightHelper = new THREE.DirectionalLightHelper(myLight, 50, 0x00ff00);\nmyScene.add(myDirectionalLightHelper);\n*/\n//创建用于投射阴影的球体\nvar mySphereGeometry=new THREE.SphereBufferGeometry( 2,36,36 );\nvar mySphereMaterial=new THREE.MeshNormalMaterial({wireframe: true,\n                                                   transparent: true} );\nvar mySphereMesh=new THREE.Mesh(mySphereGeometry,mySphereMaterial);\nmySphereMesh.position.set(0, 2.5, 0);\n//设置为true才能看到阴影\nmySphereMesh.castShadow = true;\nmyScene.add( mySphereMesh );\n//创建(白色不可见)平面\nvar myPlaneGeometry=new THREE.PlaneGeometry( 120, 120, 1, 1 );\nvar myPlaneMaterial=new THREE.MeshStandardMaterial({color:'white'});\nvar myPlaneMesh=new THREE.Mesh(myPlaneGeometry, myPlaneMaterial );\nmyPlaneMesh.rotateX(-Math.PI/2 );\nmyPlaneMesh.rotateZ(-Math.PI/7 );\nmyPlaneMesh.position.set(0, -4.5, 0)\n//表示平面支持投射阴影\nmyPlaneMesh.receiveShadow = true;\nmyScene.add(myPlaneMesh );\n//渲染球体和阴影\nmyRenderer.render(myScene, myCamera);\n\n\n\n\n\n# 聚光灯光源\n\n//创建聚光灯光源\nvar mySpotLight = new THREE.SpotLight('white');\nmySpotLight.position.set(-3, 46, -1);\nmySpotLight.distance = 80;\nmySpotLight.angle = Math.PI / 50;\n/*\n//绘制聚光灯光源辅助线\nvar mySpotLightHelper=new THREE.SpotLightHelper(mySpotLight,'green');\nmyScene.add(mySpotLightHelper);\n*/\n//设置为true才能看到阴影\nmySpotLight.castShadow = true;\nmyScene.add(mySpotLight);\n\n\n\n\n\n# 阴影模糊状态\n\n//设置为true才能看到阴影\nmyLight.castShadow = true;\nmyLight.position.set( 0, 14, 0 );        \n//设置阴影半径以产生模糊效果\nmyLight.shadow.radius = 16;\nmyScene.add( myLight );\n\n\n\n\n\n# 多个光源\n\n把光源更改成如下\n\n//创建第一束方向光\nvar myDirectionalLight1 = new THREE.DirectionalLight('white', 1);\nmyDirectionalLight1.castShadow = true;\nmyDirectionalLight1.position.set(-4, 10, 8);\n// //出现部分阴影\n// myDirectionalLight1.shadow.camera.near = 1;\n// myDirectionalLight1.shadow.camera.far = 21;\nmyScene.add(myDirectionalLight1);\n//创建第二束方向光\nvar myDirectionalLight2 = new THREE.DirectionalLight('white', 0.5);\n//设置为true才能看到阴影\nmyDirectionalLight2.castShadow = true;\nmyDirectionalLight2.position.set(4, 12, 12);\nmyScene.add(myDirectionalLight2);\n\n\n\n\n\n# THREE.PointLight光源\n\n//创建THREE.PointLight光源\nvar myPointLight = new THREE.PointLight('white');\nmyPointLight.position.set(0, 6, 0);\nmyPointLight.distance = 380;\n/*\n//绘制THREE.PointLight光源辅助线\nvar myPointLightHelper=new THREE.PointLightHelper(myPointLight,50,'green');\nmyScene.add(myPointLightHelper);\n*/\n//设置为true才能看到阴影\nmyPointLight.castShadow = true;\nmyScene.add(myPointLight);\n\n\n\n\n\n# 半球光源\n\n//创建并添加红蓝配置的半球光源\n//即指定接收自天空的颜色，接收自地面的颜色，及光照强度\nvar myHemisphereLight = new THREE.HemisphereLight('red', 'blue', 1);\nmyHemisphereLight.position.set(0, -100, -100);\nmyScene.add(myHemisphereLight);\n//绘制半球光源辅助线\nvar myHemisphereLightHelper = new THREE.HemisphereLightHelper(myHemisphereLight, 100, 'red');\nmyScene.add(myHemisphereLightHelper);\n\n\n\n\n\n# 003-全景图设置场景背景\n\n\n# 单独全景图设置场景背景\n\nvar myCamera, myScene, myRenderer;\nvar lon = 0, lat = 0, phi = 0, theta = 0;\nvar myTextureLoader = new THREE.TextureLoader();\nmyTextureLoader.load('images/img050.jpg', function (myTexture) {\n  init(myTexture);\n  animate();\n});\nfunction init(myTexture) {\n  myRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });\n  myRenderer.setSize(window.innerWidth, window.innerHeight);\n  $(\"#myContainer\").append(myRenderer.domElement);\n  myCamera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 1, 1000);\n  myScene = new THREE.Scene();\n  //使用全景图设置场景背景\n  myScene.background = new THREE.WebGLCubeRenderTarget(1024).fromEquirectangularTexture(myRenderer, myTexture);\n}\nfunction animate() {\n  requestAnimationFrame(animate);\n  lon += 0.15;//设置在经度方向的增量\n  lat = Math.max(- 85, Math.min(85, lat));\n  phi = THREE.MathUtils.degToRad(90 - lat);\n  theta = THREE.MathUtils.degToRad(lon);\n  myCamera.position.x = 100 * Math.sin(phi) * Math.cos(theta);\n  myCamera.position.y = 100 * Math.cos(phi);\n  myCamera.position.z = 100 * Math.sin(phi) * Math.sin(theta);\n  myCamera.lookAt(myScene.position);\n  myRenderer.render(myScene, myCamera);\n}\n\n\n\n# 带THREE.CubeCamera相机的全景图设置场景背景\n\nvar myCamera, myScene, myRenderer, myCubeCamera;\nvar lon = 0, lat = 0, phi = 0, theta = 0;\nvar myTextureLoader = new THREE.TextureLoader();\nmyTextureLoader.load('images/img051.jpg', function (myTexture) {\n  init(myTexture);\n  animate();\n});\nfunction init(myTexture) {\n  myRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });\n  myRenderer.setSize(window.innerWidth, window.innerHeight);\n  $(\"#myContainer\").append(myRenderer.domElement);\n  myCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);\n  myScene = new THREE.Scene();\n  //使用全景图设置场景背景\n  myScene.background = new THREE.WebGLCubeRenderTarget(1024)\n    .fromEquirectangularTexture(myRenderer, myTexture);\n  //创建THREE.CubeCamera相机\n  var myCubeRenderTarget = new THREE.WebGLCubeRenderTarget(256, {\n    format: THREE.RGBFormat, \n    generateMipmaps: true,\n    minFilter: THREE.LinearMipmapLinearFilter\n  });\n  myCubeCamera = new THREE.CubeCamera(1, 1000, myCubeRenderTarget);\n  //使用环境贴图创建MeshBasicMaterial\n  var myMeshBasicMaterial = new THREE.MeshBasicMaterial( { \n    envMap: myCubeRenderTarget.texture \n  });\n  var myMesh = new THREE.Mesh(\n    new THREE.IcosahedronBufferGeometry(40, 3), \n    myMeshBasicMaterial\n  );\n  myScene.add(myMesh);\n}\nfunction animate() {\n  requestAnimationFrame(animate);\n  //更新环境贴图(全景照相机不停地拍照)\n  myCubeCamera.update(myRenderer, myScene);\n  lon += 0.15;\n  lat = Math.max(- 85, Math.min(85, lat));\n  phi = THREE.MathUtils.degToRad(90 - lat);\n  theta = THREE.MathUtils.degToRad(lon);\n  myCamera.position.x = 100 * Math.sin(phi) * Math.cos(theta);\n  myCamera.position.y = 100 * Math.cos(phi);\n  myCamera.position.z = 100 * Math.sin(phi) * Math.sin(theta);\n  myCamera.lookAt(myScene.position);\n  myRenderer.render(myScene, myCamera);\n}\n\n\n\n# 创建2个光源\n\n\nvar myCubeCamera, myCamera, myScene, myRenderer;\nvar lon = 0, lat = 0, phi = 0, theta = 0;\nvar myTextureLoader = new THREE.TextureLoader();\nmyTextureLoader.load('images/img054.jpg', function (myTexture) {\n  init(myTexture);\n  animate();\n});\nfunction init(myTexture) {\n  //创建渲染器\n  myRenderer = new THREE.WebGLRenderer({ antialias: true });\n  myRenderer.setSize(window.innerWidth, window.innerHeight);\n  $(\"#myContainer\").append(myRenderer.domElement);\n  myCamera = new THREE.PerspectiveCamera(60,\n                                         window.innerWidth / window.innerHeight, 1, 1000);\n  myScene = new THREE.Scene();\n  //使用全景图设置场景背景\n  myScene.background = new THREE.WebGLCubeRenderTarget(1024)\n    .fromEquirectangularTexture(myRenderer, myTexture);\n  //创建环境光\n  var myAmbientLight = new THREE.AmbientLight('white');\n  myScene.add(myAmbientLight);\n  //创建两个聚光灯光源\n  var mySpotLight1 = new THREE.SpotLight('white');\n  mySpotLight1.position.set(600, 600, 600);\n  myScene.add(mySpotLight1);\n  var mySpotLight2 = new THREE.SpotLight('white');\n  mySpotLight2.position.set(-600, -600, -600);\n  myScene.add(mySpotLight2);\n  var myCubeRenderTarget = new THREE.WebGLCubeRenderTarget(256,\n                                                           {\n    format: THREE.RGBFormat, generateMipmaps: true,\n    minFilter: THREE.LinearMipmapLinearFilter\n  });\n  //创建THREE.CubeCamera全景照相机\n  myCubeCamera = new THREE.CubeCamera(1, 400, myCubeRenderTarget);\n  //使用全景照相机拍摄的环境贴图创建MeshLambertMaterial\n  var myMeshLambertMaterial = new THREE.MeshLambertMaterial(\n    { envMap: myCubeRenderTarget.texture });\n  var myMesh = new THREE.Mesh(\n    new THREE.SphereGeometry(34, 100, 100), myMeshLambertMaterial);\n  myScene.add(myMesh);\n}\nfunction animate() {\n  requestAnimationFrame(animate);\n  //更新环境贴图(全景照相机不停地拍照)\n  myCubeCamera.update(myRenderer, myScene);\n  lon += 0.35;\n  lat = Math.max(- 85, Math.min(85, lat));\n  phi = THREE.MathUtils.degToRad(90 - lat);\n  theta = THREE.MathUtils.degToRad(lon);\n  myCamera.position.x = 100 * Math.sin(phi) * Math.cos(theta);\n  myCamera.position.y = 100 * Math.cos(phi);\n  myCamera.position.z = 100 * Math.sin(phi) * Math.sin(theta);\n  myCamera.lookAt(myScene.position);\n  myRenderer.render(myScene, myCamera);\n}\n\n\n\n# 004-带箭头\n\n\n# 球体带箭头\n\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer({ antialias: true });\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\n$(\"#myContainer\").append(myRenderer.domElement);\nvar myScene = new THREE.Scene();\nmyScene.background = new THREE.Color(0xffffff);\nvar myCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);\nmyCamera.position.z = 6;\n//创建球体\nvar myGeometry = new THREE.IcosahedronBufferGeometry(2, 1);\nvar myMaterial = new THREE.MeshBasicMaterial({\n  color: 'darkgreen',\n  wireframe: true\n});\nvar myMesh = new THREE.Mesh(myGeometry, myMaterial);\nmyScene.add(myMesh);\n//创建箭头\n//表示原点方向，必须是单位向量\nvar myDirection = new THREE.Vector3(0, 10, 0);\n//表示箭头原点位置\nvar myOrigin = new THREE.Vector3(0, 0, 0);\n//表示箭头长度，默认值为1\nvar myLength = 3;\n//表示箭头颜色，默认值为0xffff00\nvar myColor = 0xff0000;\n//表示箭头头部长度，默认值为0.2 *myLength\nvar myHeadLength = 0.5;\n//表示箭头头部宽度，默认值为0.2 * myHeadLength\nvar myHeadWidth = 0.2;\nvar myArrowHelper = new THREE.ArrowHelper(myDirection, myOrigin, myLength, myColor, myHeadLength, myHeadWidth);\nmyScene.add(myArrowHelper);\n//渲染球体和箭头\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myMesh.rotation.z += 0.02;\n  myArrowHelper.rotation.z += 0.02;\n  myRenderer.render(myScene, myCamera);\n};\n\n\n\n\n\n# 多边形带箭头\n\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer({ antialias: true });\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\n$(\"#myContainer\").append(myRenderer.domElement);\nvar myCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\nmyCamera.position.set(100.23, 98.92, 99.18);\nmyCamera.lookAt(new THREE.Vector3(0, 0, 0));\nvar myScene = new THREE.Scene();\nmyScene.background = new THREE.Color('white');\n//创建二十面体\nvar myGeometry = new THREE.IcosahedronGeometry(80);\n//创建法向量材质\nvar myMaterial = new THREE.MeshNormalMaterial();\nvar myMesh = new THREE.Mesh(myGeometry, myMaterial);\n//在每个面上显示法向量\nfor (var i = 0; i < myGeometry.faces.length; i++) {\n  var myFace = myGeometry.faces[i];\n  //创建vector3，以找到每个面的中心\n  var myVector = new THREE.Vector3();\n  //将该面的三个顶点索引传给vertices以找到其顶点的坐标\n  myVector.add(myGeometry.vertices[myFace.a]);\n  myVector.add(myGeometry.vertices[myFace.b]);\n  myVector.add(myGeometry.vertices[myFace.c]);\n  myVector.divideScalar(3);\n  //箭头辅助线，相当于把法向量用箭头表示出来\n  var myArrowHelper = new THREE.ArrowHelper(\n    myFace.normal, myVector, 30, 0xff0000, 5, 6);\n  myMesh.add(myArrowHelper);\n}\nmyScene.add(myMesh);\n//渲染二十面体及箭头\nmyRenderer.render(myScene, myCamera);\n\n\n\n\n\n# 005-自转和公转\n\n\n# 中间大球自转，小球围着大球公转并且自转\n\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer({ antialias: true });\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\nmyRenderer.setClearColor('white', 1.0);\n$(\"#myContainer\").append(myRenderer.domElement);\nvar myCamera = new THREE.PerspectiveCamera(45,\n                                           window.innerWidth / window.innerHeight, 0.1, 1000);\nmyCamera.position.set(3.9, 60.18, 15.1);\nmyCamera.lookAt(new THREE.Vector3(0, 0, 0));\nvar myScene = new THREE.Scene();\n//创建大球\nvar mySphereGeometry1 = new THREE.SphereBufferGeometry(10, 26, 26);\nvar mySphereMaterial1 = new THREE.MeshNormalMaterial({\n  wireframe: true,\n  transparent: true\n});\nvar mySphereMesh1 = new THREE.Mesh(mySphereGeometry1, mySphereMaterial1);\nmyScene.add(mySphereMesh1);\n//创建小球\nvar mySphereGeometry2 = new THREE.SphereBufferGeometry(4, 16, 16);\nvar mySphereMaterial2 = new THREE.MeshNormalMaterial({\n  wireframe: true,\n  transparent: true\n});\nvar mySphereMesh2 = new THREE.Mesh(mySphereGeometry2, mySphereMaterial2);\nmySphereMesh2.translateX(26);\n//将小球与大球合成一个整体\nmySphereMesh1.add(mySphereMesh2);\n//渲染大球和小球的旋转\nvar myStep = 0.01;\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  //旋转小球与大球这个整体，公转\n  mySphereMesh1.rotation.y += myStep;\n  //旋转小球，自转\n  mySphereMesh2.rotation.y += 2 * myStep;\n  myRenderer.render(myScene, myCamera);\n};\n\n\n\n# 小球围着中心点公转并自转\n\n\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer({ antialias: true });\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\nmyRenderer.setClearColor('white', 1.0);\n$(\"#myContainer\").append(myRenderer.domElement);\nvar myCamera = new THREE.PerspectiveCamera(45,\n                                           window.innerWidth / window.innerHeight, 0.1, 1000);\nmyCamera.position.set(3.9, 60.18, 15.1);\nmyCamera.lookAt(new THREE.Vector3(0, 0, 0));\nvar myScene = new THREE.Scene();\nvar myMap = THREE.ImageUtils.loadTexture(\"images/img052.jpg\");\nmyScene.background = myMap;\n//创建不可见的旋转中心\nvar myPivot = new THREE.Object3D();\nmyScene.add(myPivot);\n//创建圆球\nvar mySphereGeometry = new THREE.SphereBufferGeometry(4, 16, 16);\nvar mySphereMaterial = new THREE.MeshNormalMaterial({\n  wireframe: true,\n  transparent: true\n});\nvar mySphereMesh = new THREE.Mesh(mySphereGeometry, mySphereMaterial);\nmySphereMesh.translateX(26);\n//将圆球与旋转中心合成一个整体\nmyPivot.add(mySphereMesh);\n//渲染旋转运动\nvar myStep = 0.01;\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  //旋转整体(圆球与中心)，公转\n  myPivot.rotation.y += myStep;\n  //旋转圆球，自转\n  mySphereMesh.rotation.y += 2 * myStep;\n  myRenderer.render(myScene, myCamera);\n};\n\n\n\n# 小球围着中心点公转并自转，光晕围着中心点转(使用相机自动旋转达到公转效果)\n\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer({ antialias: true });\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\nmyRenderer.setClearColor('black', 1.0);\n$(\"#myContainer\").append(myRenderer.domElement);\nvar myScene = new THREE.Scene();\nvar myCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);\nmyCamera.position.set(400, -600, 100);\nmyCamera.lookAt(new THREE.Vector3(-400, 600, -100));\nvar myOrbitControls = new THREE.OrbitControls(myCamera);\nmyOrbitControls.enableDamping = true;\n//是否自动旋转\nmyOrbitControls.autoRotate = true;\nmyOrbitControls.autoRotateSpeed = 2.5;\n//设置相机距离原点的最近距离\nmyOrbitControls.minDistance = 1;\n//设置相机距离原点的最远距离\nmyOrbitControls.maxDistance = 200;\n//是否开启右键拖拽\nmyOrbitControls.enablePan = true;\nvar myPointLight = new THREE.PointLight(\"#ffffff\");\nmyPointLight.position.set(-400, 600, -100);\nvar myTextureLoader = new THREE.TextureLoader();\nvar myMap1 = myTextureLoader.load(\"images/lensflare0.png\");\nvar myMap2 = myTextureLoader.load(\"images/lensflare2.png\");\nvar myMap3 = myTextureLoader.load(\"images/lensflare3.png\");\nvar myFlareColor = new THREE.Color(0xffffff);\nmyFlareColor.setHSL(0.55, 0.9, 1.0);\nvar myLensFlare = new THREE.Lensflare();\nmyLensFlare.addElement(new THREE.LensflareElement(myMap1, 500, 0.0, myFlareColor));\nmyLensFlare.addElement(new THREE.LensflareElement(myMap2, 512, 0.0));\nmyLensFlare.addElement(new THREE.LensflareElement(myMap2, 512, 0.0));\nmyLensFlare.addElement(new THREE.LensflareElement(myMap2, 512, 0.0));\nmyLensFlare.addElement(new THREE.LensflareElement(myMap3, 60, 0.6));\nmyLensFlare.addElement(new THREE.LensflareElement(myMap3, 70, 0.7));\nmyLensFlare.addElement(new THREE.LensflareElement(myMap3, 120, 0.9));\nmyLensFlare.addElement(new THREE.LensflareElement(myMap3, 70, 1.0));\nmyLensFlare.position.copy(myPointLight.position);\nmyScene.add(myLensFlare);\n//创建不可见的旋转中心\nvar myPivot = new THREE.Object3D();\nmyScene.add(myPivot);\n//创建圆球\nvar mySphereGeometry = new THREE.SphereBufferGeometry(24, 16, 16);\nvar mySphereMaterial = new THREE.MeshNormalMaterial({\n  wireframe: true,\n  transparent: true\n});\nvar mySphereMesh = new THREE.Mesh(mySphereGeometry, mySphereMaterial);\nmySphereMesh.translateX(26);\n//将圆球与旋转中心合成一个整体\nmyPivot.add(mySphereMesh);\n//渲染圆球与光晕\nanimate();\nfunction animate() {\n  myRenderer.render(myScene, myCamera);\n  myOrbitControls.update(); \t//更新轨道控制器\n  requestAnimationFrame(animate);\n}\n\n\n\n# 按轨道旋转（行星）\n\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer({ antialias: true });\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\nmyRenderer.setClearColor('black', 1.0);\n$(\"#myContainer\").append(myRenderer.domElement);\nvar myCamera = new THREE.PerspectiveCamera(20, window.innerWidth / window.innerHeight, 1, 1000);\nmyCamera.position.set(0, 0, 400);\nvar myScene = new THREE.Scene();\nvar myMap = THREE.ImageUtils.loadTexture(\"images/img052.jpg\");\nmyScene.background = myMap;\n//创建旋转系统\nvar myRotation = { x: -Math.PI * 0.42, y: Math.PI * 0.09, z: 0 };\nvar myStarRadius = 10;\nvar myTrackRadius = 80;\n//创建太阳系统\nvar myMesh = new THREE.Mesh(\n  new THREE.SphereGeometry(1, 1, 1),\n  new THREE.MeshLambertMaterial()\n);\n//创建行星轨道\nvar myTrack = new THREE.Mesh(\n  new THREE.RingGeometry(myTrackRadius, myTrackRadius + 2, 50, 1),\n  new THREE.MeshBasicMaterial());\n//创建行星\nvar myStar = new THREE.Mesh(\n  new THREE.SphereGeometry(myStarRadius, 30, 30),\n  new THREE.MeshBasicMaterial({\n    map: THREE.ImageUtils.loadTexture('images/img077.png')\n  }));\nmyStar.position.set(myTrackRadius, 0, 0);\nmyStar.rotation.x = 1.9;\n//创建行星环\nvar myStarRing = new THREE.Mesh(\n  new THREE.RingGeometry(myStarRadius + 3, myStarRadius + 8, 50, 1),\n  new THREE.MeshBasicMaterial({\n    map: THREE.ImageUtils.loadTexture('images/img077.png'),\n    side: THREE.DoubleSide\n  }));\n//创建行星环旋转中心\nmyStarCenter = new THREE.Object3D();\nmyStarCenter.add(myStarRing);\nmyStarCenter.position.set(myTrackRadius, 0, 0);\nmyStarCenter.rotation.x = 0.3;\n//创建太阳系中心\nvar myCenter = new THREE.Object3D();\nmyCenter.add(myStar);\nmyCenter.add(myTrack);\nmyCenter.add(myStarCenter);\nmyMesh.add(myCenter);\nmyMesh.rotation.set(myRotation.x, myRotation.y, myRotation.z);\nmyScene.add(myMesh);\n//渲染旋转系统\nanimate();\nfunction animate() {\n  myRenderer.render(myScene, myCamera);\n  myMesh.rotation.z -= 0.01;\n  requestAnimationFrame(animate);\n}\n\n\n\n\n\n# 006-多个立方体只转动一个\n\n\n# myCube1的立方体旋转（2个立方体其中1个固定1个旋转）\n\n//创建第一个立方体\nvar myGeometry1 =new THREE.BoxGeometry(16, 16, 16);\nvar myMaterial1 =new THREE.MeshNormalMaterial();\nvar myMesh1 = new THREE.Mesh(myGeometry1, myMaterial1);\nmyMesh1.translateX(-20);\nmyMesh1.name = 'myCube1';\nmyScene.add(myMesh1);\n//创建第二个立方体\nvar myGeometry2 = new THREE.BoxGeometry(16, 16, 16);\nvar myMaterial2 =new THREE.MeshNormalMaterial();\nvar myMesh2 = new THREE.Mesh(myGeometry2, myMaterial2);\nmyMesh2.translateX(16);\nmyMesh2.name = 'myCube2';\nmyScene.add(myMesh2);\n//渲染(旋转)立方体\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myScene.getObjectByName('myCube1').rotation.y += 0.05;\n  myRenderer.render(myScene, myCamera);\n};\n\n\n\n# mySecond的立方体旋转（3个立方体其中2个固定1个旋转）\n\n//创建渲染器\nvar myRenderer= new THREE.WebGLRenderer({antialias: true});\nmyRenderer.setSize(window.innerWidth,window.innerHeight);\nmyRenderer.setClearColor('white', 1.0);\n$(\"#myContainer\").append(myRenderer.domElement);\nvar myCamera = new THREE.PerspectiveCamera(45,\n                                           window.innerWidth / window.innerHeight, 0.1, 1000);\nmyCamera.position.set(40.06,20.92,42.68);\nmyCamera.lookAt(new THREE.Vector3(0, 0, 0));\nvar myScene = new THREE.Scene();\nvar myGroup = new THREE.Object3D();\n//创建第一个立方体\nvar myGeometry1 =new THREE.BoxGeometry(16, 16, 16);\nvar myMaterial1 =new THREE.MeshNormalMaterial();\nvar myMesh1 = new THREE.Mesh(myGeometry1, myMaterial1);\nmyMesh1.translateX(-40);\nmyGroup.add(myMesh1);\n//创建第二个立方体\nvar myGeometry2 = new THREE.BoxGeometry(16, 16, 16);\nvar myMaterial2 =new THREE.MeshNormalMaterial();\nvar myMesh2 = new THREE.Mesh(myGeometry2, myMaterial2);\nmyMesh2.translateX(-10);\nmyMesh2.name='mySecond';\nmyGroup.add(myMesh2);\n//创建第三个立方体\nvar myGeometry3 = new THREE.BoxGeometry(16, 16, 16);\nvar myMaterial3 =new THREE.MeshNormalMaterial();\nvar myMesh3 = new THREE.Mesh(myGeometry3, myMaterial3);\nmyMesh3.translateX(20);\nmyGroup.add(myMesh3);\nmyScene.add(myGroup);\n//渲染三个立方体\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  //深度遍历所有子对象\n  myGroup.traverse(function (e) {\n    //在所有子对象中，只有name是mySecond的对象围绕x轴旋转\n    if(e.name=='mySecond') {\n      e.rotation.x += 0.01;\n      //e.rotation.y += 0.01;\n      //e.rotation.z += 0.01;\n    }\n  });\n  myRenderer.render(myScene, myCamera);\n};\n\n\n\n# 007-光照区域\n\n//创建渲染器\nmyRenderer = new THREE.WebGLRenderer({ antialias: true });\nmyRenderer.setPixelRatio(window.devicePixelRatio);\nmyRenderer.gammaInput = true;\nmyRenderer.gammaOutput = true;\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\n$(\"#myContainer\").append(myRenderer.domElement);\nvar myScene = new THREE.Scene();\nvar myCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 4000);\nmyCamera.position.set(20, 5, 25);\nmyCamera.lookAt(myScene.position);\n//创建红色矩形区域光源(本身不可见)\nvar myRectAreaLight1 = new THREE.RectAreaLight(0xff0000, 5, 6, 9);\nmyRectAreaLight1.position.set(-6, 5, 0);\nmyRectAreaLight1.rotation.x = -Math.PI;\nmyScene.add(myRectAreaLight1);\n//绘制红色矩形区域光源的辅助矩形(即代表红色矩形区域光源)\nvar myRectAreaLightMesh1 = new THREE.Mesh(\n  new THREE.PlaneBufferGeometry(),\n  new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.BackSide })\n);\nmyRectAreaLightMesh1.scale.x = myRectAreaLight1.width;\nmyRectAreaLightMesh1.scale.y = myRectAreaLight1.height;\nmyRectAreaLight1.add(myRectAreaLightMesh1);\n//创建白色矩形区域光源(本身不可见)\nvar myRectAreaLight2 = new THREE.RectAreaLight(0xffffff, 10, 6, 9);\nmyRectAreaLight2.position.set(6, 5, 0);\nmyRectAreaLight2.rotation.x = -Math.PI;\nmyScene.add(myRectAreaLight2);\n//绘制白色矩形区域光源的辅助矩形(即代表白色矩形区域光源)\nvar myRectAreaLightMesh2 = new THREE.Mesh(\n  new THREE.PlaneBufferGeometry(),\n  new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.BackSide })\n);\nmyRectAreaLightMesh2.scale.x = myRectAreaLight2.width;\nmyRectAreaLightMesh2.scale.y = myRectAreaLight2.height;\nmyRectAreaLight2.add(myRectAreaLightMesh2);\n//绘制接收平面\nvar myPlaneMesh = new THREE.Mesh(\n  new THREE.PlaneGeometry(100, 60, 1, 1),\n  new THREE.MeshStandardMaterial()\n);\nmyPlaneMesh.rotation.x = -Math.PI / 2;\nmyScene.add(myPlaneMesh);\n//渲染矩形区域光源图形和平面\nmyRenderer.render(myScene, myCamera);\n\n\n\n\n\n# 008-光照贴图到平面\n\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer({ antialias: true });\nmyRenderer.setPixelRatio(window.devicePixelRatio);\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\n$(\"#myContainer\").append(myRenderer.domElement);\nvar myCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);\nmyCamera.position.set(0, 12, 15);\nmyCamera.lookAt(new THREE.Vector3(0, 0, 0));\nvar myScene = new THREE.Scene();\nmyScene.background = new THREE.Color('white');\nmyScene.add(new THREE.AmbientLight(0x444444));\n//根据光照贴图创建平面图形\nvar myPlaneGeometry = new THREE.PlaneGeometry(40, 30, 1, 1);\nvar myLightMap = new THREE.TextureLoader().load('images/img040.png');\nvar myMap = new THREE.TextureLoader().load('images/img007.jpg');\nvar myMaterial = new THREE.MeshLambertMaterial({\n  color: 0x777777, \n  lightMap: myLightMap, \n  map: myMap\n});\n//为了保证光照贴图能够正常显示，使用正常纹理的vu映射的值\nmyPlaneGeometry.faceVertexUvs[1] = myPlaneGeometry.faceVertexUvs[0];\nvar myMesh = new THREE.Mesh(myPlaneGeometry, myMaterial);\nmyMesh.rotation.x = -Math.PI / 4.6;\nmyScene.add(myMesh);\n//渲染平面图形\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myRenderer.render(myScene, myCamera);\n}\n\n\n\n\n\n# 009-三维的立方体（角度在大的立方体内）\n\n\nvar myRenderer, myCamera, myScene, myOrbitControls;\nfunction initRender() {\n  myRenderer = new THREE.WebGLRenderer({ antialias: true });\n  myRenderer.setPixelRatio(window.devicePixelRatio);\n  myRenderer.setSize(window.innerWidth, window.innerHeight);\n  myRenderer.setClearColor(0xeeeeee);\n  document.body.appendChild(myRenderer.domElement);\n  myCamera = new THREE.PerspectiveCamera(45,\n                                         window.innerWidth / window.innerHeight, 0.1, 1000);\n  myCamera.position.set(0, 0, 15);\n  myOrbitControls = new THREE.OrbitControls(myCamera, myRenderer.domElement);\n}\nfunction initScene() {\n  myScene = new THREE.Scene();\n  //创建天空盒作为场景背景\n  myScene.background = new THREE.CubeTextureLoader()\n    .setPath('images/')\n    .load(['img091px.png', 'img091nx.png', 'img091py.png',\n           'img091ny.png', 'img091pz.png', 'img091nz.png']);\n}\nfunction initModel() {\n  //绘制三维坐标轴\n  var myAxesHelper = new THREE.AxesHelper(50);\n  myScene.add(myAxesHelper);\n  //添加立方体\n  var myGeometry = new THREE.BoxGeometry(4, 4, 4);\n  var myMaterial = new THREE.MeshBasicMaterial();\n  //使用场景背景作为环境贴图\n  myMaterial.envMap = myScene.background;\n  myScene.add(new THREE.Mesh(myGeometry, myMaterial));\n}\nfunction animate() {\n  myOrbitControls.update();\n  myRenderer.render(myScene, myCamera);\n  requestAnimationFrame(animate);\n}\ninitRender();\ninitScene();\ninitModel();\nanimate();\n\n\n\n# 010-",normalizedContent:"# 001-空间线\n\n\n# 自定义图形的线条宽度和颜色\n\n//自定义图形的线条宽度和颜色\nvar mypositions = []; \t// 位置\nvar mycolors = [];\t\t\t// 颜色\nvar mypoints = three.geometryutils.hilbert3d(new three.vector3(0, 0, 0));\nvar mycurve = new three.catmullromcurve3(mypoints);\nvar divisions = math.round(12 * mypoints.length);\nvar mypoint = new three.vector3();\nvar mycolor = new three.color();\nfor (var i = 0, l = divisions; i < l; i++) {\n  var t = i / l;\n  mycurve.getpoint(t, mypoint);\n  mypositions.push(mypoint.x, mypoint.y, mypoint.z);\n  mycolor.sethsl(t, 1.0, 0.5);\n  mycolors.push(mycolor.r, mycolor.g, mycolor.b);\n}\nvar mygeometry = new three.linegeometry();\nmygeometry.setpositions(mypositions);\nmygeometry.setcolors(mycolors);\nvar mymaterial = new three.linematerial({ linewidth: 20, vertexcolors: true });\nvar myline = new three.line2(mygeometry, mymaterial);\nmyline.scale.set(2, 2, 2);\nmymaterial.resolution.set(window.innerwidth, window.innerheight);\nmyscene.add(myline);\n\n\n\n\n\n# catmullromcurve3-曲线\n\n使用catmull-rom算法， 从一系列的点创建一条平滑的三维样条曲线。\n\n# 代码示例\n\n//create a closed wavey loop \nconst curve = new three.catmullromcurve3( [ \n  new three.vector3( -10, 0, 10 ), \n  new three.vector3( -5, 5, 5 ), \n  new three.vector3( 0, 0, 0 ), \n  new three.vector3( 5, -5, 5 ), \n  new three.vector3( 10, 0, 10 ) \n] ); \nconst points = curve.getpoints( 50 ); \nconst geometry = new three.buffergeometry().setfrompoints( points ); \nconst material = new three.linebasicmaterial( { color: 0xff0000 } ); \n// create the final object to add to the scene \nconst curveobject = new three.line( geometry, material );\n\n\n# 构造函数\n\ncatmullromcurve3( points : array, closed : boolean, curvetype : string, tension : float )\n\n * points – vector3点数组\n * curvetype – 曲线的类型，默认值为centripetal。\n * closed – 该曲线是否闭合，默认值为false。\n * tension – 曲线的张力，默认为0.5。\n\n# 属性\n\n * .points : array\n   * 定义了这一曲线的vector3点数组，数组中至少需要两个点。\n * .closed: boolean\n   * 当该值为true时，曲线将会闭合（环回自身）。\n * .curvetype: string\n   * 可能的值为centripetal、chordal和catmullrom。\n * .tension: float\n   * 当.curvetype为catmullrom时，定义catmullrom的张力。\n\n\n# 三维向量（vector3）\n\n该类表示的是一个三维向量（3d vector](https://en.wikipedia.org/wiki/vector_space)）。 一个三维向量表示的是一个有顺序的、三个为一组的数字组合（标记为x、y和z）， 可被用来表示很多事物，例如：\n\n * 一个位于三维空间中的点。\n * 一个在三维空间中的方向与长度的定义。在three.js中，长度总是从(0, 0, 0)到(x, y, z)的 euclidean distance](https://en.wikipedia.org/wiki/euclidean_distance)（欧几里德距离，即直线距离）， 方向也是从(0, 0, 0)到(x, y, z)的方向。\n * 任意的、有顺序的、三个为一组的数字组合。\n\n其他的一些事物也可以使用二维向量进行表示，比如说动量矢量等等； 但以上这些是它在three.js中的常用用途。\n\n对 vector3 实例进行遍历将按相应的顺序生成它的分量 (x, y, z)。\n\n# 代码示例\n\nconst a = new three.vector3( 0, 1, 0 ); //no arguments; will be initialised to (0, 0, 0) const b = new three.vector3( ); const d = a.distanceto( b );\n\n\n# 构造函数\n\nvector3( x : float, y : float, z : float )\n\n * x - 向量的x值，默认为0。\n * y - 向量的y值，默认为0。\n * z - 向量的z值，默认为0。\n\n创建一个新的vector3。\n\n# 属性\n\n.isvector3: boolean\n\nread-only flag to check if a given object is of type vector3.\n\n * .x: float\n\n * .y : float\n\n * .z : float\n\n# 方法\n\n * .add ( v : vector3) : this\n   \n   * 将传入的向量v和这个向量相加。\n\n * .addscalar ( s : float ) : this\n   \n   * 将传入的标量s和这个向量的x值、y值以及z值相加。\n\n * .addscaledvector( v : vector3, s : float ) : this\n   \n   * 将所传入的v与s相乘所得的乘积和这个向量相加。\n\n * .addvectors ( a : vector3, b : vector3) : this\n   \n   * 将该向量设置为a + b。\n\n * .applyaxisangle( axis : vector3, angle : float ) : this\n   \n   * axis - 一个被归一化的vector3。\n   * angle - 以弧度表示的角度。\n   * 将轴和角度所指定的旋转应用到该向量上。\n\n * .applyeuler ( euler : euler ) : this\n   \n   * 通过将euler（欧拉）对象转换为quaternion（四元数）并应用， 将欧拉变换应用到这一向量上。\n\n * .applymatrix3( m : matrix3 ) : this\n   \n   * 将该向量乘以三阶矩阵m。\n\n * .applymatrix4 ( m : matrix4 ) : this\n   \n   * 将该向量乘以四阶矩阵m（第四个维度隐式地为1），并按角度进行划分。\n\n * .applynormalmatrix ( m : matrix3 ) : this\n   \n   * 将该向量乘以正规矩阵 m，并将结果进行归一化。\n\n * .applyquaternion ( quaternion : quaternion-) : this\n   \n   * 将quaternion变换应用到该向量。\n\n * .angleto ( v : vector3 ) : float\n   \n   * 以弧度返回该向量与向量v\n\n * .ceil () : this\n   \n   * 将该向量x分量、 y分量以及z分量向上取整为最接近的整数。\n\n * .clamp ( min : vector3, max : vector3 : this\n   \n   * min - 在限制范围内，x值、y值和z的最小值。\n   \n   * max - 在限制范围内，x值、y值和z的最大值。\n   \n   * 如果该向量的x值、y值或z值大于限制范围内最大x值、y值或z值，则该值将会被所对应的值取代。\n   \n   * 如果该向量的x值、y值或z值小于限制范围内最小x值、y值或z值，则该值将会被所对应的值取代。\n\n * .clamplength ( min : float, max : float ) : this\n   \n   * min - 长度将被限制为的最小值\n   \n   * max - 长度将被限制为的最大值\n   \n   * 如果向量长度大于最大值，则它将会被最大值所取代。\n   \n   * 如果向量长度小于最小值，则它将会被最小值所取代。\n\n * .clampscalar ( min : float, max : float ) : this\n   \n   * min - 分量将被限制为的最小值\n   \n   * max - 分量将被限制为的最大值\n   \n   * 如果该向量的x值、y值或z值大于最大值，则它们将被最大值所取代。\n   \n   * 如果该向量的x值、y值或z值小于最小值，则它们将被最小值所取代。\n\n * .clone () : vector3\n   \n   * 返回一个新的vector3，其具有和当前这个向量相同的x、y 和z 。\n\n * .copy ( v : vector3 ): this\n   \n   * 将所传入vector3的x 、y和z属性复制给这一vector3。\n\n * .cross ( v : vector3 ) : this\n   \n   * 将该向量设置为它本身与传入的v -cross product）。\n\n * .crossvectors ( a : vector3 , b : vector3 ) : this\n   \n   * 将该向量设置为传入的a-b-cross product）。\n\n * .distanceto ( v : vector3 ) : float\n   \n   * 计算该向量到所传入的v-\n\n * .manhattandistanceto ( v : vector3 ) : float\n   \n   * 计算该向量到所传入的v-manhattan distance。\n\n * .distancetosquared ( v : vector3 ) : float\n   \n   * 计算该向量到传入的v- 如果你只是将该距离和另一个距离进行比较，则应当比较的是距离的平方， 因为它的计算效率会更高一些。\n\n * .divide ( v : vector3 ) : this\n   \n   * 将该向量除以向量v-\n\n * .dividescalar ( s : float ) : this\n   \n   * 将该向量除以标量s。\n\n * .dot ( v : vector3 ) : float\n   \n   * 计算该vector和所传入v-dot product。\n\n * .equals ( v : vector3 ) : boolean\n   \n   * 检查该向量和v-\n\n * .floor () : this\n   \n   * 向量的分量向下取整为最接近的整数值。\n\n * .fromarray ( array : array, offset : integer ) : this\n   \n   * array - 来源矩阵。\n   \n   * offset - （可选）在数组中的元素偏移量，默认值为0。\n   \n   * 设置向量中的x 值为array[ offset + 0 ]，y 值为array[ offset + 1 ]， z 值为array[ offset + 2 ]。\n\n * .frombufferattribute ( attribute : bufferattribute, index : integer ) : this\n   \n   * attribute - 来源的attribute。\n   \n   * index - 在attribute中的索引。\n   \n   * 从attribute-x 值、y 值和z 值。\n\n * .getcomponent ( index : integer ) : float\n   \n   * index - 0, 1 or 2.\n   \n   * 如果index值为0返回x 值。\n   \n   * 如果index值为1返回y 值。\n   \n   * 如果index值为2返回z 值。\n\n * .length () : float\n   \n   * 计算从(0, 0, 0) 到 (x, y, z)的欧几里得长度 （euclidean length，即直线长度）\n\n * .manhattanlength () : float\n   \n   * 计算该向量的曼哈顿长度（manhattan length）。\n\n * .lengthsq () : float\n   \n   * 计算从(0, 0, 0)到(x, y, z)的欧几里得长度 （euclidean length，即直线长度）的平方。 如果你正在比较向量的长度，应当比较的是长度的平方，因为它的计算效率更高一些。\n\n * .lerp ( v : vector3, alpha : float ) : this\n   \n   * v - 朝着进行插值的vector3-\n   \n   * alpha - 插值因数，其范围通常在[0, 1]闭区间。\n   \n   * 在该向量与传入的向量v- —— alpha = 0 时表示的是当前向量，alpha = 1 时表示的是所传入的向量v-\n\n * .lerpvectors ( v1 : vector3, v2 : vector3, alpha : float ) : this\n   \n   * v1 - 起始的vector3-\n   \n   * v2 - 朝着进行插值的vector3-\n   \n   * alpha - 插值因数，其范围通常在[0, 1]闭区间。\n   \n   * 将此向量设置为在v1-v2- 其中alpha为两个向量之间连线的长度的百分比 —— alpha = 0 时表示的是v1- = 1 时表示的是v2-\n\n * .max ( v : vector3 ) : this\n   \n   * 如果该向量的x值、y值或z值小于所传入v- 则将该值替换为对应的最大值。\n\n * .min ( v : vector3 ) : this\n   \n   * 如果该向量的x值、y值或z值大于所传入v- 则将该值替换为对应的最小值。\n\n * .multiply ( v : vector3 ) : this\n   \n   * 将该向量与所传入的向量v-\n\n * .multiplyscalar ( s : float ) : this\n   \n   * 将该向量与所传入的标量s进行相乘。\n\n * .multiplyvectors ( a : vector3, b : vector3 ) : this\n   \n   * 按照分量顺序，将该向量设置为和a * b-\n\n * .negate () : this\n   \n   * 向量取反，即： x = -x, y = -y , z = -z。\n\n * .normalize () : this\n   \n   * 将该向量转换为单位向量（unit vector）， 也就是说，将该向量的方向设置为和原向量相同，但是其长度（length ）为1。\n\n * .project ( camera : camera ) : this\n   \n   * camera — 在投影中使用的摄像机。\n   \n   * 将此向量(坐标)从世界空间投影到相机的标准化设备坐标 (ndc) 空间。\n\n * .projectonplane ( planenormal : vector3 ) : this\n   \n   * planenormal - 表示平面法线的向量\n   \n   * projects 通过从该向量减去投影到平面法线上的向量，将该向量投影到平面上。\n\n * .projectonvector ( v : vector3 ) : this\n   \n   * 投影（projects）该向量到向量v-\n\n * .reflect ( normal : vector3 ) : this\n   \n   * normal - 反射面法线\n   \n   * 将该向量设置为对指定 normal 法线的表面的反射向量。假设法线具有单位长度。\n\n * .round () : this\n   \n   * 向量中的分量四舍五入取整为最接近的整数值。\n\n * .roundtozero () : this\n   \n   * 向量中的分量朝向0取整数（若分量为负数则向上取整，若为正数则向下取整）。\n\n * .set ( x : float, y : float, z : float ) : this\n   \n   * 设置该向量的x 、y 和 z 分量。\n\n * .setcomponent ( index : integer, value : float ) : this\n   \n   * index - 0、1 或 2。\n   \n   * value - float\n   \n   * 若index为 0 则设置 x 值为 value。\n   \n   * 若index为 1 则设置 y 值为 value。\n   \n   * 若index为 2 则设置 z 值为 value。\n\n * .setfromcylindrical ( c : cylindrical ) : this\n   \n   * 从圆柱坐标c-\n\n * .setfromcylindricalcoords ( radius : float, theta : float, y : float ) : this\n   \n   * 从圆柱坐标中的radius-theta-y-\n\n * .setfromeuler ( euler : euler ) : this\n   \n   * 根据指定的euler angle-x 、y 、z 分量。\n\n * .setfrommatrixcolumn ( matrix : matrix4, index : integer ) : this\n   \n   * 从传入的四阶矩阵matrix- 设置该向量的x 值、y 值和z 值。\n\n * .setfrommatrix3column ( matrix : matrix3, index : integer ) : this\n   \n   * 从传入的三阶矩阵 matrix 由 index 指定的列中，设置该向量的 x 值、y 值和 z 值。\n\n * .setfrommatrixposition ( m : matrix4 ) : this\n   \n   * 从变换矩阵（transformation matrix）m- 设置该向量为其中与位置相关的元素。\n\n * .setfrommatrixscale ( m : matrix4 ) : this\n   \n   * 从变换矩阵（transformation matrix）m- 设置该向量为其中与缩放相关的元素。\n\n * .setfromspherical ( s : spherical ) : this\n   \n   * 从球坐标s-\n\n * .setfromsphericalcoords ( radius : float, phi : float, theta : float ) : this\n   \n   * 从球坐标中的radius-phi-theta-\n\n * .setlength ( l : float ) : this\n   \n   * 将该向量的方向设置为和原向量相同，但是长度（length ）为l。\n\n * .setscalar ( scalar : float ) : this\n   \n   * 将该向量的x 、y 和z 值同时设置为等于传入的scalar。\n\n * .setx ( x : float ) : this\n   \n   * 将向量中的x 值替换为x。\n\n * .sety ( y : float ) : this\n   \n   * 将向量中的y 值替换为y。\n\n * .setz ( z : float ) : this\n   \n   * 将向量中的z 值替换为z。\n\n * .sub ( v : vector3 ) : this\n   \n   * 从该向量减去向量v-\n\n * .subscalar ( s : float ) : this\n   \n   * 从该向量的x 、y 和z 中减去标量s。\n\n * .subvectors ( a : vector3, b : vector3 ) : this\n   \n   * 将该向量设置为a - b-\n\n * .toarray ( array : array, offset : integer ) : array\n   \n   * array - （可选）被用于存储向量的数组。如果这个值没有传入，则将创建一个新的数组。\n   \n   * offset - （可选） 数组中元素的偏移量。\n   \n   * 返回一个数组x, y ,z]，或者将x、y和z复制到所传入的array中。\n\n * .transformdirection ( m : matrix4 ) : this\n   \n   * 通过传入的矩阵（m- x 3子矩阵）变换向量的方向， 并将结果进行normalizes （归一化）。\n\n * .unproject ( camera : camera ) : this\n   \n   * camera — 在投影中使用的摄像机。\n   \n   * 将此向量(坐标)从相机的标准化设备坐标 (ndc) 空间投影到世界空间。\n\n * .random () : this\n   \n   * 将该向量的每个分量(x、y、z)设置为介于 0 和 1 之间的伪随机数，不包括 1。\n\n\n# 002-球体阴影\n\n\n# directionallight光源\n\n//创建渲染器\nvar myrenderer = new three.webglrenderer();\nmyrenderer.setpixelratio( window.devicepixelratio );\nmyrenderer.setsize(480,320);\nmyrenderer.setclearcolor('white', 1);\n//设置为true才能看到阴影\nmyrenderer.shadowmap.enabled = true;\n$(\"#mycontainer\").append(myrenderer.domelement);\nvar myscene = new three.scene();\nvar mycamera=new three.perspectivecamera(45,480/320, 0.1, 1000);\nmycamera.position.set(4, 4, 2);\nmycamera.position.multiplyscalar(2);\nmycamera.lookat(new three.vector3(0, 0, 0));\n//创建directionallight光源\nvar mylight = new three.directionallight('white', 1 );\n//设置为true才能看到阴影\nmylight.castshadow = true;\nmylight.position.set( 0, 14, 0 );\nmyscene.add( mylight );\n/* \n//创建directionallight光源辅助线\nvar mydirectionallighthelper = new three.directionallighthelper(mylight, 50, 0x00ff00);\nmyscene.add(mydirectionallighthelper);\n*/\n//创建用于投射阴影的球体\nvar myspheregeometry=new three.spherebuffergeometry( 2,36,36 );\nvar myspherematerial=new three.meshnormalmaterial({wireframe: true,\n                                                   transparent: true} );\nvar myspheremesh=new three.mesh(myspheregeometry,myspherematerial);\nmyspheremesh.position.set(0, 2.5, 0);\n//设置为true才能看到阴影\nmyspheremesh.castshadow = true;\nmyscene.add( myspheremesh );\n//创建(白色不可见)平面\nvar myplanegeometry=new three.planegeometry( 120, 120, 1, 1 );\nvar myplanematerial=new three.meshstandardmaterial({color:'white'});\nvar myplanemesh=new three.mesh(myplanegeometry, myplanematerial );\nmyplanemesh.rotatex(-math.pi/2 );\nmyplanemesh.rotatez(-math.pi/7 );\nmyplanemesh.position.set(0, -4.5, 0)\n//表示平面支持投射阴影\nmyplanemesh.receiveshadow = true;\nmyscene.add(myplanemesh );\n//渲染球体和阴影\nmyrenderer.render(myscene, mycamera);\n\n\n\n\n\n# 聚光灯光源\n\n//创建聚光灯光源\nvar myspotlight = new three.spotlight('white');\nmyspotlight.position.set(-3, 46, -1);\nmyspotlight.distance = 80;\nmyspotlight.angle = math.pi / 50;\n/*\n//绘制聚光灯光源辅助线\nvar myspotlighthelper=new three.spotlighthelper(myspotlight,'green');\nmyscene.add(myspotlighthelper);\n*/\n//设置为true才能看到阴影\nmyspotlight.castshadow = true;\nmyscene.add(myspotlight);\n\n\n\n\n\n# 阴影模糊状态\n\n//设置为true才能看到阴影\nmylight.castshadow = true;\nmylight.position.set( 0, 14, 0 );        \n//设置阴影半径以产生模糊效果\nmylight.shadow.radius = 16;\nmyscene.add( mylight );\n\n\n\n\n\n# 多个光源\n\n把光源更改成如下\n\n//创建第一束方向光\nvar mydirectionallight1 = new three.directionallight('white', 1);\nmydirectionallight1.castshadow = true;\nmydirectionallight1.position.set(-4, 10, 8);\n// //出现部分阴影\n// mydirectionallight1.shadow.camera.near = 1;\n// mydirectionallight1.shadow.camera.far = 21;\nmyscene.add(mydirectionallight1);\n//创建第二束方向光\nvar mydirectionallight2 = new three.directionallight('white', 0.5);\n//设置为true才能看到阴影\nmydirectionallight2.castshadow = true;\nmydirectionallight2.position.set(4, 12, 12);\nmyscene.add(mydirectionallight2);\n\n\n\n\n\n# three.pointlight光源\n\n//创建three.pointlight光源\nvar mypointlight = new three.pointlight('white');\nmypointlight.position.set(0, 6, 0);\nmypointlight.distance = 380;\n/*\n//绘制three.pointlight光源辅助线\nvar mypointlighthelper=new three.pointlighthelper(mypointlight,50,'green');\nmyscene.add(mypointlighthelper);\n*/\n//设置为true才能看到阴影\nmypointlight.castshadow = true;\nmyscene.add(mypointlight);\n\n\n\n\n\n# 半球光源\n\n//创建并添加红蓝配置的半球光源\n//即指定接收自天空的颜色，接收自地面的颜色，及光照强度\nvar myhemispherelight = new three.hemispherelight('red', 'blue', 1);\nmyhemispherelight.position.set(0, -100, -100);\nmyscene.add(myhemispherelight);\n//绘制半球光源辅助线\nvar myhemispherelighthelper = new three.hemispherelighthelper(myhemispherelight, 100, 'red');\nmyscene.add(myhemispherelighthelper);\n\n\n\n\n\n# 003-全景图设置场景背景\n\n\n# 单独全景图设置场景背景\n\nvar mycamera, myscene, myrenderer;\nvar lon = 0, lat = 0, phi = 0, theta = 0;\nvar mytextureloader = new three.textureloader();\nmytextureloader.load('images/img050.jpg', function (mytexture) {\n  init(mytexture);\n  animate();\n});\nfunction init(mytexture) {\n  myrenderer = new three.webglrenderer({ antialias: true, alpha: true });\n  myrenderer.setsize(window.innerwidth, window.innerheight);\n  $(\"#mycontainer\").append(myrenderer.domelement);\n  mycamera = new three.perspectivecamera(90, window.innerwidth / window.innerheight, 1, 1000);\n  myscene = new three.scene();\n  //使用全景图设置场景背景\n  myscene.background = new three.webglcuberendertarget(1024).fromequirectangulartexture(myrenderer, mytexture);\n}\nfunction animate() {\n  requestanimationframe(animate);\n  lon += 0.15;//设置在经度方向的增量\n  lat = math.max(- 85, math.min(85, lat));\n  phi = three.mathutils.degtorad(90 - lat);\n  theta = three.mathutils.degtorad(lon);\n  mycamera.position.x = 100 * math.sin(phi) * math.cos(theta);\n  mycamera.position.y = 100 * math.cos(phi);\n  mycamera.position.z = 100 * math.sin(phi) * math.sin(theta);\n  mycamera.lookat(myscene.position);\n  myrenderer.render(myscene, mycamera);\n}\n\n\n\n# 带three.cubecamera相机的全景图设置场景背景\n\nvar mycamera, myscene, myrenderer, mycubecamera;\nvar lon = 0, lat = 0, phi = 0, theta = 0;\nvar mytextureloader = new three.textureloader();\nmytextureloader.load('images/img051.jpg', function (mytexture) {\n  init(mytexture);\n  animate();\n});\nfunction init(mytexture) {\n  myrenderer = new three.webglrenderer({ antialias: true, alpha: true });\n  myrenderer.setsize(window.innerwidth, window.innerheight);\n  $(\"#mycontainer\").append(myrenderer.domelement);\n  mycamera = new three.perspectivecamera(60, window.innerwidth / window.innerheight, 1, 1000);\n  myscene = new three.scene();\n  //使用全景图设置场景背景\n  myscene.background = new three.webglcuberendertarget(1024)\n    .fromequirectangulartexture(myrenderer, mytexture);\n  //创建three.cubecamera相机\n  var mycuberendertarget = new three.webglcuberendertarget(256, {\n    format: three.rgbformat, \n    generatemipmaps: true,\n    minfilter: three.linearmipmaplinearfilter\n  });\n  mycubecamera = new three.cubecamera(1, 1000, mycuberendertarget);\n  //使用环境贴图创建meshbasicmaterial\n  var mymeshbasicmaterial = new three.meshbasicmaterial( { \n    envmap: mycuberendertarget.texture \n  });\n  var mymesh = new three.mesh(\n    new three.icosahedronbuffergeometry(40, 3), \n    mymeshbasicmaterial\n  );\n  myscene.add(mymesh);\n}\nfunction animate() {\n  requestanimationframe(animate);\n  //更新环境贴图(全景照相机不停地拍照)\n  mycubecamera.update(myrenderer, myscene);\n  lon += 0.15;\n  lat = math.max(- 85, math.min(85, lat));\n  phi = three.mathutils.degtorad(90 - lat);\n  theta = three.mathutils.degtorad(lon);\n  mycamera.position.x = 100 * math.sin(phi) * math.cos(theta);\n  mycamera.position.y = 100 * math.cos(phi);\n  mycamera.position.z = 100 * math.sin(phi) * math.sin(theta);\n  mycamera.lookat(myscene.position);\n  myrenderer.render(myscene, mycamera);\n}\n\n\n\n# 创建2个光源\n\n\nvar mycubecamera, mycamera, myscene, myrenderer;\nvar lon = 0, lat = 0, phi = 0, theta = 0;\nvar mytextureloader = new three.textureloader();\nmytextureloader.load('images/img054.jpg', function (mytexture) {\n  init(mytexture);\n  animate();\n});\nfunction init(mytexture) {\n  //创建渲染器\n  myrenderer = new three.webglrenderer({ antialias: true });\n  myrenderer.setsize(window.innerwidth, window.innerheight);\n  $(\"#mycontainer\").append(myrenderer.domelement);\n  mycamera = new three.perspectivecamera(60,\n                                         window.innerwidth / window.innerheight, 1, 1000);\n  myscene = new three.scene();\n  //使用全景图设置场景背景\n  myscene.background = new three.webglcuberendertarget(1024)\n    .fromequirectangulartexture(myrenderer, mytexture);\n  //创建环境光\n  var myambientlight = new three.ambientlight('white');\n  myscene.add(myambientlight);\n  //创建两个聚光灯光源\n  var myspotlight1 = new three.spotlight('white');\n  myspotlight1.position.set(600, 600, 600);\n  myscene.add(myspotlight1);\n  var myspotlight2 = new three.spotlight('white');\n  myspotlight2.position.set(-600, -600, -600);\n  myscene.add(myspotlight2);\n  var mycuberendertarget = new three.webglcuberendertarget(256,\n                                                           {\n    format: three.rgbformat, generatemipmaps: true,\n    minfilter: three.linearmipmaplinearfilter\n  });\n  //创建three.cubecamera全景照相机\n  mycubecamera = new three.cubecamera(1, 400, mycuberendertarget);\n  //使用全景照相机拍摄的环境贴图创建meshlambertmaterial\n  var mymeshlambertmaterial = new three.meshlambertmaterial(\n    { envmap: mycuberendertarget.texture });\n  var mymesh = new three.mesh(\n    new three.spheregeometry(34, 100, 100), mymeshlambertmaterial);\n  myscene.add(mymesh);\n}\nfunction animate() {\n  requestanimationframe(animate);\n  //更新环境贴图(全景照相机不停地拍照)\n  mycubecamera.update(myrenderer, myscene);\n  lon += 0.35;\n  lat = math.max(- 85, math.min(85, lat));\n  phi = three.mathutils.degtorad(90 - lat);\n  theta = three.mathutils.degtorad(lon);\n  mycamera.position.x = 100 * math.sin(phi) * math.cos(theta);\n  mycamera.position.y = 100 * math.cos(phi);\n  mycamera.position.z = 100 * math.sin(phi) * math.sin(theta);\n  mycamera.lookat(myscene.position);\n  myrenderer.render(myscene, mycamera);\n}\n\n\n\n# 004-带箭头\n\n\n# 球体带箭头\n\n//创建渲染器\nvar myrenderer = new three.webglrenderer({ antialias: true });\nmyrenderer.setsize(window.innerwidth, window.innerheight);\n$(\"#mycontainer\").append(myrenderer.domelement);\nvar myscene = new three.scene();\nmyscene.background = new three.color(0xffffff);\nvar mycamera = new three.perspectivecamera(60, window.innerwidth / window.innerheight, 0.1, 1000);\nmycamera.position.z = 6;\n//创建球体\nvar mygeometry = new three.icosahedronbuffergeometry(2, 1);\nvar mymaterial = new three.meshbasicmaterial({\n  color: 'darkgreen',\n  wireframe: true\n});\nvar mymesh = new three.mesh(mygeometry, mymaterial);\nmyscene.add(mymesh);\n//创建箭头\n//表示原点方向，必须是单位向量\nvar mydirection = new three.vector3(0, 10, 0);\n//表示箭头原点位置\nvar myorigin = new three.vector3(0, 0, 0);\n//表示箭头长度，默认值为1\nvar mylength = 3;\n//表示箭头颜色，默认值为0xffff00\nvar mycolor = 0xff0000;\n//表示箭头头部长度，默认值为0.2 *mylength\nvar myheadlength = 0.5;\n//表示箭头头部宽度，默认值为0.2 * myheadlength\nvar myheadwidth = 0.2;\nvar myarrowhelper = new three.arrowhelper(mydirection, myorigin, mylength, mycolor, myheadlength, myheadwidth);\nmyscene.add(myarrowhelper);\n//渲染球体和箭头\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  mymesh.rotation.z += 0.02;\n  myarrowhelper.rotation.z += 0.02;\n  myrenderer.render(myscene, mycamera);\n};\n\n\n\n\n\n# 多边形带箭头\n\n//创建渲染器\nvar myrenderer = new three.webglrenderer({ antialias: true });\nmyrenderer.setsize(window.innerwidth, window.innerheight);\n$(\"#mycontainer\").append(myrenderer.domelement);\nvar mycamera = new three.perspectivecamera(75, window.innerwidth / window.innerheight, 0.1, 1000);\nmycamera.position.set(100.23, 98.92, 99.18);\nmycamera.lookat(new three.vector3(0, 0, 0));\nvar myscene = new three.scene();\nmyscene.background = new three.color('white');\n//创建二十面体\nvar mygeometry = new three.icosahedrongeometry(80);\n//创建法向量材质\nvar mymaterial = new three.meshnormalmaterial();\nvar mymesh = new three.mesh(mygeometry, mymaterial);\n//在每个面上显示法向量\nfor (var i = 0; i < mygeometry.faces.length; i++) {\n  var myface = mygeometry.faces[i];\n  //创建vector3，以找到每个面的中心\n  var myvector = new three.vector3();\n  //将该面的三个顶点索引传给vertices以找到其顶点的坐标\n  myvector.add(mygeometry.vertices[myface.a]);\n  myvector.add(mygeometry.vertices[myface.b]);\n  myvector.add(mygeometry.vertices[myface.c]);\n  myvector.dividescalar(3);\n  //箭头辅助线，相当于把法向量用箭头表示出来\n  var myarrowhelper = new three.arrowhelper(\n    myface.normal, myvector, 30, 0xff0000, 5, 6);\n  mymesh.add(myarrowhelper);\n}\nmyscene.add(mymesh);\n//渲染二十面体及箭头\nmyrenderer.render(myscene, mycamera);\n\n\n\n\n\n# 005-自转和公转\n\n\n# 中间大球自转，小球围着大球公转并且自转\n\n//创建渲染器\nvar myrenderer = new three.webglrenderer({ antialias: true });\nmyrenderer.setsize(window.innerwidth, window.innerheight);\nmyrenderer.setclearcolor('white', 1.0);\n$(\"#mycontainer\").append(myrenderer.domelement);\nvar mycamera = new three.perspectivecamera(45,\n                                           window.innerwidth / window.innerheight, 0.1, 1000);\nmycamera.position.set(3.9, 60.18, 15.1);\nmycamera.lookat(new three.vector3(0, 0, 0));\nvar myscene = new three.scene();\n//创建大球\nvar myspheregeometry1 = new three.spherebuffergeometry(10, 26, 26);\nvar myspherematerial1 = new three.meshnormalmaterial({\n  wireframe: true,\n  transparent: true\n});\nvar myspheremesh1 = new three.mesh(myspheregeometry1, myspherematerial1);\nmyscene.add(myspheremesh1);\n//创建小球\nvar myspheregeometry2 = new three.spherebuffergeometry(4, 16, 16);\nvar myspherematerial2 = new three.meshnormalmaterial({\n  wireframe: true,\n  transparent: true\n});\nvar myspheremesh2 = new three.mesh(myspheregeometry2, myspherematerial2);\nmyspheremesh2.translatex(26);\n//将小球与大球合成一个整体\nmyspheremesh1.add(myspheremesh2);\n//渲染大球和小球的旋转\nvar mystep = 0.01;\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  //旋转小球与大球这个整体，公转\n  myspheremesh1.rotation.y += mystep;\n  //旋转小球，自转\n  myspheremesh2.rotation.y += 2 * mystep;\n  myrenderer.render(myscene, mycamera);\n};\n\n\n\n# 小球围着中心点公转并自转\n\n\n//创建渲染器\nvar myrenderer = new three.webglrenderer({ antialias: true });\nmyrenderer.setsize(window.innerwidth, window.innerheight);\nmyrenderer.setclearcolor('white', 1.0);\n$(\"#mycontainer\").append(myrenderer.domelement);\nvar mycamera = new three.perspectivecamera(45,\n                                           window.innerwidth / window.innerheight, 0.1, 1000);\nmycamera.position.set(3.9, 60.18, 15.1);\nmycamera.lookat(new three.vector3(0, 0, 0));\nvar myscene = new three.scene();\nvar mymap = three.imageutils.loadtexture(\"images/img052.jpg\");\nmyscene.background = mymap;\n//创建不可见的旋转中心\nvar mypivot = new three.object3d();\nmyscene.add(mypivot);\n//创建圆球\nvar myspheregeometry = new three.spherebuffergeometry(4, 16, 16);\nvar myspherematerial = new three.meshnormalmaterial({\n  wireframe: true,\n  transparent: true\n});\nvar myspheremesh = new three.mesh(myspheregeometry, myspherematerial);\nmyspheremesh.translatex(26);\n//将圆球与旋转中心合成一个整体\nmypivot.add(myspheremesh);\n//渲染旋转运动\nvar mystep = 0.01;\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  //旋转整体(圆球与中心)，公转\n  mypivot.rotation.y += mystep;\n  //旋转圆球，自转\n  myspheremesh.rotation.y += 2 * mystep;\n  myrenderer.render(myscene, mycamera);\n};\n\n\n\n# 小球围着中心点公转并自转，光晕围着中心点转(使用相机自动旋转达到公转效果)\n\n//创建渲染器\nvar myrenderer = new three.webglrenderer({ antialias: true });\nmyrenderer.setsize(window.innerwidth, window.innerheight);\nmyrenderer.setclearcolor('black', 1.0);\n$(\"#mycontainer\").append(myrenderer.domelement);\nvar myscene = new three.scene();\nvar mycamera = new three.perspectivecamera(45, window.innerwidth / window.innerheight, 0.1, 1000);\nmycamera.position.set(400, -600, 100);\nmycamera.lookat(new three.vector3(-400, 600, -100));\nvar myorbitcontrols = new three.orbitcontrols(mycamera);\nmyorbitcontrols.enabledamping = true;\n//是否自动旋转\nmyorbitcontrols.autorotate = true;\nmyorbitcontrols.autorotatespeed = 2.5;\n//设置相机距离原点的最近距离\nmyorbitcontrols.mindistance = 1;\n//设置相机距离原点的最远距离\nmyorbitcontrols.maxdistance = 200;\n//是否开启右键拖拽\nmyorbitcontrols.enablepan = true;\nvar mypointlight = new three.pointlight(\"#ffffff\");\nmypointlight.position.set(-400, 600, -100);\nvar mytextureloader = new three.textureloader();\nvar mymap1 = mytextureloader.load(\"images/lensflare0.png\");\nvar mymap2 = mytextureloader.load(\"images/lensflare2.png\");\nvar mymap3 = mytextureloader.load(\"images/lensflare3.png\");\nvar myflarecolor = new three.color(0xffffff);\nmyflarecolor.sethsl(0.55, 0.9, 1.0);\nvar mylensflare = new three.lensflare();\nmylensflare.addelement(new three.lensflareelement(mymap1, 500, 0.0, myflarecolor));\nmylensflare.addelement(new three.lensflareelement(mymap2, 512, 0.0));\nmylensflare.addelement(new three.lensflareelement(mymap2, 512, 0.0));\nmylensflare.addelement(new three.lensflareelement(mymap2, 512, 0.0));\nmylensflare.addelement(new three.lensflareelement(mymap3, 60, 0.6));\nmylensflare.addelement(new three.lensflareelement(mymap3, 70, 0.7));\nmylensflare.addelement(new three.lensflareelement(mymap3, 120, 0.9));\nmylensflare.addelement(new three.lensflareelement(mymap3, 70, 1.0));\nmylensflare.position.copy(mypointlight.position);\nmyscene.add(mylensflare);\n//创建不可见的旋转中心\nvar mypivot = new three.object3d();\nmyscene.add(mypivot);\n//创建圆球\nvar myspheregeometry = new three.spherebuffergeometry(24, 16, 16);\nvar myspherematerial = new three.meshnormalmaterial({\n  wireframe: true,\n  transparent: true\n});\nvar myspheremesh = new three.mesh(myspheregeometry, myspherematerial);\nmyspheremesh.translatex(26);\n//将圆球与旋转中心合成一个整体\nmypivot.add(myspheremesh);\n//渲染圆球与光晕\nanimate();\nfunction animate() {\n  myrenderer.render(myscene, mycamera);\n  myorbitcontrols.update(); \t//更新轨道控制器\n  requestanimationframe(animate);\n}\n\n\n\n# 按轨道旋转（行星）\n\n//创建渲染器\nvar myrenderer = new three.webglrenderer({ antialias: true });\nmyrenderer.setsize(window.innerwidth, window.innerheight);\nmyrenderer.setclearcolor('black', 1.0);\n$(\"#mycontainer\").append(myrenderer.domelement);\nvar mycamera = new three.perspectivecamera(20, window.innerwidth / window.innerheight, 1, 1000);\nmycamera.position.set(0, 0, 400);\nvar myscene = new three.scene();\nvar mymap = three.imageutils.loadtexture(\"images/img052.jpg\");\nmyscene.background = mymap;\n//创建旋转系统\nvar myrotation = { x: -math.pi * 0.42, y: math.pi * 0.09, z: 0 };\nvar mystarradius = 10;\nvar mytrackradius = 80;\n//创建太阳系统\nvar mymesh = new three.mesh(\n  new three.spheregeometry(1, 1, 1),\n  new three.meshlambertmaterial()\n);\n//创建行星轨道\nvar mytrack = new three.mesh(\n  new three.ringgeometry(mytrackradius, mytrackradius + 2, 50, 1),\n  new three.meshbasicmaterial());\n//创建行星\nvar mystar = new three.mesh(\n  new three.spheregeometry(mystarradius, 30, 30),\n  new three.meshbasicmaterial({\n    map: three.imageutils.loadtexture('images/img077.png')\n  }));\nmystar.position.set(mytrackradius, 0, 0);\nmystar.rotation.x = 1.9;\n//创建行星环\nvar mystarring = new three.mesh(\n  new three.ringgeometry(mystarradius + 3, mystarradius + 8, 50, 1),\n  new three.meshbasicmaterial({\n    map: three.imageutils.loadtexture('images/img077.png'),\n    side: three.doubleside\n  }));\n//创建行星环旋转中心\nmystarcenter = new three.object3d();\nmystarcenter.add(mystarring);\nmystarcenter.position.set(mytrackradius, 0, 0);\nmystarcenter.rotation.x = 0.3;\n//创建太阳系中心\nvar mycenter = new three.object3d();\nmycenter.add(mystar);\nmycenter.add(mytrack);\nmycenter.add(mystarcenter);\nmymesh.add(mycenter);\nmymesh.rotation.set(myrotation.x, myrotation.y, myrotation.z);\nmyscene.add(mymesh);\n//渲染旋转系统\nanimate();\nfunction animate() {\n  myrenderer.render(myscene, mycamera);\n  mymesh.rotation.z -= 0.01;\n  requestanimationframe(animate);\n}\n\n\n\n\n\n# 006-多个立方体只转动一个\n\n\n# mycube1的立方体旋转（2个立方体其中1个固定1个旋转）\n\n//创建第一个立方体\nvar mygeometry1 =new three.boxgeometry(16, 16, 16);\nvar mymaterial1 =new three.meshnormalmaterial();\nvar mymesh1 = new three.mesh(mygeometry1, mymaterial1);\nmymesh1.translatex(-20);\nmymesh1.name = 'mycube1';\nmyscene.add(mymesh1);\n//创建第二个立方体\nvar mygeometry2 = new three.boxgeometry(16, 16, 16);\nvar mymaterial2 =new three.meshnormalmaterial();\nvar mymesh2 = new three.mesh(mygeometry2, mymaterial2);\nmymesh2.translatex(16);\nmymesh2.name = 'mycube2';\nmyscene.add(mymesh2);\n//渲染(旋转)立方体\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  myscene.getobjectbyname('mycube1').rotation.y += 0.05;\n  myrenderer.render(myscene, mycamera);\n};\n\n\n\n# mysecond的立方体旋转（3个立方体其中2个固定1个旋转）\n\n//创建渲染器\nvar myrenderer= new three.webglrenderer({antialias: true});\nmyrenderer.setsize(window.innerwidth,window.innerheight);\nmyrenderer.setclearcolor('white', 1.0);\n$(\"#mycontainer\").append(myrenderer.domelement);\nvar mycamera = new three.perspectivecamera(45,\n                                           window.innerwidth / window.innerheight, 0.1, 1000);\nmycamera.position.set(40.06,20.92,42.68);\nmycamera.lookat(new three.vector3(0, 0, 0));\nvar myscene = new three.scene();\nvar mygroup = new three.object3d();\n//创建第一个立方体\nvar mygeometry1 =new three.boxgeometry(16, 16, 16);\nvar mymaterial1 =new three.meshnormalmaterial();\nvar mymesh1 = new three.mesh(mygeometry1, mymaterial1);\nmymesh1.translatex(-40);\nmygroup.add(mymesh1);\n//创建第二个立方体\nvar mygeometry2 = new three.boxgeometry(16, 16, 16);\nvar mymaterial2 =new three.meshnormalmaterial();\nvar mymesh2 = new three.mesh(mygeometry2, mymaterial2);\nmymesh2.translatex(-10);\nmymesh2.name='mysecond';\nmygroup.add(mymesh2);\n//创建第三个立方体\nvar mygeometry3 = new three.boxgeometry(16, 16, 16);\nvar mymaterial3 =new three.meshnormalmaterial();\nvar mymesh3 = new three.mesh(mygeometry3, mymaterial3);\nmymesh3.translatex(20);\nmygroup.add(mymesh3);\nmyscene.add(mygroup);\n//渲染三个立方体\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  //深度遍历所有子对象\n  mygroup.traverse(function (e) {\n    //在所有子对象中，只有name是mysecond的对象围绕x轴旋转\n    if(e.name=='mysecond') {\n      e.rotation.x += 0.01;\n      //e.rotation.y += 0.01;\n      //e.rotation.z += 0.01;\n    }\n  });\n  myrenderer.render(myscene, mycamera);\n};\n\n\n\n# 007-光照区域\n\n//创建渲染器\nmyrenderer = new three.webglrenderer({ antialias: true });\nmyrenderer.setpixelratio(window.devicepixelratio);\nmyrenderer.gammainput = true;\nmyrenderer.gammaoutput = true;\nmyrenderer.setsize(window.innerwidth, window.innerheight);\n$(\"#mycontainer\").append(myrenderer.domelement);\nvar myscene = new three.scene();\nvar mycamera = new three.perspectivecamera(45, window.innerwidth / window.innerheight, 1, 4000);\nmycamera.position.set(20, 5, 25);\nmycamera.lookat(myscene.position);\n//创建红色矩形区域光源(本身不可见)\nvar myrectarealight1 = new three.rectarealight(0xff0000, 5, 6, 9);\nmyrectarealight1.position.set(-6, 5, 0);\nmyrectarealight1.rotation.x = -math.pi;\nmyscene.add(myrectarealight1);\n//绘制红色矩形区域光源的辅助矩形(即代表红色矩形区域光源)\nvar myrectarealightmesh1 = new three.mesh(\n  new three.planebuffergeometry(),\n  new three.meshbasicmaterial({ color: 0xff0000, side: three.backside })\n);\nmyrectarealightmesh1.scale.x = myrectarealight1.width;\nmyrectarealightmesh1.scale.y = myrectarealight1.height;\nmyrectarealight1.add(myrectarealightmesh1);\n//创建白色矩形区域光源(本身不可见)\nvar myrectarealight2 = new three.rectarealight(0xffffff, 10, 6, 9);\nmyrectarealight2.position.set(6, 5, 0);\nmyrectarealight2.rotation.x = -math.pi;\nmyscene.add(myrectarealight2);\n//绘制白色矩形区域光源的辅助矩形(即代表白色矩形区域光源)\nvar myrectarealightmesh2 = new three.mesh(\n  new three.planebuffergeometry(),\n  new three.meshbasicmaterial({ color: 0xffffff, side: three.backside })\n);\nmyrectarealightmesh2.scale.x = myrectarealight2.width;\nmyrectarealightmesh2.scale.y = myrectarealight2.height;\nmyrectarealight2.add(myrectarealightmesh2);\n//绘制接收平面\nvar myplanemesh = new three.mesh(\n  new three.planegeometry(100, 60, 1, 1),\n  new three.meshstandardmaterial()\n);\nmyplanemesh.rotation.x = -math.pi / 2;\nmyscene.add(myplanemesh);\n//渲染矩形区域光源图形和平面\nmyrenderer.render(myscene, mycamera);\n\n\n\n\n\n# 008-光照贴图到平面\n\n//创建渲染器\nvar myrenderer = new three.webglrenderer({ antialias: true });\nmyrenderer.setpixelratio(window.devicepixelratio);\nmyrenderer.setsize(window.innerwidth, window.innerheight);\n$(\"#mycontainer\").append(myrenderer.domelement);\nvar mycamera = new three.perspectivecamera(60, window.innerwidth / window.innerheight, 1, 1000);\nmycamera.position.set(0, 12, 15);\nmycamera.lookat(new three.vector3(0, 0, 0));\nvar myscene = new three.scene();\nmyscene.background = new three.color('white');\nmyscene.add(new three.ambientlight(0x444444));\n//根据光照贴图创建平面图形\nvar myplanegeometry = new three.planegeometry(40, 30, 1, 1);\nvar mylightmap = new three.textureloader().load('images/img040.png');\nvar mymap = new three.textureloader().load('images/img007.jpg');\nvar mymaterial = new three.meshlambertmaterial({\n  color: 0x777777, \n  lightmap: mylightmap, \n  map: mymap\n});\n//为了保证光照贴图能够正常显示，使用正常纹理的vu映射的值\nmyplanegeometry.facevertexuvs[1] = myplanegeometry.facevertexuvs[0];\nvar mymesh = new three.mesh(myplanegeometry, mymaterial);\nmymesh.rotation.x = -math.pi / 4.6;\nmyscene.add(mymesh);\n//渲染平面图形\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  myrenderer.render(myscene, mycamera);\n}\n\n\n\n\n\n# 009-三维的立方体（角度在大的立方体内）\n\n\nvar myrenderer, mycamera, myscene, myorbitcontrols;\nfunction initrender() {\n  myrenderer = new three.webglrenderer({ antialias: true });\n  myrenderer.setpixelratio(window.devicepixelratio);\n  myrenderer.setsize(window.innerwidth, window.innerheight);\n  myrenderer.setclearcolor(0xeeeeee);\n  document.body.appendchild(myrenderer.domelement);\n  mycamera = new three.perspectivecamera(45,\n                                         window.innerwidth / window.innerheight, 0.1, 1000);\n  mycamera.position.set(0, 0, 15);\n  myorbitcontrols = new three.orbitcontrols(mycamera, myrenderer.domelement);\n}\nfunction initscene() {\n  myscene = new three.scene();\n  //创建天空盒作为场景背景\n  myscene.background = new three.cubetextureloader()\n    .setpath('images/')\n    .load(['img091px.png', 'img091nx.png', 'img091py.png',\n           'img091ny.png', 'img091pz.png', 'img091nz.png']);\n}\nfunction initmodel() {\n  //绘制三维坐标轴\n  var myaxeshelper = new three.axeshelper(50);\n  myscene.add(myaxeshelper);\n  //添加立方体\n  var mygeometry = new three.boxgeometry(4, 4, 4);\n  var mymaterial = new three.meshbasicmaterial();\n  //使用场景背景作为环境贴图\n  mymaterial.envmap = myscene.background;\n  myscene.add(new three.mesh(mygeometry, mymaterial));\n}\nfunction animate() {\n  myorbitcontrols.update();\n  myrenderer.render(myscene, mycamera);\n  requestanimationframe(animate);\n}\ninitrender();\ninitscene();\ninitmodel();\nanimate();\n\n\n\n# 010-",charsets:{cjk:!0}},{title:"001-顶点和片源不同颜色的立方体",frontmatter:{},regularPath:"/three.js/SpecialEffects.html",relativePath:"three.js/SpecialEffects.md",key:"v-5f69a516",path:"/three.js/SpecialEffects.html",headers:[{level:2,title:"001-顶点和片源不同颜色的立方体",slug:"_001-顶点和片源不同颜色的立方体",normalizedTitle:"001-顶点和片源不同颜色的立方体",charIndex:2},{level:2,title:"002-指数雾的立方体",slug:"_002-指数雾的立方体",normalizedTitle:"002-指数雾的立方体",charIndex:2119},{level:2,title:"003-立方体(骰子模型)",slug:"_003-立方体-骰子模型",normalizedTitle:"003-立方体(骰子模型)",charIndex:2947},{level:3,title:"仅显示奇数点(visible是否显示)",slug:"仅显示奇数点-visible是否显示",normalizedTitle:"仅显示奇数点(visible是否显示)",charIndex:3616},{level:2,title:"004-立方体面上进行字体自定义设计",slug:"_004-立方体面上进行字体自定义设计",normalizedTitle:"004-立方体面上进行字体自定义设计",charIndex:5201},{level:2,title:"005-空心立方体",slug:"_005-空心立方体",normalizedTitle:"005-空心立方体",charIndex:6607},{level:2,title:"006-立体效果贴图",slug:"_006-立体效果贴图",normalizedTitle:"006-立体效果贴图",charIndex:7021},{level:2,title:"007-混合材质",slug:"_007-混合材质",normalizedTitle:"007-混合材质",charIndex:7871},{level:2,title:"008-凹凸材质",slug:"_008-凹凸材质",normalizedTitle:"008-凹凸材质",charIndex:8312},{level:2,title:"009-添加马赛克效果",slug:"_009-添加马赛克效果",normalizedTitle:"009-添加马赛克效果",charIndex:9159},{level:3,title:"初始化效果",slug:"初始化效果",normalizedTitle:"初始化效果",charIndex:11394},{level:3,title:"马赛克效果",slug:"马赛克效果",normalizedTitle:"马赛克效果",charIndex:9165},{level:2,title:"010-添加小灰点特效",slug:"_010-添加小灰点特效",normalizedTitle:"010-添加小灰点特效",charIndex:11418},{level:3,title:"初始化效果",slug:"初始化效果-2",normalizedTitle:"初始化效果",charIndex:11394},{level:3,title:"添加小灰点特效效果",slug:"添加小灰点特效效果",normalizedTitle:"添加小灰点特效效果",charIndex:12289},{level:2,title:"011-重影特效",slug:"_011-重影特效",normalizedTitle:"011-重影特效",charIndex:12305},{level:2,title:"012-水平镜像",slug:"_012-水平镜像",normalizedTitle:"012-水平镜像",charIndex:13151},{level:2,title:"013-垂直镜像",slug:"_013-垂直镜像",normalizedTitle:"013-垂直镜像",charIndex:14031},{level:2,title:"014-更改饱和度",slug:"_014-更改饱和度",normalizedTitle:"014-更改饱和度",charIndex:14879},{level:3,title:"初始效果",slug:"初始效果",normalizedTitle:"初始效果",charIndex:15775},{level:3,title:"更改饱和度",slug:"更改饱和度",normalizedTitle:"更改饱和度",charIndex:14883},{level:2,title:"015-更改色调",slug:"_015-更改色调",normalizedTitle:"015-更改色调",charIndex:15798},{level:2,title:"016-拖尾效果",slug:"_016-拖尾效果",normalizedTitle:"016-拖尾效果",charIndex:16644},{level:2,title:"017-泛光特效",slug:"_017-泛光特效",normalizedTitle:"017-泛光特效",charIndex:17535},{level:2,title:"018-老电影雪花扫描线特效",slug:"_018-老电影雪花扫描线特效",normalizedTitle:"018-老电影雪花扫描线特效",charIndex:18616},{level:2,title:"019-怀旧特效",slug:"_019-怀旧特效",normalizedTitle:"019-怀旧特效",charIndex:19478},{level:2,title:"020-不同颜色过滤立方体",slug:"_020-不同颜色过滤立方体",normalizedTitle:"020-不同颜色过滤立方体",charIndex:20317},{level:2,title:"021-飘白特效",slug:"_021-飘白特效",normalizedTitle:"021-飘白特效",charIndex:21428},{level:3,title:"轻微漂白图形",slug:"轻微漂白图形",normalizedTitle:"轻微漂白图形",charIndex:22184},{level:3,title:"强力漂白图形",slug:"强力漂白图形",normalizedTitle:"强力漂白图形",charIndex:22289},{level:2,title:"022-电脉冲花屏特效",slug:"_022-电脉冲花屏特效",normalizedTitle:"022-电脉冲花屏特效",charIndex:22420},{level:2,title:"023-模糊立方体",slug:"_023-模糊立方体",normalizedTitle:"023-模糊立方体",charIndex:23402},{level:3,title:"在水平方向模糊图形",slug:"在水平方向模糊图形",normalizedTitle:"在水平方向模糊图形",charIndex:24457},{level:3,title:"在垂直方向模糊图形",slug:"在垂直方向模糊图形",normalizedTitle:"在垂直方向模糊图形",charIndex:24558},{level:2,title:"024-三角形模糊特效",slug:"_024-三角形模糊特效",normalizedTitle:"024-三角形模糊特效",charIndex:24687},{level:2,title:"025-增大亮度",slug:"_025-增大亮度",normalizedTitle:"025-增大亮度",charIndex:25641},{level:2,title:"026-增大对比度",slug:"_026-增大对比度",normalizedTitle:"026-增大对比度",charIndex:26537},{level:2,title:"027-Gamma校正",slug:"_027-gamma校正",normalizedTitle:"027-gamma校正",charIndex:27436},{level:2,title:"028-改变光亮",slug:"_028-改变光亮",normalizedTitle:"028-改变光亮",charIndex:28223},{level:2,title:"029-检测边缘",slug:"_029-检测边缘",normalizedTitle:"029-检测边缘",charIndex:29026},{level:2,title:"030-添加光晕",slug:"_030-添加光晕",normalizedTitle:"030-添加光晕",charIndex:29951},{level:2,title:"031-校正颜色",slug:"_031-校正颜色",normalizedTitle:"031-校正颜色",charIndex:30839},{level:2,title:"032-变换为万花筒",slug:"_032-变换为万花筒",normalizedTitle:"032-变换为万花筒",charIndex:31862},{level:2,title:"033-添加特艺彩色",slug:"_033-添加特艺彩色",normalizedTitle:"033-添加特艺彩色",charIndex:32743},{level:2,title:"034-水平移轴特效",slug:"_034-水平移轴特效",normalizedTitle:"034-水平移轴特效",charIndex:33551},{level:2,title:"035-垂直移轴特效",slug:"_035-垂直移轴特效",normalizedTitle:"035-垂直移轴特效",charIndex:34458},{level:2,title:"036-聚焦特效",slug:"_036-聚焦特效",normalizedTitle:"036-聚焦特效",charIndex:35362},{level:2,title:"037-检测边缘",slug:"_037-检测边缘",normalizedTitle:"037-检测边缘",charIndex:36396},{level:2,title:"038-锯齿特效",slug:"_038-锯齿特效",normalizedTitle:"038-锯齿特效",charIndex:37296},{level:2,title:"039-轮廓边线",slug:"_039-轮廓边线",normalizedTitle:"039-轮廓边线",charIndex:38168},{level:2,title:"040-辉光特效",slug:"_040-辉光特效",normalizedTitle:"040-辉光特效",charIndex:39293},{level:2,title:"041-虚线边框",slug:"_041-虚线边框",normalizedTitle:"041-虚线边框",charIndex:40295},{level:2,title:"042-圆角立方体",slug:"_042-圆角立方体",normalizedTitle:"042-圆角立方体",charIndex:40939},{level:2,title:"043-扁平化",slug:"_043-扁平化",normalizedTitle:"043-扁平化",charIndex:42055},{level:2,title:"044-曲线拉伸的五角星",slug:"_044-曲线拉伸的五角星",normalizedTitle:"044-曲线拉伸的五角星",charIndex:42331},{level:2,title:"045-",slug:"_045",normalizedTitle:"045-",charIndex:43492},{level:2,title:"046-",slug:"_046",normalizedTitle:"046-",charIndex:43507},{level:2,title:"047-",slug:"_047",normalizedTitle:"047-",charIndex:43522},{level:2,title:"048-",slug:"_048",normalizedTitle:"048-",charIndex:43537},{level:2,title:"049-",slug:"_049",normalizedTitle:"049-",charIndex:43552},{level:2,title:"050-",slug:"_050",normalizedTitle:"050-",charIndex:43567}],headersStr:"001-顶点和片源不同颜色的立方体 002-指数雾的立方体 003-立方体(骰子模型) 仅显示奇数点(visible是否显示) 004-立方体面上进行字体自定义设计 005-空心立方体 006-立体效果贴图 007-混合材质 008-凹凸材质 009-添加马赛克效果 初始化效果 马赛克效果 010-添加小灰点特效 初始化效果 添加小灰点特效效果 011-重影特效 012-水平镜像 013-垂直镜像 014-更改饱和度 初始效果 更改饱和度 015-更改色调 016-拖尾效果 017-泛光特效 018-老电影雪花扫描线特效 019-怀旧特效 020-不同颜色过滤立方体 021-飘白特效 轻微漂白图形 强力漂白图形 022-电脉冲花屏特效 023-模糊立方体 在水平方向模糊图形 在垂直方向模糊图形 024-三角形模糊特效 025-增大亮度 026-增大对比度 027-Gamma校正 028-改变光亮 029-检测边缘 030-添加光晕 031-校正颜色 032-变换为万花筒 033-添加特艺彩色 034-水平移轴特效 035-垂直移轴特效 036-聚焦特效 037-检测边缘 038-锯齿特效 039-轮廓边线 040-辉光特效 041-虚线边框 042-圆角立方体 043-扁平化 044-曲线拉伸的五角星 045- 046- 047- 048- 049- 050-",content:'# 001-顶点和片源不同颜色的立方体\n\n<script id="myVertexShader" type="x-shader/x-vertex">\n   //创建顶点着色器\n    varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n      gl_Position = projectionMatrix * mvPosition;\n    }\n<\/script>\n<script id="myFragmentShader" type="x-shader/x-fragment">\n    //创建片元着色器\n    uniform float time;\n    uniform vec2 resolution;\n    varying vec2 vUv;\n    void main( void ) {\n      vec2 position = -1.0 + 2.0 * vUv;\n      float red = abs( sin( position.x * position.y + time / 5.0 ) );\n      float green = abs( sin( position.x * position.y + time / 4.0 ) );\n      float blue = abs( sin( position.x * position.y + time / 3.0 ) );\n      gl_FragColor = vec4( red, green, blue, 1.0 );\n    }\n<\/script>\n<script type="text/javascript">\n  //创建渲染器\n  var myRenderer = new THREE.WebGLRenderer({ antialias: true });\n  myRenderer.setSize(window.innerWidth, window.innerHeight);\n  myRenderer.setClearColor(\'white\', 1.0);\n  $(\'#myContainer\')[0].appendChild(myRenderer.domElement);\n  var myScene = new THREE.Scene();\n  var myCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 10, 130);\n  myCamera.position.x = 30;\n  myCamera.position.y = 30;\n  myCamera.position.z = 30;\n  myCamera.lookAt(new THREE.Vector3(0, 0, 0));\n  //创建THREE.ShaderMaterial\n  var myShaderMaterial = new THREE.ShaderMaterial({\n    uniforms: {\n      time: { type: "f", value: 1.0 },\n      resolution: { type: "v2", value: new THREE.Vector2() },\n    },\n    vertexShader: $(\'#myVertexShader\')[0].textContent,\n    fragmentShader: $(\'#myFragmentShader\')[0].textContent\n  });\n  //使用THREE.ShaderMaterial创建立方体\n  var myBoxGeometry = new THREE.BoxGeometry(16, 16, 16);\n  var myMesh = new THREE.Mesh(myBoxGeometry, myShaderMaterial);\n  myScene.add(myMesh);\n  var myStep = 0;\n  //渲染(旋转)立方体\n  animate();\n  function animate() {\n    myMesh.rotation.y = myStep += 0.01;\n    myMesh.rotation.x = myStep;\n    myMesh.rotation.z = myStep;\n    myMesh.material.uniforms.time.value += 0.1;\n    requestAnimationFrame(animate);\n    myRenderer.render(myScene, myCamera);\n  }\n<\/script>\n\n\n\n\n\n# 002-指数雾的立方体\n\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer({ antialias: true });\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\nmyRenderer.setClearColor(\'white\', 1.0);\n$("#myContainer").append(myRenderer.domElement);\nvar myScene = new THREE.Scene();\nmyScene.add(new THREE.AmbientLight(\'white\'));\n//使用指数雾设置场景的fog雾化属性\nmyScene.fog = new THREE.FogExp2(\'white\', 0.025);\nvar myCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 30, 1000);\nmyCamera.position.set(-34.34, -40.56, 35.83);\nmyCamera.lookAt(new THREE.Vector3(0, 0, 0));\n//创建立方体\nvar myGeometry = new THREE.BoxGeometry(20, 20, 20);\nvar myMaterial = new THREE.MeshLambertMaterial({ color: \'darkgreen\' });\nvar myMesh = new THREE.Mesh(myGeometry, myMaterial);\nmyScene.add(myMesh);\n//渲染立方体\nmyRenderer.render(myScene, myCamera);\n\n\n\n\n\n# 003-立方体(骰子模型)\n\n//创建立方体(骰子模型)\nvar myGeometry = new THREE.BoxGeometry(16, 16, 16);\nvar myMaterials = [];\n//在材质数组中设置多个图像(贴图)\nfor (var i = 1; i < 7; i++) {\n  var myMap = THREE.ImageUtils.loadTexture("images/img13" + i + ".jpg");\n  var myMaterial = new THREE.MeshBasicMaterial({ map: myMap });\n  myMaterials.push(myMaterial);\n}\nvar myMesh = new THREE.Mesh(myGeometry, myMaterials);\nmyScene.add(myMesh);\n//渲染立方体(骰子模型)\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  var myTimer = Date.now() * 0.0001;\n  myMesh.rotation.x = myTimer * 5;\n  myMesh.rotation.y = myTimer * 3;\n  myMesh.rotation.z = myTimer * 2;\n  myRenderer.render(myScene, myCamera);\n}\n\n\n\n\n\n# 仅显示奇数点(visible是否显示)\n\n//创建渲染器\nvar myRenderer = new THREE.WebGLRenderer({ antialias: true });\nmyRenderer.setSize(window.innerWidth, window.innerHeight);\nmyRenderer.setClearColor(\'white\', 1.0);\n$("#myContainer").append(myRenderer.domElement);\nvar myCamera = new THREE.PerspectiveCamera(45,\n                                           window.innerWidth / window.innerHeight, 30, 1000);\nmyCamera.position.set(-24, -29, 26);\nmyCamera.lookAt(new THREE.Vector3(0, 0, 0));\nvar myScene = new THREE.Scene();\nmyScene.add(new THREE.AmbientLight(\'white\'));\n//创建立方体(骰子模型)\nvar myGeometry = new THREE.BoxGeometry(16, 16, 16);\n//创建材质数组\nvar myMaterials = [];\n//在材质数组中设置图像(贴图)\nfor (var i = 1; i < 7; i++) {\n  var myMap = THREE.ImageUtils.loadTexture("images/img13" + i + ".jpg");\n  var myMaterial = new THREE.MeshBasicMaterial({ map: myMap });\n  myMaterials.push(myMaterial);\n}\nvar myMesh = new THREE.Mesh(myGeometry, myMaterials);\nmyScene.add(myMesh);\n//渲染立方体(骰子模型)\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  var myTimer = Date.now() * 0.0001;\n  myMesh.rotation.x = myTimer * 5;\n  myMesh.rotation.y = myTimer * 3;\n  myMesh.rotation.z = myTimer * 2;\n  myRenderer.render(myScene, myCamera);\n}\n//响应单击“仅显示奇数点”按钮\n$("#myButton1").click(function () {\n  //获取骰子模型所使用的材质数组，并对其进行遍历操作\n  myMesh.material.forEach((item, index) => {\n    //设置其为不可见状态\n    if (index % 2 != 0) { item.visible = false; }\n  });\n});\n//响应单击“允许显示所有点”按钮\n$("#myButton2").click(function () {\n  //获取骰子模型所使用的材质数组，并对其进行遍历操作\n  myMesh.material.forEach((item, index) => {\n    //设置所有材质为可见状态\n    item.visible = true;\n  });\n});\n\n\n\n# 004-立方体面上进行字体自定义设计\n\n//创建立方体\nvar myGeometry = new THREE.CubeGeometry(16, 16, 16);\nvar myMaterials = [];\nfor (var i = 1; i < 6; i++) {\n  var myMap = THREE.ImageUtils.loadTexture("images/img13" + i + ".jpg");\n  //var myMaterial = new THREE.MeshPhongMaterial({map: myMap});\n  var myMaterial = new THREE.MeshBasicMaterial({ map: myMap });\n  myMaterials.push(myMaterial);\n}\n//创建在画布上添加文字的函数\nfunction getTextCanvas(myText) {\n  var myWidth = window.innerWidth, myHeight = window.innerHeight;\n  var myCanvas = document.createElement(\'canvas\');\n  myCanvas.width = myWidth;\n  myCanvas.height = myHeight;\n  var myContext = myCanvas.getContext(\'2d\');\n  myContext.fillStyle = \'#00FF00\';\n  myContext.fillRect(0, 0, myWidth, myHeight);\n  myContext.font = 100 + \'px  bold\';\n  myContext.fillStyle = \'#FFFFFF\';\n  myContext.textAlign = \'center\';\n  myContext.textBaseline = \'middle\';\n  myContext.fillText(myText, myWidth / 2, myHeight / 2);\n  return myCanvas;\n}\n//根据画布创建贴图，再根据贴图创建材质\nmyMaterials.push(new THREE.MeshBasicMaterial({\n  map: new THREE.CanvasTexture(getTextCanvas(\'世界杯\'))\n}));\nvar myMesh = new THREE.Mesh(myGeometry, myMaterials);\nmyScene.add(myMesh);\n//渲染立方体\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  var myTimer = Date.now() * 0.0001;\n  myMesh.rotation.x = myTimer * 5;\n  myMesh.rotation.y = myTimer * 3;\n  myMesh.rotation.z = myTimer * 2;\n  myRenderer.render(myScene, myCamera);\n}\n\n\n\n\n\n# 005-空心立方体\n\n//创建空心立方体\nvar myGeometry2 = new THREE.BoxGeometry(16, 16, 16);\nvar myMaterial2 = new THREE.MeshNormalMaterial();\nvar myMesh2 = new THREE.Mesh(myGeometry2, myMaterial2);\n//为立方体myMesh2添加边框线\nvar myBorder = new THREE.EdgesHelper(myMesh2,\'darkgreen\');\nmyMesh2.translateX(10);\nmyBorder.translateX(10);\n//myScene.add(myMesh2);\nmyScene.add(myBorder);\n//渲染实心立方体和空心立方体\nmyRenderer.render(myScene,myCamera);\n\n\n\n\n\n# 006-立体效果贴图\n\n//创建两个立方体\nvar myGeometry = new THREE.BoxGeometry(26, 26, 26);\nvar myMap = new THREE.TextureLoader().load(\'images/img008.jpg\');\nvar myNormalMap = new THREE.TextureLoader().load(\'images/img009.jpg\');\n//设置法向贴图 normalMap，以创建更加细致的立体效果\nvar myMaterial1 = new THREE.MeshPhongMaterial();\nmyMaterial1.map = myMap;\n//myMaterial1.normalMap=myMap;\nmyMaterial1.normalMap = myNormalMap;\nmyMaterial1.normalScale = new THREE.Vector2(0.5, 0.5)\nvar myMesh1 = new THREE.Mesh(myGeometry, myMaterial1);\nmyMesh1.translateX(20);\nmyScene.add(myMesh1);\n//使用普通贴图\nvar myMaterial2 = new THREE.MeshPhongMaterial();\nmyMaterial2.map = myMap;\nvar myMesh2 = new THREE.Mesh(myGeometry, myMaterial2);\nmyMesh2.translateX(-20);\nmyScene.add(myMesh2);\n//渲染两个立方体\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myRenderer.render(myScene, myCamera);\n};\n\n\n\n\n\n# 007-混合材质\n\n//创建圆环结\nvar myGeometry = new THREE.TorusKnotGeometry(8, 3, 500, 60, 2, 7);\n//创建深度材质\nvar myMeshDepthMaterial = new THREE.MeshDepthMaterial();\n//创建绿色材质\nvar myMeshBasicMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, blending: THREE.MultiplyBlending });\n//混合两种材质\nvar myMesh = new THREE.SceneUtils.createMultiMaterialObject(myGeometry, [myMeshDepthMaterial, myMeshBasicMaterial]);\nmyScene.add(myMesh);\n\n\n\n# 008-凹凸材质\n\n//创建两个立方体\nvar myGeometry = new THREE.BoxGeometry(26,26,26);\nvar myMap=new THREE.TextureLoader().load(\'images/img087.jpg\');\nvar myBumpMap=new THREE.TextureLoader().load(\'images/img088.jpg\');\n//根据凹凸贴图bumpMap创建THREE.MeshPhongMaterial材质\nvar myMaterial1 = new THREE.MeshPhongMaterial();\nmyMaterial1.map=myMap;\n//myMaterial1.normalMap=myBumpMap;\nmyMaterial1.bumpMap=myBumpMap;\nmyMaterial1.bumpScale = 2.2;\nvar myMesh1 = new THREE.Mesh(myGeometry, myMaterial1);\nmyMesh1.translateX(20);\nmyScene.add(myMesh1);\n//根据普通贴图创建THREE.MeshPhongMaterial材质\nvar myMaterial2 = new THREE.MeshPhongMaterial();\nmyMaterial2.map=myMap;\nvar myMesh2 = new THREE.Mesh(myGeometry, myMaterial2);\nmyMesh2.translateX(-20);\nmyScene.add(myMesh2);\n//渲染两个立方体\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myRenderer.render(myScene, myCamera);\n};\n\n\n\n\n\n# 009-添加马赛克效果\n\n<script src="ThreeJS/PixelShader.js"><\/script>\n<script src="ThreeJS/EffectComposer.js"><\/script>\n<script src="ThreeJS/RenderPass.js"><\/script>\n<script src="ThreeJS/ShaderPass.js"><\/script>\n\n\nvar myRenderer = new THREE.WebGLRenderer();              //创建渲染器\nvar myWidth = 480;                                      //设置窗口宽度\nvar myHeight = 320;                                    //设置窗口高度\nmyRenderer.setSize(myWidth, myHeight);                //设置渲染区域\nmyRenderer.setClearColor("white", 1);                 //设置清空颜色\n$("#myContainer").append(myRenderer.domElement);\nvar myScene = new THREE.Scene();                          //创建场景\nvar myLight = new THREE.PointLight("red");           //创建红色光源\nmyLight.position.set(400, 800, 300);                   //设置光源位置\nmyScene.add(myLight);                            //在场景中添加光源\nvar k = myWidth / myHeight;                         //计算窗口宽高比\nvar s = 120;                              //三维场景显示范围控制系数\nvar myCamera = new THREE.OrthographicCamera(-s * k,\n                                            s * k, s, -s, 1, 1000); //创建相机\nmyCamera.position.set(400, 300, 200);                //设置相机位置\nmyCamera.lookAt(myScene.position);\nvar myGeometry = new THREE.BoxGeometry(100, 100, 100); //创建立方体\nvar myMaterial =  new THREE.MeshLambertMaterial({ color: 0xFFBF00 }); //创建材质\nvar myMesh = new THREE.Mesh(myGeometry, myMaterial);      //创建网格\nmyScene.add(myMesh);                      //在场景中添加网格(立方体)\n\n//在场景中实现后期特效(在所有图形上添加马赛克)\nvar myEffectComposer = new THREE.EffectComposer(myRenderer);\nmyEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\nvar myShaderPass = new THREE.ShaderPass(THREE.PixelShader);\nmyShaderPass.uniforms.resolution.value = new THREE.Vector2(window.innerWidth, window.innerHeight);\n\n//设置马赛克像素块大小\nmyShaderPass.uniforms.pixelSize.value = 6;\nmyEffectComposer.addPass(myShaderPass);\n\n// myRenderer.render(myScene, myCamera);                  //渲染立方体\nanimate();\nfunction animate() {\n  myEffectComposer.render();\n  requestAnimationFrame(animate);\n}\n\n//响应单击“添加马赛克特效”按钮\n$("#myButton1").click(function () {\n  myEffectComposer.addPass(myShaderPass);\n});\n//响应单击“保持原状”按钮\n$("#myButton2").click(function () {\n  myEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\n});\n\n\n\n# 初始化效果\n\n\n\n\n# 马赛克效果\n\n\n\n\n# 010-添加小灰点特效\n\n<script src="ThreeJS/DotScreenShader.js"><\/script>\n<script src="ThreeJS/EffectComposer.js"><\/script>\n<script src="ThreeJS/RenderPass.js"><\/script>\n<script src="ThreeJS/ShaderPass.js"><\/script>\n\n\n//在场景中实现后期特效(在所有图形上添加小灰点)\nvar myEffectComposer = new THREE.EffectComposer(myRenderer);\nmyEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\nvar myShaderPass = new THREE.ShaderPass(THREE.DotScreenShader);\nmyShaderPass.uniforms[\'scale\'].value = 2;\nmyEffectComposer.addPass(myShaderPass);\n//动态渲染在添加小灰点特效之后的球体和圆环结\nanimate();\nfunction animate() {\n  myEffectComposer.render();\n  requestAnimationFrame(animate);\n}\n//响应单击“添加小灰点特效”按钮\n$("#myButton1").click(function () {\n  myEffectComposer.addPass(myShaderPass);\n});\n\n//响应单击“保持原状”按钮\n$("#myButton2").click(function () {\n  myEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\n});\n\n\n\n# 初始化效果\n\n\n\n\n# 添加小灰点特效效果\n\n\n\n\n# 011-重影特效\n\n<script src="ThreeJS/EffectComposer.js"><\/script>\n<script src="ThreeJS/RenderPass.js"><\/script>\n<script src="ThreeJS/ShaderPass.js"><\/script>\n<script src="ThreeJS/RGBShiftShader.js"><\/script>\n\n\n//在场景中实现后期特效(添加重影特效)\nvar myEffectComposer = new THREE.EffectComposer(myRenderer);\nmyEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\nvar myShaderPass = new THREE.ShaderPass(THREE.RGBShiftShader);\nmyShaderPass.uniforms[\'amount\'].value = 0.005;\nmyEffectComposer.addPass(myShaderPass);\n//渲染添加重影特效之后的图形\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myEffectComposer.render();\n}\n//响应单击“添加重影特效”按钮\n$("#myButton1").click(function () {\n  myEffectComposer.addPass(myShaderPass);\n});\n//响应单击“保持原状”按钮\n$("#myButton2").click(function () {\n  myEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\n});\n\n\n\n\n\n# 012-水平镜像\n\n<script src="ThreeJS/EffectComposer.js"><\/script>\n<script src="ThreeJS/RenderPass.js"><\/script>\n<script src="ThreeJS/ShaderPass.js"><\/script>\n<script src="ThreeJS/MirrorShader.js"><\/script>\n\n\n// 需要移动下立方体的位置，让他不在对称线上\nmyMesh.translateY(120);\nmyMesh.translateX(200);\n。。。\n\n//在场景中实现后期特效(为所有图形添加水平镜像)\nvar myEffectComposer = new THREE.EffectComposer(myRenderer);\nmyEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\nvar myShaderPass = new THREE.ShaderPass(THREE.MirrorShader);\nmyEffectComposer.addPass(myShaderPass);\n//动态渲染在添加水平镜像之后的物体\nanimate();\nfunction animate() {\n  myEffectComposer.render();\n  requestAnimationFrame(animate);\n}\n//响应单击“添加水平镜像”按钮\n$("#myButton1").click(function () {\n  myEffectComposer.addPass(myShaderPass);\n});\n//响应单击“保持原状”按钮\n$("#myButton2").click(function () {\n  myEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\n});\n\n\n\n\n\n# 013-垂直镜像\n\n<script src="ThreeJS/EffectComposer.js"><\/script>\n<script src="ThreeJS/RenderPass.js"><\/script>\n<script src="ThreeJS/ShaderPass.js"><\/script>\n<script src="ThreeJS/MirrorShader.js"><\/script>\n\n\n//在场景中实现后期特效(为所有图形添加垂直镜像)\nvar myEffectComposer = new THREE.EffectComposer(myRenderer);\nmyEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\nvar myShaderPass = new THREE.ShaderPass(THREE.MirrorShader);\nmyShaderPass.uniforms[\'side\'].value = 2;\nmyEffectComposer.addPass(myShaderPass);\n//动态渲染在添加垂直镜像之后的球体和圆环结\nanimate();\nfunction animate() {\n  myEffectComposer.render();\n  requestAnimationFrame(animate);\n}\n//响应单击“添加垂直镜像”按钮\n$("#myButton1").click(function () {\n  myEffectComposer.addPass(myShaderPass);\n});\n//响应单击“保持原状”按钮\n$("#myButton2").click(function () {\n  myEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\n});\n\n\n\n\n\n# 014-更改饱和度\n\n<script src="ThreeJS/EffectComposer.js"><\/script>\n<script src="ThreeJS/RenderPass.js"><\/script>\n<script src="ThreeJS/ShaderPass.js"><\/script>\n<script src="ThreeJS/HueSaturationShader.js"><\/script>\n\n\n//在场景中实现后期特效(改变饱和度)\nvar myEffectComposer = new THREE.EffectComposer(myRenderer);\nmyEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\nvar myShaderPass = new THREE.ShaderPass(THREE.HueSaturationShader);\n//saturation取值范围：-1为最小值，灰色, 0为原状, 1是最大值\nmyShaderPass.uniforms[\'saturation\'].value = 0.69;\nmyEffectComposer.addPass(myShaderPass);\n//渲染改变饱和度之后的立方体\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myEffectComposer.render();\n}\n//响应单击“改变饱和度”按钮\n$("#myButton1").click(function () {\n  myEffectComposer.addPass(myShaderPass);\n});\n//响应单击“保持原状”按钮\n$("#myButton2").click(function () {\n  myEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\n});\n\n\n\n# 初始效果\n\n\n\n\n# 更改饱和度\n\n\n\n\n# 015-更改色调\n\n<script src="ThreeJS/EffectComposer.js"><\/script>\n<script src="ThreeJS/RenderPass.js"><\/script>\n<script src="ThreeJS/ShaderPass.js"><\/script>\n<script src="ThreeJS/HueSaturationShader.js"><\/script>\n\n\n//在场景中实现后期特效(改变色调)\nvar myEffectComposer = new THREE.EffectComposer(myRenderer);\nmyEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\nvar myShaderPass = new THREE.ShaderPass(THREE.HueSaturationShader);\nmyShaderPass.uniforms[\'hue\'].value = 0.5;\nmyEffectComposer.addPass(myShaderPass);\n//渲染改变色调之后的立方体\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myEffectComposer.render();\n}\n//响应单击“改变色调”按钮\n$("#myButton1").click(function () {\n  myEffectComposer.addPass(myShaderPass);\n});\n//响应单击“保持原状”按钮\n$("#myButton2").click(function () {\n  myEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\n});\n\n\n\n\n\n# 016-拖尾效果\n\n<script src="ThreeJS/EffectComposer.js"><\/script>\n<script src="ThreeJS/RenderPass.js"><\/script>\n<script src="ThreeJS/ShaderPass.js"><\/script>\n<script src="ThreeJS/AfterimagePass.js"><\/script>\n<script src="ThreeJS/AfterimageShader.js"><\/script>\n\n\n//在场景中实现后期特效(在转动(动态)的立方体上添加彗星拖尾特效)\nvar myEffectComposer = new THREE.EffectComposer(myRenderer);\nmyEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\nmyEffectComposer.addPass(new THREE.AfterimagePass());\n//动态渲染旋转立方体的彗星拖尾特效\nanimate();\nfunction animate() {\n  myMesh.rotation.x += 0.03;\n  myMesh.rotation.y += 0.03;\n  myEffectComposer.render();\n  requestAnimationFrame(animate);\n}\n//响应单击“添加拖尾特效”按钮\n$("#myButton1").click(function () {\n  myEffectComposer.addPass(new THREE.AfterimagePass());\n});\n//响应单击“保持原状”按钮\n$("#myButton2").click(function () {\n  myEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\n});\n\n\n\n\n\n# 017-泛光特效\n\n<script src="ThreeJS/EffectComposer.js"><\/script>\n<script src="ThreeJS/CopyShader.js"><\/script>\n<script src="ThreeJS/RenderPass.js"><\/script>\n<script src="ThreeJS/ShaderPass.js"><\/script>\n<script src="ThreeJS/BloomPass.js"><\/script>\n<script src="ThreeJS/ConvolutionShader.js"><\/script>\n\n\n//设置背景需要为黑色\nmyRenderer.setClearColor("black", 1);                 \n\n//在场景中实现后期特效（添加泛光特效）\nvar myEffectComposer = new THREE.EffectComposer(myRenderer);\nmyEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\nmyEffectComposer.addPass(new THREE.BloomPass(3, 17, 2.0, 256));\nmyEffectComposer.addPass(new THREE.ShaderPass(THREE.CopyShader));\n//渲染添加泛光特效之后的立方体\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myEffectComposer.render();\n}\n//响应单击“添加泛光特效”按钮\n$("#myButton1").click(function () {\n  myEffectComposer.addPass(new THREE.BloomPass(3, 17, 2.0, 256));\n  myEffectComposer.addPass(new THREE.ShaderPass(THREE.CopyShader));\n});\n//响应单击“保持原状”按钮\n$("#myButton2").click(function () {\n  myEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\n});\n\n\n\n\n\n# 018-老电影雪花扫描线特效\n\n<script src="ThreeJS/EffectComposer.js"><\/script>\n<script src="ThreeJS/RenderPass.js"><\/script>\n<script src="ThreeJS/ShaderPass.js"><\/script>\n<script src="ThreeJS/FilmPass.js"><\/script>\n<script src="ThreeJS/FilmShader.js"><\/script>\n\n\n//在场景中实现后期特效(在立方体上添加老电影雪花扫描线特效)\nvar myEffectComposer = new THREE.EffectComposer(myRenderer);\nmyEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\nmyEffectComposer.addPass(new THREE.FilmPass(3.1, 0.325, 256, true));\n//动态渲染在添加老电影雪花扫描线特效之后的立方体\nanimate();\nfunction animate() {\n  myEffectComposer.render();\n  requestAnimationFrame(animate);\n}\n//响应单击“添加老电影特效”按钮\n$("#myButton1").click(function () {\n  myEffectComposer.addPass(new THREE.FilmPass(3.1, 0.325, 256, true));\n});\n//响应单击“保持原状”按钮\n$("#myButton2").click(function () {\n  myEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\n});\n\n\n\n\n\n# 019-怀旧特效\n\n<script src="ThreeJS/EffectComposer.js"><\/script>\n<script src="ThreeJS/RenderPass.js"><\/script>\n<script src="ThreeJS/ShaderPass.js"><\/script>\n<script src="ThreeJS/SepiaShader.js"><\/script>\n\n\n//在场景中实现后期特效(添加怀旧特效)\nvar myEffectComposer = new THREE.EffectComposer(myRenderer);\nmyEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\nvar myShaderPass = new THREE.ShaderPass(THREE.SepiaShader);\nmyShaderPass.uniforms[\'amount\'].value = 1.7;\nmyEffectComposer.addPass(myShaderPass);\n//渲染添加怀旧特效之后的立方体\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myEffectComposer.render();\n}\n//响应单击“添加怀旧特效”按钮\n$("#myButton1").click(function () {\n  myEffectComposer.addPass(myShaderPass);\n});\n//响应单击“保持原状”按钮\n$("#myButton2").click(function () {\n  myEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\n});\n\n\n\n\n\n# 020-不同颜色过滤立方体\n\n<script src="ThreeJS/EffectComposer.js"><\/script>\n<script src="ThreeJS/RenderPass.js"><\/script>\n<script src="ThreeJS/ShaderPass.js"><\/script>\n<script src="ThreeJS/ColorifyShader.js"><\/script>\n<script src="ThreeJS/OrbitControls.js"><\/script>\n\n\n//在场景中实现后期特效(使用不同颜色过滤立方体)\nvar myEffectComposer = new THREE.EffectComposer(myRenderer);\nmyEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\nvar myShaderPass = new THREE.ShaderPass(THREE.ColorifyShader);\nmyShaderPass.uniforms[\'color\'].value.setRGB(0, 1, 0);\nmyEffectComposer.addPass(myShaderPass);\n//渲染使用不同颜色过滤的立方体\nanimate();\nfunction animate() {\n  myEffectComposer.render();\n  requestAnimationFrame(animate);\n}\n//创建轨道控制器(旋转、缩放图形)\nvar myOrbitControls = new THREE.OrbitControls(myCamera);\n//响应单击“使用红色过滤图形”按钮\n$("#myButton1").click(function () {\n  myShaderPass.uniforms[\'color\'].value.setRGB(1, 0, 0);\n});\n//响应单击“使用绿色过滤图形”按钮\n$("#myButton2").click(function () {\n  myShaderPass.uniforms[\'color\'].value.setRGB(0, 1, 0);\n});\n//响应单击“使用蓝色过滤图形”按钮\n$("#myButton3").click(function () {\n  myShaderPass.uniforms[\'color\'].value.setRGB(0, 0, 1);\n});\n\n\n\n\n\n# 021-飘白特效\n\n<script src="ThreeJS/EffectComposer.js"><\/script>\n<script src="ThreeJS/RenderPass.js"><\/script>\n<script src="ThreeJS/ShaderPass.js"><\/script>\n<script src="ThreeJS/BleachBypassShader.js"><\/script>\n<script src="ThreeJS/OrbitControls.js"><\/script>\n\n\n//在场景中实现后期特效(为立方体添加飘白特效)\nvar myEffectComposer = new THREE.EffectComposer(myRenderer);\nmyEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\nvar myShaderPass = new THREE.ShaderPass(THREE.BleachBypassShader);\nmyShaderPass.uniforms[\'opacity\'].value = 2.9;\nmyEffectComposer.addPass(myShaderPass);\n//渲染经过漂白的立方体\nanimate();\nfunction animate() {\n  myEffectComposer.render();\n  requestAnimationFrame(animate);\n}\n//创建轨道控制器(旋转、缩放图形)\nvar myOrbitControls = new THREE.OrbitControls(myCamera);\n//响应单击“轻微漂白图形”按钮\n$("#myButton1").click(function () {\n  myShaderPass.uniforms[\'opacity\'].value = 2.9;\n});\n//响应单击“强力漂白图形”按钮\n$("#myButton2").click(function () {\n  myShaderPass.uniforms[\'opacity\'].value = 100.9;\n});\n\n\n\n# 轻微漂白图形\n\n\n\n\n# 强力漂白图形\n\n\n\n\n# 022-电脉冲花屏特效\n\n<script src="ThreeJS/EffectComposer.js"><\/script>\n<script src="ThreeJS/RenderPass.js"><\/script>\n<script src="ThreeJS/ShaderPass.js"><\/script>\n<script src="ThreeJS/GlitchPass.js"><\/script>\n<script src="ThreeJS/DigitalGlitch.js"><\/script>\n<script src="ThreeJS/CopyShader.js"><\/script>\n<script src="ThreeJS/OrbitControls.js"><\/script>\n\n\n//在场景中实现后期特效(在立方体上产生电脉冲花屏特效)\nvar myEffectComposer = new THREE.EffectComposer(myRenderer);\nmyEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\nmyEffectComposer.addPass(new THREE.GlitchPass());\n//动态渲染在添加电脉冲特效之后的立方体\nanimate();\nfunction animate() {\n  myEffectComposer.render();\n  requestAnimationFrame(animate);\n}\n//响应单击“添加电脉冲特效”按钮\n$("#myButton1").click(function () {\n  myEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\n  myEffectComposer.addPass(new THREE.GlitchPass());\n});\n//响应单击“保持原状”按钮\n$("#myButton2").click(function () {\n  myEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\n});\n\n\n\n\n\n# 023-模糊立方体\n\n <script src="ThreeJS/EffectComposer.js"><\/script>\n    <script src="ThreeJS/ShaderPass.js"><\/script>\n    <script src="ThreeJS/RenderPass.js"><\/script>\n    <script src="ThreeJS/HorizontalBlurShader.js"><\/script>\n    <script src="ThreeJS/VerticalBlurShader.js"><\/script>\n\n\n//在场景中实现后期特效(模糊立方体)\nvar myHorizontalBlurShader = new THREE.ShaderPass(THREE.HorizontalBlurShader);\nmyHorizontalBlurShader.enabled = false;\nmyHorizontalBlurShader.uniforms.h.value = 1 / (window.innerHeight * 0.8);\nvar myVerticalBlurShader = new THREE.ShaderPass(THREE.VerticalBlurShader);\nmyVerticalBlurShader.enabled = false;\nmyVerticalBlurShader.uniforms.v.value = 1 / (window.innerWidth * 0.3);\nvar myRenderPass = new THREE.RenderPass(myScene, myCamera);\nvar myEffectComposer = new THREE.EffectComposer(myRenderer);\nmyEffectComposer.addPass(myRenderPass);\nmyEffectComposer.addPass(myHorizontalBlurShader);\nmyEffectComposer.addPass(myVerticalBlurShader);\n//渲染模糊之后的立方体\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myEffectComposer.render();\n}\n//响应单击“在水平方向模糊图形”按钮\n$("#myButton1").click(function () {\n  myHorizontalBlurShader.enabled = true;\n});\n//响应单击“在垂直方向模糊图形”按钮\n$("#myButton2").click(function () {\n  myVerticalBlurShader.enabled = true;\n});\n\n\n\n# 在水平方向模糊图形\n\n\n\n\n# 在垂直方向模糊图形\n\n\n\n\n# 024-三角形模糊特效\n\n<script src="ThreeJS/EffectComposer.js"><\/script>\n<script src="ThreeJS/ShaderPass.js"><\/script>\n<script src="ThreeJS/RenderPass.js"><\/script>\n<script src="ThreeJS/TriangleBlurShader.js"><\/script>\n\n\n//在立方体上添加三角形模糊特效\nvar myTriangleBlurPass =\n    new THREE.ShaderPass(THREE.TriangleBlurShader, \'texture\');\nmyTriangleBlurPass.enabled = false;\nmyTriangleBlurPass.uniforms.delta.value = new THREE.Vector2(0.05, 0.05);\nvar myRenderPass = new THREE.RenderPass(myScene, myCamera);\nvar myEffectComposer = new THREE.EffectComposer(myRenderer);\nmyEffectComposer.addPass(myRenderPass);\nmyEffectComposer.addPass(myTriangleBlurPass);\n//渲染在立方体上的三角形模糊特效\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myEffectComposer.render();\n}\n//响应单击“在图形上添加三角形模糊特效”按钮\n$("#myButton1").click(function () {\n  myTriangleBlurPass.enabled = true;\n});\n//响应单击“取消图形的三角形模糊特效”按钮\n$("#myButton2").click(function () {\n  myTriangleBlurPass.enabled = false;\n});\n\n\n\n# 025-增大亮度\n\n<script src="ThreeJS/EffectComposer.js"><\/script>\n<script src="ThreeJS/RenderPass.js"><\/script>\n<script src="ThreeJS/ShaderPass.js"><\/script>\n<script src="ThreeJS/CopyShader.js"><\/script>\n<script src="ThreeJS/BrightnessContrastShader.js"><\/script>\n\n\n//在场景中实现后期特效(改变所有图形亮度)\nvar myEffectComposer = new THREE.EffectComposer(myRenderer);\nmyEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\nvar myShaderPass = new THREE.ShaderPass(THREE.BrightnessContrastShader);\nmyShaderPass.uniforms[\'brightness\'].value = 0;\nmyEffectComposer.addPass(myShaderPass);\n//渲染亮度改变之后的图形\nrender();\nfunction render() {\n  requestAnimationFrame(render);\n  myEffectComposer.render();\n}\n//响应单击“增大亮度”按钮\n$("#myButton1").click(function () {\n  myShaderPass.uniforms[\'brightness\'].value = 0.5;\n});\n//响应单击“保持原状”按钮\n$("#myButton2").click(function () {\n  myShaderPass.uniforms[\'brightness\'].value = 0;\n});\n\n\n\n\n\n# 026-增大对比度\n\n<script src="ThreeJS/EffectComposer.js"><\/script>\n<script src="ThreeJS/RenderPass.js"><\/script>\n<script src="ThreeJS/ShaderPass.js"><\/script>\n<script src="ThreeJS/CopyShader.js"><\/script>\n<script src="ThreeJS/BrightnessContrastShader.js"><\/script>\n\n\n//在场景中实现后期特效(改变所有图形的对比度)\nvar myEffectComposer = new THREE.EffectComposer(myRenderer);\nmyEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\nvar myShaderPass = new THREE.ShaderPass(THREE.BrightnessContrastShader);\nmyShaderPass.uniforms[\'contrast\'].value = 0;\nmyEffectComposer.addPass(myShaderPass);\n//渲染对比度改变之后的立方体\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myEffectComposer.render();\n}\n//响应单击“增大对比度”按钮\n$("#myButton1").click(function () {\n  myShaderPass.uniforms[\'contrast\'].value = 0.5;\n});\n//响应单击“保持原状”按钮\n$("#myButton2").click(function () {\n  myShaderPass.uniforms[\'contrast\'].value = 0;\n});\n\n\n\n\n\n# 027-Gamma校正\n\n<script src="ThreeJS/EffectComposer.js"><\/script>\n<script src="ThreeJS/RenderPass.js"><\/script>\n<script src="ThreeJS/ShaderPass.js"><\/script>\n<script src="ThreeJS/GammaCorrectionShader.js"><\/script>\n\n\n//在场景中实现后期特效(对所有图形进行Gamma校正)\nvar myEffectComposer = new THREE.EffectComposer(myRenderer);\nmyEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\nvar myShaderPass = new THREE.ShaderPass(THREE.GammaCorrectionShader);\n//渲染Gamma校正之后的立方体\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myEffectComposer.render();\n}\n//响应单击“Gamma校正”按钮\n$("#myButton1").click(function () {\n  myEffectComposer.addPass(myShaderPass);\n});\n//响应单击“保持原状”按钮\n$("#myButton2").click(function () {\n  myEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\n});\n\n\n\n\n\n# 028-改变光亮\n\n<script src="ThreeJS/EffectComposer.js"><\/script>\n<script src="ThreeJS/RenderPass.js"><\/script>\n<script src="ThreeJS/ShaderPass.js"><\/script>\n<script src="ThreeJS/LuminosityShader.js"><\/script>\n\n\n//在场景中实现后期特效(改变所有图形的光亮)\nvar myEffectComposer = new THREE.EffectComposer(myRenderer);\nmyEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\nvar myShaderPass = new THREE.ShaderPass(THREE.LuminosityShader);\nmyEffectComposer.addPass(myShaderPass);\n//渲染光亮改变之后的立方体\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myEffectComposer.render();\n}\n//响应单击“改变光亮”按钮\n$("#myButton1").click(function () {\n  myEffectComposer.addPass(myShaderPass);\n});\n//响应单击“保持原状”按钮\n$("#myButton2").click(function () {\n  myEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\n});\n\n\n\n\n\n# 029-检测边缘\n\n<script src="ThreeJS/EffectComposer.js"><\/script>\n<script src="ThreeJS/RenderPass.js"><\/script>\n<script src="ThreeJS/ShaderPass.js"><\/script>\n<script src="ThreeJS/SobelOperatorShader.js"><\/script>\n\n\n//在场景中实现后期特效(使用Sobel算子检测图形图像的轮廓边缘)\nvar myEffectComposer = new THREE.EffectComposer(myRenderer);\nmyEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\nvar myShaderPass = new THREE.ShaderPass(THREE.SobelOperatorShader);\nmyShaderPass.uniforms[\'resolution\'].value =\n  new THREE.Vector2(window.innerWidth, window.innerHeight);\nmyEffectComposer.addPass(myShaderPass);\n//渲染立方体(图形图像)边缘\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myEffectComposer.render();\n}\n//响应单击“检测边缘”按钮\n$("#myButton1").click(function () {\n  myEffectComposer.addPass(myShaderPass);\n});\n//响应单击“保持原状”按钮\n$("#myButton2").click(function () {\n  myEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\n});\n\n\n\n\n\n# 030-添加光晕\n\n<script src="ThreeJS/EffectComposer.js"><\/script>\n<script src="ThreeJS/RenderPass.js"><\/script>\n<script src="ThreeJS/ShaderPass.js"><\/script>\n<script src="ThreeJS/VignetteShader.js"><\/script>\n\n\n//在场景中实现后期特效(在球体周围添加光晕特效)\nvar myEffectComposer = new THREE.EffectComposer(myRenderer);\nmyEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\nvar myShaderPass = new THREE.ShaderPass(THREE.VignetteShader);\nmyShaderPass.uniforms[\'darkness\'].value = 4;\nmyShaderPass.uniforms[\'offset\'].value = 1;\nmyEffectComposer.addPass(myShaderPass);\n//渲染添加光晕之后的球体\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myEffectComposer.render();\n}\n//响应单击“添加光晕”按钮\n$("#myButton1").click(function () {\n  myEffectComposer.addPass(myShaderPass);\n});\n//响应单击“保持原状”按钮\n$("#myButton2").click(function () {\n  myEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\n});\n\n\n\n\n\n# 031-校正颜色\n\n<script src="ThreeJS/EffectComposer.js"><\/script>\n<script src="ThreeJS/RenderPass.js"><\/script>\n<script src="ThreeJS/ShaderPass.js"><\/script>\n<script src="ThreeJS/ColorCorrectionShader.js"><\/script>\n\n\n//在场景中实现后期特效(校正图形图像的颜色)\nvar myEffectComposer = new THREE.EffectComposer(myRenderer);\nmyEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\nvar myShaderPass = new THREE.ShaderPass(THREE.ColorCorrectionShader);\nmyShaderPass.uniforms[\'powRGB\'].value = new THREE.Vector3(2, 2, 2);\n//myShaderPass.uniforms[\'mulRGB\'].value=new THREE.Vector3( 1, 1, 1 );\n// myShaderPass.uniforms[\'addRGB\'].value=new THREE.Vector3( 0, 0, 0 );\nmyEffectComposer.addPass(myShaderPass);\n//渲染在校正颜色之后的立方体\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myEffectComposer.render();\n}\n//响应单击“校正颜色”按钮\n$("#myButton1").click(function () {\n  myEffectComposer.addPass(myShaderPass);\n});\n//响应单击“保持原状”按钮\n$("#myButton2").click(function () {\n  myEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\n});\n\n\n\n\n\n# 032-变换为万花筒\n\n<script src="ThreeJS/EffectComposer.js"><\/script>\n<script src="ThreeJS/RenderPass.js"><\/script>\n<script src="ThreeJS/ShaderPass.js"><\/script>\n<script src="ThreeJS/KaleidoShader.js"><\/script>\n\n\n//在场景中实现后期特效(变换为万花筒)\nvar myEffectComposer = new THREE.EffectComposer(myRenderer);\nmyEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\nvar myShaderPass = new THREE.ShaderPass(THREE.KaleidoShader);\nmyShaderPass.uniforms[\'sides\'].value = 8;\nmyShaderPass.uniforms[\'angle\'].value = 45;\nmyEffectComposer.addPass(myShaderPass);\n//渲染改变之后的万花筒\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myEffectComposer.render();\n}\n//响应单击“变换为万花筒”按钮\n$("#myButton1").click(function () {\n  myEffectComposer.addPass(myShaderPass);\n});\n//响应单击“保持原状”按钮\n$("#myButton2").click(function () {\n  myEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\n});\n\n\n\n\n\n# 033-添加特艺彩色\n\n<script src="ThreeJS/EffectComposer.js"><\/script>\n<script src="ThreeJS/RenderPass.js"><\/script>\n<script src="ThreeJS/ShaderPass.js"><\/script>\n<script src="ThreeJS/TechnicolorShader.js"><\/script>\n\n\n//在场景中实现后期特效(添加特艺彩色)\nvar myEffectComposer = new THREE.EffectComposer(myRenderer);\nmyEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\nvar myShaderPass = new THREE.ShaderPass(THREE.TechnicolorShader);\nmyEffectComposer.addPass(myShaderPass);\n//渲染添加特艺彩色之后的立方体\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myEffectComposer.render();\n}\n//响应单击“添加特艺彩色”按钮\n$("#myButton1").click(function () {\n  myEffectComposer.addPass(myShaderPass);\n});\n//响应单击“保持原状”按钮\n$("#myButton2").click(function () {\n  myEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\n});\n\n\n\n\n\n# 034-水平移轴特效\n\n<script src="ThreeJS/EffectComposer.js"><\/script>\n<script src="ThreeJS/RenderPass.js"><\/script>\n<script src="ThreeJS/ShaderPass.js"><\/script>\n<script src="ThreeJS/HorizontalTiltShiftShader.js"><\/script>\n\n\n//在场景中实现后期特效(添加水平移轴特效)\nvar myEffectComposer = new THREE.EffectComposer(myRenderer);\nmyEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\nvar myShaderPass = new THREE.ShaderPass(THREE.HorizontalTiltShiftShader);\nmyShaderPass.uniforms[\'h\'].value = 0.5;\nmyShaderPass.uniforms[\'r\'].value = 0.1;\nmyEffectComposer.addPass(myShaderPass);\n//渲染添加水平移轴特效之后的立方体\nrender();\nfunction render() {\n  requestAnimationFrame(render);\n  myEffectComposer.render();\n}\n//响应单击“添加水平移轴特效”按钮\n$("#myButton1").click(function () {\n  myEffectComposer.addPass(myShaderPass);\n});\n//响应单击“保持原状”按钮\n$("#myButton2").click(function () {\n  myEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\n});\n\n\n\n\n\n# 035-垂直移轴特效\n\n<script src="ThreeJS/EffectComposer.js"><\/script>\n<script src="ThreeJS/RenderPass.js"><\/script>\n<script src="ThreeJS/ShaderPass.js"><\/script>\n<script src="ThreeJS/VerticalTiltShiftShader.js"><\/script>\n\n\n//在场景中实现后期特效(添加垂直移轴特效)\nvar myEffectComposer = new THREE.EffectComposer(myRenderer);\nmyEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\nvar myShaderPass = new THREE.ShaderPass(THREE.VerticalTiltShiftShader);\nmyShaderPass.uniforms[\'v\'].value = 0.5;\nmyShaderPass.uniforms[\'r\'].value = 0.35;\nmyEffectComposer.addPass(myShaderPass);\n//渲染添加垂直移轴特效之后的立方体\nrender();\nfunction render() {\n  requestAnimationFrame(render);\n  myEffectComposer.render();\n}\n//响应单击“添加垂直移轴特效”按钮\n$("#myButton1").click(function () {\n  myEffectComposer.addPass(myShaderPass);\n});\n//响应单击“保持原状”按钮\n$("#myButton2").click(function () {\n  myEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\n});\n\n\n\n\n\n# 036-聚焦特效\n\n<script src="ThreeJS/EffectComposer.js"><\/script>\n<script src="ThreeJS/RenderPass.js"><\/script>\n<script src="ThreeJS/ShaderPass.js"><\/script>\n<script src="ThreeJS/FocusShader.js"><\/script>\n\n\n//在场景中实现后期特效(添加聚焦特效)\nvar myEffectComposer = new THREE.EffectComposer(myRenderer);\nmyEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\nvar myShaderPass = new THREE.ShaderPass(THREE.FocusShader);\nmyShaderPass.uniforms[\'screenWidth\'].value = window.innerWidth;\nmyShaderPass.uniforms[\'screenHeight\'].value = window.innerHeight;\nmyShaderPass.uniforms[\'sampleDistance\'].value = 0.000094;\nmyShaderPass.uniforms[\'waveFactor\'].value = 0.00125;\nmyEffectComposer.addPass(myShaderPass);\n//渲染添加聚焦特效之后的球体\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myEffectComposer.render();\n}\n//响应单击“添加聚焦特效”按钮\n$("#myButton1").click(function () {\n  myEffectComposer.addPass(myShaderPass);\n});\n//响应单击“保持原状”按钮\n$("#myButton2").click(function () {\n  myEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\n});\n\n\n\n\n\n# 037-检测边缘\n\n<script src="ThreeJS/FreiChenShader.js"><\/script>\n<script src="ThreeJS/EffectComposer.js"><\/script>\n<script src="ThreeJS/RenderPass.js"><\/script>\n<script src="ThreeJS/ShaderPass.js"><\/script>\n\n\n//在场景中实现后期特效(检测边缘)\nvar myEffectComposer = new THREE.EffectComposer(myRenderer);\nmyEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\nvar myShaderPass = new THREE.ShaderPass(THREE.FreiChenShader);\nmyShaderPass.uniforms[\'aspect\'].value =\n  new THREE.Vector2(window.innerWidth, window.innerHeight);\nmyEffectComposer.addPass(myShaderPass);\n//渲染检测边缘之后的立方体(图形图像)\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myEffectComposer.render();\n}\n//响应单击“检测边缘”按钮\n$("#myButton1").click(function () {\n  myEffectComposer.addPass(myShaderPass);\n});\n//响应单击“保持原状”按钮\n$("#myButton2").click(function () {\n  myEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\n});\n\n\n\n\n\n# 038-锯齿特效\n\n<script src="ThreeJS/EffectComposer.js"><\/script>\n<script src="ThreeJS/RenderPass.js"><\/script>\n<script src="ThreeJS/ShaderPass.js"><\/script>\n<script src="ThreeJS/FXAAShader.js"><\/script>\n\n\n//在场景中实现后期特效(添加锯齿特效)\nvar myEffectComposer = new THREE.EffectComposer(myRenderer);\nmyEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\nvar myShaderPass = new THREE.ShaderPass(THREE.FXAAShader);\nmyShaderPass.uniforms[\'resolution\'].value = new THREE.Vector2(1 / 64, 1 / 64);\nmyEffectComposer.addPass(myShaderPass);\n//渲染在添加锯齿特效之后的立方体\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myEffectComposer.render();\n}\n//响应单击“添加锯齿特效”按钮\n$("#myButton1").click(function () {\n  myEffectComposer.addPass(myShaderPass);\n});\n//响应单击“保持原状”按钮\n$("#myButton2").click(function () {\n  myEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\n});\n\n\n\n\n\n# 039-轮廓边线\n\n <script src="ThreeJS/CopyShader.js"><\/script>\n    <script src="ThreeJS/EffectComposer.js"> <\/script>\n    <script src="ThreeJS/RenderPass.js"><\/script>\n    <script src="ThreeJS/ShaderPass.js"><\/script>\n    <script src="ThreeJS/OutlinePass.js"><\/script>\n\n\n //在场景中实现后期特效(添加轮廓边线)\n       var myEffectComposer = new THREE.EffectComposer(myRenderer);\n        myEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\n        var myOutlinePass = new THREE.OutlinePass(new THREE.Vector2(window.innerWidth,\n            window.innerHeight), myScene, myCamera, [myMesh]);\n        myEffectComposer.addPass(myOutlinePass);\n        //动态渲染在添加轮廓边线之后的图形\n        var isOutline = true;\n        function animate() {\n            requestAnimationFrame(animate);\n            if (isOutline) myEffectComposer.render();\n            else myRenderer.render(myScene, myCamera);\n        }\n        animate();\n        //响应单击“添加轮廓边线”按钮\n        $("#myButton1").click(function () {\n            isOutline = true;\n        });\n        //响应单击“保持原状”按钮\n        $("#myButton2").click(function () {\n            isOutline = false;\n        });\n\n\n\n\n\n# 040-辉光特效\n\n<script src="ThreeJS/EffectComposer.js"><\/script>\n    <script src="ThreeJS/RenderPass.js"><\/script>\n    <script src="ThreeJS/ShaderPass.js"><\/script>\n    <script src="ThreeJS/CopyShader.js"><\/script>\n    <script src="ThreeJS/UnrealBloomPass.js"><\/script>\n    <script src="ThreeJS/LuminosityHighPassShader.js"><\/script>\n\n\n//在场景中实现后期特效(添加辉光特效)\nvar myEffectComposer = new THREE.EffectComposer(myRenderer);\nmyEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\nvar myUnrealBloomPass = new THREE.UnrealBloomPass(\n  new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.6);\nmyEffectComposer.addPass(myUnrealBloomPass);\n//渲染在添加辉光特效之后的立方体\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myEffectComposer.render();\n}\n//响应单击“添加辉光特效”按钮\n$("#myButton1").click(function () {\n  myEffectComposer.addPass(myUnrealBloomPass);\n});\n//响应单击“保持原状”按钮\n$("#myButton2").click(function () {\n  myEffectComposer.addPass(new THREE.RenderPass(myScene, myCamera));\n});\n\n\n\n\n\n# 041-虚线边框\n\n//渲染立方体及其虚线边框\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myRenderer.render(myScene, myCamera);\n}\n//响应单击“添加虚线边框”按钮\n$("#myButton1").click(function () {\n  var myEdgeGeometry = new THREE.EdgesGeometry(myGeometry);\n  var myEdgeMaterial =\n      new THREE.LineDashedMaterial({ color: 0x000000, dashSize: 6 });\n  var myLineSegments = new THREE.LineSegments(myEdgeGeometry, myEdgeMaterial);\n  myLineSegments.computeLineDistances();\n  myLineSegments.name = \'myLine\';\n  myScene.add(myLineSegments);\n});\n//响应单击“移除虚线边框”按钮\n$("#myButton2").click(function () {\n  myScene.remove(myScene.getObjectByName(\'myLine\'));\n});\n\n\n\n\n\n# 042-圆角立方体\n\n<script src="ThreeJS/SubdivisionModifier.js"><\/script>\n\n\n//创建立方体\n// var myGeometry = new THREE.BoxGeometry(100, 100, 100); \n//创建圆角立方体\nvar myBoxGeometry = new THREE.BoxGeometry(100, 100, 100, 2, 2, 2);\nvar myModifier = new THREE.SubdivisionModifier(3);\nvar myGeometry = myModifier.modify(myBoxGeometry);\n// var myMaterial =  new THREE.MeshLambertMaterial({ color: 0xFFBF00 }); //创建材质\nvar myMap = THREE.ImageUtils.loadTexture("images/img073.jpg");\nvar myMaterial = new THREE.MeshBasicMaterial({ map: myMap });\nvar myMesh = new THREE.Mesh(myGeometry, myMaterial);      //创建网格\n// myMesh.translateY(50);\n// myMesh.translateX(200);\nmyScene.add(myMesh);                      //在场景中添加网格(立方体)\n//渲染立方体\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myRenderer.render(myScene, myCamera);\n}\n//响应单击“启用圆角效果”按钮\n$("#myButton1").click(function () {\n  var myGeometry = new THREE.BoxGeometry(100, 100, 100, 2, 2, 2);\n  myMesh.geometry = myModifier.modify(myGeometry);\n});\n//响应单击“禁用圆角效果”按钮\n$("#myButton2").click(function () {\n  myMesh.geometry = new THREE.BoxGeometry(100, 100, 100, 2, 2, 2);\n});\n\n\n\n\n\n# 043-扁平化\n\nvar myGeometry = new THREE.SphereGeometry(80, 30, 30);\n//创建法向量材质\nvar myMaterial = new THREE.MeshNormalMaterial();\n//扁平化球面\nmyMaterial.flatShading = true;\nvar myMesh = new THREE.Mesh(myGeometry, myMaterial);\nmyMesh.name = \'flatShadingTrue\';\nmyScene.add(myMesh);\n\n\n\n\n\n# 044-曲线拉伸的五角星\n\n<script src="ThreeJS/TrackballControls.js"><\/script>\n\n\nvar myTrackballControls =\n    new THREE.TrackballControls(myCamera, myRenderer.domElement);\n//创建拉伸曲线\nvar myRandomPoints = [];\nfor (var i = 0; i < 10; i++) {\n  myRandomPoints.push(new THREE.Vector3((i - 4.5) * 50,\n                                        THREE.MathUtils.randFloat(-50, 50), THREE.MathUtils.randFloat(-50, 50)));\n}\nvar myRandomPath = new THREE.CatmullRomCurve3(myRandomPoints);\nvar myExtrudeSettings = { steps: 600, extrudePath: myRandomPath };\n//创建五角星\nvar myPoints = [], myCount = 5;\nfor (var i = 0; i < myCount * 2; i++) {\n  var l = i % 2 == 1 ? 20 : 40;\n  var a = i / myCount * Math.PI;\n  myPoints.push(new THREE.Vector2(Math.cos(a) * l, Math.sin(a) * l));\n}\nvar myShape = new THREE.Shape(myPoints);\nvar myGeometry = new THREE.ExtrudeGeometry(myShape, myExtrudeSettings);\nvar myMaterial = new THREE.MeshLambertMaterial({ color: 0x00ff00 });\nvar myMesh = new THREE.Mesh(myGeometry, myMaterial);\nmyScene.add(myMesh);\n//渲染沿着曲线拉伸的五角星\nanimate();\nfunction animate() {\n  requestAnimationFrame(animate);\n  myTrackballControls.update();\n  myRenderer.render(myScene, myCamera);\n}\n\n\n\n# 045-\n\n\n\n\n\n\n\n\n# 046-\n\n\n\n\n\n\n\n\n# 047-\n\n\n\n\n\n\n\n\n# 048-\n\n\n\n\n\n\n\n\n# 049-\n\n\n\n\n\n\n\n\n# 050-\n\n\n\n\n\n',normalizedContent:'# 001-顶点和片源不同颜色的立方体\n\n<script id="myvertexshader" type="x-shader/x-vertex">\n   //创建顶点着色器\n    varying vec2 vuv;\n    void main() {\n      vuv = uv;\n      vec4 mvposition = modelviewmatrix * vec4( position, 1.0 );\n      gl_position = projectionmatrix * mvposition;\n    }\n<\/script>\n<script id="myfragmentshader" type="x-shader/x-fragment">\n    //创建片元着色器\n    uniform float time;\n    uniform vec2 resolution;\n    varying vec2 vuv;\n    void main( void ) {\n      vec2 position = -1.0 + 2.0 * vuv;\n      float red = abs( sin( position.x * position.y + time / 5.0 ) );\n      float green = abs( sin( position.x * position.y + time / 4.0 ) );\n      float blue = abs( sin( position.x * position.y + time / 3.0 ) );\n      gl_fragcolor = vec4( red, green, blue, 1.0 );\n    }\n<\/script>\n<script type="text/javascript">\n  //创建渲染器\n  var myrenderer = new three.webglrenderer({ antialias: true });\n  myrenderer.setsize(window.innerwidth, window.innerheight);\n  myrenderer.setclearcolor(\'white\', 1.0);\n  $(\'#mycontainer\')[0].appendchild(myrenderer.domelement);\n  var myscene = new three.scene();\n  var mycamera = new three.perspectivecamera(45, window.innerwidth / window.innerheight, 10, 130);\n  mycamera.position.x = 30;\n  mycamera.position.y = 30;\n  mycamera.position.z = 30;\n  mycamera.lookat(new three.vector3(0, 0, 0));\n  //创建three.shadermaterial\n  var myshadermaterial = new three.shadermaterial({\n    uniforms: {\n      time: { type: "f", value: 1.0 },\n      resolution: { type: "v2", value: new three.vector2() },\n    },\n    vertexshader: $(\'#myvertexshader\')[0].textcontent,\n    fragmentshader: $(\'#myfragmentshader\')[0].textcontent\n  });\n  //使用three.shadermaterial创建立方体\n  var myboxgeometry = new three.boxgeometry(16, 16, 16);\n  var mymesh = new three.mesh(myboxgeometry, myshadermaterial);\n  myscene.add(mymesh);\n  var mystep = 0;\n  //渲染(旋转)立方体\n  animate();\n  function animate() {\n    mymesh.rotation.y = mystep += 0.01;\n    mymesh.rotation.x = mystep;\n    mymesh.rotation.z = mystep;\n    mymesh.material.uniforms.time.value += 0.1;\n    requestanimationframe(animate);\n    myrenderer.render(myscene, mycamera);\n  }\n<\/script>\n\n\n\n\n\n# 002-指数雾的立方体\n\n//创建渲染器\nvar myrenderer = new three.webglrenderer({ antialias: true });\nmyrenderer.setsize(window.innerwidth, window.innerheight);\nmyrenderer.setclearcolor(\'white\', 1.0);\n$("#mycontainer").append(myrenderer.domelement);\nvar myscene = new three.scene();\nmyscene.add(new three.ambientlight(\'white\'));\n//使用指数雾设置场景的fog雾化属性\nmyscene.fog = new three.fogexp2(\'white\', 0.025);\nvar mycamera = new three.perspectivecamera(45, window.innerwidth / window.innerheight, 30, 1000);\nmycamera.position.set(-34.34, -40.56, 35.83);\nmycamera.lookat(new three.vector3(0, 0, 0));\n//创建立方体\nvar mygeometry = new three.boxgeometry(20, 20, 20);\nvar mymaterial = new three.meshlambertmaterial({ color: \'darkgreen\' });\nvar mymesh = new three.mesh(mygeometry, mymaterial);\nmyscene.add(mymesh);\n//渲染立方体\nmyrenderer.render(myscene, mycamera);\n\n\n\n\n\n# 003-立方体(骰子模型)\n\n//创建立方体(骰子模型)\nvar mygeometry = new three.boxgeometry(16, 16, 16);\nvar mymaterials = [];\n//在材质数组中设置多个图像(贴图)\nfor (var i = 1; i < 7; i++) {\n  var mymap = three.imageutils.loadtexture("images/img13" + i + ".jpg");\n  var mymaterial = new three.meshbasicmaterial({ map: mymap });\n  mymaterials.push(mymaterial);\n}\nvar mymesh = new three.mesh(mygeometry, mymaterials);\nmyscene.add(mymesh);\n//渲染立方体(骰子模型)\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  var mytimer = date.now() * 0.0001;\n  mymesh.rotation.x = mytimer * 5;\n  mymesh.rotation.y = mytimer * 3;\n  mymesh.rotation.z = mytimer * 2;\n  myrenderer.render(myscene, mycamera);\n}\n\n\n\n\n\n# 仅显示奇数点(visible是否显示)\n\n//创建渲染器\nvar myrenderer = new three.webglrenderer({ antialias: true });\nmyrenderer.setsize(window.innerwidth, window.innerheight);\nmyrenderer.setclearcolor(\'white\', 1.0);\n$("#mycontainer").append(myrenderer.domelement);\nvar mycamera = new three.perspectivecamera(45,\n                                           window.innerwidth / window.innerheight, 30, 1000);\nmycamera.position.set(-24, -29, 26);\nmycamera.lookat(new three.vector3(0, 0, 0));\nvar myscene = new three.scene();\nmyscene.add(new three.ambientlight(\'white\'));\n//创建立方体(骰子模型)\nvar mygeometry = new three.boxgeometry(16, 16, 16);\n//创建材质数组\nvar mymaterials = [];\n//在材质数组中设置图像(贴图)\nfor (var i = 1; i < 7; i++) {\n  var mymap = three.imageutils.loadtexture("images/img13" + i + ".jpg");\n  var mymaterial = new three.meshbasicmaterial({ map: mymap });\n  mymaterials.push(mymaterial);\n}\nvar mymesh = new three.mesh(mygeometry, mymaterials);\nmyscene.add(mymesh);\n//渲染立方体(骰子模型)\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  var mytimer = date.now() * 0.0001;\n  mymesh.rotation.x = mytimer * 5;\n  mymesh.rotation.y = mytimer * 3;\n  mymesh.rotation.z = mytimer * 2;\n  myrenderer.render(myscene, mycamera);\n}\n//响应单击“仅显示奇数点”按钮\n$("#mybutton1").click(function () {\n  //获取骰子模型所使用的材质数组，并对其进行遍历操作\n  mymesh.material.foreach((item, index) => {\n    //设置其为不可见状态\n    if (index % 2 != 0) { item.visible = false; }\n  });\n});\n//响应单击“允许显示所有点”按钮\n$("#mybutton2").click(function () {\n  //获取骰子模型所使用的材质数组，并对其进行遍历操作\n  mymesh.material.foreach((item, index) => {\n    //设置所有材质为可见状态\n    item.visible = true;\n  });\n});\n\n\n\n# 004-立方体面上进行字体自定义设计\n\n//创建立方体\nvar mygeometry = new three.cubegeometry(16, 16, 16);\nvar mymaterials = [];\nfor (var i = 1; i < 6; i++) {\n  var mymap = three.imageutils.loadtexture("images/img13" + i + ".jpg");\n  //var mymaterial = new three.meshphongmaterial({map: mymap});\n  var mymaterial = new three.meshbasicmaterial({ map: mymap });\n  mymaterials.push(mymaterial);\n}\n//创建在画布上添加文字的函数\nfunction gettextcanvas(mytext) {\n  var mywidth = window.innerwidth, myheight = window.innerheight;\n  var mycanvas = document.createelement(\'canvas\');\n  mycanvas.width = mywidth;\n  mycanvas.height = myheight;\n  var mycontext = mycanvas.getcontext(\'2d\');\n  mycontext.fillstyle = \'#00ff00\';\n  mycontext.fillrect(0, 0, mywidth, myheight);\n  mycontext.font = 100 + \'px  bold\';\n  mycontext.fillstyle = \'#ffffff\';\n  mycontext.textalign = \'center\';\n  mycontext.textbaseline = \'middle\';\n  mycontext.filltext(mytext, mywidth / 2, myheight / 2);\n  return mycanvas;\n}\n//根据画布创建贴图，再根据贴图创建材质\nmymaterials.push(new three.meshbasicmaterial({\n  map: new three.canvastexture(gettextcanvas(\'世界杯\'))\n}));\nvar mymesh = new three.mesh(mygeometry, mymaterials);\nmyscene.add(mymesh);\n//渲染立方体\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  var mytimer = date.now() * 0.0001;\n  mymesh.rotation.x = mytimer * 5;\n  mymesh.rotation.y = mytimer * 3;\n  mymesh.rotation.z = mytimer * 2;\n  myrenderer.render(myscene, mycamera);\n}\n\n\n\n\n\n# 005-空心立方体\n\n//创建空心立方体\nvar mygeometry2 = new three.boxgeometry(16, 16, 16);\nvar mymaterial2 = new three.meshnormalmaterial();\nvar mymesh2 = new three.mesh(mygeometry2, mymaterial2);\n//为立方体mymesh2添加边框线\nvar myborder = new three.edgeshelper(mymesh2,\'darkgreen\');\nmymesh2.translatex(10);\nmyborder.translatex(10);\n//myscene.add(mymesh2);\nmyscene.add(myborder);\n//渲染实心立方体和空心立方体\nmyrenderer.render(myscene,mycamera);\n\n\n\n\n\n# 006-立体效果贴图\n\n//创建两个立方体\nvar mygeometry = new three.boxgeometry(26, 26, 26);\nvar mymap = new three.textureloader().load(\'images/img008.jpg\');\nvar mynormalmap = new three.textureloader().load(\'images/img009.jpg\');\n//设置法向贴图 normalmap，以创建更加细致的立体效果\nvar mymaterial1 = new three.meshphongmaterial();\nmymaterial1.map = mymap;\n//mymaterial1.normalmap=mymap;\nmymaterial1.normalmap = mynormalmap;\nmymaterial1.normalscale = new three.vector2(0.5, 0.5)\nvar mymesh1 = new three.mesh(mygeometry, mymaterial1);\nmymesh1.translatex(20);\nmyscene.add(mymesh1);\n//使用普通贴图\nvar mymaterial2 = new three.meshphongmaterial();\nmymaterial2.map = mymap;\nvar mymesh2 = new three.mesh(mygeometry, mymaterial2);\nmymesh2.translatex(-20);\nmyscene.add(mymesh2);\n//渲染两个立方体\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  myrenderer.render(myscene, mycamera);\n};\n\n\n\n\n\n# 007-混合材质\n\n//创建圆环结\nvar mygeometry = new three.torusknotgeometry(8, 3, 500, 60, 2, 7);\n//创建深度材质\nvar mymeshdepthmaterial = new three.meshdepthmaterial();\n//创建绿色材质\nvar mymeshbasicmaterial = new three.meshbasicmaterial({ color: 0x00ff00, transparent: true, blending: three.multiplyblending });\n//混合两种材质\nvar mymesh = new three.sceneutils.createmultimaterialobject(mygeometry, [mymeshdepthmaterial, mymeshbasicmaterial]);\nmyscene.add(mymesh);\n\n\n\n# 008-凹凸材质\n\n//创建两个立方体\nvar mygeometry = new three.boxgeometry(26,26,26);\nvar mymap=new three.textureloader().load(\'images/img087.jpg\');\nvar mybumpmap=new three.textureloader().load(\'images/img088.jpg\');\n//根据凹凸贴图bumpmap创建three.meshphongmaterial材质\nvar mymaterial1 = new three.meshphongmaterial();\nmymaterial1.map=mymap;\n//mymaterial1.normalmap=mybumpmap;\nmymaterial1.bumpmap=mybumpmap;\nmymaterial1.bumpscale = 2.2;\nvar mymesh1 = new three.mesh(mygeometry, mymaterial1);\nmymesh1.translatex(20);\nmyscene.add(mymesh1);\n//根据普通贴图创建three.meshphongmaterial材质\nvar mymaterial2 = new three.meshphongmaterial();\nmymaterial2.map=mymap;\nvar mymesh2 = new three.mesh(mygeometry, mymaterial2);\nmymesh2.translatex(-20);\nmyscene.add(mymesh2);\n//渲染两个立方体\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  myrenderer.render(myscene, mycamera);\n};\n\n\n\n\n\n# 009-添加马赛克效果\n\n<script src="threejs/pixelshader.js"><\/script>\n<script src="threejs/effectcomposer.js"><\/script>\n<script src="threejs/renderpass.js"><\/script>\n<script src="threejs/shaderpass.js"><\/script>\n\n\nvar myrenderer = new three.webglrenderer();              //创建渲染器\nvar mywidth = 480;                                      //设置窗口宽度\nvar myheight = 320;                                    //设置窗口高度\nmyrenderer.setsize(mywidth, myheight);                //设置渲染区域\nmyrenderer.setclearcolor("white", 1);                 //设置清空颜色\n$("#mycontainer").append(myrenderer.domelement);\nvar myscene = new three.scene();                          //创建场景\nvar mylight = new three.pointlight("red");           //创建红色光源\nmylight.position.set(400, 800, 300);                   //设置光源位置\nmyscene.add(mylight);                            //在场景中添加光源\nvar k = mywidth / myheight;                         //计算窗口宽高比\nvar s = 120;                              //三维场景显示范围控制系数\nvar mycamera = new three.orthographiccamera(-s * k,\n                                            s * k, s, -s, 1, 1000); //创建相机\nmycamera.position.set(400, 300, 200);                //设置相机位置\nmycamera.lookat(myscene.position);\nvar mygeometry = new three.boxgeometry(100, 100, 100); //创建立方体\nvar mymaterial =  new three.meshlambertmaterial({ color: 0xffbf00 }); //创建材质\nvar mymesh = new three.mesh(mygeometry, mymaterial);      //创建网格\nmyscene.add(mymesh);                      //在场景中添加网格(立方体)\n\n//在场景中实现后期特效(在所有图形上添加马赛克)\nvar myeffectcomposer = new three.effectcomposer(myrenderer);\nmyeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\nvar myshaderpass = new three.shaderpass(three.pixelshader);\nmyshaderpass.uniforms.resolution.value = new three.vector2(window.innerwidth, window.innerheight);\n\n//设置马赛克像素块大小\nmyshaderpass.uniforms.pixelsize.value = 6;\nmyeffectcomposer.addpass(myshaderpass);\n\n// myrenderer.render(myscene, mycamera);                  //渲染立方体\nanimate();\nfunction animate() {\n  myeffectcomposer.render();\n  requestanimationframe(animate);\n}\n\n//响应单击“添加马赛克特效”按钮\n$("#mybutton1").click(function () {\n  myeffectcomposer.addpass(myshaderpass);\n});\n//响应单击“保持原状”按钮\n$("#mybutton2").click(function () {\n  myeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\n});\n\n\n\n# 初始化效果\n\n\n\n\n# 马赛克效果\n\n\n\n\n# 010-添加小灰点特效\n\n<script src="threejs/dotscreenshader.js"><\/script>\n<script src="threejs/effectcomposer.js"><\/script>\n<script src="threejs/renderpass.js"><\/script>\n<script src="threejs/shaderpass.js"><\/script>\n\n\n//在场景中实现后期特效(在所有图形上添加小灰点)\nvar myeffectcomposer = new three.effectcomposer(myrenderer);\nmyeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\nvar myshaderpass = new three.shaderpass(three.dotscreenshader);\nmyshaderpass.uniforms[\'scale\'].value = 2;\nmyeffectcomposer.addpass(myshaderpass);\n//动态渲染在添加小灰点特效之后的球体和圆环结\nanimate();\nfunction animate() {\n  myeffectcomposer.render();\n  requestanimationframe(animate);\n}\n//响应单击“添加小灰点特效”按钮\n$("#mybutton1").click(function () {\n  myeffectcomposer.addpass(myshaderpass);\n});\n\n//响应单击“保持原状”按钮\n$("#mybutton2").click(function () {\n  myeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\n});\n\n\n\n# 初始化效果\n\n\n\n\n# 添加小灰点特效效果\n\n\n\n\n# 011-重影特效\n\n<script src="threejs/effectcomposer.js"><\/script>\n<script src="threejs/renderpass.js"><\/script>\n<script src="threejs/shaderpass.js"><\/script>\n<script src="threejs/rgbshiftshader.js"><\/script>\n\n\n//在场景中实现后期特效(添加重影特效)\nvar myeffectcomposer = new three.effectcomposer(myrenderer);\nmyeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\nvar myshaderpass = new three.shaderpass(three.rgbshiftshader);\nmyshaderpass.uniforms[\'amount\'].value = 0.005;\nmyeffectcomposer.addpass(myshaderpass);\n//渲染添加重影特效之后的图形\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  myeffectcomposer.render();\n}\n//响应单击“添加重影特效”按钮\n$("#mybutton1").click(function () {\n  myeffectcomposer.addpass(myshaderpass);\n});\n//响应单击“保持原状”按钮\n$("#mybutton2").click(function () {\n  myeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\n});\n\n\n\n\n\n# 012-水平镜像\n\n<script src="threejs/effectcomposer.js"><\/script>\n<script src="threejs/renderpass.js"><\/script>\n<script src="threejs/shaderpass.js"><\/script>\n<script src="threejs/mirrorshader.js"><\/script>\n\n\n// 需要移动下立方体的位置，让他不在对称线上\nmymesh.translatey(120);\nmymesh.translatex(200);\n。。。\n\n//在场景中实现后期特效(为所有图形添加水平镜像)\nvar myeffectcomposer = new three.effectcomposer(myrenderer);\nmyeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\nvar myshaderpass = new three.shaderpass(three.mirrorshader);\nmyeffectcomposer.addpass(myshaderpass);\n//动态渲染在添加水平镜像之后的物体\nanimate();\nfunction animate() {\n  myeffectcomposer.render();\n  requestanimationframe(animate);\n}\n//响应单击“添加水平镜像”按钮\n$("#mybutton1").click(function () {\n  myeffectcomposer.addpass(myshaderpass);\n});\n//响应单击“保持原状”按钮\n$("#mybutton2").click(function () {\n  myeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\n});\n\n\n\n\n\n# 013-垂直镜像\n\n<script src="threejs/effectcomposer.js"><\/script>\n<script src="threejs/renderpass.js"><\/script>\n<script src="threejs/shaderpass.js"><\/script>\n<script src="threejs/mirrorshader.js"><\/script>\n\n\n//在场景中实现后期特效(为所有图形添加垂直镜像)\nvar myeffectcomposer = new three.effectcomposer(myrenderer);\nmyeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\nvar myshaderpass = new three.shaderpass(three.mirrorshader);\nmyshaderpass.uniforms[\'side\'].value = 2;\nmyeffectcomposer.addpass(myshaderpass);\n//动态渲染在添加垂直镜像之后的球体和圆环结\nanimate();\nfunction animate() {\n  myeffectcomposer.render();\n  requestanimationframe(animate);\n}\n//响应单击“添加垂直镜像”按钮\n$("#mybutton1").click(function () {\n  myeffectcomposer.addpass(myshaderpass);\n});\n//响应单击“保持原状”按钮\n$("#mybutton2").click(function () {\n  myeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\n});\n\n\n\n\n\n# 014-更改饱和度\n\n<script src="threejs/effectcomposer.js"><\/script>\n<script src="threejs/renderpass.js"><\/script>\n<script src="threejs/shaderpass.js"><\/script>\n<script src="threejs/huesaturationshader.js"><\/script>\n\n\n//在场景中实现后期特效(改变饱和度)\nvar myeffectcomposer = new three.effectcomposer(myrenderer);\nmyeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\nvar myshaderpass = new three.shaderpass(three.huesaturationshader);\n//saturation取值范围：-1为最小值，灰色, 0为原状, 1是最大值\nmyshaderpass.uniforms[\'saturation\'].value = 0.69;\nmyeffectcomposer.addpass(myshaderpass);\n//渲染改变饱和度之后的立方体\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  myeffectcomposer.render();\n}\n//响应单击“改变饱和度”按钮\n$("#mybutton1").click(function () {\n  myeffectcomposer.addpass(myshaderpass);\n});\n//响应单击“保持原状”按钮\n$("#mybutton2").click(function () {\n  myeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\n});\n\n\n\n# 初始效果\n\n\n\n\n# 更改饱和度\n\n\n\n\n# 015-更改色调\n\n<script src="threejs/effectcomposer.js"><\/script>\n<script src="threejs/renderpass.js"><\/script>\n<script src="threejs/shaderpass.js"><\/script>\n<script src="threejs/huesaturationshader.js"><\/script>\n\n\n//在场景中实现后期特效(改变色调)\nvar myeffectcomposer = new three.effectcomposer(myrenderer);\nmyeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\nvar myshaderpass = new three.shaderpass(three.huesaturationshader);\nmyshaderpass.uniforms[\'hue\'].value = 0.5;\nmyeffectcomposer.addpass(myshaderpass);\n//渲染改变色调之后的立方体\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  myeffectcomposer.render();\n}\n//响应单击“改变色调”按钮\n$("#mybutton1").click(function () {\n  myeffectcomposer.addpass(myshaderpass);\n});\n//响应单击“保持原状”按钮\n$("#mybutton2").click(function () {\n  myeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\n});\n\n\n\n\n\n# 016-拖尾效果\n\n<script src="threejs/effectcomposer.js"><\/script>\n<script src="threejs/renderpass.js"><\/script>\n<script src="threejs/shaderpass.js"><\/script>\n<script src="threejs/afterimagepass.js"><\/script>\n<script src="threejs/afterimageshader.js"><\/script>\n\n\n//在场景中实现后期特效(在转动(动态)的立方体上添加彗星拖尾特效)\nvar myeffectcomposer = new three.effectcomposer(myrenderer);\nmyeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\nmyeffectcomposer.addpass(new three.afterimagepass());\n//动态渲染旋转立方体的彗星拖尾特效\nanimate();\nfunction animate() {\n  mymesh.rotation.x += 0.03;\n  mymesh.rotation.y += 0.03;\n  myeffectcomposer.render();\n  requestanimationframe(animate);\n}\n//响应单击“添加拖尾特效”按钮\n$("#mybutton1").click(function () {\n  myeffectcomposer.addpass(new three.afterimagepass());\n});\n//响应单击“保持原状”按钮\n$("#mybutton2").click(function () {\n  myeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\n});\n\n\n\n\n\n# 017-泛光特效\n\n<script src="threejs/effectcomposer.js"><\/script>\n<script src="threejs/copyshader.js"><\/script>\n<script src="threejs/renderpass.js"><\/script>\n<script src="threejs/shaderpass.js"><\/script>\n<script src="threejs/bloompass.js"><\/script>\n<script src="threejs/convolutionshader.js"><\/script>\n\n\n//设置背景需要为黑色\nmyrenderer.setclearcolor("black", 1);                 \n\n//在场景中实现后期特效（添加泛光特效）\nvar myeffectcomposer = new three.effectcomposer(myrenderer);\nmyeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\nmyeffectcomposer.addpass(new three.bloompass(3, 17, 2.0, 256));\nmyeffectcomposer.addpass(new three.shaderpass(three.copyshader));\n//渲染添加泛光特效之后的立方体\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  myeffectcomposer.render();\n}\n//响应单击“添加泛光特效”按钮\n$("#mybutton1").click(function () {\n  myeffectcomposer.addpass(new three.bloompass(3, 17, 2.0, 256));\n  myeffectcomposer.addpass(new three.shaderpass(three.copyshader));\n});\n//响应单击“保持原状”按钮\n$("#mybutton2").click(function () {\n  myeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\n});\n\n\n\n\n\n# 018-老电影雪花扫描线特效\n\n<script src="threejs/effectcomposer.js"><\/script>\n<script src="threejs/renderpass.js"><\/script>\n<script src="threejs/shaderpass.js"><\/script>\n<script src="threejs/filmpass.js"><\/script>\n<script src="threejs/filmshader.js"><\/script>\n\n\n//在场景中实现后期特效(在立方体上添加老电影雪花扫描线特效)\nvar myeffectcomposer = new three.effectcomposer(myrenderer);\nmyeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\nmyeffectcomposer.addpass(new three.filmpass(3.1, 0.325, 256, true));\n//动态渲染在添加老电影雪花扫描线特效之后的立方体\nanimate();\nfunction animate() {\n  myeffectcomposer.render();\n  requestanimationframe(animate);\n}\n//响应单击“添加老电影特效”按钮\n$("#mybutton1").click(function () {\n  myeffectcomposer.addpass(new three.filmpass(3.1, 0.325, 256, true));\n});\n//响应单击“保持原状”按钮\n$("#mybutton2").click(function () {\n  myeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\n});\n\n\n\n\n\n# 019-怀旧特效\n\n<script src="threejs/effectcomposer.js"><\/script>\n<script src="threejs/renderpass.js"><\/script>\n<script src="threejs/shaderpass.js"><\/script>\n<script src="threejs/sepiashader.js"><\/script>\n\n\n//在场景中实现后期特效(添加怀旧特效)\nvar myeffectcomposer = new three.effectcomposer(myrenderer);\nmyeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\nvar myshaderpass = new three.shaderpass(three.sepiashader);\nmyshaderpass.uniforms[\'amount\'].value = 1.7;\nmyeffectcomposer.addpass(myshaderpass);\n//渲染添加怀旧特效之后的立方体\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  myeffectcomposer.render();\n}\n//响应单击“添加怀旧特效”按钮\n$("#mybutton1").click(function () {\n  myeffectcomposer.addpass(myshaderpass);\n});\n//响应单击“保持原状”按钮\n$("#mybutton2").click(function () {\n  myeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\n});\n\n\n\n\n\n# 020-不同颜色过滤立方体\n\n<script src="threejs/effectcomposer.js"><\/script>\n<script src="threejs/renderpass.js"><\/script>\n<script src="threejs/shaderpass.js"><\/script>\n<script src="threejs/colorifyshader.js"><\/script>\n<script src="threejs/orbitcontrols.js"><\/script>\n\n\n//在场景中实现后期特效(使用不同颜色过滤立方体)\nvar myeffectcomposer = new three.effectcomposer(myrenderer);\nmyeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\nvar myshaderpass = new three.shaderpass(three.colorifyshader);\nmyshaderpass.uniforms[\'color\'].value.setrgb(0, 1, 0);\nmyeffectcomposer.addpass(myshaderpass);\n//渲染使用不同颜色过滤的立方体\nanimate();\nfunction animate() {\n  myeffectcomposer.render();\n  requestanimationframe(animate);\n}\n//创建轨道控制器(旋转、缩放图形)\nvar myorbitcontrols = new three.orbitcontrols(mycamera);\n//响应单击“使用红色过滤图形”按钮\n$("#mybutton1").click(function () {\n  myshaderpass.uniforms[\'color\'].value.setrgb(1, 0, 0);\n});\n//响应单击“使用绿色过滤图形”按钮\n$("#mybutton2").click(function () {\n  myshaderpass.uniforms[\'color\'].value.setrgb(0, 1, 0);\n});\n//响应单击“使用蓝色过滤图形”按钮\n$("#mybutton3").click(function () {\n  myshaderpass.uniforms[\'color\'].value.setrgb(0, 0, 1);\n});\n\n\n\n\n\n# 021-飘白特效\n\n<script src="threejs/effectcomposer.js"><\/script>\n<script src="threejs/renderpass.js"><\/script>\n<script src="threejs/shaderpass.js"><\/script>\n<script src="threejs/bleachbypassshader.js"><\/script>\n<script src="threejs/orbitcontrols.js"><\/script>\n\n\n//在场景中实现后期特效(为立方体添加飘白特效)\nvar myeffectcomposer = new three.effectcomposer(myrenderer);\nmyeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\nvar myshaderpass = new three.shaderpass(three.bleachbypassshader);\nmyshaderpass.uniforms[\'opacity\'].value = 2.9;\nmyeffectcomposer.addpass(myshaderpass);\n//渲染经过漂白的立方体\nanimate();\nfunction animate() {\n  myeffectcomposer.render();\n  requestanimationframe(animate);\n}\n//创建轨道控制器(旋转、缩放图形)\nvar myorbitcontrols = new three.orbitcontrols(mycamera);\n//响应单击“轻微漂白图形”按钮\n$("#mybutton1").click(function () {\n  myshaderpass.uniforms[\'opacity\'].value = 2.9;\n});\n//响应单击“强力漂白图形”按钮\n$("#mybutton2").click(function () {\n  myshaderpass.uniforms[\'opacity\'].value = 100.9;\n});\n\n\n\n# 轻微漂白图形\n\n\n\n\n# 强力漂白图形\n\n\n\n\n# 022-电脉冲花屏特效\n\n<script src="threejs/effectcomposer.js"><\/script>\n<script src="threejs/renderpass.js"><\/script>\n<script src="threejs/shaderpass.js"><\/script>\n<script src="threejs/glitchpass.js"><\/script>\n<script src="threejs/digitalglitch.js"><\/script>\n<script src="threejs/copyshader.js"><\/script>\n<script src="threejs/orbitcontrols.js"><\/script>\n\n\n//在场景中实现后期特效(在立方体上产生电脉冲花屏特效)\nvar myeffectcomposer = new three.effectcomposer(myrenderer);\nmyeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\nmyeffectcomposer.addpass(new three.glitchpass());\n//动态渲染在添加电脉冲特效之后的立方体\nanimate();\nfunction animate() {\n  myeffectcomposer.render();\n  requestanimationframe(animate);\n}\n//响应单击“添加电脉冲特效”按钮\n$("#mybutton1").click(function () {\n  myeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\n  myeffectcomposer.addpass(new three.glitchpass());\n});\n//响应单击“保持原状”按钮\n$("#mybutton2").click(function () {\n  myeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\n});\n\n\n\n\n\n# 023-模糊立方体\n\n <script src="threejs/effectcomposer.js"><\/script>\n    <script src="threejs/shaderpass.js"><\/script>\n    <script src="threejs/renderpass.js"><\/script>\n    <script src="threejs/horizontalblurshader.js"><\/script>\n    <script src="threejs/verticalblurshader.js"><\/script>\n\n\n//在场景中实现后期特效(模糊立方体)\nvar myhorizontalblurshader = new three.shaderpass(three.horizontalblurshader);\nmyhorizontalblurshader.enabled = false;\nmyhorizontalblurshader.uniforms.h.value = 1 / (window.innerheight * 0.8);\nvar myverticalblurshader = new three.shaderpass(three.verticalblurshader);\nmyverticalblurshader.enabled = false;\nmyverticalblurshader.uniforms.v.value = 1 / (window.innerwidth * 0.3);\nvar myrenderpass = new three.renderpass(myscene, mycamera);\nvar myeffectcomposer = new three.effectcomposer(myrenderer);\nmyeffectcomposer.addpass(myrenderpass);\nmyeffectcomposer.addpass(myhorizontalblurshader);\nmyeffectcomposer.addpass(myverticalblurshader);\n//渲染模糊之后的立方体\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  myeffectcomposer.render();\n}\n//响应单击“在水平方向模糊图形”按钮\n$("#mybutton1").click(function () {\n  myhorizontalblurshader.enabled = true;\n});\n//响应单击“在垂直方向模糊图形”按钮\n$("#mybutton2").click(function () {\n  myverticalblurshader.enabled = true;\n});\n\n\n\n# 在水平方向模糊图形\n\n\n\n\n# 在垂直方向模糊图形\n\n\n\n\n# 024-三角形模糊特效\n\n<script src="threejs/effectcomposer.js"><\/script>\n<script src="threejs/shaderpass.js"><\/script>\n<script src="threejs/renderpass.js"><\/script>\n<script src="threejs/triangleblurshader.js"><\/script>\n\n\n//在立方体上添加三角形模糊特效\nvar mytriangleblurpass =\n    new three.shaderpass(three.triangleblurshader, \'texture\');\nmytriangleblurpass.enabled = false;\nmytriangleblurpass.uniforms.delta.value = new three.vector2(0.05, 0.05);\nvar myrenderpass = new three.renderpass(myscene, mycamera);\nvar myeffectcomposer = new three.effectcomposer(myrenderer);\nmyeffectcomposer.addpass(myrenderpass);\nmyeffectcomposer.addpass(mytriangleblurpass);\n//渲染在立方体上的三角形模糊特效\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  myeffectcomposer.render();\n}\n//响应单击“在图形上添加三角形模糊特效”按钮\n$("#mybutton1").click(function () {\n  mytriangleblurpass.enabled = true;\n});\n//响应单击“取消图形的三角形模糊特效”按钮\n$("#mybutton2").click(function () {\n  mytriangleblurpass.enabled = false;\n});\n\n\n\n# 025-增大亮度\n\n<script src="threejs/effectcomposer.js"><\/script>\n<script src="threejs/renderpass.js"><\/script>\n<script src="threejs/shaderpass.js"><\/script>\n<script src="threejs/copyshader.js"><\/script>\n<script src="threejs/brightnesscontrastshader.js"><\/script>\n\n\n//在场景中实现后期特效(改变所有图形亮度)\nvar myeffectcomposer = new three.effectcomposer(myrenderer);\nmyeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\nvar myshaderpass = new three.shaderpass(three.brightnesscontrastshader);\nmyshaderpass.uniforms[\'brightness\'].value = 0;\nmyeffectcomposer.addpass(myshaderpass);\n//渲染亮度改变之后的图形\nrender();\nfunction render() {\n  requestanimationframe(render);\n  myeffectcomposer.render();\n}\n//响应单击“增大亮度”按钮\n$("#mybutton1").click(function () {\n  myshaderpass.uniforms[\'brightness\'].value = 0.5;\n});\n//响应单击“保持原状”按钮\n$("#mybutton2").click(function () {\n  myshaderpass.uniforms[\'brightness\'].value = 0;\n});\n\n\n\n\n\n# 026-增大对比度\n\n<script src="threejs/effectcomposer.js"><\/script>\n<script src="threejs/renderpass.js"><\/script>\n<script src="threejs/shaderpass.js"><\/script>\n<script src="threejs/copyshader.js"><\/script>\n<script src="threejs/brightnesscontrastshader.js"><\/script>\n\n\n//在场景中实现后期特效(改变所有图形的对比度)\nvar myeffectcomposer = new three.effectcomposer(myrenderer);\nmyeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\nvar myshaderpass = new three.shaderpass(three.brightnesscontrastshader);\nmyshaderpass.uniforms[\'contrast\'].value = 0;\nmyeffectcomposer.addpass(myshaderpass);\n//渲染对比度改变之后的立方体\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  myeffectcomposer.render();\n}\n//响应单击“增大对比度”按钮\n$("#mybutton1").click(function () {\n  myshaderpass.uniforms[\'contrast\'].value = 0.5;\n});\n//响应单击“保持原状”按钮\n$("#mybutton2").click(function () {\n  myshaderpass.uniforms[\'contrast\'].value = 0;\n});\n\n\n\n\n\n# 027-gamma校正\n\n<script src="threejs/effectcomposer.js"><\/script>\n<script src="threejs/renderpass.js"><\/script>\n<script src="threejs/shaderpass.js"><\/script>\n<script src="threejs/gammacorrectionshader.js"><\/script>\n\n\n//在场景中实现后期特效(对所有图形进行gamma校正)\nvar myeffectcomposer = new three.effectcomposer(myrenderer);\nmyeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\nvar myshaderpass = new three.shaderpass(three.gammacorrectionshader);\n//渲染gamma校正之后的立方体\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  myeffectcomposer.render();\n}\n//响应单击“gamma校正”按钮\n$("#mybutton1").click(function () {\n  myeffectcomposer.addpass(myshaderpass);\n});\n//响应单击“保持原状”按钮\n$("#mybutton2").click(function () {\n  myeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\n});\n\n\n\n\n\n# 028-改变光亮\n\n<script src="threejs/effectcomposer.js"><\/script>\n<script src="threejs/renderpass.js"><\/script>\n<script src="threejs/shaderpass.js"><\/script>\n<script src="threejs/luminosityshader.js"><\/script>\n\n\n//在场景中实现后期特效(改变所有图形的光亮)\nvar myeffectcomposer = new three.effectcomposer(myrenderer);\nmyeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\nvar myshaderpass = new three.shaderpass(three.luminosityshader);\nmyeffectcomposer.addpass(myshaderpass);\n//渲染光亮改变之后的立方体\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  myeffectcomposer.render();\n}\n//响应单击“改变光亮”按钮\n$("#mybutton1").click(function () {\n  myeffectcomposer.addpass(myshaderpass);\n});\n//响应单击“保持原状”按钮\n$("#mybutton2").click(function () {\n  myeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\n});\n\n\n\n\n\n# 029-检测边缘\n\n<script src="threejs/effectcomposer.js"><\/script>\n<script src="threejs/renderpass.js"><\/script>\n<script src="threejs/shaderpass.js"><\/script>\n<script src="threejs/sobeloperatorshader.js"><\/script>\n\n\n//在场景中实现后期特效(使用sobel算子检测图形图像的轮廓边缘)\nvar myeffectcomposer = new three.effectcomposer(myrenderer);\nmyeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\nvar myshaderpass = new three.shaderpass(three.sobeloperatorshader);\nmyshaderpass.uniforms[\'resolution\'].value =\n  new three.vector2(window.innerwidth, window.innerheight);\nmyeffectcomposer.addpass(myshaderpass);\n//渲染立方体(图形图像)边缘\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  myeffectcomposer.render();\n}\n//响应单击“检测边缘”按钮\n$("#mybutton1").click(function () {\n  myeffectcomposer.addpass(myshaderpass);\n});\n//响应单击“保持原状”按钮\n$("#mybutton2").click(function () {\n  myeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\n});\n\n\n\n\n\n# 030-添加光晕\n\n<script src="threejs/effectcomposer.js"><\/script>\n<script src="threejs/renderpass.js"><\/script>\n<script src="threejs/shaderpass.js"><\/script>\n<script src="threejs/vignetteshader.js"><\/script>\n\n\n//在场景中实现后期特效(在球体周围添加光晕特效)\nvar myeffectcomposer = new three.effectcomposer(myrenderer);\nmyeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\nvar myshaderpass = new three.shaderpass(three.vignetteshader);\nmyshaderpass.uniforms[\'darkness\'].value = 4;\nmyshaderpass.uniforms[\'offset\'].value = 1;\nmyeffectcomposer.addpass(myshaderpass);\n//渲染添加光晕之后的球体\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  myeffectcomposer.render();\n}\n//响应单击“添加光晕”按钮\n$("#mybutton1").click(function () {\n  myeffectcomposer.addpass(myshaderpass);\n});\n//响应单击“保持原状”按钮\n$("#mybutton2").click(function () {\n  myeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\n});\n\n\n\n\n\n# 031-校正颜色\n\n<script src="threejs/effectcomposer.js"><\/script>\n<script src="threejs/renderpass.js"><\/script>\n<script src="threejs/shaderpass.js"><\/script>\n<script src="threejs/colorcorrectionshader.js"><\/script>\n\n\n//在场景中实现后期特效(校正图形图像的颜色)\nvar myeffectcomposer = new three.effectcomposer(myrenderer);\nmyeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\nvar myshaderpass = new three.shaderpass(three.colorcorrectionshader);\nmyshaderpass.uniforms[\'powrgb\'].value = new three.vector3(2, 2, 2);\n//myshaderpass.uniforms[\'mulrgb\'].value=new three.vector3( 1, 1, 1 );\n// myshaderpass.uniforms[\'addrgb\'].value=new three.vector3( 0, 0, 0 );\nmyeffectcomposer.addpass(myshaderpass);\n//渲染在校正颜色之后的立方体\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  myeffectcomposer.render();\n}\n//响应单击“校正颜色”按钮\n$("#mybutton1").click(function () {\n  myeffectcomposer.addpass(myshaderpass);\n});\n//响应单击“保持原状”按钮\n$("#mybutton2").click(function () {\n  myeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\n});\n\n\n\n\n\n# 032-变换为万花筒\n\n<script src="threejs/effectcomposer.js"><\/script>\n<script src="threejs/renderpass.js"><\/script>\n<script src="threejs/shaderpass.js"><\/script>\n<script src="threejs/kaleidoshader.js"><\/script>\n\n\n//在场景中实现后期特效(变换为万花筒)\nvar myeffectcomposer = new three.effectcomposer(myrenderer);\nmyeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\nvar myshaderpass = new three.shaderpass(three.kaleidoshader);\nmyshaderpass.uniforms[\'sides\'].value = 8;\nmyshaderpass.uniforms[\'angle\'].value = 45;\nmyeffectcomposer.addpass(myshaderpass);\n//渲染改变之后的万花筒\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  myeffectcomposer.render();\n}\n//响应单击“变换为万花筒”按钮\n$("#mybutton1").click(function () {\n  myeffectcomposer.addpass(myshaderpass);\n});\n//响应单击“保持原状”按钮\n$("#mybutton2").click(function () {\n  myeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\n});\n\n\n\n\n\n# 033-添加特艺彩色\n\n<script src="threejs/effectcomposer.js"><\/script>\n<script src="threejs/renderpass.js"><\/script>\n<script src="threejs/shaderpass.js"><\/script>\n<script src="threejs/technicolorshader.js"><\/script>\n\n\n//在场景中实现后期特效(添加特艺彩色)\nvar myeffectcomposer = new three.effectcomposer(myrenderer);\nmyeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\nvar myshaderpass = new three.shaderpass(three.technicolorshader);\nmyeffectcomposer.addpass(myshaderpass);\n//渲染添加特艺彩色之后的立方体\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  myeffectcomposer.render();\n}\n//响应单击“添加特艺彩色”按钮\n$("#mybutton1").click(function () {\n  myeffectcomposer.addpass(myshaderpass);\n});\n//响应单击“保持原状”按钮\n$("#mybutton2").click(function () {\n  myeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\n});\n\n\n\n\n\n# 034-水平移轴特效\n\n<script src="threejs/effectcomposer.js"><\/script>\n<script src="threejs/renderpass.js"><\/script>\n<script src="threejs/shaderpass.js"><\/script>\n<script src="threejs/horizontaltiltshiftshader.js"><\/script>\n\n\n//在场景中实现后期特效(添加水平移轴特效)\nvar myeffectcomposer = new three.effectcomposer(myrenderer);\nmyeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\nvar myshaderpass = new three.shaderpass(three.horizontaltiltshiftshader);\nmyshaderpass.uniforms[\'h\'].value = 0.5;\nmyshaderpass.uniforms[\'r\'].value = 0.1;\nmyeffectcomposer.addpass(myshaderpass);\n//渲染添加水平移轴特效之后的立方体\nrender();\nfunction render() {\n  requestanimationframe(render);\n  myeffectcomposer.render();\n}\n//响应单击“添加水平移轴特效”按钮\n$("#mybutton1").click(function () {\n  myeffectcomposer.addpass(myshaderpass);\n});\n//响应单击“保持原状”按钮\n$("#mybutton2").click(function () {\n  myeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\n});\n\n\n\n\n\n# 035-垂直移轴特效\n\n<script src="threejs/effectcomposer.js"><\/script>\n<script src="threejs/renderpass.js"><\/script>\n<script src="threejs/shaderpass.js"><\/script>\n<script src="threejs/verticaltiltshiftshader.js"><\/script>\n\n\n//在场景中实现后期特效(添加垂直移轴特效)\nvar myeffectcomposer = new three.effectcomposer(myrenderer);\nmyeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\nvar myshaderpass = new three.shaderpass(three.verticaltiltshiftshader);\nmyshaderpass.uniforms[\'v\'].value = 0.5;\nmyshaderpass.uniforms[\'r\'].value = 0.35;\nmyeffectcomposer.addpass(myshaderpass);\n//渲染添加垂直移轴特效之后的立方体\nrender();\nfunction render() {\n  requestanimationframe(render);\n  myeffectcomposer.render();\n}\n//响应单击“添加垂直移轴特效”按钮\n$("#mybutton1").click(function () {\n  myeffectcomposer.addpass(myshaderpass);\n});\n//响应单击“保持原状”按钮\n$("#mybutton2").click(function () {\n  myeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\n});\n\n\n\n\n\n# 036-聚焦特效\n\n<script src="threejs/effectcomposer.js"><\/script>\n<script src="threejs/renderpass.js"><\/script>\n<script src="threejs/shaderpass.js"><\/script>\n<script src="threejs/focusshader.js"><\/script>\n\n\n//在场景中实现后期特效(添加聚焦特效)\nvar myeffectcomposer = new three.effectcomposer(myrenderer);\nmyeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\nvar myshaderpass = new three.shaderpass(three.focusshader);\nmyshaderpass.uniforms[\'screenwidth\'].value = window.innerwidth;\nmyshaderpass.uniforms[\'screenheight\'].value = window.innerheight;\nmyshaderpass.uniforms[\'sampledistance\'].value = 0.000094;\nmyshaderpass.uniforms[\'wavefactor\'].value = 0.00125;\nmyeffectcomposer.addpass(myshaderpass);\n//渲染添加聚焦特效之后的球体\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  myeffectcomposer.render();\n}\n//响应单击“添加聚焦特效”按钮\n$("#mybutton1").click(function () {\n  myeffectcomposer.addpass(myshaderpass);\n});\n//响应单击“保持原状”按钮\n$("#mybutton2").click(function () {\n  myeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\n});\n\n\n\n\n\n# 037-检测边缘\n\n<script src="threejs/freichenshader.js"><\/script>\n<script src="threejs/effectcomposer.js"><\/script>\n<script src="threejs/renderpass.js"><\/script>\n<script src="threejs/shaderpass.js"><\/script>\n\n\n//在场景中实现后期特效(检测边缘)\nvar myeffectcomposer = new three.effectcomposer(myrenderer);\nmyeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\nvar myshaderpass = new three.shaderpass(three.freichenshader);\nmyshaderpass.uniforms[\'aspect\'].value =\n  new three.vector2(window.innerwidth, window.innerheight);\nmyeffectcomposer.addpass(myshaderpass);\n//渲染检测边缘之后的立方体(图形图像)\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  myeffectcomposer.render();\n}\n//响应单击“检测边缘”按钮\n$("#mybutton1").click(function () {\n  myeffectcomposer.addpass(myshaderpass);\n});\n//响应单击“保持原状”按钮\n$("#mybutton2").click(function () {\n  myeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\n});\n\n\n\n\n\n# 038-锯齿特效\n\n<script src="threejs/effectcomposer.js"><\/script>\n<script src="threejs/renderpass.js"><\/script>\n<script src="threejs/shaderpass.js"><\/script>\n<script src="threejs/fxaashader.js"><\/script>\n\n\n//在场景中实现后期特效(添加锯齿特效)\nvar myeffectcomposer = new three.effectcomposer(myrenderer);\nmyeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\nvar myshaderpass = new three.shaderpass(three.fxaashader);\nmyshaderpass.uniforms[\'resolution\'].value = new three.vector2(1 / 64, 1 / 64);\nmyeffectcomposer.addpass(myshaderpass);\n//渲染在添加锯齿特效之后的立方体\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  myeffectcomposer.render();\n}\n//响应单击“添加锯齿特效”按钮\n$("#mybutton1").click(function () {\n  myeffectcomposer.addpass(myshaderpass);\n});\n//响应单击“保持原状”按钮\n$("#mybutton2").click(function () {\n  myeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\n});\n\n\n\n\n\n# 039-轮廓边线\n\n <script src="threejs/copyshader.js"><\/script>\n    <script src="threejs/effectcomposer.js"> <\/script>\n    <script src="threejs/renderpass.js"><\/script>\n    <script src="threejs/shaderpass.js"><\/script>\n    <script src="threejs/outlinepass.js"><\/script>\n\n\n //在场景中实现后期特效(添加轮廓边线)\n       var myeffectcomposer = new three.effectcomposer(myrenderer);\n        myeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\n        var myoutlinepass = new three.outlinepass(new three.vector2(window.innerwidth,\n            window.innerheight), myscene, mycamera, [mymesh]);\n        myeffectcomposer.addpass(myoutlinepass);\n        //动态渲染在添加轮廓边线之后的图形\n        var isoutline = true;\n        function animate() {\n            requestanimationframe(animate);\n            if (isoutline) myeffectcomposer.render();\n            else myrenderer.render(myscene, mycamera);\n        }\n        animate();\n        //响应单击“添加轮廓边线”按钮\n        $("#mybutton1").click(function () {\n            isoutline = true;\n        });\n        //响应单击“保持原状”按钮\n        $("#mybutton2").click(function () {\n            isoutline = false;\n        });\n\n\n\n\n\n# 040-辉光特效\n\n<script src="threejs/effectcomposer.js"><\/script>\n    <script src="threejs/renderpass.js"><\/script>\n    <script src="threejs/shaderpass.js"><\/script>\n    <script src="threejs/copyshader.js"><\/script>\n    <script src="threejs/unrealbloompass.js"><\/script>\n    <script src="threejs/luminosityhighpassshader.js"><\/script>\n\n\n//在场景中实现后期特效(添加辉光特效)\nvar myeffectcomposer = new three.effectcomposer(myrenderer);\nmyeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\nvar myunrealbloompass = new three.unrealbloompass(\n  new three.vector2(window.innerwidth, window.innerheight), 1.5, 0.4, 0.6);\nmyeffectcomposer.addpass(myunrealbloompass);\n//渲染在添加辉光特效之后的立方体\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  myeffectcomposer.render();\n}\n//响应单击“添加辉光特效”按钮\n$("#mybutton1").click(function () {\n  myeffectcomposer.addpass(myunrealbloompass);\n});\n//响应单击“保持原状”按钮\n$("#mybutton2").click(function () {\n  myeffectcomposer.addpass(new three.renderpass(myscene, mycamera));\n});\n\n\n\n\n\n# 041-虚线边框\n\n//渲染立方体及其虚线边框\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  myrenderer.render(myscene, mycamera);\n}\n//响应单击“添加虚线边框”按钮\n$("#mybutton1").click(function () {\n  var myedgegeometry = new three.edgesgeometry(mygeometry);\n  var myedgematerial =\n      new three.linedashedmaterial({ color: 0x000000, dashsize: 6 });\n  var mylinesegments = new three.linesegments(myedgegeometry, myedgematerial);\n  mylinesegments.computelinedistances();\n  mylinesegments.name = \'myline\';\n  myscene.add(mylinesegments);\n});\n//响应单击“移除虚线边框”按钮\n$("#mybutton2").click(function () {\n  myscene.remove(myscene.getobjectbyname(\'myline\'));\n});\n\n\n\n\n\n# 042-圆角立方体\n\n<script src="threejs/subdivisionmodifier.js"><\/script>\n\n\n//创建立方体\n// var mygeometry = new three.boxgeometry(100, 100, 100); \n//创建圆角立方体\nvar myboxgeometry = new three.boxgeometry(100, 100, 100, 2, 2, 2);\nvar mymodifier = new three.subdivisionmodifier(3);\nvar mygeometry = mymodifier.modify(myboxgeometry);\n// var mymaterial =  new three.meshlambertmaterial({ color: 0xffbf00 }); //创建材质\nvar mymap = three.imageutils.loadtexture("images/img073.jpg");\nvar mymaterial = new three.meshbasicmaterial({ map: mymap });\nvar mymesh = new three.mesh(mygeometry, mymaterial);      //创建网格\n// mymesh.translatey(50);\n// mymesh.translatex(200);\nmyscene.add(mymesh);                      //在场景中添加网格(立方体)\n//渲染立方体\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  myrenderer.render(myscene, mycamera);\n}\n//响应单击“启用圆角效果”按钮\n$("#mybutton1").click(function () {\n  var mygeometry = new three.boxgeometry(100, 100, 100, 2, 2, 2);\n  mymesh.geometry = mymodifier.modify(mygeometry);\n});\n//响应单击“禁用圆角效果”按钮\n$("#mybutton2").click(function () {\n  mymesh.geometry = new three.boxgeometry(100, 100, 100, 2, 2, 2);\n});\n\n\n\n\n\n# 043-扁平化\n\nvar mygeometry = new three.spheregeometry(80, 30, 30);\n//创建法向量材质\nvar mymaterial = new three.meshnormalmaterial();\n//扁平化球面\nmymaterial.flatshading = true;\nvar mymesh = new three.mesh(mygeometry, mymaterial);\nmymesh.name = \'flatshadingtrue\';\nmyscene.add(mymesh);\n\n\n\n\n\n# 044-曲线拉伸的五角星\n\n<script src="threejs/trackballcontrols.js"><\/script>\n\n\nvar mytrackballcontrols =\n    new three.trackballcontrols(mycamera, myrenderer.domelement);\n//创建拉伸曲线\nvar myrandompoints = [];\nfor (var i = 0; i < 10; i++) {\n  myrandompoints.push(new three.vector3((i - 4.5) * 50,\n                                        three.mathutils.randfloat(-50, 50), three.mathutils.randfloat(-50, 50)));\n}\nvar myrandompath = new three.catmullromcurve3(myrandompoints);\nvar myextrudesettings = { steps: 600, extrudepath: myrandompath };\n//创建五角星\nvar mypoints = [], mycount = 5;\nfor (var i = 0; i < mycount * 2; i++) {\n  var l = i % 2 == 1 ? 20 : 40;\n  var a = i / mycount * math.pi;\n  mypoints.push(new three.vector2(math.cos(a) * l, math.sin(a) * l));\n}\nvar myshape = new three.shape(mypoints);\nvar mygeometry = new three.extrudegeometry(myshape, myextrudesettings);\nvar mymaterial = new three.meshlambertmaterial({ color: 0x00ff00 });\nvar mymesh = new three.mesh(mygeometry, mymaterial);\nmyscene.add(mymesh);\n//渲染沿着曲线拉伸的五角星\nanimate();\nfunction animate() {\n  requestanimationframe(animate);\n  mytrackballcontrols.update();\n  myrenderer.render(myscene, mycamera);\n}\n\n\n\n# 045-\n\n\n\n\n\n\n\n\n# 046-\n\n\n\n\n\n\n\n\n# 047-\n\n\n\n\n\n\n\n\n# 048-\n\n\n\n\n\n\n\n\n# 049-\n\n\n\n\n\n\n\n\n# 050-\n\n\n\n\n\n',charsets:{cjk:!0}},{title:"vue",frontmatter:{},regularPath:"/vue/",relativePath:"vue/README.md",key:"v-2f52b1d2",path:"/vue/",headers:[{level:2,title:"优化打包app.js",slug:"优化打包app-js",normalizedTitle:"优化打包app.js",charIndex:10},{level:3,title:"vue路由的懒加载",slug:"vue路由的懒加载",normalizedTitle:"vue路由的懒加载",charIndex:25},{level:3,title:"vue组件的按需加载（2种方式）",slug:"vue组件的按需加载-2种方式",normalizedTitle:"vue组件的按需加载（2种方式）",charIndex:2270},{level:2,title:"vue 中 v-show 和 v-if 的区别是什么？",slug:"vue-中-v-show-和-v-if-的区别是什么",normalizedTitle:"vue 中 v-show 和 v-if 的区别是什么？",charIndex:3321},{level:2,title:"v-if和v-for为什么不能连用？",slug:"v-if和v-for为什么不能连用",normalizedTitle:"v-if和v-for为什么不能连用？",charIndex:3569},{level:2,title:"keep-alive 组件有什么作用？",slug:"keep-alive-组件有什么作用",normalizedTitle:"keep-alive 组件有什么作用？",charIndex:3694},{level:2,title:"说下vue生命周期钩子函数?",slug:"说下vue生命周期钩子函数",normalizedTitle:"说下vue生命周期钩子函数?",charIndex:3927},{level:2,title:"Vue中computed和watch区别?",slug:"vue中computed和watch区别",normalizedTitle:"vue中computed和watch区别?",charIndex:4309},{level:2,title:"Vue3 中的数据响应式是怎么实现的？",slug:"vue3-中的数据响应式是怎么实现的",normalizedTitle:"vue3 中的数据响应式是怎么实现的？",charIndex:4431},{level:2,title:"v-model 该如何实现？",slug:"v-model-该如何实现",normalizedTitle:"v-model 该如何实现？",charIndex:4771},{level:2,title:"vue3中v-model的变化?",slug:"vue3中v-model的变化",normalizedTitle:"vue3中v-model的变化?",charIndex:5665},{level:3,title:"vue2中为什么检测不到数组的变化，如何解决?",slug:"vue2中为什么检测不到数组的变化-如何解决",normalizedTitle:"vue2中为什么检测不到数组的变化，如何解决?",charIndex:6228},{level:3,title:"请简述 Vue 中 Template 的实现思路？",slug:"请简述-vue-中-template-的实现思路",normalizedTitle:"请简述 vue 中 template 的实现思路？",charIndex:6353},{level:2,title:"Vue3 中 Teleport 的作用是什么",slug:"vue3-中-teleport-的作用是什么",normalizedTitle:"vue3 中 teleport 的作用是什么",charIndex:6610},{level:2,title:"虚拟 DOM 有什么作用，如何构建虚拟DOM？",slug:"虚拟-dom-有什么作用-如何构建虚拟dom",normalizedTitle:"虚拟 dom 有什么作用，如何构建虚拟dom？",charIndex:7689},{level:2,title:"如何把真实 dom 转变为虚拟 dom，代码实现一下？",slug:"如何把真实-dom-转变为虚拟-dom-代码实现一下",normalizedTitle:"如何把真实 dom 转变为虚拟 dom，代码实现一下？",charIndex:8309},{level:2,title:"说一下vue3的composition api?",slug:"说一下vue3的composition-api",normalizedTitle:"说一下vue3的composition api?",charIndex:9177},{level:2,title:"说一下 Vue3 与 Vue2 的对比？",slug:"说一下-vue3-与-vue2-的对比",normalizedTitle:"说一下 vue3 与 vue2 的对比？",charIndex:10542},{level:2,title:"为什么要使用模块化？模块化的常见规范有那几种，各有什么特点？",slug:"为什么要使用模块化-模块化的常见规范有那几种-各有什么特点",normalizedTitle:"为什么要使用模块化？模块化的常见规范有那几种，各有什么特点？",charIndex:11721},{level:2,title:"vue 中组件间有哪些通信方式?",slug:"vue-中组件间有哪些通信方式",normalizedTitle:"vue 中组件间有哪些通信方式?",charIndex:13267}],headersStr:"优化打包app.js vue路由的懒加载 vue组件的按需加载（2种方式） vue 中 v-show 和 v-if 的区别是什么？ v-if和v-for为什么不能连用？ keep-alive 组件有什么作用？ 说下vue生命周期钩子函数? Vue中computed和watch区别? Vue3 中的数据响应式是怎么实现的？ v-model 该如何实现？ vue3中v-model的变化? vue2中为什么检测不到数组的变化，如何解决? 请简述 Vue 中 Template 的实现思路？ Vue3 中 Teleport 的作用是什么 虚拟 DOM 有什么作用，如何构建虚拟DOM？ 如何把真实 dom 转变为虚拟 dom，代码实现一下？ 说一下vue3的composition api? 说一下 Vue3 与 Vue2 的对比？ 为什么要使用模块化？模块化的常见规范有那几种，各有什么特点？ vue 中组件间有哪些通信方式?",content:"# vue\n\n\n# 优化打包app.js\n\n\n# vue路由的懒加载\n\n# 方法一 resolve\n\n这一种方法较常见。它主要是使用了resolve的异步机制，用require代替了import,实现按需加载，下面是代码示例：\n\nimport Vue from 'vue'\nimport Router from 'vue-router'\n// import HelloWorld from '@/components/HelloWorld'\nVue.use(Router)\nexport default new Router({\n    routes: [\n        //     {\n        //       path: '/',\n        //       name: 'HelloWorld',\n        //       component: HelloWorld\n        //     }\n        {\n            path: '/',\n            name: 'HelloWorld',\n            component: resolve => require(['@/components/HelloWorld'], resolve)\n        }\n    ]\n})\n\n\n# 方法二 官网方法\n\nvue-router在官网提供了一种方法，可以理解也是为通过Promise的resolve机制。因为Promise函数返回的Promise为resolve组件本身，而我们又可以使用import来导入组件。整合起来代码示例如下：\n\nimport Vue from 'vue'\nimport Router from 'vue-router'\n// import HelloWorld from '@/components/HelloWorld'\nVue.use(Router)\nexport default new Router({\n    routes: [\n        //{\n        //\tpath: '/',\n        //\tname: 'HelloWorld',\n        //\tcomponent: HelloWorld\n        //}\n        {\n            path: '/',\n            name: 'HelloWorld',\n            component: () => import('@/components/HelloWorld.vue')\n        }\n    ]\n}) \n// -----------------------------------------------------\nimport Vue from 'vue'\nimport Router from 'vue-router'\n// import HelloWorld from '@/components/HelloWorld'\nconst HelloWorld = () => import('@/components/HelloWorld.vue')\nVue.use(Router)\nexport default new Router({\n    routes: [\n        //{\n        //\tpath: '/',\n        //\tname: 'HelloWorld',\n        //\tcomponent: HelloWorld\n        //}\n        {\n            path: '/',\n            name: 'HelloWorld',\n            component: HelloWorld\n        }\n    ]\n}) \n\n\n官网中还提供了通过注释语法来提供chunk name的方法，但是webpack的版本要高于2.4的版本。感兴趣的可以到官网了解一下。\n\n# 方法三 require.ensure\n\n这种模式可以通过参数中的webpackChunkName将js分开打包。\n\nimport Vue from 'vue'\nimport Router from 'vue-router'\n// import HelloWorld from '@/components/HelloWorld'\nVue.use(Router)\nexport default new Router({\n    routes: [\n        //{\n        //\tpath: '/',\n        //\tname: 'HelloWorld',\n        //\tcomponent: HelloWorld\n        //}\n        {\n            path: '/',\n            name: 'HelloWorld',\n            component: resolve => require.ensure([], () => resolve(require('@/components/'+componentName)), 'webpackChunkName')\n        }\n    ]\n})\n\n\n\n# vue组件的按需加载（2种方式）\n\n# 动态组件方式\n\n组件里面：\n\n<script>\n    export default {\n        components: {\n            aview: function(resolve) {\n                require([\"./a.vue\"], resolve);\n            },\n            bview: function(resolve) {\n                require([\"./b.vue\"], resolve);\n            }\n        }\n    }\n<\/script>\n\n\n模板里面：\n\n<component :is=\"current\" :data=\"myData\" ></component>\n<script>\n    export default {\n        data: function() {\n            return {\n                current: \"\",\n                myData:\"\",\n                show:false\n            }\n        },\n        methods: {\n            changeComponents:function(view) {\n                if(view=='aview') {\n                    this.myData='a1000';\n                } else {\n                    this.myData='b1000';\n                }\n                this.current=view;\n            }\n        }\n    }\n<\/script>\n\n\n# v-if方式(强制创建和结束生命周期)\n\n// 模板：\n<aview v-if=\"show\"></aview>\n// 组件：\n<script>\n    export default {\n        components: {\n            aview:require(\"./a.vue\")\n        }\n    }\n<\/script>\n\n\n\n# vue 中 v-show 和 v-if 的区别是什么？\n\nv-show 只是在 display: none 和 display: block 之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换 CSS，DOM 还是一直保留着的。v-if 的话就得说到 Vue 底层的编译了。当属性初始为 false 时，组件就不会被渲染，直到条件为 true，并且切换条件时会触发销毁/挂载组件，并且基于 v-if 的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。\n\n\n# v-if和v-for为什么不能连用？\n\nv-for比v-if优先，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候 。可以采取多层包裹来解决性能损耗问题。例如外层给标签绑定指令v-if或者是内层标签绑定v-if\n\n\n# keep-alive 组件有什么作用？\n\n如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。 对于 keep-alive 组件来说，它拥有两个独有的生命周期钩子函数，分别为 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。\n\n\n# 说下vue生命周期钩子函数?\n\n– beforeCreate :这个时期，this变量还不能使用，在data下的数据，和methods下的方法，watcher中的事件都不能获得到。\n\n– created这个时候可以操作vue实例中的数据和各种方法，但是还不能对\"dom\"节点进行操作。\n\n– beforeMounte：在挂载开始之前被调用：相关的 render 函数首次被调用\n\n– mounted：挂载完毕，这时dom节点被渲染到文档内，一些需要dom的操作在此时才能正常进行\n\n– beforeUpdate：data中数据已经更新完毕，页面视图还未响应更改\n\n– updated：数据和视图都更新完毕\n\n– beforeDestroy：销毁之前，实例上事件、指令等都可以使用，这里组件没有真正的销毁。\n\n– destroyed：数据、指令、等完全销毁\n\n\n# Vue中computed和watch区别?\n\ncomputed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容。 watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。\n\n\n# Vue3 中的数据响应式是怎么实现的？\n\nobserve(data) {\n    let _this = this;\n    this._data = new Proxy(data, {\n        set(target, prop, newValue) {\n            let event = new CustomEvent(prop, {\n                detail: newValue\n            });\n            _this.dispatchEvent(event);\n            return Reflect.set(...arguments);\n        }\n    });\n}\n\n\n\n# v-model 该如何实现？\n\nv-model本质上是v-on和v-bind的语法糖。v-model在内部为不同元素抛出不同的事件，如：\n\ntext 和 textarea 元素使用 value 属性和 input 事件；\n\ncheckbox 和 radio 使用 checked 属性和 change 事件；\n\nselect 字段将 value 作为 prop 并将 change 作为事件。 v-model作用在普通表单上<input v-model=\"myvalue\" /> // 等同于<input v-bind:value=\"myvalue\" v-on:input=\"myvalue=$event.target.value\"> v-model作用在组件上> 父组件v-model语法糖本质上可以修改为 '<child :value=\"message\" @input=\"function(e){message = e}\"></child>' 在组件的实现中，我们是可以通过 v-model属性 来配置子组件接收的prop名称，以及派发的事件名称。 例如：\n\n父组件>\n\n// html>\n<mycom v-model=\"myvalue\" ></mycom>>\n// 等同于>\n<mycom :value=\"myvalue\" @input=\"(e)=>{myvalue = e}\" ></mycom>\n// js\nnew Vue({ el: \"#app\", components:{ mycom }, data: { myvalue: \"123\" }})\n\n\n子组件\n\nlet mycom = { \n    props:['value'], \n    template:`<div><input :value=\"value\"  @input=\"fn\" /></div>`, \n    methods:{ \n        fn(e){ \n            this.$emit('input',e.target.value) \n        } \n    } \n}\n\n\n\n# vue3中v-model的变化?\n\nvue3取消了.sync修饰符的使用，直接使用v-model进行替换即可。\n\n对于自定义组件使用v-model时，prop与事件的默认名称变更，\n\n从vue2版本的value/@input变更为modelValue/@update:modelValue。\n\n修改model的名称从原来的model选项进行修改，变更为传递参数给model，写法为v-model:argument。\n\n使用v-model参数后会改变prop和事件名为argument/@update:argument。\n\n现在一个组件可以同时使用多个v-model进行绑定。并且在vue3中v-model支持自定义修饰符，他将会通过props中的modelModifiers属性接收。\n\n# 问题：是否还可以使用vue2版本的方式配置model名称？\n\n答：不可以，v-model参数是一个不向下兼容的改动，在vue3中修改model的名称就是通过v-model参数进行修改。\n\n# 问题：在同一个组件上绑定多个v-model时需不需要单独进行配置？\n\n答：绑定多个v-model的时候只要传参对model名称进行变更，每个v-model将会同步到不同的prop属性当中，所以并不需要在组件中添加额外的选项进行配置。\n\n\n# vue2中为什么检测不到数组的变化，如何解决?\n\n由于由JavaScript 的限制，Vue 不能检测数组变动。解决方案是通过全局Vue.set或者用实例方法vm.$set来修改。同样也可以通过变异方法splice来修改数组触发数据响应式。\n\n\n# 请简述 Vue 中 Template 的实现思路？\n\n * 第一步是将 模板字符串 转换成 element ASTs（解析器）(abstract syntax tree,抽象语法树）\n * 第二步是对 AST 进行静态节点标记，主要用来做虚拟DOM的渲染优化（优化器）\n * 第三步是 使用 element ASTs 生成 render 函数代码字符串（代码生成器）\n\n【讲师讲解视频地址】：https://pan.baidu.com/s/1LrQLRZDSMCi4GsHjtXq3kQ 提取码：0826\n\n\n# Vue3 中 Teleport 的作用是什么\n\n他的作用就是将一个嵌套在组件内部的某些内容可以渲染到当前组件外部。假设我们有一个modal组件，该组件分为触发modal打开的button以及模态框本体\n\n<div style=\"position: relative;\">\n    <button @click=\"modalOpen = true\"> Open full screen modal! </button>\n    <div v-if=\"modalOpen\" class=\"modal\">\n        <div> \n            I'm a modal! \n            <button @click=\"modalOpen = false\"> Close </button>\n        </div>\n    </div>\n</div>\n\n\n但我们需要给模态框position: absolute时，其会以其定位父级也就是含有相对定位的div进行偏移，同时将会受到其父级样式影响。此时我们就只能将组件拆分为两个组件或者用一个其他的全局状态进行控制。\n\n如果使用teleport就可以将modal渲染到body标签内，避免上述困扰\n\n<div style=\"position: relative;\">\n    <button @click=\"modalOpen = true\"> Open full screen modal! </button>\n    <telepot to=\"body\">\n        <div v-if=\"modalOpen\" class=\"modal\">\n            <div> I'm a modal!\n                <button @click=\"modalOpen = false\"> Close </button>\n            </div>\n        </div>\n    </telepot>\n</div>\n\n\n# 问题：teleport可以包含vue组件使用么？\n\n答：可以，当teleport包含的是vue组件时，只是将该组件渲染到对应的标签当中，他的props等依然是从该组件的父组件进行注入。\n\n# 问题：可以使用多个teleport指向同一标签么？\n\n答：可以的，就比如有一个复用的modal组件，他在多个地方被使用时会被指向相同标签比如body。这时将会按照顺序进行追加，后挂载的元素会在较早挂载元素之后的位置。\n\n\n# 虚拟 DOM 有什么作用，如何构建虚拟DOM？\n\nclass Vdom{\n    constructor(option){\n        this.tagName = option.tagName;\n        this.props = option.props || {};\n        this.children = option.children || '';\n    }\n    render(){\n        let el = document.createElement(this.tagName);\n        for(let propsKay in this.props){\n            el.setAttribute(propsKay,this.props[propsKay])\n        }\n        if(Array.isArray(this.children)){\n            this.children.forEach((item)=>{\n                el.appendChild(item.render());\n            })\n        }else{\n            el.innerText = this.children\n        }\n        return el;\n    }\n}\n\n\n\n# 如何把真实 dom 转变为虚拟 dom，代码实现一下？\n\nfunction vDom(node){\n    let nodeType = node.nodeType;\n    let _vnode = null;\n    if(nodeType === 1){//元素节点\n        let props = node.attributes;\n        console.log(props);\n        let property = {};\n        for(let i=0;i<props.length;i++){\n            property[props[i].name] = props[i].nodeValue;\n        }\n        _vnode = new VNode({\n            tagName:node.nodeName,\n            props:property,\n            type:nodeType\n        })\n        let children = node.childNodes;\n        for(let i=0;i<children.length;i++){\n            if(children[i].nodeType === 1 || children[i].length > 1){\n                _vnode.appendChild(vDom(children[i]))\n            }\n        }\n    }else if(nodeType === 3){\n        _vnode = new VNode({\n            type:nodeType,\n            value:node.nodeValue.trim()\n        })\n    }\n    return _vnode;\n}\n\n\n\n# 说一下vue3的composition api?\n\ncomposition api意为组合式api，其主要是代码组织结构上的变动。\n\nvue2版本的options api，通过一个配置集合将代码划分为多个部分，使得代码组织结构比较清晰，比如父组件直接传入的数据存放于props，方法存放于methods等，但是其代码逻辑复用方面一直表现得不是很友好。composition api就是用于解决该问题，在vue3当中新增加了一个生命周期函数为setup。setup将在创建组件之前被执行，一旦props被解析时，setup将服务于composition api充当入口点。\n\n从使用角度来讲composition api主要有以下几点与options api不同响应式数据声明改变，通过ref/reactive两个方法均可以声明响应式数据，但是两者使用方式略有不同。\n\nref所声明的响应式变量将会返回一个包含有value属性的对象，value的值就是该响应式变量所对应的值。所以在不论在获取还是改变ref声明的响应式变量时都需要通过.value进行操作。\n\nreactive返回的则是通过Proxy处理后的对象。使用生命周期函数时，变为从vue中引入对应生命周期函数例如onMounted，生命周期函数接受一个函数作为参数，该函数将会在对应生命周期阶段被执行。watch使用方式改变，watch作为函数接受至少两个参数，第一个参数为被watch的响应式数据，第二个参数为回调函数。当watch接受的响应式数据不同会有不同的使用方式，当watch的数据为通过ref声明的响应式变量时，watch直接接受ref响应式变量如watch(refValue)。\n\n当watch数据为通过reactive声明时，需要传入一个函数，该函数返回reactive变量如watch(() => reactiveValue.value)。同时新增watchEffect，他会收集内部依赖，当内部依赖发生改变时就会被执行。\n\nprops现在作为setup的第一个参数进行接收，使用props时可以通过vue暴露的toRefs方法将props上的属性转为独立的ref响应式变量，从而进行使用。在setup当中代码将可以根据功能进行组织并提取，这极大程度的解决了以往代码可读性较低以及逻辑服用难的缺点。\n\n# 问题：composition api是强制使用的么？我还可以在vue3中使用options api的方式进行开发么？\n\n答：composition api并不被强制使用，他只是在大型项目中对于代码复用以及逻辑提取上有很大的有点，并且他极大的提高了代码可读性。vue3是向下兼容的，在vue3当中依然可以通过options api进行开发。同时尤大本人曾在Vue Mastery上表示过，对于新手来讲，options api的学习可能对于上手vue来说更加快速。\n\n# 问题：我还可以在setup中通过this来使用实例上的属性么？\n\n答：不可以，因为setup执行是在组件创建之前，这时还并没有组件实例，所以在setup中并没有this，如果希望使用一些实例上的方法，可以通过getCurrentInstance方法先获取实例在进行操作。\n\n\n# 说一下 Vue3 与 Vue2 的对比？\n\n首先从性能层面讲，vue3不论是渲染速度或是打包速度均快于vue2，这里有以下几个原因数据劫持方式改变，\n\n原有通过Object.defineProperty进行的数据劫持改变为Proxy进行数据代理。\n\n由于Proxy可以动态判断该数据是否为深层嵌套数据，而Object.defineProperty为遍历全部深层嵌套数据，导致两者仅在数据劫持上就产生了极大的时间差距。\n\nvue3打包策略，vue3支持了tree-shaking，即排除任何未实际使用的代码，打包体积极大缩小。同时由于打包后体积缩小文件数量减少，页面加载文件所需时间也极大缩短。\n\ndiff优化，vue3中会对静态节点进行提升，所有静态节点(及不包含任何响应式数据及事件等)在进行比对时不会被遍历。这促使vue3在进行节点比对时所需的比对时间大幅减少。\n\n性能之后还有生命周期的改变，vue2中的beforeCreate与created被setup一个生命周期所替代，同时beforeDestroy与destroyed分别改名为beforeUnmount与unmounted。同时vue3当中的响应式数据声明也有所改变，但这主要体现与在setup中进行响应式数据的声明。\n\nvue3当中暴露了两个方法，分别是reactive与ref方法。他们均是用来声明响应式数据，只是对于不同情况有各自的有点。由上面一点可以引出vue3当中发生的最大改变 - composition api。vue3的代码组织有以前的options api切换到了composition api，这使得我们在处理大型项目时不会再像以前一样，一个功能的代码将被分割到data、computed、method等等当中，我们可以将相同功能代码提出进行封装，这极大提高了代码可读性。\n\n除此以外vue3中双向绑定也进行了修改。vue3中取消了v-bind的.sync修饰符，因为这更符合v-model的逻辑。v-model主要有以下两点不同：\n\n * 一个组件可以同时包含多个v-model，model名称的更改由之前的model选项变更为传递一个参数给model，传参方式为v-model:argument\n * 当v-model用于自定义组件时，prop与事件的默认名称由以前的value/@input变更为modelValue/@update:modelValue。\n\n如果使用了v-model参数改变了model名字，比如v-model:title，则对应prop与事件名称为title/@update:title。最后vue3对ts的支持程度也是vue2所不能达到的，例如vue3当中提供了一个defineComponent，他能为props提供完整的类型推断。\n\n\n# 为什么要使用模块化？模块化的常见规范有那几种，各有什么特点？\n\n在JavaScript发展初期就是为了实现简单的页面交互逻辑，寥寥数语即可；如今CPU、浏览器性能得到了极大的提升，很多页面逻辑迁移到了客户端（表单验证等），随着web2.0时代的到来，前端代码日益膨胀，此时在JS方面就会考虑使用模块化规范去管理。\n\n模块化的好处\n\n避免命名冲突(减少命名空间污染)更好的分离, 按需加载更高复用性高可维护性CommonJS· 所有代码都运行在模块作用域，不会污染全局作用域。\n\n模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。\n\n模块加载的顺序，按照其在代码中出现的顺序。\n\n基本语法\n\n暴露模块：module.exports = value或exports.xxx = value\n\n引入模块：require(xxx),如果是第三方模块，xxx为模块名；\n\n如果是自定义模块，xxx为模块文件路径AMDCommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。\n\nAMD规范则是非同步加载模块，允许指定回调函数。\n\n由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。\n\n但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。\n\n基本语法：\n\n暴露模块 define(['module1', 'module2'], function(m1, m2){ return 模块})\n\n引用模块 require(['module1', 'module2'], function(m1, m2){ 使用m1/m2})\n\nCMD\n\nCMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。在 Sea.js 中，所有 JavaScript 模块都遵循 CMD模块定义规范。\n\nES6\n\nES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，\n\nCommonJS 模块就是对象，输入时必须查找对象属性。\n\n定义模块\n\nvar basicNum = 0;\nvar add = function (a, b) {\n    return a + b;\n};\nexport { basicNum, add };\n\n\n引用模块\n\nimport { basicNum, add } from './math';\nfunction test(ele) {    \n    ele.textContent = add(99 + basicNum);\n}\n\n\nCommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD/CMD解决方案。\n\nAMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。\n\nCMD规范与AMD规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在Node.js中运行。不过，依赖SPM 打包，模块的加载逻辑偏重ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。\n\n\n# vue 中组件间有哪些通信方式?\n\n 1. props / $emit适用于父子组件通信这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。\n 2. ref 与 $parent / $children适用于父子组件通信ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例$parent / $children：访问父 / 子实例\n 3. EventBus （$emit / $on）适用于父子、隔代、兄弟组件通信这种方法通过一个空的 Vue 实例/作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。\n 4. $attrs/$listeners适用于隔代组件通信$attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind=“$attrs” 传入内部组件。通常配合 inheritAttrs 选项一起使用。$listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=“$listeners” 传入内部组件\n 5. provide / inject适用于隔代组件通信祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。\n 6. Vuex适用于父子、隔代、兄弟组件通信Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。",normalizedContent:"# vue\n\n\n# 优化打包app.js\n\n\n# vue路由的懒加载\n\n# 方法一 resolve\n\n这一种方法较常见。它主要是使用了resolve的异步机制，用require代替了import,实现按需加载，下面是代码示例：\n\nimport vue from 'vue'\nimport router from 'vue-router'\n// import helloworld from '@/components/helloworld'\nvue.use(router)\nexport default new router({\n    routes: [\n        //     {\n        //       path: '/',\n        //       name: 'helloworld',\n        //       component: helloworld\n        //     }\n        {\n            path: '/',\n            name: 'helloworld',\n            component: resolve => require(['@/components/helloworld'], resolve)\n        }\n    ]\n})\n\n\n# 方法二 官网方法\n\nvue-router在官网提供了一种方法，可以理解也是为通过promise的resolve机制。因为promise函数返回的promise为resolve组件本身，而我们又可以使用import来导入组件。整合起来代码示例如下：\n\nimport vue from 'vue'\nimport router from 'vue-router'\n// import helloworld from '@/components/helloworld'\nvue.use(router)\nexport default new router({\n    routes: [\n        //{\n        //\tpath: '/',\n        //\tname: 'helloworld',\n        //\tcomponent: helloworld\n        //}\n        {\n            path: '/',\n            name: 'helloworld',\n            component: () => import('@/components/helloworld.vue')\n        }\n    ]\n}) \n// -----------------------------------------------------\nimport vue from 'vue'\nimport router from 'vue-router'\n// import helloworld from '@/components/helloworld'\nconst helloworld = () => import('@/components/helloworld.vue')\nvue.use(router)\nexport default new router({\n    routes: [\n        //{\n        //\tpath: '/',\n        //\tname: 'helloworld',\n        //\tcomponent: helloworld\n        //}\n        {\n            path: '/',\n            name: 'helloworld',\n            component: helloworld\n        }\n    ]\n}) \n\n\n官网中还提供了通过注释语法来提供chunk name的方法，但是webpack的版本要高于2.4的版本。感兴趣的可以到官网了解一下。\n\n# 方法三 require.ensure\n\n这种模式可以通过参数中的webpackchunkname将js分开打包。\n\nimport vue from 'vue'\nimport router from 'vue-router'\n// import helloworld from '@/components/helloworld'\nvue.use(router)\nexport default new router({\n    routes: [\n        //{\n        //\tpath: '/',\n        //\tname: 'helloworld',\n        //\tcomponent: helloworld\n        //}\n        {\n            path: '/',\n            name: 'helloworld',\n            component: resolve => require.ensure([], () => resolve(require('@/components/'+componentname)), 'webpackchunkname')\n        }\n    ]\n})\n\n\n\n# vue组件的按需加载（2种方式）\n\n# 动态组件方式\n\n组件里面：\n\n<script>\n    export default {\n        components: {\n            aview: function(resolve) {\n                require([\"./a.vue\"], resolve);\n            },\n            bview: function(resolve) {\n                require([\"./b.vue\"], resolve);\n            }\n        }\n    }\n<\/script>\n\n\n模板里面：\n\n<component :is=\"current\" :data=\"mydata\" ></component>\n<script>\n    export default {\n        data: function() {\n            return {\n                current: \"\",\n                mydata:\"\",\n                show:false\n            }\n        },\n        methods: {\n            changecomponents:function(view) {\n                if(view=='aview') {\n                    this.mydata='a1000';\n                } else {\n                    this.mydata='b1000';\n                }\n                this.current=view;\n            }\n        }\n    }\n<\/script>\n\n\n# v-if方式(强制创建和结束生命周期)\n\n// 模板：\n<aview v-if=\"show\"></aview>\n// 组件：\n<script>\n    export default {\n        components: {\n            aview:require(\"./a.vue\")\n        }\n    }\n<\/script>\n\n\n\n# vue 中 v-show 和 v-if 的区别是什么？\n\nv-show 只是在 display: none 和 display: block 之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换 css，dom 还是一直保留着的。v-if 的话就得说到 vue 底层的编译了。当属性初始为 false 时，组件就不会被渲染，直到条件为 true，并且切换条件时会触发销毁/挂载组件，并且基于 v-if 的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。\n\n\n# v-if和v-for为什么不能连用？\n\nv-for比v-if优先，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候 。可以采取多层包裹来解决性能损耗问题。例如外层给标签绑定指令v-if或者是内层标签绑定v-if\n\n\n# keep-alive 组件有什么作用？\n\n如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。 对于 keep-alive 组件来说，它拥有两个独有的生命周期钩子函数，分别为 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。\n\n\n# 说下vue生命周期钩子函数?\n\n– beforecreate :这个时期，this变量还不能使用，在data下的数据，和methods下的方法，watcher中的事件都不能获得到。\n\n– created这个时候可以操作vue实例中的数据和各种方法，但是还不能对\"dom\"节点进行操作。\n\n– beforemounte：在挂载开始之前被调用：相关的 render 函数首次被调用\n\n– mounted：挂载完毕，这时dom节点被渲染到文档内，一些需要dom的操作在此时才能正常进行\n\n– beforeupdate：data中数据已经更新完毕，页面视图还未响应更改\n\n– updated：数据和视图都更新完毕\n\n– beforedestroy：销毁之前，实例上事件、指令等都可以使用，这里组件没有真正的销毁。\n\n– destroyed：数据、指令、等完全销毁\n\n\n# vue中computed和watch区别?\n\ncomputed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容。 watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。\n\n\n# vue3 中的数据响应式是怎么实现的？\n\nobserve(data) {\n    let _this = this;\n    this._data = new proxy(data, {\n        set(target, prop, newvalue) {\n            let event = new customevent(prop, {\n                detail: newvalue\n            });\n            _this.dispatchevent(event);\n            return reflect.set(...arguments);\n        }\n    });\n}\n\n\n\n# v-model 该如何实现？\n\nv-model本质上是v-on和v-bind的语法糖。v-model在内部为不同元素抛出不同的事件，如：\n\ntext 和 textarea 元素使用 value 属性和 input 事件；\n\ncheckbox 和 radio 使用 checked 属性和 change 事件；\n\nselect 字段将 value 作为 prop 并将 change 作为事件。 v-model作用在普通表单上<input v-model=\"myvalue\" /> // 等同于<input v-bind:value=\"myvalue\" v-on:input=\"myvalue=$event.target.value\"> v-model作用在组件上> 父组件v-model语法糖本质上可以修改为 '<child :value=\"message\" @input=\"function(e){message = e}\"></child>' 在组件的实现中，我们是可以通过 v-model属性 来配置子组件接收的prop名称，以及派发的事件名称。 例如：\n\n父组件>\n\n// html>\n<mycom v-model=\"myvalue\" ></mycom>>\n// 等同于>\n<mycom :value=\"myvalue\" @input=\"(e)=>{myvalue = e}\" ></mycom>\n// js\nnew vue({ el: \"#app\", components:{ mycom }, data: { myvalue: \"123\" }})\n\n\n子组件\n\nlet mycom = { \n    props:['value'], \n    template:`<div><input :value=\"value\"  @input=\"fn\" /></div>`, \n    methods:{ \n        fn(e){ \n            this.$emit('input',e.target.value) \n        } \n    } \n}\n\n\n\n# vue3中v-model的变化?\n\nvue3取消了.sync修饰符的使用，直接使用v-model进行替换即可。\n\n对于自定义组件使用v-model时，prop与事件的默认名称变更，\n\n从vue2版本的value/@input变更为modelvalue/@update:modelvalue。\n\n修改model的名称从原来的model选项进行修改，变更为传递参数给model，写法为v-model:argument。\n\n使用v-model参数后会改变prop和事件名为argument/@update:argument。\n\n现在一个组件可以同时使用多个v-model进行绑定。并且在vue3中v-model支持自定义修饰符，他将会通过props中的modelmodifiers属性接收。\n\n# 问题：是否还可以使用vue2版本的方式配置model名称？\n\n答：不可以，v-model参数是一个不向下兼容的改动，在vue3中修改model的名称就是通过v-model参数进行修改。\n\n# 问题：在同一个组件上绑定多个v-model时需不需要单独进行配置？\n\n答：绑定多个v-model的时候只要传参对model名称进行变更，每个v-model将会同步到不同的prop属性当中，所以并不需要在组件中添加额外的选项进行配置。\n\n\n# vue2中为什么检测不到数组的变化，如何解决?\n\n由于由javascript 的限制，vue 不能检测数组变动。解决方案是通过全局vue.set或者用实例方法vm.$set来修改。同样也可以通过变异方法splice来修改数组触发数据响应式。\n\n\n# 请简述 vue 中 template 的实现思路？\n\n * 第一步是将 模板字符串 转换成 element asts（解析器）(abstract syntax tree,抽象语法树）\n * 第二步是对 ast 进行静态节点标记，主要用来做虚拟dom的渲染优化（优化器）\n * 第三步是 使用 element asts 生成 render 函数代码字符串（代码生成器）\n\n【讲师讲解视频地址】：https://pan.baidu.com/s/1lrqlrzdsmci4gshjtxq3kq 提取码：0826\n\n\n# vue3 中 teleport 的作用是什么\n\n他的作用就是将一个嵌套在组件内部的某些内容可以渲染到当前组件外部。假设我们有一个modal组件，该组件分为触发modal打开的button以及模态框本体\n\n<div style=\"position: relative;\">\n    <button @click=\"modalopen = true\"> open full screen modal! </button>\n    <div v-if=\"modalopen\" class=\"modal\">\n        <div> \n            i'm a modal! \n            <button @click=\"modalopen = false\"> close </button>\n        </div>\n    </div>\n</div>\n\n\n但我们需要给模态框position: absolute时，其会以其定位父级也就是含有相对定位的div进行偏移，同时将会受到其父级样式影响。此时我们就只能将组件拆分为两个组件或者用一个其他的全局状态进行控制。\n\n如果使用teleport就可以将modal渲染到body标签内，避免上述困扰\n\n<div style=\"position: relative;\">\n    <button @click=\"modalopen = true\"> open full screen modal! </button>\n    <telepot to=\"body\">\n        <div v-if=\"modalopen\" class=\"modal\">\n            <div> i'm a modal!\n                <button @click=\"modalopen = false\"> close </button>\n            </div>\n        </div>\n    </telepot>\n</div>\n\n\n# 问题：teleport可以包含vue组件使用么？\n\n答：可以，当teleport包含的是vue组件时，只是将该组件渲染到对应的标签当中，他的props等依然是从该组件的父组件进行注入。\n\n# 问题：可以使用多个teleport指向同一标签么？\n\n答：可以的，就比如有一个复用的modal组件，他在多个地方被使用时会被指向相同标签比如body。这时将会按照顺序进行追加，后挂载的元素会在较早挂载元素之后的位置。\n\n\n# 虚拟 dom 有什么作用，如何构建虚拟dom？\n\nclass vdom{\n    constructor(option){\n        this.tagname = option.tagname;\n        this.props = option.props || {};\n        this.children = option.children || '';\n    }\n    render(){\n        let el = document.createelement(this.tagname);\n        for(let propskay in this.props){\n            el.setattribute(propskay,this.props[propskay])\n        }\n        if(array.isarray(this.children)){\n            this.children.foreach((item)=>{\n                el.appendchild(item.render());\n            })\n        }else{\n            el.innertext = this.children\n        }\n        return el;\n    }\n}\n\n\n\n# 如何把真实 dom 转变为虚拟 dom，代码实现一下？\n\nfunction vdom(node){\n    let nodetype = node.nodetype;\n    let _vnode = null;\n    if(nodetype === 1){//元素节点\n        let props = node.attributes;\n        console.log(props);\n        let property = {};\n        for(let i=0;i<props.length;i++){\n            property[props[i].name] = props[i].nodevalue;\n        }\n        _vnode = new vnode({\n            tagname:node.nodename,\n            props:property,\n            type:nodetype\n        })\n        let children = node.childnodes;\n        for(let i=0;i<children.length;i++){\n            if(children[i].nodetype === 1 || children[i].length > 1){\n                _vnode.appendchild(vdom(children[i]))\n            }\n        }\n    }else if(nodetype === 3){\n        _vnode = new vnode({\n            type:nodetype,\n            value:node.nodevalue.trim()\n        })\n    }\n    return _vnode;\n}\n\n\n\n# 说一下vue3的composition api?\n\ncomposition api意为组合式api，其主要是代码组织结构上的变动。\n\nvue2版本的options api，通过一个配置集合将代码划分为多个部分，使得代码组织结构比较清晰，比如父组件直接传入的数据存放于props，方法存放于methods等，但是其代码逻辑复用方面一直表现得不是很友好。composition api就是用于解决该问题，在vue3当中新增加了一个生命周期函数为setup。setup将在创建组件之前被执行，一旦props被解析时，setup将服务于composition api充当入口点。\n\n从使用角度来讲composition api主要有以下几点与options api不同响应式数据声明改变，通过ref/reactive两个方法均可以声明响应式数据，但是两者使用方式略有不同。\n\nref所声明的响应式变量将会返回一个包含有value属性的对象，value的值就是该响应式变量所对应的值。所以在不论在获取还是改变ref声明的响应式变量时都需要通过.value进行操作。\n\nreactive返回的则是通过proxy处理后的对象。使用生命周期函数时，变为从vue中引入对应生命周期函数例如onmounted，生命周期函数接受一个函数作为参数，该函数将会在对应生命周期阶段被执行。watch使用方式改变，watch作为函数接受至少两个参数，第一个参数为被watch的响应式数据，第二个参数为回调函数。当watch接受的响应式数据不同会有不同的使用方式，当watch的数据为通过ref声明的响应式变量时，watch直接接受ref响应式变量如watch(refvalue)。\n\n当watch数据为通过reactive声明时，需要传入一个函数，该函数返回reactive变量如watch(() => reactivevalue.value)。同时新增watcheffect，他会收集内部依赖，当内部依赖发生改变时就会被执行。\n\nprops现在作为setup的第一个参数进行接收，使用props时可以通过vue暴露的torefs方法将props上的属性转为独立的ref响应式变量，从而进行使用。在setup当中代码将可以根据功能进行组织并提取，这极大程度的解决了以往代码可读性较低以及逻辑服用难的缺点。\n\n# 问题：composition api是强制使用的么？我还可以在vue3中使用options api的方式进行开发么？\n\n答：composition api并不被强制使用，他只是在大型项目中对于代码复用以及逻辑提取上有很大的有点，并且他极大的提高了代码可读性。vue3是向下兼容的，在vue3当中依然可以通过options api进行开发。同时尤大本人曾在vue mastery上表示过，对于新手来讲，options api的学习可能对于上手vue来说更加快速。\n\n# 问题：我还可以在setup中通过this来使用实例上的属性么？\n\n答：不可以，因为setup执行是在组件创建之前，这时还并没有组件实例，所以在setup中并没有this，如果希望使用一些实例上的方法，可以通过getcurrentinstance方法先获取实例在进行操作。\n\n\n# 说一下 vue3 与 vue2 的对比？\n\n首先从性能层面讲，vue3不论是渲染速度或是打包速度均快于vue2，这里有以下几个原因数据劫持方式改变，\n\n原有通过object.defineproperty进行的数据劫持改变为proxy进行数据代理。\n\n由于proxy可以动态判断该数据是否为深层嵌套数据，而object.defineproperty为遍历全部深层嵌套数据，导致两者仅在数据劫持上就产生了极大的时间差距。\n\nvue3打包策略，vue3支持了tree-shaking，即排除任何未实际使用的代码，打包体积极大缩小。同时由于打包后体积缩小文件数量减少，页面加载文件所需时间也极大缩短。\n\ndiff优化，vue3中会对静态节点进行提升，所有静态节点(及不包含任何响应式数据及事件等)在进行比对时不会被遍历。这促使vue3在进行节点比对时所需的比对时间大幅减少。\n\n性能之后还有生命周期的改变，vue2中的beforecreate与created被setup一个生命周期所替代，同时beforedestroy与destroyed分别改名为beforeunmount与unmounted。同时vue3当中的响应式数据声明也有所改变，但这主要体现与在setup中进行响应式数据的声明。\n\nvue3当中暴露了两个方法，分别是reactive与ref方法。他们均是用来声明响应式数据，只是对于不同情况有各自的有点。由上面一点可以引出vue3当中发生的最大改变 - composition api。vue3的代码组织有以前的options api切换到了composition api，这使得我们在处理大型项目时不会再像以前一样，一个功能的代码将被分割到data、computed、method等等当中，我们可以将相同功能代码提出进行封装，这极大提高了代码可读性。\n\n除此以外vue3中双向绑定也进行了修改。vue3中取消了v-bind的.sync修饰符，因为这更符合v-model的逻辑。v-model主要有以下两点不同：\n\n * 一个组件可以同时包含多个v-model，model名称的更改由之前的model选项变更为传递一个参数给model，传参方式为v-model:argument\n * 当v-model用于自定义组件时，prop与事件的默认名称由以前的value/@input变更为modelvalue/@update:modelvalue。\n\n如果使用了v-model参数改变了model名字，比如v-model:title，则对应prop与事件名称为title/@update:title。最后vue3对ts的支持程度也是vue2所不能达到的，例如vue3当中提供了一个definecomponent，他能为props提供完整的类型推断。\n\n\n# 为什么要使用模块化？模块化的常见规范有那几种，各有什么特点？\n\n在javascript发展初期就是为了实现简单的页面交互逻辑，寥寥数语即可；如今cpu、浏览器性能得到了极大的提升，很多页面逻辑迁移到了客户端（表单验证等），随着web2.0时代的到来，前端代码日益膨胀，此时在js方面就会考虑使用模块化规范去管理。\n\n模块化的好处\n\n避免命名冲突(减少命名空间污染)更好的分离, 按需加载更高复用性高可维护性commonjs· 所有代码都运行在模块作用域，不会污染全局作用域。\n\n模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。\n\n模块加载的顺序，按照其在代码中出现的顺序。\n\n基本语法\n\n暴露模块：module.exports = value或exports.xxx = value\n\n引入模块：require(xxx),如果是第三方模块，xxx为模块名；\n\n如果是自定义模块，xxx为模块文件路径amdcommonjs规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。\n\namd规范则是非同步加载模块，允许指定回调函数。\n\n由于node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以commonjs规范比较适用。\n\n但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用amd规范。\n\n基本语法：\n\n暴露模块 define(['module1', 'module2'], function(m1, m2){ return 模块})\n\n引用模块 require(['module1', 'module2'], function(m1, m2){ 使用m1/m2})\n\ncmd\n\ncmd规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。cmd规范整合了commonjs和amd规范的特点。在 sea.js 中，所有 javascript 模块都遵循 cmd模块定义规范。\n\nes6\n\nes6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。commonjs 和 amd 模块，都只能在运行时确定这些东西。比如，\n\ncommonjs 模块就是对象，输入时必须查找对象属性。\n\n定义模块\n\nvar basicnum = 0;\nvar add = function (a, b) {\n    return a + b;\n};\nexport { basicnum, add };\n\n\n引用模块\n\nimport { basicnum, add } from './math';\nfunction test(ele) {    \n    ele.textcontent = add(99 + basicnum);\n}\n\n\ncommonjs规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了amd/cmd解决方案。\n\namd规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，amd规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。\n\ncmd规范与amd规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在node.js中运行。不过，依赖spm 打包，模块的加载逻辑偏重es6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 commonjs 和 amd 规范，成为浏览器和服务器通用的模块解决方案。\n\n\n# vue 中组件间有哪些通信方式?\n\n 1. props / $emit适用于父子组件通信这种方法是 vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。\n 2. ref 与 $parent / $children适用于父子组件通信ref：如果在普通的 dom 元素上使用，引用指向的就是 dom 元素；如果用在子组件上，引用就指向组件实例$parent / $children：访问父 / 子实例\n 3. eventbus （$emit / $on）适用于父子、隔代、兄弟组件通信这种方法通过一个空的 vue 实例/作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。\n 4. $attrs/$listeners适用于隔代组件通信$attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind=“$attrs” 传入内部组件。通常配合 inheritattrs 选项一起使用。$listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=“$listeners” 传入内部组件\n 5. provide / inject适用于隔代组件通信祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。provide / inject api 主要解决了跨级组件间的通信问题，不过它的使用场主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。\n 6. vuex适用于父子、隔代、兄弟组件通信vuex 是一个专为 vue.js 应用程序开发的状态管理模式。每一个 vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。vuex 的状态存储是响应式的。当 vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。",charsets:{cjk:!0}},{title:"1. 安装svg依赖",frontmatter:{},regularPath:"/vue/vue+svg.html",relativePath:"vue/vue+svg.md",key:"v-48a1f714",path:"/vue/vue+svg.html",headers:[{level:2,title:"1. 安装svg依赖",slug:"_1-安装svg依赖",normalizedTitle:"1. 安装svg依赖",charIndex:2},{level:2,title:"2. 创建svg文件夹存放svg图标",slug:"_2-创建svg文件夹存放svg图标",normalizedTitle:"2. 创建svg文件夹存放svg图标",charIndex:88},{level:2,title:"3. vue.config.js 中配置svg图片",slug:"_3-vue-config-js-中配置svg图片",normalizedTitle:"3. vue.config.js 中配置svg图片",charIndex:154},{level:2,title:"4. 创建index.js 导入所有svg图标",slug:"_4-创建index-js-导入所有svg图标",normalizedTitle:"4. 创建index.js 导入所有svg图标",charIndex:967},{level:2,title:"5. main.js中引入icons/index.js",slug:"_5-main-js中引入icons-index-js",normalizedTitle:"5. main.js中引入icons/index.js",charIndex:1363},{level:2,title:"6. 创建SvgIcon公用组件",slug:"_6-创建svgicon公用组件",normalizedTitle:"6. 创建svgicon公用组件",charIndex:1397}],headersStr:"1. 安装svg依赖 2. 创建svg文件夹存放svg图标 3. vue.config.js 中配置svg图片 4. 创建index.js 导入所有svg图标 5. main.js中引入icons/index.js 6. 创建SvgIcon公用组件",content:"# 1. 安装svg依赖\n\n在vue中首先需要安装可以加载svg的依赖。 npm安装：npm install svg-sprite-loader --save-dev\n\n\n# 2. 创建svg文件夹存放svg图标\n\n创建icons文件夹，在icons文件夹下创建svg文件夹存放本地svg图标。\n\n\n\n\n# 3. vue.config.js 中配置svg图片\n\n\n\nvue.config.js代码：\n\nconst path = require('path')\n\nmodule.exports = {\n    chainWebpack:config=>{\n        // svg图标加载\n        config.module\n            .rule('svg')\n            .exclude.add(path.join(__dirname, 'src/assets/icons/svg'))\n            .end()\n\n        config.module\n            .rule('icons')// 定义一个名叫 icons 的规则\n            .test(/\\.svg$/)// 设置 icons 的匹配正则\n            .include.add(path.join(__dirname,'src/assets/icons/svg'))// 设置当前规则的作用目录，只在当前目录下才执行当前规则\n            .end()\n            .use('svg-sprite')// 指定一个名叫 svg-sprite 的 loader 配置\n            .loader('svg-sprite-loader')// 该配置使用 svg-sprite-loader 作为处理 loader\n            .options({// 该 svg-sprite-loader 的配置\n            symbolId:'icon-[name]'\n        })\n            .end()\n    }\n}\n\n\n\ninclude.add(路径)–路径不正确会报以下错误：\n\n\n\n\n# 4. 创建index.js 导入所有svg图标\n\nicons文件夹创建index.js 自动导入所有svg图标。\n\n\n\nicons/index.js代码：\n\nconst req = require.context('@/assets/icons/svg',false,/\\.svg$/)\nconst requireAll = requireContext =>{\n    // requireContext.keys()数据：['./404.svg', './agency.svg', './det.svg', './user.svg']\n    requireContext.keys().map(requireContext)\n} \nrequireAll(req)\n\n\n执行 requireContext.keys().map(requireContext)得到返回的数据：\n\n\n\n\n# 5. main.js中引入icons/index.js\n\n\n\n\n# 6. 创建SvgIcon公用组件\n\n\n\nSvgIcon/index.vue代码：\n\n<template>\n<i v-if=\"iconFileName.indexOf('el-icon-') === 0\" :class=\"iconFileName\" />\n<svg v-else class=\"svg-icon\" aria-hidden=\"true\" v-on=\"$listeners\">\n    <use :xlink:href=\"`#icon-${iconFileName}`\" />\n    </svg>\n</template>\n\n<script>\n    export default {\n        name: 'SvgIcon',\n        props: {\n            iconFileName: {\n                type: String,\n                required: true\n            }\n        }\n    }\n<\/script>\n\n<style scoped>\n    .svg-icon {\n        width: 1em;\n        height: 1em;\n        overflow: hidden;\n        vertical-align: -0.15em;\n        fill: currentColor;\n    }\n</style>\n\n\n全局注册SvgIcon组件：\n\n\n\n使用SvgIcon组件：\n\n",normalizedContent:"# 1. 安装svg依赖\n\n在vue中首先需要安装可以加载svg的依赖。 npm安装：npm install svg-sprite-loader --save-dev\n\n\n# 2. 创建svg文件夹存放svg图标\n\n创建icons文件夹，在icons文件夹下创建svg文件夹存放本地svg图标。\n\n\n\n\n# 3. vue.config.js 中配置svg图片\n\n\n\nvue.config.js代码：\n\nconst path = require('path')\n\nmodule.exports = {\n    chainwebpack:config=>{\n        // svg图标加载\n        config.module\n            .rule('svg')\n            .exclude.add(path.join(__dirname, 'src/assets/icons/svg'))\n            .end()\n\n        config.module\n            .rule('icons')// 定义一个名叫 icons 的规则\n            .test(/\\.svg$/)// 设置 icons 的匹配正则\n            .include.add(path.join(__dirname,'src/assets/icons/svg'))// 设置当前规则的作用目录，只在当前目录下才执行当前规则\n            .end()\n            .use('svg-sprite')// 指定一个名叫 svg-sprite 的 loader 配置\n            .loader('svg-sprite-loader')// 该配置使用 svg-sprite-loader 作为处理 loader\n            .options({// 该 svg-sprite-loader 的配置\n            symbolid:'icon-[name]'\n        })\n            .end()\n    }\n}\n\n\n\ninclude.add(路径)–路径不正确会报以下错误：\n\n\n\n\n# 4. 创建index.js 导入所有svg图标\n\nicons文件夹创建index.js 自动导入所有svg图标。\n\n\n\nicons/index.js代码：\n\nconst req = require.context('@/assets/icons/svg',false,/\\.svg$/)\nconst requireall = requirecontext =>{\n    // requirecontext.keys()数据：['./404.svg', './agency.svg', './det.svg', './user.svg']\n    requirecontext.keys().map(requirecontext)\n} \nrequireall(req)\n\n\n执行 requirecontext.keys().map(requirecontext)得到返回的数据：\n\n\n\n\n# 5. main.js中引入icons/index.js\n\n\n\n\n# 6. 创建svgicon公用组件\n\n\n\nsvgicon/index.vue代码：\n\n<template>\n<i v-if=\"iconfilename.indexof('el-icon-') === 0\" :class=\"iconfilename\" />\n<svg v-else class=\"svg-icon\" aria-hidden=\"true\" v-on=\"$listeners\">\n    <use :xlink:href=\"`#icon-${iconfilename}`\" />\n    </svg>\n</template>\n\n<script>\n    export default {\n        name: 'svgicon',\n        props: {\n            iconfilename: {\n                type: string,\n                required: true\n            }\n        }\n    }\n<\/script>\n\n<style scoped>\n    .svg-icon {\n        width: 1em;\n        height: 1em;\n        overflow: hidden;\n        vertical-align: -0.15em;\n        fill: currentcolor;\n    }\n</style>\n\n\n全局注册svgicon组件：\n\n\n\n使用svgicon组件：\n\n",charsets:{cjk:!0}},{title:"vue-router",frontmatter:{},regularPath:"/vue/vue-router.html",relativePath:"vue/vue-router.md",key:"v-0e8da270",path:"/vue/vue-router.html",headers:[{level:2,title:"vue-router使用例子",slug:"vue-router使用例子",normalizedTitle:"vue-router使用例子",charIndex:77},{level:2,title:"动态生成路由",slug:"动态生成路由",normalizedTitle:"动态生成路由",charIndex:179},{level:3,title:"登录是获取添加的路由，存在vuex中",slug:"登录是获取添加的路由-存在vuex中",normalizedTitle:"登录是获取添加的路由，存在vuex中",charIndex:190},{level:3,title:"解决刷新页面路由丢失问题，在APP.vue文件下调用initRoutes",slug:"解决刷新页面路由丢失问题-在app-vue文件下调用initroutes",normalizedTitle:"解决刷新页面路由丢失问题，在app.vue文件下调用initroutes",charIndex:5876}],headersStr:"vue-router使用例子 动态生成路由 登录是获取添加的路由，存在vuex中 解决刷新页面路由丢失问题，在APP.vue文件下调用initRoutes",content:"# vue-router\n\nvue-router官网 https://router.vuejs.org/zh/installation.html\n\n\n# vue-router使用例子\n\n挂载\n\nimport Vue from 'vue'\nimport VueRouter from 'vue-router'\n\nVue.use(VueRouter)\n\n\n\n# 动态生成路由\n\n\n# 登录是获取添加的路由，存在vuex中\n\n# login.vue\n\nimport {initRoutes} from \"@/router/index.js\"; // 按需引入路由的动态注入方法\n// 获取要添加的路由\nlet navList = [\n    {\n        module: \"system\",\n        children: [\n            {\n                id: 1,\n                path: \"/system/marketTopics\",\n                icon: \"icon-shichang\",\n                title: \"市场主体专题\",\n            },\n            {\n                id: 2,\n                path: \"/system/floorTopics\",\n                icon: \"icon-changfang\",\n                title: \"楼宇厂房载体专题\",\n            },\n            {\n                id: 3,\n                path: \"/system/industryTopics\",\n                icon: \"icon-xiangmu\",\n                title: \"产业项目专题\",\n            }, {\n                id: 4,\n                path: \"/system/user\",\n                icon: \"el-icon-menu\",\n                title: \"用户管理\",\n            },\n        ],\n    },\n    {\n        module: \"user\",\n        children: [\n            {\n                id: 1,\n                path: \"/user\",\n                icon: \"el-icon-menu\",\n                title: \"用户管理\",\n            },\n\n        ],\n    },\n];\n// 存在vueX中\nthis.$store.commit(\"setNavList\", navList);\n// 动态添加路由\ninitRoutes();\n\n\n\n# vueX代码如下：\n\nimport Vue from 'vue'\nimport Vuex from 'vuex'\nVue.use(Vuex)\n\nexport default new Vuex.Store({\n    state: {\n        // 动态路由\n        navList: JSON.parse(window.sessionStorage.getItem('navList') || '[]')\n    },\n    mutations: {\n        // 动态路由\n        setNavList(state, data) {\n            state.navList = data;\n            window.sessionStorage.setItem(\"navList\", JSON.stringify(data));\n        }\n    },\n    actions: {\n\n    },\n    modules: {}\n})\n\n\n# router/index.js 路由配置文件代码如下\n\nimport Vue from 'vue'\nimport VueRouter from 'vue-router'\nimport store from '@/store'\n\nimport Login from '@/views/Login'\nimport Index from '@/views/Index'\n\nimport Error from '@/views/Error'\nimport NotFound from '@/views/NotFound'\n// 数据管理\nimport System from '@/views/System'\nimport MarketTopics from '@/views/System/MarketTopics' //市场主体专题\nimport FloorTopics from '@/views/System/FloorTopics' //楼宇厂房专题\nimport IndustryTopics from '@/views/System/IndustryTopics' //产业项目专题\nimport User1 from '@/views/System/User' //用户管理\n// 用户管理\nimport User from '@/views/User'\n\n\n// 需要动态添加的路由\nconst marketTopics = { path: '/system/marketTopics', component: MarketTopics }\nconst floorTopics = { path: '/system/floorTopics', component: FloorTopics }\nconst industryTopics = { path: '/system/industryTopics', component: IndustryTopics }\nconst user = { path: '/system/User', component: User1 }\n// 动态路由根据名称匹配跳转页面\nconst ruleMapping = {\n    '/system/marketTopics': marketTopics,\n    '/system/floorTopics': floorTopics,\n    '/system/industryTopics': industryTopics,\n    '/system/user': user,\n};\n\nVue.use(VueRouter)\n\n// 创建默认路由\nconst createRouter = () => new VueRouter({\n    // mode: 'history',\n    base: '/', // 打包时需要配置访问目录\n    routes: [{\n        path: '/',\n        redirect: \"/login\"\n    }, {\n        path: '/login',\n        component: Login\n    }, {\n        path: '/index',\n        component: Index,\n        name:\"Index\",\n    }, {\n        path: '/notFound',\n        name: 'notFound',\n        component: NotFound\n    }, {\n        // 没有路由的访问权限时，访问的页面404\n        path: '*',\n        component: Error\n    }]\n})\n\nconst router = createRouter();\n\n/* \n    路由导航守卫\n    to 要跳转到哪个界面\n    from 从哪跳转来的\n    next 是否要放行\n*/\nrouter.beforeEach((to, from, next) => {\n    if (to.path === '/login') {\n        // 如果是要跳转登录就直接放行\n        next()\n    } else {\n        // 检查路由元信息，是否开启登录验证\n        if (to.matched.some(record => record.meta.requiresAuth)) {\n            const token = store.state.user.token;\n            // 判断用户是否已经登录\n            if (!token) {\n                // 没登陆还是跳转登录页\n                next('/notFound')\n            } else {\n                // 正常情况就放行,设置当前路由地址\n                window.sessionStorage.setItem('activePath', to.path)\n                next()\n            }\n        } else {\n            // 没开启登录验证，放行\n            next()\n        }\n    }\n});\n// 解决 Vue 重复点击相同路由，出现 Uncaught (in promise) NavigationDuplicated: Avoided redundant navigation 问题\nconst VueRouterPush =VueRouter.prototype.push\nVueRouter.prototype.push = function push (to) {\n    return VueRouterPush.call(this, to).catch(err => err)\n}\n\n// 动态导入路由\nexport function initRoutes() {\n    const token = store.state.user.token;\n    if (!token) {\n        router.login\n    } else {\n        const currentRoutes = router.options.routes; // 获取要添加路由的当前路由\n        const navList = store.state.navList; // 获取state中缓存的根据权限获取的路由\n        if (navList.length > 0) {\n            const currentIndex = { path: '/system', component: System, children: [] }\n            let currentUser = \"\"\n            navList.forEach(item => { // 循环获取的路由\n                if (item.module == \"system\") {\n                    const list = item.children\n                    const redirect = list[0].path;\n                    currentIndex.redirect = redirect\n                    list.forEach((t, i) => {\n                        const temp = ruleMapping[t.path]; // 获取需要动态添加的路由，对应的跳转页面配置\n                        currentIndex.children.push(temp); // 将匹配的路由，添加到当前路由的对应子路由位置\n                    })\n                } else if (item.module == \"user\") {\n                    currentUser = { path: '/user', component: User, children: [] }\n                    currentRoutes.push(currentUser);\n                }\n\n            });\n            currentRoutes.push(currentIndex);\n            router.addRoutes(currentRoutes); // 执行动态添加路由方法，完成动态路由添加\n        }\n    }\n}\n\n// 重置路由（退出登录，切换账号）\nexport function resetRouter() {\n    const newRouter = createRouter()\n    router.matcher = newRouter.matcher // the relevant part\n    router.options = newRouter.options;\n}\n\n\nexport default router\n\n\n\n# 解决刷新页面路由丢失问题，在APP.vue文件下调用initRoutes\n\n代码如下：\n\n<template>\n    <div id=\"app\">\n        <router-view></router-view>\n    </div>\n</template>\n\n<script>\n    import { initRoutes } from '@/router/index.js'\n    export default {\n        created() {\n            // 生命周期内，刷新时重新动态添加组件,防止刷新后路由丢失\n            initRoutes()\n        }\n    }\n<\/script>\n\n<style>\n    #app {\n        height: 100%;\n    }\n</style>\n",normalizedContent:"# vue-router\n\nvue-router官网 https://router.vuejs.org/zh/installation.html\n\n\n# vue-router使用例子\n\n挂载\n\nimport vue from 'vue'\nimport vuerouter from 'vue-router'\n\nvue.use(vuerouter)\n\n\n\n# 动态生成路由\n\n\n# 登录是获取添加的路由，存在vuex中\n\n# login.vue\n\nimport {initroutes} from \"@/router/index.js\"; // 按需引入路由的动态注入方法\n// 获取要添加的路由\nlet navlist = [\n    {\n        module: \"system\",\n        children: [\n            {\n                id: 1,\n                path: \"/system/markettopics\",\n                icon: \"icon-shichang\",\n                title: \"市场主体专题\",\n            },\n            {\n                id: 2,\n                path: \"/system/floortopics\",\n                icon: \"icon-changfang\",\n                title: \"楼宇厂房载体专题\",\n            },\n            {\n                id: 3,\n                path: \"/system/industrytopics\",\n                icon: \"icon-xiangmu\",\n                title: \"产业项目专题\",\n            }, {\n                id: 4,\n                path: \"/system/user\",\n                icon: \"el-icon-menu\",\n                title: \"用户管理\",\n            },\n        ],\n    },\n    {\n        module: \"user\",\n        children: [\n            {\n                id: 1,\n                path: \"/user\",\n                icon: \"el-icon-menu\",\n                title: \"用户管理\",\n            },\n\n        ],\n    },\n];\n// 存在vuex中\nthis.$store.commit(\"setnavlist\", navlist);\n// 动态添加路由\ninitroutes();\n\n\n\n# vuex代码如下：\n\nimport vue from 'vue'\nimport vuex from 'vuex'\nvue.use(vuex)\n\nexport default new vuex.store({\n    state: {\n        // 动态路由\n        navlist: json.parse(window.sessionstorage.getitem('navlist') || '[]')\n    },\n    mutations: {\n        // 动态路由\n        setnavlist(state, data) {\n            state.navlist = data;\n            window.sessionstorage.setitem(\"navlist\", json.stringify(data));\n        }\n    },\n    actions: {\n\n    },\n    modules: {}\n})\n\n\n# router/index.js 路由配置文件代码如下\n\nimport vue from 'vue'\nimport vuerouter from 'vue-router'\nimport store from '@/store'\n\nimport login from '@/views/login'\nimport index from '@/views/index'\n\nimport error from '@/views/error'\nimport notfound from '@/views/notfound'\n// 数据管理\nimport system from '@/views/system'\nimport markettopics from '@/views/system/markettopics' //市场主体专题\nimport floortopics from '@/views/system/floortopics' //楼宇厂房专题\nimport industrytopics from '@/views/system/industrytopics' //产业项目专题\nimport user1 from '@/views/system/user' //用户管理\n// 用户管理\nimport user from '@/views/user'\n\n\n// 需要动态添加的路由\nconst markettopics = { path: '/system/markettopics', component: markettopics }\nconst floortopics = { path: '/system/floortopics', component: floortopics }\nconst industrytopics = { path: '/system/industrytopics', component: industrytopics }\nconst user = { path: '/system/user', component: user1 }\n// 动态路由根据名称匹配跳转页面\nconst rulemapping = {\n    '/system/markettopics': markettopics,\n    '/system/floortopics': floortopics,\n    '/system/industrytopics': industrytopics,\n    '/system/user': user,\n};\n\nvue.use(vuerouter)\n\n// 创建默认路由\nconst createrouter = () => new vuerouter({\n    // mode: 'history',\n    base: '/', // 打包时需要配置访问目录\n    routes: [{\n        path: '/',\n        redirect: \"/login\"\n    }, {\n        path: '/login',\n        component: login\n    }, {\n        path: '/index',\n        component: index,\n        name:\"index\",\n    }, {\n        path: '/notfound',\n        name: 'notfound',\n        component: notfound\n    }, {\n        // 没有路由的访问权限时，访问的页面404\n        path: '*',\n        component: error\n    }]\n})\n\nconst router = createrouter();\n\n/* \n    路由导航守卫\n    to 要跳转到哪个界面\n    from 从哪跳转来的\n    next 是否要放行\n*/\nrouter.beforeeach((to, from, next) => {\n    if (to.path === '/login') {\n        // 如果是要跳转登录就直接放行\n        next()\n    } else {\n        // 检查路由元信息，是否开启登录验证\n        if (to.matched.some(record => record.meta.requiresauth)) {\n            const token = store.state.user.token;\n            // 判断用户是否已经登录\n            if (!token) {\n                // 没登陆还是跳转登录页\n                next('/notfound')\n            } else {\n                // 正常情况就放行,设置当前路由地址\n                window.sessionstorage.setitem('activepath', to.path)\n                next()\n            }\n        } else {\n            // 没开启登录验证，放行\n            next()\n        }\n    }\n});\n// 解决 vue 重复点击相同路由，出现 uncaught (in promise) navigationduplicated: avoided redundant navigation 问题\nconst vuerouterpush =vuerouter.prototype.push\nvuerouter.prototype.push = function push (to) {\n    return vuerouterpush.call(this, to).catch(err => err)\n}\n\n// 动态导入路由\nexport function initroutes() {\n    const token = store.state.user.token;\n    if (!token) {\n        router.login\n    } else {\n        const currentroutes = router.options.routes; // 获取要添加路由的当前路由\n        const navlist = store.state.navlist; // 获取state中缓存的根据权限获取的路由\n        if (navlist.length > 0) {\n            const currentindex = { path: '/system', component: system, children: [] }\n            let currentuser = \"\"\n            navlist.foreach(item => { // 循环获取的路由\n                if (item.module == \"system\") {\n                    const list = item.children\n                    const redirect = list[0].path;\n                    currentindex.redirect = redirect\n                    list.foreach((t, i) => {\n                        const temp = rulemapping[t.path]; // 获取需要动态添加的路由，对应的跳转页面配置\n                        currentindex.children.push(temp); // 将匹配的路由，添加到当前路由的对应子路由位置\n                    })\n                } else if (item.module == \"user\") {\n                    currentuser = { path: '/user', component: user, children: [] }\n                    currentroutes.push(currentuser);\n                }\n\n            });\n            currentroutes.push(currentindex);\n            router.addroutes(currentroutes); // 执行动态添加路由方法，完成动态路由添加\n        }\n    }\n}\n\n// 重置路由（退出登录，切换账号）\nexport function resetrouter() {\n    const newrouter = createrouter()\n    router.matcher = newrouter.matcher // the relevant part\n    router.options = newrouter.options;\n}\n\n\nexport default router\n\n\n\n# 解决刷新页面路由丢失问题，在app.vue文件下调用initroutes\n\n代码如下：\n\n<template>\n    <div id=\"app\">\n        <router-view></router-view>\n    </div>\n</template>\n\n<script>\n    import { initroutes } from '@/router/index.js'\n    export default {\n        created() {\n            // 生命周期内，刷新时重新动态添加组件,防止刷新后路由丢失\n            initroutes()\n        }\n    }\n<\/script>\n\n<style>\n    #app {\n        height: 100%;\n    }\n</style>\n",charsets:{cjk:!0}},{title:"three.js",frontmatter:{},regularPath:"/three.js/three.js.html",relativePath:"three.js/three.js.md",key:"v-68fd1656",path:"/three.js/three.js.html",headers:[{level:2,title:"three.js文档结构",slug:"three-js文档结构",normalizedTitle:"three.js文档结构",charIndex:28},{level:2,title:"Three.js控制物体显示与隐藏的方法",slug:"three-js控制物体显示与隐藏的方法",normalizedTitle:"three.js控制物体显示与隐藏的方法",charIndex:1588},{level:3,title:"visible属性",slug:"visible属性",normalizedTitle:"visible属性",charIndex:1627},{level:3,title:"layers属性",slug:"layers属性",normalizedTitle:"layers属性",charIndex:1642},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:6793},{level:2,title:"Clock",slug:"clock",normalizedTitle:"clock",charIndex:6917},{level:3,title:".getDelta ()方法",slug:"getdelta-方法",normalizedTitle:".getdelta ()方法",charIndex:7075},{level:3,title:"两帧渲染时间间隔",slug:"两帧渲染时间间隔",normalizedTitle:"两帧渲染时间间隔",charIndex:7282},{level:3,title:"属性.autoStart: Boolean",slug:"属性-autostart-boolean",normalizedTitle:"属性.autostart: boolean",charIndex:8084},{level:3,title:"属性.startTime : Float",slug:"属性-starttime-float",normalizedTitle:"属性.starttime : float",charIndex:8157},{level:3,title:"属性.startTime : Float",slug:"属性-starttime-float-2",normalizedTitle:"属性.starttime : float",charIndex:8157},{level:3,title:"属性.elapsedTime : Float",slug:"属性-elapsedtime-float",normalizedTitle:"属性.elapsedtime : float",charIndex:8293},{level:3,title:"属性.running : Boolean",slug:"属性-running-boolean",normalizedTitle:"属性.running : boolean",charIndex:8338},{level:3,title:"方法.start ()",slug:"方法-start",normalizedTitle:"方法.start ()",charIndex:8380},{level:3,title:"方法.stop ()",slug:"方法-stop",normalizedTitle:"方法.stop ()",charIndex:8474},{level:3,title:"方法.getElapsedTime ()",slug:"方法-getelapsedtime",normalizedTitle:"方法.getelapsedtime ()",charIndex:8516},{level:3,title:"方法.getDelta ()",slug:"方法-getdelta",normalizedTitle:"方法.getdelta ()",charIndex:8617},{level:2,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:7272},{level:3,title:"地球绕太阳自转公转",slug:"地球绕太阳自转公转",normalizedTitle:"地球绕太阳自转公转",charIndex:8730},{level:3,title:"球体按轨迹运动_WebGL三维场景",slug:"球体按轨迹运动-webgl三维场景",normalizedTitle:"球体按轨迹运动_webgl三维场景",charIndex:12813},{level:3,title:"Three.js三维地图可视化",slug:"three-js三维地图可视化",normalizedTitle:"three.js三维地图可视化",charIndex:16728},{level:3,title:"可视化地图——three.js实现",slug:"可视化地图-three-js实现",normalizedTitle:"可视化地图——three.js实现",charIndex:17585}],headersStr:"three.js文档结构 Three.js控制物体显示与隐藏的方法 visible属性 layers属性 总结 Clock .getDelta ()方法 两帧渲染时间间隔 属性.autoStart: Boolean 属性.startTime : Float 属性.startTime : Float 属性.elapsedTime : Float 属性.running : Boolean 方法.start () 方法.stop () 方法.getElapsedTime () 方法.getDelta () 案例 地球绕太阳自转公转 球体按轨迹运动_WebGL三维场景 Three.js三维地图可视化 可视化地图——three.js实现",content:"# three.js\n\nThree.js中文网\n\n\n# three.js文档结构\n\n通过下面的树状图简单展示了从three.js官网下载的文件three.js-master包含的子文件，有些内容已经在线部署，可以通过树状图上的超链接直接访问。\n\n\n\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n\n    \x3c!--引入three.js三维引擎--\x3e\n    <script src=\"http://www.yanhuangxueyuan.com/3D/example/three.min.js\"><\/script>\n  </head>\n  <body>\n    <script>\n      /**\n        * 创建场景对象\n       */\n      var scene=new THREE.Scene();\n      /**\n       * 创建网格模型\n       */\n      var box=new THREE.BoxGeometry(100,100,100);//创建一个立方体几何对象\n      var material=new THREE.MeshLambertMaterial({color:0x0000ff});//材质对象\n      var mesh=new THREE.Mesh(box,material);//网格模型对象\n      scene.add(mesh);//网格模型添加到场景中\n\n\n      /**\n        * 创建渲染器对象\n        */\n      var renderer=new THREE.WebGLRenderer();\n      renderer.setSize(width,height);\n      renderer.setClearColor(0xb9d3ff,1);//设置背景颜色\n      document.body.appendChild(renderer.domElement);//body元素中插入canvas对象\n      //执行渲染操作\n      renderer.render(scene,camera);\n    <\/script>\n  </body>\n</html>\n\n\nvar geometry = new THREE.Geometry(); //声明一个空几何体对象\nvar p1 = new THREE.Vector3(0,0,0); //顶点1坐标\nvar p2 = new THREE.Vector3(80,0,0); //顶点2坐标\nvar p3 = new THREE.Vector3(0,80,0); //顶点3坐标\ngeometry.vertices.push(p1,p2,p3); //顶点坐标添加到geometry对象\nvar face = new THREE.Face3( 0, 1, 2, normal); //创建三角面\n/**顶点颜色**/\nvar color1 = new THREE.Color(0xFF0000);//顶点1颜色——红色\nvar color2 = new THREE.Color(0x00FF00);//顶点2颜色——绿色\nvar color3 = new THREE.Color(0x0000FF);//顶点3颜色——蓝色\nvar normal = new THREE.Vector3( 0, 0, 1 ); //三角面法向量\nface.vertexColors.push(color1, color2,color3);//定义三角面三个顶点的颜色\ngeometry.faces.push( face ); //三角面添加到几何体\n\n\n\n# Three.js控制物体显示与隐藏的方法\n\n主要包括以下几种方式：\n\n 1. visible属性；\n 2. layers属性。\n\n\n# visible属性\n\nvisible 是Object3D的属性。只有当 visible 是 true 的时候，该物体才会被渲染。任何继承 Object3D 的对象都可以通过该属性去控制它的显示与否，比如：Mesh，Group，Sprite，Light等。\n\n举个简单的例子：\n\n// 控制单个物体的显示和隐藏\n\nconst geometry = new THREE.PlaneGeometry(1, 1) // 1*1的一个平面\n\nconst planeMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 }) // 红色平面\n\nconst plane = new THREE.Mesh(geometry, planeMaterial)\n\nplane.visible = false // 不显示单个物体\n\nscene.add(plane)\n// 控制一组物体的显示和隐藏\nconst geometry = new THREE.PlaneGeometry(1, 1)\nconst planeMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 })\nconst plane = new THREE.Mesh(geometry, planeMaterial)\nconst group = new THREE.Group()\ngroup.add(plane)\ngroup.visible = false // 不显示一组物体\n\nscene.add(group)\n\n\n通过后面的例子可以看出，当我们想要控制一组物体的显示与隐藏，可以把这些物体放入一个 Group 中，只通过控制 Group 的显示与隐藏即可。\n\n这块的代码逻辑是在WebGLRenderer.js的 projectObject 方法中实现的。\n\n首先，在 render 方法中调用了 projectObject 方法：\n\nthis.render = function ( scene, camera ) {\n  // ...\n\n  projectObject( scene, camera, 0, _this.sortObjects );\n  // ...\n\n}\n\n\nprojectObject 方法的定义如下：\n\nfunction projectObject( object, camera, groupOrder, sortObjects ) {\n  if ( object.visible === false ) return; // 注释1：visible属性是false直接返回\n  // ...\n\n  var children = object.children; // 注释2：递归应用在children上\n\n  for ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\n    projectObject( children[ i ], camera, groupOrder, sortObjects ); // 注释2：递归应用在children上\n\n\n  }\n\n}\n\n\n从注释1可以看出，如果 Group 的 visible 是 false，那么就不会在 children 上递归调用，所以就能达到通过 Group 控制一组对象的显示与隐藏的效果。\n\n当 visible 是 false 的时候，Raycaster 的 intersectObject 或者 intersectObjects 也不会把该物体考虑在内。这块的代码逻辑是在 Raycaster.js：\n\nintersectObject: function ( object, recursive, optionalTarget ) {\n// ...\n\n  intersectObject( object, this, intersects, recursive ); // 注释1：调用了公共方法intersectObject\n// ...\n\n},\n\n\nintersectObjects: function ( objects, recursive, optionalTarget ) {\n// ...\n\nfor ( var i = 0, l = objects.length; i < l; i ++ ) {\n\n\n    intersectObject( objects[ i ], this, intersects, recursive ); // 注释1：循环调用了公共方法intersectObject\n\n\n  }\n// ...\n\n}\n\n// 注释1：公共方法intersectObject\nfunction intersectObject( object, raycaster, intersects, recursive ) {\n\nif ( object.visible === false ) return; // 注释1：如果visible是false，直接return\n\n// ...\n\n}\n\n\n从注释1可以看出，如果 Group 或者单个物体的 visible 是 false ，就不做检测了。\n\n\n# layers属性\n\nObject3D的layers属性 是一个 Layers 对象。任何继承 Object3D 的对象都有这个属性，比如 Camera 。Raycaster 虽然不是继承自 Object3D ，但它同样有 layers 属性（r113版本以上）。\n\n和上面的 visible 属性一样，layers 属性同样可以控制物体的显示与隐藏、Raycaster 的行为。当物体和相机至少有一个同样的层的时候，物体就可见，否则不可见。同样，当物体和 Raycaster 至少有一个同样的层的时候，才会进行是否相交的测试。这里，强调了是至少有一个，是因为 Layers 可以设置多个层。\n\nLayers 一共可以表示 32 个层，0 到 31 层。内部表示为：\n\n\n\nLayers 可以设置同时拥有多个层：\n\n 1. 可以通过 Layers 的 enable 和 disable 方法开启和关闭当前层，参数是上面表格中的 0 到 31 。\n 2. 可以通过 Layers 的 set 方法 只开启 当前层，参数是上述表格中的 0 到 31。\n 3. 可以通过 Layers 的 test 的方法判断两个 Layers 对象是否存在 至少一个公共层 。\n\n当开启多个层的时候，其实就是上述表格中的二进制进行 按位或 操作。比如 同时 开启 0、2、31 层，那么内部存储的值就是 10000000000000000000000000000101。\n\nlayers 属性默认只开启 0 层。\n\n还是上面那个例子，我们看下怎么控制物体的显示和隐藏：\n\n// 控制单个物体的显示和隐藏\n\nconst geometry = new THREE.PlaneGeometry(1, 1)\n\nconst planeMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 })\n\nconst plane = new THREE.Mesh(geometry, planeMaterial)\n\nplane.layers.set(1) // 设置平面只有第1层，相机默认是在第0层，所以该物体不会显示出来\n\nscene.add(plane)\n// 控制一组物体的显示和隐藏\nconst geometry = new THREE.PlaneGeometry(1, 1)\nconst planeMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 })\nconst plane = new THREE.Mesh(geometry, planeMaterial)\nconst group = new THREE.Group()\ngroup.layers.set(1) // 注释1: 设置group只有第一层，相机默认是在第0层，但是此时平面物体还是显示出来了？\ngroup.add(plane)\n\nscene.add(group)\n\n\n设置单个物体的 layer 可以看到物体成功的没有显示出来。但是，当我们给 group 设置 layer 之后，发现 group 的 children（平面物体）还是显示了出来。那么，这是什么原因呢？让我们看下源码，同样还是上面的 projectObject 方法：\n\nfunction projectObject( object, camera, groupOrder, sortObjects ) {\n\nif ( object.visible === false ) return;\n\n\n  var visible = object.layers.test( camera.layers ); // 注释1：判断物体和相机是否存在一个公共层\n\nif ( visible ) { // 注释1：如果存在，对物体进行下面的处理\n// ...\n\n  }\n\n\n  var children = object.children; // 注释1：不管该物体是否和相机存在一个公共层，都会对children进行递归\n\nfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\n    projectObject( children[ i ], camera, groupOrder, sortObjects );\n\n\n  }\n\n}\n\n\n从上述注释1可以看出，即使该物体和相机不存在公共层，也不影响该物体的 children 显示。这也就解释了上述为什么给 group 设置 layers ，但是平面物体还是能显示出来。从这一点上来看，layers 和 visible 属性在控制物体显示和隐藏的方面是不一样的。\n\n和 visible 属性一样，接下来我们看下 Layers 对 Raycaster 的影响。同样我还是看了 Raycaster.js 文件，但是发现根本就没有 layers 字段。后来，我看了下最新版本 r140 的 Raycaster.js：\n\nfunction intersectObject( object, raycaster, intersects, recursive ) {\n\nif ( object.layers.test( raycaster.layers ) ) { // 注释1：判断物体和Raycaster是否有公共层\n\nobject.raycast( raycaster, intersects );\n\n\n  }\n\nif ( recursive === true ) { // 注释1：不管该物体和Raycaster是否有公共层，都不影响children\n\n\n    const children = object.children;\n\nfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\n      intersectObject( children[ i ], raycaster, intersects, true );\n\n\n    }\n\n  }\n\n}\n\n\n不同于前面，visible 和 layers 都可以用来控制物体的显示与隐藏，visible 和 layers 只有一个可以用来控制 Raycaster 的行为，具体是哪一个生效，可以看下 Three.js的迁移指南。\n\n可以看到，从 r114 版本，废除了 visible ，开始使用 layers 控制 Raycaster 的行为：\n\n> r113 → r114 Raycaster honors now invisible 3D objects in intersection tests. Use the new property Raycaster.layers for selectively ignoring 3D objects during raycasting.\n\n\n# 总结\n\n从上面可以看出，visible 和 layers 在控制物体显示与隐藏、Raycaster 是否进行等方面是存在差异的。\n\n当该物体的 visible 属性为 false 并且 layers 属性测试失败的时候，行为总结如下：\n\n\n\n\n# Clock\n\nClock本质上就是对Date进行封装，提供了一些方法和属性，当你通过Threejs编写一些和时间相关程序时候，不用在对Date进行封装，直接调用Clock对象的方法和属性即可。\n\n通过Three.js实现一些动画功能往往需要Clock对象获得一些时间数据，比如骨骼动画、变形动画、粒子动画。\n\n\n# .getDelta ()方法\n\n.getDelta ()是Clock对象比较常用的方法，默认情况下，简单说.getDelta ()方法的功能就是获得前后两次执行该方法的时间间隔，假设你执行一次.getDelta ()方法，再执行一次.getDelta ()方法，第二次执行.getDelta ()方法时候，可以返回上次调用该方法到本次调用之间的时间间隔，返回间隔时间单位是秒，可以参考下面的代码案例理解。\n\n\n# 两帧渲染时间间隔\n\n代码功能：下面一段的代码功能就是通过Clock对象的方法.getDelta()获得Threejs本次执行渲染方法.render()和上次执行渲染方法.render()的时间间隔，简单的说就是通过.getDelta()方法获得Three.js两帧渲染时间间隔。\n\n阅读下面代码你应该首先对Threejs的渲染方法有一定的概念，Threejs渲染器的渲染方法.render()每执行一次就得到一帧图像，渲染效果也就是图像会显示在Cnavas画布上，如果一个三维场景是不停变化的，肯定要周期性调用执行.render()方法，更新canvas画布显示内容，一帧帧图像随着时间变化，这样就展现出来一个动画效果。为了周期性执行渲染器渲染方法.render()，一般通过浏览器的APIrequestAnimationFrame实现，浏览器会控制渲染频率，一般性能理想的情况下，每秒s渲染60次左右，在实际的项目中，如果需要渲染的场景比较复杂，一般都会低于60，也就是渲染的两帧时间间隔大于16.67ms。\n\n// 创建一个时钟对象Clock\nvar clock = new THREE.Clock();\nfunction render() {\n  renderer.render(scene, camera); //执行渲染方法，渲染出来一帧图像\n  requestAnimationFrame(render); //周期性执行渲染函数\n  //clock.getDelta()方法获得两帧的时间间隔\n  var T = clock.getDelta();//返回时间单位：秒\n  // 可以在控制打印查看你的渲染时间间隔\n  console.log('两帧渲染时间间隔',T*1000+'毫秒');\n  console.log('查看每秒渲染频率',1/T);\n}\nrender();\n\n\n\n# 属性.autoStart: Boolean\n\n如果设置为 true，则在第一次 update 时开启时钟Clock。默认值是 true。\n\n\n# 属性.startTime : Float\n\n存储时钟Clock最后一次调用 start 方法的时间\n\n\n# 属性.startTime : Float\n\n存储时钟Clock最后一次调用 start, getElapsedTime 或 getDelta 方法的时间。\n\n\n# 属性.elapsedTime : Float\n\n保存时钟Clock运行的总时长。\n\n\n# 属性.running : Boolean\n\n判断时钟Clock是否在运行。\n\n\n# 方法.start ()\n\n启动时钟。同时将 startTime 和 oldTime 设置为当前时间。 设置 elapsedTime 为 0，并且设置 running 为 true\n\n\n# 方法.stop ()\n\n停止时钟。同时将 oldTime 设置为当前时间。\n\n\n# 方法.getElapsedTime ()\n\n获取自时钟启动后的秒数，摒弃将 oldTime 设置为当前时间。 如果 autoStart 设置为 true 且时钟并未运行，则该方法同时启动时钟。\n\n\n# 方法.getDelta ()\n\n获取自 oldTime 设置后到当前的秒数。 同时将 oldTime 设置为当前时间。 如果 autoStart 设置为 true 且时钟并未运行，则该方法同时启动时钟。\n\n\n# 案例\n\n\n# 地球绕太阳自转公转\n\n\n\n<!DOCTYPE html>\n<html lang=\"en\">\n\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>地球绕太阳转</title>\n  </head>\n\n  <body>\n    <canvas id=\"c2d\" class=\"c2d\" width=\"1000\" height=\"500\"></canvas>\n    <script type=\"module\">\n      // 官网地址\n      import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r132/build/three.module.js'\n      import { OrbitControls } from 'https://threejsfundamentals.org/threejs/resources/threejs/r132/examples/jsm/controls/OrbitControls.js'\n\n      const canvas = document.querySelector('#c2d')\n      // 渲染器\n      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true })\n\n      const fov = 40 // 视野范围\n      const aspect = 2 // 相机默认值 画布的宽高比\n      const near = 0.1 // 近平面\n      const far = 1000 // 远平面\n      // 透视投影相机\n      const camera = new THREE.PerspectiveCamera(fov, aspect, near, far)\n\n      // 相机位置\n      camera.position.set(0, 0, 50)\n      camera.up.set(0, 0, 1)\n      camera.lookAt(0, 0, 0)\n      // 控制相机\n      const controls = new OrbitControls(camera, canvas)\n      controls.update()\n\n      // 纹理加载器\n      const loader = new THREE.TextureLoader()\n      // 创建场景\n      const scene = new THREE.Scene()\n      // 添加星空背景，修改背景展示图片纹理。\n      const bgTexture = loader.load('./img/c8f87a1ea32adff09847c25aaaa9a6fe.jpeg')\n      scene.background = bgTexture\n\n      // 添加太阳\n      // 物体网格对象\n      const objects = []\n      {\n        // 一球多用\n        const radius = 2\n        const widthSegments = 36\n        const heightSegments = 36\n        const sphereGeometry = new THREE.SphereGeometry(radius, widthSegments, heightSegments)\n\n        // 太阳\n        const sunTexture = loader.load('./img/a7053dd646bb89e1b27fe8ac08a4d8f4.jpeg')\n        const sunMaterial = new THREE.MeshBasicMaterial({ map: sunTexture })\n        const sunMesh = new THREE.Mesh(sphereGeometry, sunMaterial)\n        // 放大3倍\n        sunMesh.scale.set(3, 3, 3)\n        // scene.add(sunMesh)\n        // 放入控制对象\n        objects.push(sunMesh)\n\n\n        // 地球\n        const earthTexture = loader.load('./img/a282e216f7f48eb6c7db198788858ba3.jpeg')\n        const earthMaterial = new THREE.MeshPhongMaterial({\n          map: earthTexture\n        })\n        const earthMesh = new THREE.Mesh(sphereGeometry, earthMaterial)\n        earthMesh.position.x = 20\n        // scene.add(earthMesh)\n        // 放入控制对象\n        objects.push(earthMesh)\n\n        // 屏蔽掉 太阳加入全局场景\n        // scene.add(sunMesh) \n        // 屏蔽掉 地球加入全局场景\n        // scene.add(earthMesh)\n\n        // 太阳系 物体对象\n        const solarSystem = new THREE.Object3D()\n        scene.add(solarSystem)\n        objects.push(solarSystem)\n\n        solarSystem.add(sunMesh)\n        solarSystem.add(earthMesh)\n\n\n        // 同样的月球要围绕地球转，添加一个地月系到太阳系中旋转。\n        // earthMesh.position.x = 20\n        // solarSystem.add(earthMesh)\n\n        // 地月系 物体对象\n        const landOrbit = new THREE.Object3D()\n        landOrbit.position.x = 20\n        solarSystem.add(landOrbit)\n        // objects.push(landOrbit)\n\n        // 月球\n        const moonTexture = loader.load('../img/2.jpg')\n        const moonMaterial = new THREE.MeshPhongMaterial({ map: moonTexture })\n        const moonMesh = new THREE.Mesh(sphereGeometry, moonMaterial)\n        moonMesh.scale.set(0.5, 0.5, 0.5)\n        moonMesh.position.x = 5\n        objects.push(moonMesh)\n\n        // 加入地月系\n        landOrbit.add(earthMesh)\n        landOrbit.add(moonMesh)\n\n      }\n\n\n      {\n        const color = 0xffffff\n        const intensity = 1\n        // 创建光源\n        const light = new THREE.PointLight(color, intensity)\n        // 光源 加入场景\n        scene.add(light)\n      }\n\n      function render(time) {\n        time *= 0.001\n        /* \n        1.创建一个球几何体，太阳、地球、月亮都是球形，我们可以公用一个球体。\n        2.使用基础材质加载太阳纹理。因为灯光是点光源，发光点在中心，太阳也在中心，使用其他材质是无法接收光源。\n        3.太阳比其他球体大，放大3倍。\n      */\n        // 网格对象 旋转\n        objects.forEach((obj) => {\n          obj.rotation.y = time\n        })\n\n        // 加载渲染器\n        renderer.render(scene, camera)\n\n        // 开始动画\n        requestAnimationFrame(render)\n      }\n\n      // 开始渲染\n      requestAnimationFrame(render)\n    <\/script>\n  </body>\n</html>\n\n\n\n# 球体按轨迹运动_WebGL三维场景\n\n效果图\n\n\n\n<!DOCTYPE html>\n<html lang=\"en\">\n\n  <head>\n    <meta charset=\"UTF-8\">\n    <title>第一个three.js文件_WebGL三维场景</title>\n    <style>\n      body {\n        margin: 0;\n        overflow: hidden; //隐藏body窗口区域滚动条\n      }\n    </style>\n    \x3c!--引入three.js三维引擎--\x3e\n    \x3c!-- <script src=\"./3D/example/three.min.js\"><\/script> --\x3e\n    <script src=\"https://threejs.org/build/three.js\"><\/script>\n    \x3c!--引入轨道控件OrbitControls.js--\x3e\n    <script src=\"./3D/example/OrbitControls.js\"><\/script>\n  </head>\n\n  <body>\n\n    <script>\n      /**\n     * 创建场景对象\n     */\n      var scene = new THREE.Scene();\n      /**\n     * 创建一个设置重复纹理的管道\n     */\n      var curve = new THREE.CatmullRomCurve3([\n        new THREE.Vector3(-80, -40, 0),\n        new THREE.Vector3(-70, 40, 0),\n        new THREE.Vector3(70, 40, 0),\n        new THREE.Vector3(80, -40, 0)\n      ],false/*是否闭合*/);\n      var tubeGeometry = new THREE.TubeGeometry(curve, 100, 0.6, 50, false);\n      var textureLoader = new THREE.TextureLoader();\n      var texture = textureLoader.load('run.jpg');\n      // 设置阵列模式为 RepeatWrapping\n      texture.wrapS = THREE.RepeatWrapping\n      texture.wrapT=THREE.RepeatWrapping\n      // 设置x方向的偏移(沿着管道路径方向)，y方向默认1\n      //等价texture.repeat= new THREE.Vector2(20,1)\n      texture.repeat.x = 20;\n      var tubeMaterial = new THREE.MeshPhongMaterial({\n        map: texture,\n        transparent: true,\n      });\n      var tube = new THREE.Mesh(tubeGeometry, tubeMaterial);\n      scene.add(tube)\n      /**\n     * 创建一个半透明管道\n     */\n      var tubeGeometry2 = new THREE.TubeGeometry(curve, 100, 2, 50, false);\n      var tubeMaterial2 = new THREE.MeshPhongMaterial({\n        color: 0x4488ff,\n        transparent: true,\n        opacity: 0.3,\n      });\n      var tube2 = new THREE.Mesh(tubeGeometry2, tubeMaterial2);\n      scene.add(tube2)\n\n      scene.add(new THREE.AxesHelper(300))\n\n      //小人box\n      //geometryP = new THREE.CircleGeometry( 5, 32 );\n      geometryP = new THREE.SphereGeometry(5,16,16);\n      console.log('geometryP',geometryP);\n      var materialP = new THREE.MeshBasicMaterial( { color: 0xff0000 ,side:THREE.DoubleSide} );\n      circleP = new THREE.Mesh( geometryP, materialP );\n      scene.add( circleP );\n      geometryP.rotateY(Math.PI/2);\n\n      circleP.position.set(-80, -40, 0);\n      console.log(circleP);\n\n      /**\n     * 光源设置\n     */\n      //点光源\n      var point = new THREE.PointLight(0xffffff);\n      point.position.set(400, 200, 300); //点光源位置\n      scene.add(point); //点光源添加到场景中\n      //环境光\n      var ambient = new THREE.AmbientLight(0x888888);\n      scene.add(ambient);\n      /**\n     * 相机设置\n     */\n      var width = window.innerWidth; //窗口宽度\n      var height = window.innerHeight; //窗口高度\n      var k = width / height; //窗口宽高比\n      var s = 100; //三维场景缩放系数\n      //创建相机对象\n      var camera = new THREE.OrthographicCamera(-s * k, s * k, s, -s, 1, 1000);\n      camera.position.set(200, 300, 200); //设置相机位置\n      camera.lookAt(scene.position); //设置相机方向(指向的场景对象)\n      /**\n     * 创建渲染器对象\n     */\n      var renderer = new THREE.WebGLRenderer({\n        antialias: true\n      });\n      renderer.setSize(width, height);\n      // renderer.setClearColor(0xb9d3ff,1);//设置背景颜色\n      document.body.appendChild(renderer.domElement); //body元素中插入canvas对象\n\n      var progress=0;\t\n\n      // 渲染函数\n      function render() {\n        renderer.render(scene, camera); //执行渲染操作\n        requestAnimationFrame(render);\n        // 使用加减法可以设置不同的运动方向\n        // 设置纹理偏移\n        texture.offset.x -= 0.06\n\n        if(progress>1.0){\n          return;    //停留在管道末端,否则会一直跑到起点 循环再跑\n        }\n        progress += 0.0009;\n        console.log(progress);\n        if(curve){\n          let point = curve.getPoint(progress);\n          if(point&&point.x){\n            circleP.position.set(point.x,point.y,point.z);\n          }\n        }\n\n      }\n      render();\n      var controls = new THREE.OrbitControls(camera); //创建控件对象\n    <\/script>\n  </body>\n</html>\n\n\n\n# Three.js三维地图可视化\n\n# 实现一个简单的Three.js三维地图\n\n// 首先创建一个场景\nvar scene = new THREE.Scene();\n\n// 创建一个渲染器，使用WebGL技术\nvar renderer = new THREE.WebGLRenderer();\n\n// 设置渲染器的大小为窗口大小\nrenderer.setSize(window.innerWidth, window.innerHeight);\n\n// 将渲染器添加到DOM中\ndocument.body.appendChild(renderer.domElement);\n\n// 创建一个立方体作为地图\nvar geometry = new THREE.CubeGeometry(500, 500, 10);\n\n// 给立方体添加颜色\nvar material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });\n\n// 将几何体和材质组合成一个网格对象\nvar cube = new THREE.Mesh(geometry, material);\n\n// 将网格对象添加到场景中\nscene.add(cube);\n\n// 创建一个摄像机，设置视野和位置\nvar camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\ncamera.position.z = 100;\n\n// 创建一个光源\nvar light = new THREE.AmbientLight(0xffffff);\nscene.add(light);\n\n// 渲染器渲染场景和摄像机\nrenderer.render(scene, camera);\n\n\n运行代码，我们可以在浏览器中看到一个绿色的立方体，这就是我们实现的一个简单的Three.js三维地图。\n\n\n# 可视化地图——three.js实现\n\n# 场景的搭建\n\nclass chinaMap {\n  constructor() {\n    this.init()\n  }\n\n  init() {\n    // 第一步新建一个场景\n    this.scene = new THREE.Scene()\n    this.setCamera()\n    this.setRenderer()\n  }\n\n  // 新建透视相机\n  setCamera() {\n    // 第二参数就是 长度和宽度比 默认采纳浏览器  返回以像素为单位的窗口的外部宽度和高度\n    this.camera = new THREE.PerspectiveCamera(\n      75,\n      window.innerWidth / window.innerHeight,\n      0.1,\n      1000\n    )\n  }\n\n  // 设置渲染器\n  setRenderer() {\n    this.renderer = new THREE.WebGLRenderer()\n    // 设置画布的大小\n    this.renderer.setSize(window.innerWidth, window.innerHeight)\n    //这里 其实就是canvas 画布  renderer.domElement\n    document.body.appendChild(this.renderer.domElement)\n  }\n\n  // 设置环境光\n  setLight() {\n    this.ambientLight = new THREE.AmbientLight(0xffffff) // 环境光\n    this.scene.add(ambientLight)\n  }\n}\n\n\n# 渲染\n\ninit() {\n  //第一步新建一个场景\n  this.scene = new THREE.Scene()\n  this.setCamera()\n  this.setRenderer()\n  const geometry = new THREE.BoxGeometry()\n  const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 })\n  const cube = new THREE.Mesh(geometry, material)\n  this.scene.add(cube)\n  this.render()\n}\n\n//render 办法 \nrender() {\n  this.renderer.render(this.scene, this.camera)\n}\n\n\n# 距离设置\n\n默认状况下，当咱们调用scene.add()的时候，物体将会被增加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了避免这种状况的产生，咱们只须要将摄像机略微向外挪动一些即可\n\n// 新建透视相机\nsetCamera() {\n  // 第二参数就是 长度和宽度比 默认采纳浏览器  返回以像素为单位的窗口的外部宽度和高度\n  this.camera = new THREE.PerspectiveCamera(\n    75,\n    window.innerWidth / window.innerHeight,\n    0.1,\n    1000\n  )\n  this.camera.position.z = 5\n}\n\n\n# 动态旋转\n\ninit() {\n  //第一步新建一个场景\n  this.scene = new THREE.Scene()\n  this.setCamera()\n  this.setRenderer()\n  const geometry = new THREE.BoxGeometry()\n  const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 })\n  this.cube = new THREE.Mesh(geometry, material)\n  this.scene.add(this.cube)\n  this.animate()\n}\n\nrender() {\n  this.renderer.render(this.scene, this.camera)\n}\n\nanimate() {\n  requestAnimationFrame(this.animate.bind(this))\n  this.cube.rotation.x += 0.01\n  this.cube.rotation.y += 0.01\n  this.render()\n}\n\n\n# 地图数据的取得\n\n把中国地图的数据json拷贝下来\n\n// 加载地图数据\nloadMapData() {\n  const loader = new THREE.FileLoader()\n  loader.load('../json/china.json', (data) => {\n    const jsondata = JSON.parse(JSON.stringify(data))\n    })\n}\n\n\n其实次要的是上面有个经纬度坐标， 其实这个才是我关怀的，有了点能力生成线，最初能力生成立体。 这里波及到一个知识点， 墨卡托投影转换。 墨卡托投影转换能够把咱们经纬度坐标转换成咱们对应立体的2d坐标。\n\n间接用可视化框架——d3 它外面有自带的墨卡托投影转换。\n\n// 墨卡托投影转换\nconst projection = d3\n.geoMercator()\n.center([104.0, 37.5])\n.scale(80)\n.translate([0, 0])\n\n\nObject3d是three.js 所有的基类, 提供了一系列的属性和办法来对三维空间中的物体进行操纵。能够通过.add( object )办法来将对象进行组合，该办法将对象增加为子对象\n\n我这里的整个中国是一个大的Object3d，每一个省是一个Object3d，省是挂在中国下的。 而后中国这个Map挂在scene这个Object3d下。 很显著，在three.js 是一个很典型的树形数据结构，我画了张图给大家看下。\n\nScence场景下挂了很多货色， 其中有一个就是Map, 整个地图， 而后每个省份， 每个省份又是由Mesh和lLine 组成的。\n\ngenerateGeometry(jsondata) {\n  // 初始化一个地图对象\n  this.map = new THREE.Object3D()\n  // 墨卡托投影转换\n  const projection = d3\n  .geoMercator()\n  .center([104.0, 37.5])\n  .scale(80)\n  .translate([0, 0])\n\n  jsondata.features.forEach((elem) => {\n    // 定一个省份3D对象\n    const province = new THREE.Object3D()\n    this.map.add(province)\n  })\n  this.scene.add(this.map)\n}\n\n\n# 生成地图几何体\n\nThree.shape() 和 THREE.ExtrudeGeometry（） 为什么会用到这个呢？ 我给大家解释下， 首先每一个省份轮廓组成的下标是一个 2d坐标，然而咱们要生成立方体，shape() 能够定义一个二维形态立体。 它能够和ExtrudeGeometry一起应用，获取点，或者获取三角面。\n\n// 每个的 坐标 数组\nconst coordinates = elem.geometry.coordinates\n// 循环坐标数组\ncoordinates.forEach((multiPolygon) => {\n  multiPolygon.forEach((polygon) => {\n    const shape = new THREE.Shape()\n    const lineMaterial = new THREE.LineBasicMaterial({\n      color: 'white',\n    })\n    const lineGeometry = new THREE.Geometry()\n\n    for (let i = 0; i < polygon.length; i++) {\n      const [x, y] = projection(polygon[i])\n      if (i === 0) {\n        shape.moveTo(x, -y)\n      }\n      shape.lineTo(x, -y)\n      lineGeometry.vertices.push(new THREE.Vector3(x, -y, 4.01))\n    }\n\n    const extrudeSettings = {\n      depth: 10,\n      bevelEnabled: false,\n    }\n\n    const geometry = new THREE.ExtrudeGeometry(\n      shape,\n      extrudeSettings\n    )\n    const material = new THREE.MeshBasicMaterial({\n      color: '#2defff',\n      transparent: true,\n      opacity: 0.6,\n    })\n    const material1 = new THREE.MeshBasicMaterial({\n      color: '#3480C4',\n      transparent: true,\n      opacity: 0.5,\n    })\n\n    const mesh = new THREE.Mesh(geometry, [material, material1])\n    const line = new THREE.Line(lineGeometry, lineMaterial)\n    province.add(mesh)\n    province.add(line)\n  })\n})\n\n\n遍历第一个点的的和canvas2d画图其实是截然不同的， 挪动终点， 而后前面在划线， 画出轮廓。而后咱们在这里能够设置拉伸的深度， 而后接下来就是设置材质了。lineGeometry 其实 对应的是轮廓的边线\n\n# 相机辅助视图\n\n为了不便调相机地位， 我减少了辅助视图， cameraHelper。 而后你回看下屏幕会呈现一个十字架，而后咱们就能够一直地调整相机的地位，让咱们地地图处于画面的地方\n\naddHelper() {\n  const helper = new THREE.CameraHelper(this.camera)\n  this.scene.add(helper)\n}\n\n\n# 减少交互控制器\n\n当初地图是曾经生成了，然而用户交互感比拟差，这里咱们引入three的OrbitControls 能够用鼠标在画面随便转动，就能够看到立方体的每一个局部了。然而这个办法不在three 的包外面， 得独自引入一个文件\n\n<div id=\"canvas\"></div>\n\n\n// 设置渲染器\nsetRenderer() {\n  this.renderer = new THREE.WebGLRenderer()\n  // 设置画布的大小\n  this.renderer.setSize(window.innerWidth, window.innerHeight)\n  //这里 其实就是canvas 画布  renderer.domElement（需要更改成canvas的盒子）\n  // document.body.appendChild(this.renderer.domElement)\n  document.getElementById(\"canvas\").appendChild(this.renderer.domElement);\n}\n\nsetController() {\n  this.controller = new THREE.OrbitControls(\n    this.camera,\n    document.getElementById('canvas')\n  )\n}\n\n\n# 射线追踪\n\n然而对于我本人而言还是不称心， 我怎么晓得的我点击的是哪一个省份呢，OK这时候就要引入咱们three中十分重要的一个类了，Raycaster 。\n\n> 这个类用于进行raycasting（光线投射）。 光线投射用于进行鼠标拾取（在三维空间中计算出鼠标移过了什么物体）。\n\n咱们能够对canvas监听的onmouseMove 事件，而后 咱们就能够晓得以后挪动的鼠标是抉择的哪一个mesh。然而在这之前，咱们先对每一个province这个对象上减少一个属性来示意他是哪一个省份的。\n\n// 将省份的属性 加进来\nprovince.properties = elem.properties\n\n\nOk, 咱们能够引入射线追踪了带入如下：\n\nsetRaycaster() {\n  this.raycaster = new THREE.Raycaster()\n  this.mouse = new THREE.Vector2()\n  const onMouseMove = (event) => {\n    // 将鼠标地位归一化为设施坐标。x 和 y 方向的取值范畴是 (-1 to +1)\n    this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1\n    this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1\n  }\n  window.addEventListener('mousemove', onMouseMove, false)\n}\n\nanimate() {\n  requestAnimationFrame(this.animate.bind(this))\n  // 通过摄像机和鼠标地位更新射线\n  this.raycaster.setFromCamera(this.mouse, this.camera)\n  this.render()\n}\n\n\n因为咱们不停地在在画布挪动， 所以须要不停的的射线地位。当初有了射线， 那咱们须要场景的所有货色去比拟了，rayCaster 也提供了办法代码如下：\n\nconst intersects = this.raycaster.intersectObjects(\n  this.scene.children, // 场景的\n  true  // 若为true，则同时也会检测所有物体的后辈。否则将只会检测对象自身的相交局部\n)\n\n\n这个intersects失去的穿插很多，然而呢咱们只抉择其中一个，那就是物体材质个数有两个的， 因为咱们下面就是用对mesh用两个材质\n\nconst mesh = new THREE.Mesh(geometry, [material, material1])\n\n\n所以过滤代码如下\n\nanimate() {\n  requestAnimationFrame(this.animate.bind(this))\n  // 通过摄像机和鼠标地位更新射线\n  this.raycaster.setFromCamera(this.mouse, this.camera)\n  // 算出射线 与当场景相交的对象有那些\n  const intersects = this.raycaster.intersectObjects(\n    this.scene.children,\n    true\n  )\n  const find = intersects.find(\n    (item) => item.object.material && item.object.material.length === 2\n  )\n\n  this.render()\n}\n\n\n我怎么晓得我到底找到没，咱们对找到的mesh将它的外表变成灰色，然而这样会导致一个问题，咱们鼠标再一次挪动的时候要把上一次的材质给他恢复过来。\n\n代码如下：\n\nanimate() {\n  requestAnimationFrame(this.animate.bind(this))\n  // 通过摄像机和鼠标地位更新射线\n  this.raycaster.setFromCamera(this.mouse, this.camera)\n  // 算出射线 与当场景相交的对象有那些\n  const intersects = this.raycaster.intersectObjects(\n    this.scene.children,\n    true\n  )\n  // 复原上一次清空的\n  if (this.lastPick) {\n    this.lastPick.object.material[0].color.set('#2defff')\n    this.lastPick.object.material[1].color.set('#3480C4')\n  }\n  this.lastPick = null\n  this.lastPick = intersects.find(\n    (item) => item.object.material && item.object.material.length === 2\n  )\n  if (this.lastPick) {\n    this.lastPick.object.material[0].color.set(0xff0000)\n    this.lastPick.object.material[1].color.set(0xff0000)\n  }\n\n  this.render()\n}\n\n\n看下效果图：\n\n# 减少tooltip\n\n为了让交互更加完满，找到了同时在鼠标右下方显示个tooltip，那这个必定是一个div默认是影藏的，而后依据鼠标的挪动挪动相应的地位。\n\n第一步新建div\n\n<div id=\"tooltip\"></div>\n\n\n第二步设置款式 默认是影藏的\n\n#tooltip {\n  position: absolute;\n  z-index: 2;\n  background: white;\n  padding: 10px;\n  border-radius: 2px;\n  visibility: hidden;\n}\n\n\n第三步更改div的地位：\n\nsetRaycaster() {\n  this.raycaster = new THREE.Raycaster()\n  this.mouse = new THREE.Vector2()\n  this.tooltip = document.getElementById('tooltip')\n  const onMouseMove = (event) => {\n    this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1\n    this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1\n    // 更改div地位\n    this.tooltip.style.left = event.clientX + 2 + 'px'\n    this.tooltip.style.top = event.clientY + 2 + 'px'\n  }\n\n  window.addEventListener('mousemove', onMouseMove, false)\n}\n\n\n最初一步设置tooltip的名字：\n\nshowTip() {\n  // 显示省份的信息\n  if (this.lastPick) {\n    const properties = this.lastPick.object.parent.properties\n\n    this.tooltip.textContent = properties.name\n\n    this.tooltip.style.visibility = 'visible'\n  } else {\n    this.tooltip.style.visibility = 'hidden'\n  }\n}\n\n\n到这里，整个3d可视化地球我的项目曾经实现了",normalizedContent:"# three.js\n\nthree.js中文网\n\n\n# three.js文档结构\n\n通过下面的树状图简单展示了从three.js官网下载的文件three.js-master包含的子文件，有些内容已经在线部署，可以通过树状图上的超链接直接访问。\n\n\n\n<!doctype html>\n<html lang=\"en\">\n  <head>\n\n    \x3c!--引入three.js三维引擎--\x3e\n    <script src=\"http://www.yanhuangxueyuan.com/3d/example/three.min.js\"><\/script>\n  </head>\n  <body>\n    <script>\n      /**\n        * 创建场景对象\n       */\n      var scene=new three.scene();\n      /**\n       * 创建网格模型\n       */\n      var box=new three.boxgeometry(100,100,100);//创建一个立方体几何对象\n      var material=new three.meshlambertmaterial({color:0x0000ff});//材质对象\n      var mesh=new three.mesh(box,material);//网格模型对象\n      scene.add(mesh);//网格模型添加到场景中\n\n\n      /**\n        * 创建渲染器对象\n        */\n      var renderer=new three.webglrenderer();\n      renderer.setsize(width,height);\n      renderer.setclearcolor(0xb9d3ff,1);//设置背景颜色\n      document.body.appendchild(renderer.domelement);//body元素中插入canvas对象\n      //执行渲染操作\n      renderer.render(scene,camera);\n    <\/script>\n  </body>\n</html>\n\n\nvar geometry = new three.geometry(); //声明一个空几何体对象\nvar p1 = new three.vector3(0,0,0); //顶点1坐标\nvar p2 = new three.vector3(80,0,0); //顶点2坐标\nvar p3 = new three.vector3(0,80,0); //顶点3坐标\ngeometry.vertices.push(p1,p2,p3); //顶点坐标添加到geometry对象\nvar face = new three.face3( 0, 1, 2, normal); //创建三角面\n/**顶点颜色**/\nvar color1 = new three.color(0xff0000);//顶点1颜色——红色\nvar color2 = new three.color(0x00ff00);//顶点2颜色——绿色\nvar color3 = new three.color(0x0000ff);//顶点3颜色——蓝色\nvar normal = new three.vector3( 0, 0, 1 ); //三角面法向量\nface.vertexcolors.push(color1, color2,color3);//定义三角面三个顶点的颜色\ngeometry.faces.push( face ); //三角面添加到几何体\n\n\n\n# three.js控制物体显示与隐藏的方法\n\n主要包括以下几种方式：\n\n 1. visible属性；\n 2. layers属性。\n\n\n# visible属性\n\nvisible 是object3d的属性。只有当 visible 是 true 的时候，该物体才会被渲染。任何继承 object3d 的对象都可以通过该属性去控制它的显示与否，比如：mesh，group，sprite，light等。\n\n举个简单的例子：\n\n// 控制单个物体的显示和隐藏\n\nconst geometry = new three.planegeometry(1, 1) // 1*1的一个平面\n\nconst planematerial = new three.meshbasicmaterial({ color: 0x00ff00 }) // 红色平面\n\nconst plane = new three.mesh(geometry, planematerial)\n\nplane.visible = false // 不显示单个物体\n\nscene.add(plane)\n// 控制一组物体的显示和隐藏\nconst geometry = new three.planegeometry(1, 1)\nconst planematerial = new three.meshbasicmaterial({ color: 0x00ff00 })\nconst plane = new three.mesh(geometry, planematerial)\nconst group = new three.group()\ngroup.add(plane)\ngroup.visible = false // 不显示一组物体\n\nscene.add(group)\n\n\n通过后面的例子可以看出，当我们想要控制一组物体的显示与隐藏，可以把这些物体放入一个 group 中，只通过控制 group 的显示与隐藏即可。\n\n这块的代码逻辑是在webglrenderer.js的 projectobject 方法中实现的。\n\n首先，在 render 方法中调用了 projectobject 方法：\n\nthis.render = function ( scene, camera ) {\n  // ...\n\n  projectobject( scene, camera, 0, _this.sortobjects );\n  // ...\n\n}\n\n\nprojectobject 方法的定义如下：\n\nfunction projectobject( object, camera, grouporder, sortobjects ) {\n  if ( object.visible === false ) return; // 注释1：visible属性是false直接返回\n  // ...\n\n  var children = object.children; // 注释2：递归应用在children上\n\n  for ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\n    projectobject( children[ i ], camera, grouporder, sortobjects ); // 注释2：递归应用在children上\n\n\n  }\n\n}\n\n\n从注释1可以看出，如果 group 的 visible 是 false，那么就不会在 children 上递归调用，所以就能达到通过 group 控制一组对象的显示与隐藏的效果。\n\n当 visible 是 false 的时候，raycaster 的 intersectobject 或者 intersectobjects 也不会把该物体考虑在内。这块的代码逻辑是在 raycaster.js：\n\nintersectobject: function ( object, recursive, optionaltarget ) {\n// ...\n\n  intersectobject( object, this, intersects, recursive ); // 注释1：调用了公共方法intersectobject\n// ...\n\n},\n\n\nintersectobjects: function ( objects, recursive, optionaltarget ) {\n// ...\n\nfor ( var i = 0, l = objects.length; i < l; i ++ ) {\n\n\n    intersectobject( objects[ i ], this, intersects, recursive ); // 注释1：循环调用了公共方法intersectobject\n\n\n  }\n// ...\n\n}\n\n// 注释1：公共方法intersectobject\nfunction intersectobject( object, raycaster, intersects, recursive ) {\n\nif ( object.visible === false ) return; // 注释1：如果visible是false，直接return\n\n// ...\n\n}\n\n\n从注释1可以看出，如果 group 或者单个物体的 visible 是 false ，就不做检测了。\n\n\n# layers属性\n\nobject3d的layers属性 是一个 layers 对象。任何继承 object3d 的对象都有这个属性，比如 camera 。raycaster 虽然不是继承自 object3d ，但它同样有 layers 属性（r113版本以上）。\n\n和上面的 visible 属性一样，layers 属性同样可以控制物体的显示与隐藏、raycaster 的行为。当物体和相机至少有一个同样的层的时候，物体就可见，否则不可见。同样，当物体和 raycaster 至少有一个同样的层的时候，才会进行是否相交的测试。这里，强调了是至少有一个，是因为 layers 可以设置多个层。\n\nlayers 一共可以表示 32 个层，0 到 31 层。内部表示为：\n\n\n\nlayers 可以设置同时拥有多个层：\n\n 1. 可以通过 layers 的 enable 和 disable 方法开启和关闭当前层，参数是上面表格中的 0 到 31 。\n 2. 可以通过 layers 的 set 方法 只开启 当前层，参数是上述表格中的 0 到 31。\n 3. 可以通过 layers 的 test 的方法判断两个 layers 对象是否存在 至少一个公共层 。\n\n当开启多个层的时候，其实就是上述表格中的二进制进行 按位或 操作。比如 同时 开启 0、2、31 层，那么内部存储的值就是 10000000000000000000000000000101。\n\nlayers 属性默认只开启 0 层。\n\n还是上面那个例子，我们看下怎么控制物体的显示和隐藏：\n\n// 控制单个物体的显示和隐藏\n\nconst geometry = new three.planegeometry(1, 1)\n\nconst planematerial = new three.meshbasicmaterial({ color: 0x00ff00 })\n\nconst plane = new three.mesh(geometry, planematerial)\n\nplane.layers.set(1) // 设置平面只有第1层，相机默认是在第0层，所以该物体不会显示出来\n\nscene.add(plane)\n// 控制一组物体的显示和隐藏\nconst geometry = new three.planegeometry(1, 1)\nconst planematerial = new three.meshbasicmaterial({ color: 0x00ff00 })\nconst plane = new three.mesh(geometry, planematerial)\nconst group = new three.group()\ngroup.layers.set(1) // 注释1: 设置group只有第一层，相机默认是在第0层，但是此时平面物体还是显示出来了？\ngroup.add(plane)\n\nscene.add(group)\n\n\n设置单个物体的 layer 可以看到物体成功的没有显示出来。但是，当我们给 group 设置 layer 之后，发现 group 的 children（平面物体）还是显示了出来。那么，这是什么原因呢？让我们看下源码，同样还是上面的 projectobject 方法：\n\nfunction projectobject( object, camera, grouporder, sortobjects ) {\n\nif ( object.visible === false ) return;\n\n\n  var visible = object.layers.test( camera.layers ); // 注释1：判断物体和相机是否存在一个公共层\n\nif ( visible ) { // 注释1：如果存在，对物体进行下面的处理\n// ...\n\n  }\n\n\n  var children = object.children; // 注释1：不管该物体是否和相机存在一个公共层，都会对children进行递归\n\nfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\n    projectobject( children[ i ], camera, grouporder, sortobjects );\n\n\n  }\n\n}\n\n\n从上述注释1可以看出，即使该物体和相机不存在公共层，也不影响该物体的 children 显示。这也就解释了上述为什么给 group 设置 layers ，但是平面物体还是能显示出来。从这一点上来看，layers 和 visible 属性在控制物体显示和隐藏的方面是不一样的。\n\n和 visible 属性一样，接下来我们看下 layers 对 raycaster 的影响。同样我还是看了 raycaster.js 文件，但是发现根本就没有 layers 字段。后来，我看了下最新版本 r140 的 raycaster.js：\n\nfunction intersectobject( object, raycaster, intersects, recursive ) {\n\nif ( object.layers.test( raycaster.layers ) ) { // 注释1：判断物体和raycaster是否有公共层\n\nobject.raycast( raycaster, intersects );\n\n\n  }\n\nif ( recursive === true ) { // 注释1：不管该物体和raycaster是否有公共层，都不影响children\n\n\n    const children = object.children;\n\nfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\n      intersectobject( children[ i ], raycaster, intersects, true );\n\n\n    }\n\n  }\n\n}\n\n\n不同于前面，visible 和 layers 都可以用来控制物体的显示与隐藏，visible 和 layers 只有一个可以用来控制 raycaster 的行为，具体是哪一个生效，可以看下 three.js的迁移指南。\n\n可以看到，从 r114 版本，废除了 visible ，开始使用 layers 控制 raycaster 的行为：\n\n> r113 → r114 raycaster honors now invisible 3d objects in intersection tests. use the new property raycaster.layers for selectively ignoring 3d objects during raycasting.\n\n\n# 总结\n\n从上面可以看出，visible 和 layers 在控制物体显示与隐藏、raycaster 是否进行等方面是存在差异的。\n\n当该物体的 visible 属性为 false 并且 layers 属性测试失败的时候，行为总结如下：\n\n\n\n\n# clock\n\nclock本质上就是对date进行封装，提供了一些方法和属性，当你通过threejs编写一些和时间相关程序时候，不用在对date进行封装，直接调用clock对象的方法和属性即可。\n\n通过three.js实现一些动画功能往往需要clock对象获得一些时间数据，比如骨骼动画、变形动画、粒子动画。\n\n\n# .getdelta ()方法\n\n.getdelta ()是clock对象比较常用的方法，默认情况下，简单说.getdelta ()方法的功能就是获得前后两次执行该方法的时间间隔，假设你执行一次.getdelta ()方法，再执行一次.getdelta ()方法，第二次执行.getdelta ()方法时候，可以返回上次调用该方法到本次调用之间的时间间隔，返回间隔时间单位是秒，可以参考下面的代码案例理解。\n\n\n# 两帧渲染时间间隔\n\n代码功能：下面一段的代码功能就是通过clock对象的方法.getdelta()获得threejs本次执行渲染方法.render()和上次执行渲染方法.render()的时间间隔，简单的说就是通过.getdelta()方法获得three.js两帧渲染时间间隔。\n\n阅读下面代码你应该首先对threejs的渲染方法有一定的概念，threejs渲染器的渲染方法.render()每执行一次就得到一帧图像，渲染效果也就是图像会显示在cnavas画布上，如果一个三维场景是不停变化的，肯定要周期性调用执行.render()方法，更新canvas画布显示内容，一帧帧图像随着时间变化，这样就展现出来一个动画效果。为了周期性执行渲染器渲染方法.render()，一般通过浏览器的apirequestanimationframe实现，浏览器会控制渲染频率，一般性能理想的情况下，每秒s渲染60次左右，在实际的项目中，如果需要渲染的场景比较复杂，一般都会低于60，也就是渲染的两帧时间间隔大于16.67ms。\n\n// 创建一个时钟对象clock\nvar clock = new three.clock();\nfunction render() {\n  renderer.render(scene, camera); //执行渲染方法，渲染出来一帧图像\n  requestanimationframe(render); //周期性执行渲染函数\n  //clock.getdelta()方法获得两帧的时间间隔\n  var t = clock.getdelta();//返回时间单位：秒\n  // 可以在控制打印查看你的渲染时间间隔\n  console.log('两帧渲染时间间隔',t*1000+'毫秒');\n  console.log('查看每秒渲染频率',1/t);\n}\nrender();\n\n\n\n# 属性.autostart: boolean\n\n如果设置为 true，则在第一次 update 时开启时钟clock。默认值是 true。\n\n\n# 属性.starttime : float\n\n存储时钟clock最后一次调用 start 方法的时间\n\n\n# 属性.starttime : float\n\n存储时钟clock最后一次调用 start, getelapsedtime 或 getdelta 方法的时间。\n\n\n# 属性.elapsedtime : float\n\n保存时钟clock运行的总时长。\n\n\n# 属性.running : boolean\n\n判断时钟clock是否在运行。\n\n\n# 方法.start ()\n\n启动时钟。同时将 starttime 和 oldtime 设置为当前时间。 设置 elapsedtime 为 0，并且设置 running 为 true\n\n\n# 方法.stop ()\n\n停止时钟。同时将 oldtime 设置为当前时间。\n\n\n# 方法.getelapsedtime ()\n\n获取自时钟启动后的秒数，摒弃将 oldtime 设置为当前时间。 如果 autostart 设置为 true 且时钟并未运行，则该方法同时启动时钟。\n\n\n# 方法.getdelta ()\n\n获取自 oldtime 设置后到当前的秒数。 同时将 oldtime 设置为当前时间。 如果 autostart 设置为 true 且时钟并未运行，则该方法同时启动时钟。\n\n\n# 案例\n\n\n# 地球绕太阳自转公转\n\n\n\n<!doctype html>\n<html lang=\"en\">\n\n  <head>\n    <meta charset=\"utf-8\" />\n    <title>地球绕太阳转</title>\n  </head>\n\n  <body>\n    <canvas id=\"c2d\" class=\"c2d\" width=\"1000\" height=\"500\"></canvas>\n    <script type=\"module\">\n      // 官网地址\n      import * as three from 'https://threejsfundamentals.org/threejs/resources/threejs/r132/build/three.module.js'\n      import { orbitcontrols } from 'https://threejsfundamentals.org/threejs/resources/threejs/r132/examples/jsm/controls/orbitcontrols.js'\n\n      const canvas = document.queryselector('#c2d')\n      // 渲染器\n      const renderer = new three.webglrenderer({ canvas, antialias: true })\n\n      const fov = 40 // 视野范围\n      const aspect = 2 // 相机默认值 画布的宽高比\n      const near = 0.1 // 近平面\n      const far = 1000 // 远平面\n      // 透视投影相机\n      const camera = new three.perspectivecamera(fov, aspect, near, far)\n\n      // 相机位置\n      camera.position.set(0, 0, 50)\n      camera.up.set(0, 0, 1)\n      camera.lookat(0, 0, 0)\n      // 控制相机\n      const controls = new orbitcontrols(camera, canvas)\n      controls.update()\n\n      // 纹理加载器\n      const loader = new three.textureloader()\n      // 创建场景\n      const scene = new three.scene()\n      // 添加星空背景，修改背景展示图片纹理。\n      const bgtexture = loader.load('./img/c8f87a1ea32adff09847c25aaaa9a6fe.jpeg')\n      scene.background = bgtexture\n\n      // 添加太阳\n      // 物体网格对象\n      const objects = []\n      {\n        // 一球多用\n        const radius = 2\n        const widthsegments = 36\n        const heightsegments = 36\n        const spheregeometry = new three.spheregeometry(radius, widthsegments, heightsegments)\n\n        // 太阳\n        const suntexture = loader.load('./img/a7053dd646bb89e1b27fe8ac08a4d8f4.jpeg')\n        const sunmaterial = new three.meshbasicmaterial({ map: suntexture })\n        const sunmesh = new three.mesh(spheregeometry, sunmaterial)\n        // 放大3倍\n        sunmesh.scale.set(3, 3, 3)\n        // scene.add(sunmesh)\n        // 放入控制对象\n        objects.push(sunmesh)\n\n\n        // 地球\n        const earthtexture = loader.load('./img/a282e216f7f48eb6c7db198788858ba3.jpeg')\n        const earthmaterial = new three.meshphongmaterial({\n          map: earthtexture\n        })\n        const earthmesh = new three.mesh(spheregeometry, earthmaterial)\n        earthmesh.position.x = 20\n        // scene.add(earthmesh)\n        // 放入控制对象\n        objects.push(earthmesh)\n\n        // 屏蔽掉 太阳加入全局场景\n        // scene.add(sunmesh) \n        // 屏蔽掉 地球加入全局场景\n        // scene.add(earthmesh)\n\n        // 太阳系 物体对象\n        const solarsystem = new three.object3d()\n        scene.add(solarsystem)\n        objects.push(solarsystem)\n\n        solarsystem.add(sunmesh)\n        solarsystem.add(earthmesh)\n\n\n        // 同样的月球要围绕地球转，添加一个地月系到太阳系中旋转。\n        // earthmesh.position.x = 20\n        // solarsystem.add(earthmesh)\n\n        // 地月系 物体对象\n        const landorbit = new three.object3d()\n        landorbit.position.x = 20\n        solarsystem.add(landorbit)\n        // objects.push(landorbit)\n\n        // 月球\n        const moontexture = loader.load('../img/2.jpg')\n        const moonmaterial = new three.meshphongmaterial({ map: moontexture })\n        const moonmesh = new three.mesh(spheregeometry, moonmaterial)\n        moonmesh.scale.set(0.5, 0.5, 0.5)\n        moonmesh.position.x = 5\n        objects.push(moonmesh)\n\n        // 加入地月系\n        landorbit.add(earthmesh)\n        landorbit.add(moonmesh)\n\n      }\n\n\n      {\n        const color = 0xffffff\n        const intensity = 1\n        // 创建光源\n        const light = new three.pointlight(color, intensity)\n        // 光源 加入场景\n        scene.add(light)\n      }\n\n      function render(time) {\n        time *= 0.001\n        /* \n        1.创建一个球几何体，太阳、地球、月亮都是球形，我们可以公用一个球体。\n        2.使用基础材质加载太阳纹理。因为灯光是点光源，发光点在中心，太阳也在中心，使用其他材质是无法接收光源。\n        3.太阳比其他球体大，放大3倍。\n      */\n        // 网格对象 旋转\n        objects.foreach((obj) => {\n          obj.rotation.y = time\n        })\n\n        // 加载渲染器\n        renderer.render(scene, camera)\n\n        // 开始动画\n        requestanimationframe(render)\n      }\n\n      // 开始渲染\n      requestanimationframe(render)\n    <\/script>\n  </body>\n</html>\n\n\n\n# 球体按轨迹运动_webgl三维场景\n\n效果图\n\n\n\n<!doctype html>\n<html lang=\"en\">\n\n  <head>\n    <meta charset=\"utf-8\">\n    <title>第一个three.js文件_webgl三维场景</title>\n    <style>\n      body {\n        margin: 0;\n        overflow: hidden; //隐藏body窗口区域滚动条\n      }\n    </style>\n    \x3c!--引入three.js三维引擎--\x3e\n    \x3c!-- <script src=\"./3d/example/three.min.js\"><\/script> --\x3e\n    <script src=\"https://threejs.org/build/three.js\"><\/script>\n    \x3c!--引入轨道控件orbitcontrols.js--\x3e\n    <script src=\"./3d/example/orbitcontrols.js\"><\/script>\n  </head>\n\n  <body>\n\n    <script>\n      /**\n     * 创建场景对象\n     */\n      var scene = new three.scene();\n      /**\n     * 创建一个设置重复纹理的管道\n     */\n      var curve = new three.catmullromcurve3([\n        new three.vector3(-80, -40, 0),\n        new three.vector3(-70, 40, 0),\n        new three.vector3(70, 40, 0),\n        new three.vector3(80, -40, 0)\n      ],false/*是否闭合*/);\n      var tubegeometry = new three.tubegeometry(curve, 100, 0.6, 50, false);\n      var textureloader = new three.textureloader();\n      var texture = textureloader.load('run.jpg');\n      // 设置阵列模式为 repeatwrapping\n      texture.wraps = three.repeatwrapping\n      texture.wrapt=three.repeatwrapping\n      // 设置x方向的偏移(沿着管道路径方向)，y方向默认1\n      //等价texture.repeat= new three.vector2(20,1)\n      texture.repeat.x = 20;\n      var tubematerial = new three.meshphongmaterial({\n        map: texture,\n        transparent: true,\n      });\n      var tube = new three.mesh(tubegeometry, tubematerial);\n      scene.add(tube)\n      /**\n     * 创建一个半透明管道\n     */\n      var tubegeometry2 = new three.tubegeometry(curve, 100, 2, 50, false);\n      var tubematerial2 = new three.meshphongmaterial({\n        color: 0x4488ff,\n        transparent: true,\n        opacity: 0.3,\n      });\n      var tube2 = new three.mesh(tubegeometry2, tubematerial2);\n      scene.add(tube2)\n\n      scene.add(new three.axeshelper(300))\n\n      //小人box\n      //geometryp = new three.circlegeometry( 5, 32 );\n      geometryp = new three.spheregeometry(5,16,16);\n      console.log('geometryp',geometryp);\n      var materialp = new three.meshbasicmaterial( { color: 0xff0000 ,side:three.doubleside} );\n      circlep = new three.mesh( geometryp, materialp );\n      scene.add( circlep );\n      geometryp.rotatey(math.pi/2);\n\n      circlep.position.set(-80, -40, 0);\n      console.log(circlep);\n\n      /**\n     * 光源设置\n     */\n      //点光源\n      var point = new three.pointlight(0xffffff);\n      point.position.set(400, 200, 300); //点光源位置\n      scene.add(point); //点光源添加到场景中\n      //环境光\n      var ambient = new three.ambientlight(0x888888);\n      scene.add(ambient);\n      /**\n     * 相机设置\n     */\n      var width = window.innerwidth; //窗口宽度\n      var height = window.innerheight; //窗口高度\n      var k = width / height; //窗口宽高比\n      var s = 100; //三维场景缩放系数\n      //创建相机对象\n      var camera = new three.orthographiccamera(-s * k, s * k, s, -s, 1, 1000);\n      camera.position.set(200, 300, 200); //设置相机位置\n      camera.lookat(scene.position); //设置相机方向(指向的场景对象)\n      /**\n     * 创建渲染器对象\n     */\n      var renderer = new three.webglrenderer({\n        antialias: true\n      });\n      renderer.setsize(width, height);\n      // renderer.setclearcolor(0xb9d3ff,1);//设置背景颜色\n      document.body.appendchild(renderer.domelement); //body元素中插入canvas对象\n\n      var progress=0;\t\n\n      // 渲染函数\n      function render() {\n        renderer.render(scene, camera); //执行渲染操作\n        requestanimationframe(render);\n        // 使用加减法可以设置不同的运动方向\n        // 设置纹理偏移\n        texture.offset.x -= 0.06\n\n        if(progress>1.0){\n          return;    //停留在管道末端,否则会一直跑到起点 循环再跑\n        }\n        progress += 0.0009;\n        console.log(progress);\n        if(curve){\n          let point = curve.getpoint(progress);\n          if(point&&point.x){\n            circlep.position.set(point.x,point.y,point.z);\n          }\n        }\n\n      }\n      render();\n      var controls = new three.orbitcontrols(camera); //创建控件对象\n    <\/script>\n  </body>\n</html>\n\n\n\n# three.js三维地图可视化\n\n# 实现一个简单的three.js三维地图\n\n// 首先创建一个场景\nvar scene = new three.scene();\n\n// 创建一个渲染器，使用webgl技术\nvar renderer = new three.webglrenderer();\n\n// 设置渲染器的大小为窗口大小\nrenderer.setsize(window.innerwidth, window.innerheight);\n\n// 将渲染器添加到dom中\ndocument.body.appendchild(renderer.domelement);\n\n// 创建一个立方体作为地图\nvar geometry = new three.cubegeometry(500, 500, 10);\n\n// 给立方体添加颜色\nvar material = new three.meshbasicmaterial({ color: 0x00ff00 });\n\n// 将几何体和材质组合成一个网格对象\nvar cube = new three.mesh(geometry, material);\n\n// 将网格对象添加到场景中\nscene.add(cube);\n\n// 创建一个摄像机，设置视野和位置\nvar camera = new three.perspectivecamera(75, window.innerwidth / window.innerheight, 0.1, 1000);\ncamera.position.z = 100;\n\n// 创建一个光源\nvar light = new three.ambientlight(0xffffff);\nscene.add(light);\n\n// 渲染器渲染场景和摄像机\nrenderer.render(scene, camera);\n\n\n运行代码，我们可以在浏览器中看到一个绿色的立方体，这就是我们实现的一个简单的three.js三维地图。\n\n\n# 可视化地图——three.js实现\n\n# 场景的搭建\n\nclass chinamap {\n  constructor() {\n    this.init()\n  }\n\n  init() {\n    // 第一步新建一个场景\n    this.scene = new three.scene()\n    this.setcamera()\n    this.setrenderer()\n  }\n\n  // 新建透视相机\n  setcamera() {\n    // 第二参数就是 长度和宽度比 默认采纳浏览器  返回以像素为单位的窗口的外部宽度和高度\n    this.camera = new three.perspectivecamera(\n      75,\n      window.innerwidth / window.innerheight,\n      0.1,\n      1000\n    )\n  }\n\n  // 设置渲染器\n  setrenderer() {\n    this.renderer = new three.webglrenderer()\n    // 设置画布的大小\n    this.renderer.setsize(window.innerwidth, window.innerheight)\n    //这里 其实就是canvas 画布  renderer.domelement\n    document.body.appendchild(this.renderer.domelement)\n  }\n\n  // 设置环境光\n  setlight() {\n    this.ambientlight = new three.ambientlight(0xffffff) // 环境光\n    this.scene.add(ambientlight)\n  }\n}\n\n\n# 渲染\n\ninit() {\n  //第一步新建一个场景\n  this.scene = new three.scene()\n  this.setcamera()\n  this.setrenderer()\n  const geometry = new three.boxgeometry()\n  const material = new three.meshbasicmaterial({ color: 0x00ff00 })\n  const cube = new three.mesh(geometry, material)\n  this.scene.add(cube)\n  this.render()\n}\n\n//render 办法 \nrender() {\n  this.renderer.render(this.scene, this.camera)\n}\n\n\n# 距离设置\n\n默认状况下，当咱们调用scene.add()的时候，物体将会被增加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了避免这种状况的产生，咱们只须要将摄像机略微向外挪动一些即可\n\n// 新建透视相机\nsetcamera() {\n  // 第二参数就是 长度和宽度比 默认采纳浏览器  返回以像素为单位的窗口的外部宽度和高度\n  this.camera = new three.perspectivecamera(\n    75,\n    window.innerwidth / window.innerheight,\n    0.1,\n    1000\n  )\n  this.camera.position.z = 5\n}\n\n\n# 动态旋转\n\ninit() {\n  //第一步新建一个场景\n  this.scene = new three.scene()\n  this.setcamera()\n  this.setrenderer()\n  const geometry = new three.boxgeometry()\n  const material = new three.meshbasicmaterial({ color: 0x00ff00 })\n  this.cube = new three.mesh(geometry, material)\n  this.scene.add(this.cube)\n  this.animate()\n}\n\nrender() {\n  this.renderer.render(this.scene, this.camera)\n}\n\nanimate() {\n  requestanimationframe(this.animate.bind(this))\n  this.cube.rotation.x += 0.01\n  this.cube.rotation.y += 0.01\n  this.render()\n}\n\n\n# 地图数据的取得\n\n把中国地图的数据json拷贝下来\n\n// 加载地图数据\nloadmapdata() {\n  const loader = new three.fileloader()\n  loader.load('../json/china.json', (data) => {\n    const jsondata = json.parse(json.stringify(data))\n    })\n}\n\n\n其实次要的是上面有个经纬度坐标， 其实这个才是我关怀的，有了点能力生成线，最初能力生成立体。 这里波及到一个知识点， 墨卡托投影转换。 墨卡托投影转换能够把咱们经纬度坐标转换成咱们对应立体的2d坐标。\n\n间接用可视化框架——d3 它外面有自带的墨卡托投影转换。\n\n// 墨卡托投影转换\nconst projection = d3\n.geomercator()\n.center([104.0, 37.5])\n.scale(80)\n.translate([0, 0])\n\n\nobject3d是three.js 所有的基类, 提供了一系列的属性和办法来对三维空间中的物体进行操纵。能够通过.add( object )办法来将对象进行组合，该办法将对象增加为子对象\n\n我这里的整个中国是一个大的object3d，每一个省是一个object3d，省是挂在中国下的。 而后中国这个map挂在scene这个object3d下。 很显著，在three.js 是一个很典型的树形数据结构，我画了张图给大家看下。\n\nscence场景下挂了很多货色， 其中有一个就是map, 整个地图， 而后每个省份， 每个省份又是由mesh和lline 组成的。\n\ngenerategeometry(jsondata) {\n  // 初始化一个地图对象\n  this.map = new three.object3d()\n  // 墨卡托投影转换\n  const projection = d3\n  .geomercator()\n  .center([104.0, 37.5])\n  .scale(80)\n  .translate([0, 0])\n\n  jsondata.features.foreach((elem) => {\n    // 定一个省份3d对象\n    const province = new three.object3d()\n    this.map.add(province)\n  })\n  this.scene.add(this.map)\n}\n\n\n# 生成地图几何体\n\nthree.shape() 和 three.extrudegeometry（） 为什么会用到这个呢？ 我给大家解释下， 首先每一个省份轮廓组成的下标是一个 2d坐标，然而咱们要生成立方体，shape() 能够定义一个二维形态立体。 它能够和extrudegeometry一起应用，获取点，或者获取三角面。\n\n// 每个的 坐标 数组\nconst coordinates = elem.geometry.coordinates\n// 循环坐标数组\ncoordinates.foreach((multipolygon) => {\n  multipolygon.foreach((polygon) => {\n    const shape = new three.shape()\n    const linematerial = new three.linebasicmaterial({\n      color: 'white',\n    })\n    const linegeometry = new three.geometry()\n\n    for (let i = 0; i < polygon.length; i++) {\n      const [x, y] = projection(polygon[i])\n      if (i === 0) {\n        shape.moveto(x, -y)\n      }\n      shape.lineto(x, -y)\n      linegeometry.vertices.push(new three.vector3(x, -y, 4.01))\n    }\n\n    const extrudesettings = {\n      depth: 10,\n      bevelenabled: false,\n    }\n\n    const geometry = new three.extrudegeometry(\n      shape,\n      extrudesettings\n    )\n    const material = new three.meshbasicmaterial({\n      color: '#2defff',\n      transparent: true,\n      opacity: 0.6,\n    })\n    const material1 = new three.meshbasicmaterial({\n      color: '#3480c4',\n      transparent: true,\n      opacity: 0.5,\n    })\n\n    const mesh = new three.mesh(geometry, [material, material1])\n    const line = new three.line(linegeometry, linematerial)\n    province.add(mesh)\n    province.add(line)\n  })\n})\n\n\n遍历第一个点的的和canvas2d画图其实是截然不同的， 挪动终点， 而后前面在划线， 画出轮廓。而后咱们在这里能够设置拉伸的深度， 而后接下来就是设置材质了。linegeometry 其实 对应的是轮廓的边线\n\n# 相机辅助视图\n\n为了不便调相机地位， 我减少了辅助视图， camerahelper。 而后你回看下屏幕会呈现一个十字架，而后咱们就能够一直地调整相机的地位，让咱们地地图处于画面的地方\n\naddhelper() {\n  const helper = new three.camerahelper(this.camera)\n  this.scene.add(helper)\n}\n\n\n# 减少交互控制器\n\n当初地图是曾经生成了，然而用户交互感比拟差，这里咱们引入three的orbitcontrols 能够用鼠标在画面随便转动，就能够看到立方体的每一个局部了。然而这个办法不在three 的包外面， 得独自引入一个文件\n\n<div id=\"canvas\"></div>\n\n\n// 设置渲染器\nsetrenderer() {\n  this.renderer = new three.webglrenderer()\n  // 设置画布的大小\n  this.renderer.setsize(window.innerwidth, window.innerheight)\n  //这里 其实就是canvas 画布  renderer.domelement（需要更改成canvas的盒子）\n  // document.body.appendchild(this.renderer.domelement)\n  document.getelementbyid(\"canvas\").appendchild(this.renderer.domelement);\n}\n\nsetcontroller() {\n  this.controller = new three.orbitcontrols(\n    this.camera,\n    document.getelementbyid('canvas')\n  )\n}\n\n\n# 射线追踪\n\n然而对于我本人而言还是不称心， 我怎么晓得的我点击的是哪一个省份呢，ok这时候就要引入咱们three中十分重要的一个类了，raycaster 。\n\n> 这个类用于进行raycasting（光线投射）。 光线投射用于进行鼠标拾取（在三维空间中计算出鼠标移过了什么物体）。\n\n咱们能够对canvas监听的onmousemove 事件，而后 咱们就能够晓得以后挪动的鼠标是抉择的哪一个mesh。然而在这之前，咱们先对每一个province这个对象上减少一个属性来示意他是哪一个省份的。\n\n// 将省份的属性 加进来\nprovince.properties = elem.properties\n\n\nok, 咱们能够引入射线追踪了带入如下：\n\nsetraycaster() {\n  this.raycaster = new three.raycaster()\n  this.mouse = new three.vector2()\n  const onmousemove = (event) => {\n    // 将鼠标地位归一化为设施坐标。x 和 y 方向的取值范畴是 (-1 to +1)\n    this.mouse.x = (event.clientx / window.innerwidth) * 2 - 1\n    this.mouse.y = -(event.clienty / window.innerheight) * 2 + 1\n  }\n  window.addeventlistener('mousemove', onmousemove, false)\n}\n\nanimate() {\n  requestanimationframe(this.animate.bind(this))\n  // 通过摄像机和鼠标地位更新射线\n  this.raycaster.setfromcamera(this.mouse, this.camera)\n  this.render()\n}\n\n\n因为咱们不停地在在画布挪动， 所以须要不停的的射线地位。当初有了射线， 那咱们须要场景的所有货色去比拟了，raycaster 也提供了办法代码如下：\n\nconst intersects = this.raycaster.intersectobjects(\n  this.scene.children, // 场景的\n  true  // 若为true，则同时也会检测所有物体的后辈。否则将只会检测对象自身的相交局部\n)\n\n\n这个intersects失去的穿插很多，然而呢咱们只抉择其中一个，那就是物体材质个数有两个的， 因为咱们下面就是用对mesh用两个材质\n\nconst mesh = new three.mesh(geometry, [material, material1])\n\n\n所以过滤代码如下\n\nanimate() {\n  requestanimationframe(this.animate.bind(this))\n  // 通过摄像机和鼠标地位更新射线\n  this.raycaster.setfromcamera(this.mouse, this.camera)\n  // 算出射线 与当场景相交的对象有那些\n  const intersects = this.raycaster.intersectobjects(\n    this.scene.children,\n    true\n  )\n  const find = intersects.find(\n    (item) => item.object.material && item.object.material.length === 2\n  )\n\n  this.render()\n}\n\n\n我怎么晓得我到底找到没，咱们对找到的mesh将它的外表变成灰色，然而这样会导致一个问题，咱们鼠标再一次挪动的时候要把上一次的材质给他恢复过来。\n\n代码如下：\n\nanimate() {\n  requestanimationframe(this.animate.bind(this))\n  // 通过摄像机和鼠标地位更新射线\n  this.raycaster.setfromcamera(this.mouse, this.camera)\n  // 算出射线 与当场景相交的对象有那些\n  const intersects = this.raycaster.intersectobjects(\n    this.scene.children,\n    true\n  )\n  // 复原上一次清空的\n  if (this.lastpick) {\n    this.lastpick.object.material[0].color.set('#2defff')\n    this.lastpick.object.material[1].color.set('#3480c4')\n  }\n  this.lastpick = null\n  this.lastpick = intersects.find(\n    (item) => item.object.material && item.object.material.length === 2\n  )\n  if (this.lastpick) {\n    this.lastpick.object.material[0].color.set(0xff0000)\n    this.lastpick.object.material[1].color.set(0xff0000)\n  }\n\n  this.render()\n}\n\n\n看下效果图：\n\n# 减少tooltip\n\n为了让交互更加完满，找到了同时在鼠标右下方显示个tooltip，那这个必定是一个div默认是影藏的，而后依据鼠标的挪动挪动相应的地位。\n\n第一步新建div\n\n<div id=\"tooltip\"></div>\n\n\n第二步设置款式 默认是影藏的\n\n#tooltip {\n  position: absolute;\n  z-index: 2;\n  background: white;\n  padding: 10px;\n  border-radius: 2px;\n  visibility: hidden;\n}\n\n\n第三步更改div的地位：\n\nsetraycaster() {\n  this.raycaster = new three.raycaster()\n  this.mouse = new three.vector2()\n  this.tooltip = document.getelementbyid('tooltip')\n  const onmousemove = (event) => {\n    this.mouse.x = (event.clientx / window.innerwidth) * 2 - 1\n    this.mouse.y = -(event.clienty / window.innerheight) * 2 + 1\n    // 更改div地位\n    this.tooltip.style.left = event.clientx + 2 + 'px'\n    this.tooltip.style.top = event.clienty + 2 + 'px'\n  }\n\n  window.addeventlistener('mousemove', onmousemove, false)\n}\n\n\n最初一步设置tooltip的名字：\n\nshowtip() {\n  // 显示省份的信息\n  if (this.lastpick) {\n    const properties = this.lastpick.object.parent.properties\n\n    this.tooltip.textcontent = properties.name\n\n    this.tooltip.style.visibility = 'visible'\n  } else {\n    this.tooltip.style.visibility = 'hidden'\n  }\n}\n\n\n到这里，整个3d可视化地球我的项目曾经实现了",charsets:{cjk:!0}},{title:"vue-manage-system（管理后台开源）",frontmatter:{},regularPath:"/vue/vueManageSystem.html",relativePath:"vue/vueManageSystem.md",key:"v-243444d6",path:"/vue/vueManageSystem.html",headersStr:null,content:"# vue-manage-system（管理后台开源）\n\n官网",normalizedContent:"# vue-manage-system（管理后台开源）\n\n官网",charsets:{cjk:!0}},{title:"vue",frontmatter:{},regularPath:"/vue/vue.html",relativePath:"vue/vue.md",key:"v-36f66c54",path:"/vue/vue.html",headers:[{level:2,title:"vue使用注意",slug:"vue使用注意",normalizedTitle:"vue使用注意",charIndex:39},{level:3,title:"vue生命周期钩子函数",slug:"vue生命周期钩子函数",normalizedTitle:"vue生命周期钩子函数",charIndex:51},{level:3,title:"computed和watch区别?",slug:"computed和watch区别",normalizedTitle:"computed和watch区别?",charIndex:430},{level:3,title:"wacth",slug:"wacth",normalizedTitle:"wacth",charIndex:548},{level:3,title:"v-html会遇到xxs攻击",slug:"v-html会遇到xxs攻击",normalizedTitle:"v-html会遇到xxs攻击",charIndex:694},{level:2,title:"vue + element ui",slug:"vue-element-ui",normalizedTitle:"vue + element ui",charIndex:1439},{level:3,title:"Form 表单验证",slug:"form-表单验证",normalizedTitle:"form 表单验证",charIndex:1474},{level:3,title:"DatePicker 日期选择器",slug:"datepicker-日期选择器",normalizedTitle:"datepicker 日期选择器",charIndex:6169},{level:3,title:"Upload 上传",slug:"upload-上传",normalizedTitle:"upload 上传",charIndex:6895},{level:2,title:"vue + vue-i18n",slug:"vue-vue-i18n",normalizedTitle:"vue + vue-i18n",charIndex:6923},{level:2,title:"vue 封装 前端 @功能的实现",slug:"vue-封装-前端-功能的实现",normalizedTitle:"vue 封装 前端 @功能的实现",charIndex:8621},{level:2,title:"基于contenteditable技术实现@选人功能",slug:"基于contenteditable技术实现-选人功能",normalizedTitle:"基于contenteditable技术实现@选人功能",charIndex:12052},{level:2,title:"「多图预警」完美实现一个@功能",slug:"「多图预警」完美实现一个-功能",normalizedTitle:"「多图预警」完美实现一个@功能",charIndex:30653}],headersStr:"vue使用注意 vue生命周期钩子函数 computed和watch区别? wacth v-html会遇到xxs攻击 vue + element ui Form 表单验证 DatePicker 日期选择器 Upload 上传 vue + vue-i18n vue 封装 前端 @功能的实现 基于contenteditable技术实现@选人功能 「多图预警」完美实现一个@功能",content:"# vue\n\nvue官网 https://cn.vuejs.org/\n\n\n# vue使用注意\n\n\n# vue生命周期钩子函数\n\n– beforeCreate :这个时期，this变量还不能使用，在data下的数据，和methods下的方法，watcher中的事件都不能获得到。\n\n– created这个时候可以操作vue实例中的数据和各种方法，但是还不能对\"dom\"节点进行操作。\n\n– beforeMounte：在挂载开始之前被调用：相关的 render 函数首次被调用\n\n– mounted：挂载完毕，这时dom节点被渲染到文档内，一些需要dom的操作在此时才能正常进行\n\n– beforeUpdate：data中数据已经更新完毕，页面视图还未响应更改\n\n– updated：数据和视图都更新完毕\n\n– beforeDestroy：销毁之前，实例上事件、指令等都可以使用，这里组件没有真正的销毁。\n\n– destroyed：数据、指令、等完全销毁\n\n\n# computed和watch区别?\n\ncomputed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容。 watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。\n\n\n# wacth\n\nwatch: {\n    data: {\n        immediate: true,\n        deep: true,\n        handler(newValue, oldValue) {\n\t\t\t// 处理函数\n        }\n    }\n},\n\n\n\n# v-html会遇到xxs攻击\n\n 1. 下载 xss 依赖\n    \n    npm install xss --save\n    \n\n 2. main.js中引入xss包并挂载到vue原型上\n    \n    import xss from \"xss\";\n    Vue.prototype.xss = xss;\n    \n\n 3. 在vue.config.js中覆写html指令\n    \n    chainWebpack: config => {\n        config.module\n            .rule(\"vue\")\n            .use(\"vue-loader\")\n            .loader(\"vue-loader\")\n            .tap(options => {\n            options.compilerOptions.directives = {\n                html(node, directiveMeta) {\n                    (node.props || (node.props = [])).push({\n                        name: \"innerHTML\",\n                        value: `xss(_s(${directiveMeta.value}))`\n                    });\n                }\n            };\n            return options;\n        });\n    }\n    \n\n\n# vue + element ui\n\nelement ui官网\n\n\n# Form 表单验证\n\nForm 表单 官网\n\n提示\n\n当一个 form 元素中只有一个输入框时，在该输入框中按下回车应提交该表单。如果希望阻止这一默认行为，可以在 <el-form> 标签上添加 @submit.native.prevent。\n\n# 验证bug原因只有以下两种：\n\n 1. 没有在data上定义（需要再验证之前定义好表单上的数据）\n 2. prop和v-model的字段不一致\n\n# 验证例子：\n\n<el-form :model=\"ruleForm\" :rules=\"rules\" ref=\"ruleForm\" label-width=\"100px\" class=\"demo-ruleForm\">\n    <el-form-item label=\"活动名称\" prop=\"name\">\n        <el-input v-model=\"ruleForm.name\"></el-input>\n    </el-form-item>\n    <el-form-item label=\"活动区域\" prop=\"region\">\n        <el-select v-model=\"ruleForm.region\" placeholder=\"请选择活动区域\">\n            <el-option label=\"区域一\" value=\"shanghai\"></el-option>\n            <el-option label=\"区域二\" value=\"beijing\"></el-option>\n        </el-select>\n    </el-form-item>\n    <el-form-item label=\"活动时间\" required>\n        <el-col :span=\"11\">\n            <el-form-item prop=\"date1\">\n                <el-date-picker type=\"date\" placeholder=\"选择日期\" v-model=\"ruleForm.date1\" style=\"width: 100%;\"></el-date-picker>\n            </el-form-item>\n        </el-col>\n        <el-col class=\"line\" :span=\"2\">-</el-col>\n        <el-col :span=\"11\">\n            <el-form-item prop=\"date2\">\n                <el-time-picker type=\"fixed-time\" placeholder=\"选择时间\" v-model=\"ruleForm.date2\" style=\"width: 100%;\"></el-time-picker>\n            </el-form-item>\n        </el-col>\n    </el-form-item>\n    <el-form-item label=\"即时配送\" prop=\"delivery\">\n        <el-switch v-model=\"ruleForm.delivery\"></el-switch>\n    </el-form-item>\n    <el-form-item label=\"活动性质\" prop=\"type\">\n        <el-checkbox-group v-model=\"ruleForm.type\">\n            <el-checkbox label=\"美食/餐厅线上活动\" name=\"type\"></el-checkbox>\n            <el-checkbox label=\"地推活动\" name=\"type\"></el-checkbox>\n            <el-checkbox label=\"线下主题活动\" name=\"type\"></el-checkbox>\n            <el-checkbox label=\"单纯品牌曝光\" name=\"type\"></el-checkbox>\n        </el-checkbox-group>\n    </el-form-item>\n    <el-form-item label=\"特殊资源\" prop=\"resource\">\n        <el-radio-group v-model=\"ruleForm.resource\">\n            <el-radio label=\"线上品牌商赞助\"></el-radio>\n            <el-radio label=\"线下场地免费\"></el-radio>\n        </el-radio-group>\n    </el-form-item>\n    <el-form-item label=\"活动形式\" prop=\"desc\">\n        <el-input type=\"textarea\" v-model=\"ruleForm.desc\"></el-input>\n    </el-form-item>\n    <el-form-item>\n        <el-button type=\"primary\" @click=\"submitForm('ruleForm')\">立即创建</el-button>\n        <el-button @click=\"resetForm('ruleForm')\">重置</el-button>\n    </el-form-item>\n</el-form>\n<script>\n    export default {\n        data() {\n            return {\n                ruleForm: {\n                    name: '',\n                    region: '',\n                    date1: '',\n                    date2: '',\n                    delivery: false,\n                    type: [],\n                    resource: '',\n                    desc: ''\n                },\n                rules: {\n                    name: [\n                        { required: true, message: '请输入活动名称', trigger: 'blur' },\n                        { min: 3, max: 5, message: '长度在 3 到 5 个字符', trigger: 'blur' }\n                    ],\n                    region: [\n                        { required: true, message: '请选择活动区域', trigger: 'change' }\n                    ],\n                    date1: [\n                        { type: 'date', required: true, message: '请选择日期', trigger: 'change' }\n                    ],\n                    date2: [\n                        { type: 'date', required: true, message: '请选择时间', trigger: 'change' }\n                    ],\n                    type: [\n                        { type: 'array', required: true, message: '请至少选择一个活动性质', trigger: 'change' }\n                    ],\n                    resource: [\n                        { required: true, message: '请选择活动资源', trigger: 'change' }\n                    ],\n                    desc: [\n                        { required: true, message: '请填写活动形式', trigger: 'blur' }\n                    ]\n                }\n            };\n        },\n        methods: {\n            submitForm(formName) {\n                this.$refs[formName].validate((valid) => {\n                    if (valid) {\n                        alert('submit!');\n                    } else {\n                        console.log('error submit!!');\n                        return false;\n                    }\n                });\n            },\n            resetForm(formName) {\n                this.$refs[formName].resetFields();\n            }\n        }\n    }\n<\/script>\n\n\n注意\n\n在wacth中调用 $refs 方法，需要在 $nextTick 函数内使用\n\nwatch: {\n    data: {\n        immediate: true,\n        deep: true,\n        handler(newValue, oldValue) {\n            this. $nextTick(()=>{\n            \tthis.$refs[formName].resetFields();\n            })\n        }\n    }\n},\n\n\n\n# DatePicker 日期选择器\n\nDatePicker 日期选择器 官网\n\n# 限制时间的选择\n\n<el-date-picker\n                :value=\"value\"\n                :placeholder=\"data.label\" \n                type=\"date\"\n                value-format=\"yyyy-MM-dd\"\n                :picker-options=\"PickerDisabled\">\n</el-date-picker>\n\n\n在vue的data上定义范围\n\nPickerDisabled: {\n    //结束时间限制\n    disabledDate: (time) => {\n        let beginVal = this.formInline.startTime; // this.formInline.startTime：开始时间\n        if (beginVal) {\n            return (\n                time.getTime() < new Date(beginVal).getTime() - 86400000 ||\n                time.getTime() > Date.now()\n            );\n        } else {\n            return time.getTime() > Date.now(); // 不能选择大于今天的日期\n        }\n    },\n},\n\n\n\n# Upload 上传\n\nUpload 上传 官网\n\n\n# vue + vue-i18n\n\n1.在项目文件src下新建internationalization（自定义）文件夹\n\n\n\n2.安装国际化依赖包\n\nnpm i vue-i18n -S\n\n\n3.在internationalization（自定义）文件夹下新建文件 en.js、zh.js、index.js\n\n\n\n4.在上述index.js文件中，写入\n\nimport Vue from 'vue'\nimport VueI18n from 'vue-i18n'\nimport Cookies from 'js-cookie'\nimport elementEnLocale from 'element-ui/lib/locale/lang/en' // element-ui lang\nimport elementZhLocale from 'element-ui/lib/locale/lang/zh-CN'// element-ui lang\nimport enLocale from './en'\nimport zhLocale from './zh'\n\nVue.use(VueI18n)\n\nconst messages = {\n    en: {\n        ...enLocale,\n        ...elementEnLocale\n    },\n    zh: {\n        ...zhLocale,\n        ...elementZhLocale\n    }\n}\nexport function getLanguage() {\n    const chooseLanguage = Cookies.get('language')||'zh-CN'\n    console.log('当前语言',chooseLanguage)\n    if (chooseLanguage) return (chooseLanguage === 'zh-CN' ? 'zh' : 'en')\n\n    // if has not choose language\n    const language = (navigator.language || navigator.browserLanguage).toLowerCase()\n    const locales = Object.keys(messages)\n    for (const locale of locales) {\n        if (language.indexOf(locale) > -1) {\n            return locale\n        }\n    }\n    return 'en'\n}\nconst i18n = new VueI18n({\n    // set locale\n    // options: en | zh | es\n    locale: getLanguage(),\n    // set locale messages\n    messages\n})\n\nexport default i18n\n\n\n5.在上述zh.js/en.js文件中分别写入\n\nexport default {\n    login: {\n        wisdomLightingSystem: '智慧照明系统'\n    },\n    route: {\n        projectLog: '项目日志'\n    }\n}\n\n\nexport default {\n    login: {\n        wisdomLightingSystem: 'Wisdom Lighting'\n    },\n    route: {\n        projectLog: 'Project Log'\n    }\n}\n\n\n6.在全局的main.js文件中引入\n\n\n\n\n\n7.在页面内使用\n\n\n\n8.关于路由导航的国际化（这里是我自己的配置，仅供参考）\n\n\n\n\n\n\n\n9.最终结果\n\n\n\n\n# vue 封装 前端 @功能的实现\n\n在输入框中输入@后，弹出选人的浮框，然后选择人（可多选），选完后，关闭浮框，然后在输入框中加入@XXX，然后焦点定位刚开始输入@的位置。删除的时候，@XXX要一块删除。 分析： 1.因为要在输入框中把@xxx高亮显示，所以需要用到可编辑元素。\n\n <div contentEditable></div>\n\n\n2.用到selection和range对象\n\n开撸：\n\n<div \n     className={styles.talkInput} \n     id=\"talkInput\" \n     contentEditable\n     onKeyDown={onTalkKeyDown}\n     onInput={changeTalkContent}>\n</div>\n\n\nfunction changeTalkContent(e) {\n    setTalkContent(e.target.innerText);\n    if (e.nativeEvent.data === '@') { //监听输入@\n        openSelect();\n    }\n}\n\n\nfunction openSelect() {\n    //打开选人浮层\n    dispatch({ type: 'share/update', payload: { visible: true } });\n    let selection = window.getSelection();//创建selection,用法可以直接去MDN 去查看 https://developer.mozilla.org/zh-CN/docs/Web/API/Selection\n    setFocusNode(selection.focusNode); // 缓存光标所在节点\n    setFocusOffset(selection.focusOffset); // 缓存光标所在节点位置\n    let inputId = document.getElementById('talkInput');\n    inputId.blur();\n}\n\n\n选完人后\n\nfunction onSelectSubmit(val) {\n    //val 选择的人的信息\n    let userList = val.sharedUserIds;\n    setDirectUsers([...directUsers, ...userList]);\n    let inputId = document.getElementById('talkInput');\n    let selection = window.getSelection();\n    let range = window.getSelection().getRangeAt(0);\n    //选中输入的@符号\n    range.setStart(focusNode, focusOffset - 1);\n    range.setEnd(focusNode, focusOffset);\n    //删除输入的@符号\n    range.deleteContents();\n\n    userList.forEach((s) => {\n        var spanNode1 = document.createElement('span');\n        var spanNode2 = document.createElement('span');\n        spanNode1.className = styles.atFont;\n        spanNode1.innerHTML = '@' + s.nickName;\n        spanNode1.contentEditable = false;//设置为不可编辑，是为了整个@xxx一起删掉\n        spanNode1.setAttribute('data-userId', s.userId);\n        spanNode2.innerHTML = '&nbsp;';\n        var frag = document.createDocumentFragment(),\n            node,\n            lastNode;\n        frag.appendChild(spanNode1);//在 Range 的起点处插入一个节点。\n        while ((node = spanNode2.firstChild)) {\n            lastNode = frag.appendChild(node);\n        }\n        range.insertNode(frag);\n        selection.extend(lastNode, 1);\n        selection.collapseToEnd();//将当前的选区折叠到最末尾的一个点。\n    });\n}\n\n\n删除@xxx的时候，要把@xxx一起删除\n\nfunction onTalkKeyDown(e) {\n    let inputId = document.getElementById('talkInput');\n    let delUserId = null,\n        canDel = true;\n    if (e.key == 'Backspace') {//按下删除键时\n        let range = window.getSelection().getRangeAt(0);\n        let removeNode = null;\n        //焦点在@xxx后面的时候\n        if (range.startOffset <= 1 && range.startContainer.parentElement.className.indexOf('atFont') < 0) {\n            removeNode = range.startContainer.previousElementSibling;\n        }\n        //  点一下@xxx的时候，直接删除@xxx的时候，此时range.startContainer是@xxx,range.startContainer.parentElement是<span>@xxx</span>\n        if (range.startContainer.parentElement.className.indexOf('atFont') >= 0) {\n            removeNode = range.startContainer.parentElement;\n        }\n        if (removeNode) {\n            delUserId = removeNode.getAttribute('data-userid');\n            inputId.removeChild(removeNode);\n        }\n\n        let userList = [...directUsers],\n            newUserList = [];\n        userList.forEach((s) => {\n            if (canDel && s.userId === delUserId) {\n                canDel = false;\n            } else {\n                newUserList = [...newUserList, { ...s }];\n            }\n        });\n        setDirectUsers([...newUserList]);\n    }\n}\n\n\n结束。\n\n\n# 基于contenteditable技术实现@选人功能\n\n@功能，是一个“看起来简单”，实际上“要考虑特别多问题” 的功能需求。本文对这个常见的功能需求的实现进行了记录。\n\n之前我在小程序里在没有 contenteditable 的input中实现了一个输入 @ 字符实现 at 选人功能的需求。无米之炊: 小程序内实现一个具有“@功能at功能”的输入框。当时由于小程序缺少富文本输入框，因此只能在纯 input 里面实现人名输入和用户信息还原。\n\n如今咱们就要来实现 web 的版本了。web 端具有更加丰富的 api 给我们使用，但是其考虑的问题也会更多，因为web端用户的输入变换莫测(即用户可以使用鼠标、键盘或其他输入设备随意的选择、粘贴、控制文本框)。因此，web端如果采用拦截用户所有输入情况进行 \"虚拟抽象层\" 处理和渲染会有些力不从心。\n\n本文最终还是采用通用的方案---contenteditable来实现，下面介绍其过程和思路。\n\n明确需求\n\n要做这个需求，我们需要首先明确 at功能需求 其本质上要包含哪些必要的功能以及一些特定的前置条件，这会直接影响到我们技术方案的设计。\n\n前置条件明确\n\n我们需要向产品确认联系人中是否有 “重名” 的联系人，如联系人中是否会有 2 个叫做 “小明” 的联系人。\n\n如果不会重名，我们便可以使用一种 “类似新浪微博” 的方案，即无需管理和记录每个人的真实id，只需让用户在文本框内随意选择和输入文本和人名，等到最后用户点击保存提交微博时，将文本框内的字符串依次遍历反解(反解办法就是，先找到一个@字符作为开始，然后直到碰到一个空格作为结束，看一下该字符串是否等于某个人名账号)。\n\n由于新浪微博他的人名(账户)是唯一的，因此他便采用了如上简便的做法。从我们随意输入和粘贴一段文本之后产生的bug来看，的确如此：\n\n以上是我通过鼠标@或者文本输入插入了一些 齐鲁晚报 的人名。但是当我主动把其中某些字符删掉，或者把 \"@齐鲁晚报\" 后方的空格干掉，提交后微博便无法还原我at的人了。图上每个人名我都无法hover或点击(因为我破坏了人名反解的结构)。\n\n但是，如果我从其他地方拷贝一个 \"@齐鲁晚报\" 的字符串，然后在其后方敲入一个空格，再提交，则微博可以获取到该用户。\n\n因此，我们猜到新浪微博反解人名的办法是：寻找@字符及其后方的空格作为一个人名。我们查看新浪微博dom中是通过textarea实现的输入框，通过其 api限制以及上面的效果来看，其原理就是如我们所猜测的一样：基于输入内容的字符串进行反解而已，思路比较简单。\n\n而本文我所面向的需求前置条件是：联系人具有可重复的人名。此时的技术方案便面临一个最大的问题：如何能反解出输入框中人名的信息？举例来说：假如我们输入框中的字符串内容是 \"你好，@小明，我们一起吃饭吧，你叫上另外一个 @小明\"。 那么，提交给后台存储时，我们比如告知后台第一个小明是1号小明，第二个小明是2号小明。如何做到呢？这个我们在下文讲述。\n\n需求定义\n\nOK，我们来基于 “人名可以重复” 这个前置条件，来定义一下我们的需求。用户可以在文本框中输入任意的普通字符\n\n用户可以通过输入一个 \"@\" 字符来调起一个选人浮层，选人浮层的位置必须放置在光标所在的位置，且能够根据窗口边缘进行适当的位置调整。例如下方空间不够时，则放到上方。我们来看看新浪微博：\n\n这个是默认下方空间够用的时候。当下方不够时，浮层会出现在上方：\n\n但是，经过测试，当右侧空间不够时，它并没有出现在左方：\n\n理论上，最好的方案应该是：左上、左下、右上、右下每个方向都可以放置浮层，如果任何一个位置空间不够，则换一个位置放置。其放置也是有优先级的，例如右下方和右上方同时都能放下，则右下方优先级更高。其优先级顺序应该是：右下方、右上方、左下方、左上方。\n\n当选人浮层出现后，用户可以通过键盘的“上”、“下”来操纵选人浮层上对应的人选，并可以通过“回车键”将人选填入到输入框中。当然，也可以支持鼠标选择。\n\n输入框中的人名是一个整体。即：当用户鼠标在输入框中人名附近左右移动时，光标不能放置到人名中间。同时，用户在人名后方按下“退格”键，则会把当前人名整体瞬间删除。\n\n支持模糊搜索。即：当用户输入 @ 时，弹出推荐的联系人，当他输入 \"@小\"，则浮层里要把 \"小明\" \"小红\" \"小x\" 等搜索后的联系人。 且选人完毕后，要把选中的如 \"小红\" 填入到文本框中\n\n用户输入完毕后，可以把文本框中所有字符串或人名转成对应的结构存储到后端存储。从而在其他页面可以展示。例如QQ空间发表说说后，后台需要给你输入的人名发送at通知，而且要在你的qq说说页面展示你发表的内容(当你鼠标放到人名上还可以展示用户卡片)，如图：\n\n技术上要考虑的点：\n\n需求看起来简单，实际上这个功能是个前端大坑。我们看看这涉及到多少个要考虑的点，每个点都不是那么简单：如何能反解出输入框中人名的信息\n\n后台提交接口该如何设计\n\n人名检索接口设计。用户键入关键字后，要通过搜索接口实时拉取人名，api接口该如何设计\n\n如何检测@字符。如何区分是出默认人选还是按输入模糊检索。\n\n选人后如何替换掉原来的检索文案。\n\n选人浮层的定位。如何定位光标位置，如何将浮层放置在页面中最合适的位置；当浮层还没渲染时，如何知道浮层宽高从而进行位置选择\n\n中文输入bug。中文输入时，编辑器内会先出现拼音，等用户按“空格”或“回车”后变成中文，应该如何处理这种场景\n\n如何实现整个人名一次性删除\n\n人名隔离问题。即如何确保输入人名之后，再输入其他字符时自动产生一个新的textNode类型的节点，而不是插入到人名标签中\n\nplaceholder 怎样实现\n\n粘贴操作的处理。当用户粘贴富文本时，我们要不允许其粘贴或者将其粘贴内容转成纯文本。\n\n下面我们依次来说明如何基于 Web前端 来说实现一个具有完整at功能的输入框。\n\n行业洞察\n\n我们来瞅瞅行业里别人是咋做的。\n\n新浪微博\n\n微博是通过一个纯的 textarea 来实现的at功能。我们可以看到，他输入的人名就是一个纯字符串，且我们可以把光标放置到人名中间，甚至我们可以删掉人名中的某个字符，从而破坏掉人名：\n\n因此，他的实现是 “仅仅将用户所选的用户id放到输入框对应位置”。他也无须对输入框中的人名建立一个用户信息的记录映射，因为他的场景比较特殊：它at出来的每个人名都是一个唯一id。所以，当他把输入框文本提交给后台时，也无须做任何处理，直接提交即可。后台可以根据字符串中的 “@” 和 “@后方的空格” 找出每个 “所谓的人名” 然后检索数据库找出其对应的用户信息。\n\n通常这种at功能还存在一个“中文输入法”的坑，就是如果你输入中文，那么此时输入法会先将拼音放置到输入框，然后等你选词完毕后再把中文换到输入框，这会带来at功能的bug。我们看看新浪微博是咋处理的：在中文输入法输入时，新浪微博为了避免我们后文提到的诡异问题，它直接屏蔽掉了中文输入时的检索能力哈哈。如图，输入中文时并不会触发选人的搜索。\n\nQQ空间\n\nqq空间是用 contenteditable 的div来实现的。他把用户信息藏到了一个标签里。如图文本框中有2个同名的 catting，但他们分别是2个不同的用户。 由于空间是使用 contenteditable 实现的输入框，因此其人名通过 button 标签给包裹起来了，于是它把每个用户的id等信息藏到了button标签中。\n\nQQ空间怎么处理中文输入法问题的呢，我们看看：\n\n恩，他直接在有输入法弹窗的情况下，不允许你通过键盘操纵选人面板，也就不存在互相影响的问题了，也是机智。\n\n再看看 QQ 空间的 placeholder 是怎么实现的呢？我们看看他的输入框dom：\n\n发现这里有个div里放置了placeholder的内容，盖在输入框上面。该dom跟输入框div并列。当我们鼠标点击placeholder位置的时候，意味着我们打算开始输入，这时他把placeholder div隐藏，并主动聚焦到输入框的div里面，从而实现了placeholder效果。\n\n由于我们的需求背景存在人名重复，因此无法采用新浪微博这种 “基于字符串解析反解” 的方案，而必须采用类似 QQ空间的 contenteditable 藏信息的方案。下面我们来分别看上文提到的各个技术点如何各个击破。\n\n如何能反解出输入框中人名的信息\n\n前文我们已经分析了能面向“人名重复”场景的解决方案，只有如下2个办法：拦截用户的输入，搞一个 虚拟抽象层，像我之前做的 小程序方案一样，维持一个特殊的内存结构。\n\n使用 contenteditable 的富文本输入框作为输入区域。这样可以将每个人的用户信息藏到文本框里的人名标签里。例如使用span或button包裹人名。\n\n第一种方案比较适合小程序场景下输入模式比较单一，只有虚拟键盘的输入；对于PC端用户输入模式多样的情况来说，实现难度极大。因此，我们采用方案2这种比较主流和简便的方案---把用户信息藏到标签里。\n\n举个栗子：你在输入框中输入了 “你好 @小明”。 那么在 contenteditable 的输入框中其实是：\n\n你好, @小明 这样，我们拿到输入框内部的innerHTML后，可以轻松的拿到每个at人名的个人信息。\n\n于是我设计了一个 AtEditor 的Vue组件，其 template 部分是这样的：\n\nref=\"jsEditorElement\"\n\ncontenteditable=\"true\"\n\n:class=\"[placeholderClass]\"\n\n@keyup=\"onInputText\"\n\n@keydown=\"onInputKeyDown\"\n\n@blur=\"onCloseDialog\"\n\n@mouseup=\"doToggleDialog\"\n\n@paste=\"doOnPaste\"\n\n>\n\n{{(item.name)}}\n\n\n其中jsEditorElement就是输入框，设置其contenteditable为ture，同时绑定好了各种事件进行后续的逻辑处理。\n\n其中jsDialogElement就是选人的浮层，通过visibility样式控制他是否展示，通过atDialogPos样式控制他的fixed定位的top和left坐标。\n\n后台提交接口设计\n\n当用户输入完毕，点击提交或保存时，我们的需求通常需要把文本框内部的文本和人名提取出来，且按序提交给后端存储。例如你空间或微博发布的每一条说说都要存储到后台数据库。那么，这里的接口我们可以将输入框内容抽象成1种消息结构，且该结构有2种类型。\n\nclass Msg {\n    constructor(type, data) {\n\n        this.type = type; // type可以是at类型也可以是text类型\n\n        this.data = data\n\n    }\n\n}\n\n\n例如依然是 “你好，@小明” 这样的输入。那么我们提交给后台时，其数据结构是这样的:\n\nvar postMsgs = [\n\n    {\n\n        type: 'text',\n\n        data: '你好，'\n\n    },\n\n    {\n\n        type: 'at',\n\n        data: {\n\n            name: '小明',\n\n            id: 1\n\n        }\n\n    }\n\n]\n\n\n人名检索接口设计\n\n这里，我们是采用了2个不同的接口来分别实现 “获取推荐的几个联系人” 和 “根据用户输入的内容来搜索匹配的联系人”。因此，我们有如下2个接口：\n\ngetDefaultUsers\n\n@paramslimit: 限制最大返回的联系人数量\n\n@returnpersons: [\n\n{ name: '小明', id: 1 },\n\n{ name: '小红', id: 2 }\n\n]\n\ngetSearchUsers\n\n@paramslimit: 限制最大返回的联系人数量\n\nkeyword: 用户在@后方输入的用来搜索的文本\n\n@returnpersons: [\n\n{ name: '小明', id: 1 },\n\n{ name: '小红', id: 2 }\n\n]\n\n\n这里实际上也可以使用一个接口来实现。例如无论用户 “只输入了@”，还是输入了 \"@小\" 都通过 getSearchUsers来调用，即只输入@时的keyword是空。\n\nat字符和输入的检测\n\n其实这里也比较复杂，我们不止要对 @ 字符做出特殊的反应。我们有多种不同的输入都要做出特殊的反应，如：当用户输入 @ 时，我们要调起默认选人\n\n当用户输入@，且后方跟着大于等于1个字符时，要调起搜索选人\n\n当用户鼠标点击到某个字符处，要判断光标前方字符是否有 @，且区分是调起默认选人还是搜素选人\n\n当用户键盘键入 “上箭头” “下箭头” 时，要将行为拦截并转换成对选人浮层人选的上下切换\n\n当用户输入“回车”时，要拦截并转换成对选人浮层人选的确认操作\n\n当用户输入“ESC返回”时，要转成对选人浮层的关闭操作\n\n如上这些，我们主要是监听用户的 “keydown” 和 “keyup” 事件来做的。\n\n之所以有些在 keydown里做，有些在keyup里做，是因为在keyup发生的时候，用户的文字已经输入到文本框了，所以这个事件比较适合检测@字符。但是像有些按键我们是不期望他默认行为发生的，因此我需要在 keydown 的时候就拦截掉，例如回车、上下箭头。\n\n先来看，键盘事件keydown我是如何拦截的：\n\n// 键盘按下\n\nonInputKeyDown(e) {\n\n    if (this.isShowDialog) {\n\n        if (e.code == 'ArrowDown' || e.code === 'ArrowUp') {\n\n            // 上下移动光标，用于调整 dialog 里的人\n\n            if (e.code == 'ArrowDown') {\n\n                this.activeIndex++\n\n                if (this.activeIndex === this.lists.length) {\n\n                    this.activeIndex = this.lists.length - 1\n\n                }\n\n            }\n\n            if (e.code == 'ArrowUp') {\n\n                this.activeIndex--\n\n                if (this.activeIndex === -1) {\n\n                    this.activeIndex = 0\n\n                }\n\n            }\n\n            preventAfterAction.call(this, e)\n\n        }\n\n        else if (e.code === 'Enter') {\n\n            // 如果有弹窗，则代表确认选人\n\n            this.isShowDialog = false\n\n            preventAfterAction.call(this, e)\n\n            this.selectPerson(this.lists[this.activeIndex])\n\n        }\n\n        else if (e.code === 'Escape') {\n\n            this.isShowDialog = false\n\n            preventAfterAction.call(this, e)\n\n        }\n\n    }\n\n    else {\n\n        // 回车给拦掉，什么都不做\n\n        if (e.code === 'Enter') {\n\n            preventAfterAction.call(this, e)\n\n        }\n\n    }\n\n    function preventAfterAction(e) {\n\n        e.preventDefault()\n\n        this.preventKeyUp = true\n\n    }\n\n},\n\n\n再来看 keyup 我是如何检测 @ 的：\n\n// 按键弹起\n\nonInputText(e) {\n\n    if (this.preventKeyUp) {\n\n        this.preventKeyUp = false\n\n        return\n\n    }\n\n    this.preventKeyUp = false\n\n    const el = e.currentTarget\n\n    // 这是输入了@，那就直接弹选人浮层\n\n    if (e.code == 'Digit2' && e.shiftKey) {\n\n        this.showDefaultDialog()\n\n    }\n\n    else {\n\n        // 这里是输入的不是@，但是可能前方有@，因此需要进行检测看看是否要展示选人浮层\n\n        this.doToggleDialog()\n\n    }\n\n},\n\n\n来看看\n\ndoToggleDialog:doToggleDialog() {\n\n    const rangeInfo = this.getEditorRange()\n\n    if (!rangeInfo || !rangeInfo.range || !rangeInfo.selection) return\n\n    const curNode = rangeInfo.range.endContainer\n\n    if (!curNode || curNode.nodeName !== '#text') return\n\n    const searchStr = curNode.textContent.slice(0, rangeInfo.selection.focusOffset)\n\n    // 判断光标位置前方是否有at，只有一个at则展示默认dialog，除了at还有关键字则展示searchDialog\n\n    const keywords = (/@([^@]*)$/).exec(searchStr)\n\n    if (keywords && keywords.length >= 2) {\n\n        // 展示搜索选人\n\n        const key_words = keywords[1]\n\n        const allMathStr = keywords[0]\n\n        if (allMathStr === '@') {\n\n            this.showDefaultDialog()\n\n        }\n\n        else {\n\n            this.showSearchDialog(key_words)\n\n        }\n\n        // 重点：记下弹窗前光标位置range\n\n        this.editorRange = rangeInfo\n\n    }\n\n    else {\n\n        // 关掉选人\n\n        this.closeDialog()\n\n    }\n\n},\n\n\n这里其实就是检测本次输入完字符后，光标前方是否有@，如果只有一个@就展示默认推荐人，如果是 \"@xxx\" 这样的结构，则用xxx去检索推荐人。\n\nshowSearchDilaog的代码我就不贴了，其实就是查询接口，拿到返回的人选列表，放到当前 Vue 的lists字段上。这里贴一下 getEditorRange的代码，他是用户获取当前光标选取的信息(即在弹出选人之前，把输入框中此刻的光标位置先记下来)\n\ngetEditorRange() {\n\n    let range = null;\n\n    let selection = null;\n\n    if (window.getSelection) {\n\n        selection = window.getSelection();\n\n        if (selection.getRangeAt && selection.rangeCount) {\n\n            range = selection.getRangeAt(0);\n\n            return {\n\n                range,\n\n                selection,\n\n            };\n\n        } else {\n\n            return null;\n\n        }\n\n    } else {\n\n        return null;\n\n    }\n\n},\n\n\n选人浮层的定位。\n\n上文解决了浮层何时弹，现在就要解决浮层要弹在哪里的问题。我们需要在浮层isSHow设置为 true之前，就要算出把浮层放在哪里。这里我们首先要解决俩问题：如何在浮层渲染之前知道当前浮层的宽高。因为我们要计算浮层边缘跟整个window窗口的边界，从而找到最合适的放置位置。\n\n如何知道当前光标的位置。因为我们的浮层必然是像一个气泡一样，以光标位置为起点展示的。\n\n对于第一个问题，基于 vue 的 nextTick 来实现即可，因为 nextTick是在vue的异步dom更新队列之后执行的，此时dom已经更新(同时我们的dialog是基于visibility实现隐藏的，因此其宽高我们实际上是能拿到的)。\n\n对于第二个问题，业界通常是使用一个隐藏标签来重放输入框内容从而计算位置。我们这里直接使用了一个现成的类库：http://ichord.github.io/Caret...\n\n以下是 showDialog 函数的具体实现：\n\nshowDialog() {\n\n    this.isShowDialog = false // 先隐藏\n\n    this.$nextTick(() => {\n\n        // 等隐藏完毕，且最新lists数据dom生成后，可基于此时的dom去获取最新的dialog宽高和坐标\n\n        const el = this.$refs['jsEditorElement']\n\n        const jsDialogElement = this.$refs['jsDialogElement']\n\n        if (!el) return\n\n        const caret = $(el).caret('offset')\n\n        var realPosition = this._getAdapterPosition(caret, jsDialogElement) // 获取正确的放置坐标，防止超出边界。本文基于offset\n\n        this.atDialogPos = {\n\n            left: realPosition.left + 'px',\n\n            top: realPosition.top + 'px'\n\n        }\n\n        this.activeIndex = 0\n\n        this.isShowDialog = true // 此时再展示出来\n\n    })\n\n},\n\n\n接下来的问题：如何将浮层放置在页面中最合适的位置。前文我们已经说了这个放置的大致最佳策略。即：左上、左下、右上、右下每个方向都可以放置浮层\n\n如果任何一个位置空间不够，则换一个位置放置。\n\n其放置也是有优先级的，例如右下方和右上方同时都能放下，则右下方优先级更高。其优先级顺序应该是：右下方、右上方、左下方、左上方。\n\n我是4个方向依次试探来实现的：\n\n_getAdapterPosition(caret, dialogElem) {\n\n    const fixHeightGap = 5;\n\n    caret.top = caret.top - fixHeightGap\n\n    caret.height = caret.height + fixHeightGap + 5\n\n    const clientWidth = document.scrollingElement.clientWidth\n\n    const clientHeight = document.scrollingElement.clientHeight\n\n    const toClientLeft = caret.left\n\n    const toClientTop = (caret.top - document.scrollingElement.scrollTop)\n\n    const toClientRight = clientWidth - toClientLeft\n\n    const toClientBottom = clientHeight - toClientTop\n\n    const dialogSize = {\n\n        height: dialogElem.offsetHeight,\n\n        width: dialogElem.offsetWidth\n\n    }\n\n    // 看是否可放右侧下方 (原点要从光标下方开始算起, 因此toClientBottom要加一下光标高度)\n\n    if (((toClientBottom - caret.height) >= dialogSize.height) && (toClientRight >= dialogSize.width)) {\n\n        return {\n\n            top: toClientTop + caret.height,\n\n            left: toClientLeft\n\n        }\n\n    }\n\n    else if ((toClientTop >= dialogSize.height) && (toClientRight >= dialogSize.width)) {\n\n        return {\n\n            top: toClientTop - dialogSize.height,\n\n            left: toClientLeft\n\n        }\n\n    }\n\n    else if (((toClientBottom - caret.height) >= dialogSize.height) && (toClientLeft >= dialogSize.width)) {\n\n        return {\n\n            top: toClientTop + caret.height,\n\n            left: toClientLeft - dialogSize.width\n\n        }\n\n    }\n\n    else if ((toClientTop >= dialogSize.height) && (toClientLeft >= dialogSize.width)) {\n\n        return {\n\n            top: toClientTop - dialogSize.height,\n\n            left: toClientLeft - dialogSize.width\n\n        }\n\n    }\n\n    else {\n\n        let left = toClientLeft > toClientRight ? toClientLeft - dialogSize.width : toClientLeft\n\n        let top = toClientTop > toClientBottom ? toClientTop - dialogSize.height : toClientTop + caret.height\n\n        return {\n\n            top,\n\n            left\n\n        }\n\n    }\n\n    return caret\n\n},\n\n\n如何实现整个人名一次性删除\n\n这里可以很复杂，也可以很简单。最简单的方案就是业界通常使用的 button 标签，尤其是 chrome 内核的浏览器，button标签方案是比较兼容的。我们可以将人名对应的用户信息 塞到 button 标签当中。但为了能在退格的时候将他整体删除且不能随意修改，我们通常对 button 标签再加点料：\n\nconst btn = document.createElement('button')\n\nbtn.dataset['person'] = JSON.stringify(person)\n\nbtn.textContent = `@${person.name}`\n\nbtn.contentEditable = false\n\nbtn.addEventListener('click', () => {\n\n    return false\n\n}, false)\n\nbtn.tabindex = '-1'\n\n\n选人后如何替换掉原来的检索文案。\n\n在弹出选人浮层的时候onToggleDialog中 ，我们有个关键的代码，就是：\n\n// 重点：记下弹窗前光标位置range\n\nthis.editorRange = rangeInfo\n\n\n由于我们之前的光标已经记下来了，因此，当选人确认后，我们要做的：就是把之前光标位置到前方@字符的内容delete删除，然后换成我们选择的人名(即我们创建的button标签)。代码如下：\n\nselectPerson(person) {\n\n    person.corp_id = person.corp_id || window.corp_id;\n\n    this.isShowDialog = false\n\n    const editor = this.$refs['jsEditorElement']\n\n    if (editor) {\n\n        editor.focus()\n\n        // 删掉草稿start\n\n        const editorRange = this.editorRange.range\n\n        if (!editorRange) return\n\n        const textNode = editorRange.endContainer // 拿到末尾文本节点\n\n        const endOffset = editorRange.endOffset // 光标位置\n\n        // 找出光标前的at符号位置\n\n        const textNodeValue = textNode.nodeValue\n\n        const expRes = (/@([^@]*)$/).exec(textNodeValue)\n\n        if (expRes && expRes.length > 1) {\n\n            editorRange.setStart(textNode, expRes.index)\n\n            editorRange.setEnd(textNode, endOffset)\n\n            // console.log('要插入at的位置range', editorRange, editorRange.startOffset, editorRange.endOffset)\n\n            editorRange.deleteContents() // 删除草稿end\n\n            // console.log('delete后的range', editorRange, editorRange.startOffset, editorRange.endOffset)\n\n            // return\n\n            const btn = document.createElement('button')\n\n            btn.dataset['person'] = JSON.stringify(person)\n\n            btn.textContent = `@${person.name}`\n\n            btn.contentEditable = false\n\n            btn.addEventListener('click', () => {\n\n                return false\n\n            }, false)\n\n            btn.tabindex = '-1'\n\n            const bSpaceNode = document.createTextNode('\\u200b') // 不可见字符，为了放光标方便\n\n            this.insertHtmlAtCaret([btn, bSpaceNode], this.editorRange.selection, this.editorRange.range)\n\n        }\n\n    }\n\n},\n\n\n人名隔离问题\n\n默认情况下，当我们的button添加到输入框之后，如果我们在 button 后方继续输入普通文本，那么文本可能会跑到button标签内部。\n\n例如，当你选择了小明之后，输入框中如果是这样的结构：\n\n你好，小明 当你在后方再输入：“一起吃饭”。那么，结构可能会变成：\n\n你好，小明一起吃饭把 新字符跑到了button标签内部，显然不符合我们的预期。因此，这里我们必须通过hack手段来解决。如何确保输入人名之后，再输入其他字符时自动产生一个新的textNode类型的节点，而不是插入到人名标签中呢？\n\n大家可能注意到上一小节代码中，我们给 insertHtmlAtCaret 函数传递元素时，除了传递button，还传递了一个自己创建的 textNode节点：const bSpaceNode = document.createTextNode('\\u200b') // 不可见字符，为了放光标方便\n\n这个字符是一个不可见的字符，但他的确是一个字符。有了这么一个字符在 button 的后方，则我们新添加字符的话，他就是在 \\u200b位置往后添加，这样就可以实现我们期望的效果了。 关于插入什么字符，业界通常也会使用空格字符来实现，例如QQ空间便是使用空格字符。\n\n而我这里为了不让领宽字符提交到后台，所以在提交之前做了下检测：// 从dom中拿出带有at信息的结构 (对于at是用button包裹，就把button里的date-person属性拿出来)\n\ngetMsgStructure: function(elem) {\n\n    elem = elem[0]\n\n    var res = []\n\n    var self = this\n\n    Array.from(elem.childNodes).forEach(function(child) {\n\n        if (child.nodeName === '#text') {\n\n            var str = child.nodeValue\n\n            if (str && str.length > 0) {\n\n                var lastChar = str[str.length - 1]\n\n                if (lastChar.charCodeAt(0) === 0x200b) {\n\n                    // 零宽字符去掉\n\n                    str = str.slice(0, -1)\n\n                }\n\n            }\n\n            console.log('str', str)\n\n            if (str) {\n\n                res.push({type: 'text', data: str})\n\n            }\n\n        } else if (child.nodeName === 'BR') {\n\n            res.push({type: 'text', data: '\\n'})\n\n        } else if (child.nodeName === 'BUTTON') {\n\n            res.push({type: 'at', data: JSON.parse(child.dataset.person)})\n\n        }\n\n        else if (child.nodeName === 'SPAN') {\n\n            res.push({type: 'text', data: child.textContent})\n\n        }\n\n    })\n\n    res = self._defragmentation(res)\n\n    return res\n\n},\n\n\n数据碎片问题\n\n什么是数据碎片问题呢。举个栗子：\n\n例如：用户输入了 \"你好，@小明，吃了吗\" 这样一段话，当用户把“@小明” 删掉后，文本变成 “你好，吃了吗”，但实际上底层 contenteditable 文本域里面是2个 textNode：“你好，” 和 “吃了吗”。 虽然对于整体功能来说没什么大碍，但是不利于后端减少数据结构的冗余。\n\n那么这里的解决办法也比较容易，就是提交给后台之前，对同类型的 textNode 节点进行合并，减少碎片。这里简单实现了一下这个合并算法：\n\n_defragmentation(msgs) {\n\n    // msgs 就是上文说说的消息数据结构\n\n    const newMsgs = [];\n\n    msgs.forEach(msg => {\n\n        const last = newMsgs[newMsgs.length - 1];\n\n        if (last && last.type && last.type === 'text' && msg.type === 'text') {\n\n            last.data = last.data + msg.data\n\n        }\n\n        else {\n\n            if (msg && msg.type === 'text' && msg.renderLength == 0) return;\n\n            newMsgs.push(msg);\n\n        }\n\n    });\n\n    return newMsgs\n\n},\n\n\n中文输入bug\n\n中文输入时，编辑器内会先出现拼音，此时会触发输入框的 keydown，keyup等事件，从而导致我们选人浮层开始出现。可是当用户按下 回车键，我们的选人逻辑会将选中的人名放置到输入框，而中文输入法会将他的候选词放入输入框，这里会导致“选的人”和“选的词”同时出现到输入框里。\n\n应该如何处理这种场景呢？我采用的办法是，检测到中文输入选词完毕后，我们及时更新我vue组件内的光标选取变量，从而让选人事件发生后，可以正确的删除前方的文案。\n\n例如：当用户输入 \"@x\"，此时他输入法中出现了 “小，晓，笑” 等候选词，同时此时我们的选人浮层也出现了。\n\n当他按下回车，此时输入法会立刻将“小”放置到输入框，从而输入框内容变成 \"@小\"。而此时，我需要立刻将我 Vue组件的 editorRange 变量更新，记录下此时光标位于 “@小” 后方。\n\n那么，接下来 回车会触发我的选人确认逻辑，此时我的逻辑会将光标位置开始到前方的@位置所有字符进行删除替换，因此 \"@小\"就变成了 “@小明”。\n\n做法：给输入框增加2个事件\n\n\"@compositionstart=\"onCompositionStart\"\n\n@compositiοnend=\"onCompositionEnd\"\n\n\n方法实现：\n\nonCompositionStart() {\n\n    console.log('正在输入中文');\n\n},\n\n\nonCompositionEnd(e) {\n\n    if (this.isShowDialog) {\n\n        // 重置光标位置，因为此时中文会填进去。。\n\n        this.editorRange = this.getEditorRange();\n\n    }\n\n},\n\n\nplaceholder 的实现\n\n这里，我采用了 css 的简便方案，即通过 empty 伪类选择器，检测到 div 中内容为空时，我们往输入框的 after 伪类下添加一个 文本；当光标focus到输入框的时候，我们使用 focus 伪类再清掉 after元素的内容。从而实现 placeholder 的效果。\n\n.at-editor-placeholder-cn:empty:before {\n\n    content: '填写内容，输入@以选择某人';\n\n    color: gray;\n\n}\n\n.at-editor-placeholder-cn:focus:before {\n\n    content: none;\n\n}\n\n\n粘贴的处理\n\n当用户进行“粘贴”，我们要拦截粘贴动作，并取其粘贴板上的文本内容，手工放置到光标位置。这里我在 onDoPaste 函数中实现:\n\ndoOnPaste(e) {\n\n    var pastedText = undefined;\n\n    if (window.clipboardData && window.clipboardData.getData) { // IE\n\n        pastedText = window.clipboardData.getData('Text');\n\n    } else if (e.clipboardData && e.clipboardData.getData) {\n\n        pastedText = e.clipboardData.getData('text/plain');\n\n    }\n\n    // 放到光标位置\n\n    const rangeInfo = this.getEditorRange()\n\n    if (rangeInfo && pastedText) {\n\n        rangeInfo.range.deleteContents()\n\n        const newTextNode = document.createTextNode(pastedText)\n\n        this.insertHtmlAtCaret(newTextNode, rangeInfo.selection, rangeInfo.range)\n\n    }\n\n    e.preventDefault()\n\n    return false;\n\n},\n\n\n这里最主要是这一句：e.clipboardData.getData('text/plain');\n\n帮助我们拿到所有dom中的纯文本部分。\n\n总结\n\n至此，我们实现了一个 “看起来简单” 但 “要考虑的点特别多” 的输入框 at 功能。\n\n\n# 「多图预警」完美实现一个@功能\n\n地址：https://segmentfault.com/a/1190000042481321?utm_source=sf-hot-article\n\n\x3c!-- 富文本聊天消息输入框 --\x3e\n<div\n     class=\"chat-input\"\n     ref=\"chatInput\"\n     contenteditable=\"true\"\n     placeholder=\"请输入内容\"\n     @input=\"inputChatContent\"\n     @blur=\"chatContentBlur\"\n     @mouseup=\"chatContentMouseup\"\n     ></div>\n\x3c!-- 用户列表浮窗 --\x3e\n<ul\n    class=\"popper\"\n    v-show=\"isShowUserList\"\n    ref=\"popper\"\n    :style=\"popperStyle\"\n    v-click-out-hide\n    >\n    <li v-for=\"(item, index) in userList\" :key=\"index\" @click=\"selectUser(item)\">\n        <el-row>{{item.name}}</el-row>\n    </li>\n</ul>\n\n\nexport default {\n    methods: {\n        getRange(){\n            const selection = document.getSelection();\n            const range = selection.getRangeAt(0);\n            return range\n        },\n        /**\n        * 输入聊天内容\n        * @param {*} ev\n        */\n        inputChatContent(ev) {\n            if (ev.data === '@') {\n                // 在输入@字符时候就保存一下光标\n                this.saveCaret()\n                const pos = this.getCaretPos()\n                this.showUserList()\n                this.$nextTick(() => {\n                    this.setUserListPos(pos)\n                })\n            } else {\n                this.hideUserList()\n            }\n        },\n\n        /**\n        * 获取光标位置\n        * @returns\n        */\n        getCaretPos() {\n            const range = this.getRange()\n            const pos = range.getBoundingClientRect()\n\n            return pos\n        },\n\n        /**\n        * 设置用户列表的位置\n        * @param {*} pos\n        */\n        setUserListPos(pos) {\n            const $popper = this.$refs.popper\n            const panelWidth = $popper.offsetWidth\n            const panelHeight = $popper.offsetHeight\n            const { x, y } = pos\n\n            this.popperStyle = {\n                top: y - panelHeight - 20 + 'px',\n                left: x - panelWidth / 2 + 'px'\n            }\n        },\n\n        hideUserList() {\n            this.isShowUserList = false\n        },\n\n        showUserList() {\n            this.isShowUserList = true\n        },\n\n\n        /**\n        * 选择用户\n        */\n        selectUser(user) {\n            // 让失焦事件先执行\n            setTimeout(() => {\n                this.hideUserList()\n                this.insertContent(user)\n            })\n        },\n\n        /**\n        * 恢复光标\n        */\n        restoreCaret() {\n            if (this.lastRange) {\n                const selection = window.getSelection()\n                selection.removeAllRanges()\n                selection.addRange(this.lastRange)\n            }\n        },\n\n        /**\n        * 插入内容\n        * @param {*} data\n        */\n        insertContent(data) {\n            this.restoreCaret() // 还原光标\n\n            const selection = window.getSelection()\n            const range = selection.getRangeAt(0)\n            range.collapse(false) // 折叠选区，光标移到最后\n            range.insertNode(data.content)\n            range.collapse(false)\n\n            selection.removeAllRanges()\n            selection.addRange(range)\n        },\n        /**\n        * 删除输入框中光标位置现有的@字符\n        */\n        deleteCaretAtCode() {\n            const range = this.getRange()\n            // 光标开始节点和光标在节点上的偏移量，找到光标准确位置，选中光标位置前一个字符范围并删除，\n            const node = range.startContainer\n            const end = range.endOffset\n\n            // 开始节点内容最后一个字符是@，删除，否则不删除\n            if (node.textContent[end - 1] === '@') {\n                range.setStart(node, end ? end - 1 : 0)\n                range.deleteContents()\n            }\n        },\n\n        /**\n        * 转换要插入光标位置的内容\n        * @param {*} data\n        */\n        parseContent(data) {\n            const { type = 'text', name } = data\n            let content = null\n\n            // type 是插入内容类型，可能是文本、@标签、图片、表情等\n            if (type === 'text') {\n                content = document.createTextNode(name)\n            } else if (type === 'at') {\n                // 删除输入框中光标位置现有的@字符\n                this.deleteCaretAtCode()\n\n                const $span = document.createElement('span')\n                $span.contentEditable = false\n                $span.classList.add('tag')\n                $span.innerHTML = `@${name}`\n\n                // 插入一个空格字符（\\u0010）到@标签后面，可以解决部分浏览器上光标在聊天输入框后面\n                const $space = document.createTextNode('\\u0010')\n                const frag = document.createDocumentFragment()\n\n                frag.appendChild($span)\n                frag.appendChild($space)\n\n                content = frag\n            }\n            return content\n        },\n\n        /**\n        * 插入内容\n        * @param {*} data\n        */\n        insertContent(data) {\n            this.restoreCaret() // 还原光标\n\n            const selection = window.getSelection()\n            const range = selection.getRangeAt(0)\n            range.collapse(false) // 折叠选区，光标移到最后\n\n            const pc = this.parseContent(data)\n            range.insertNode(pc)\n            range.collapse(false)\n\n            selection.removeAllRanges()\n            selection.addRange(range)\n        }\n    }\n}\n\n\n.popper li {\n    /* 用户不能选中文本 firfox 非编辑编辑元素也可选中 */\n    user-select: none;\n    -webkit-user-select: none;\n    list-style: none;\n    padding: 10px;\n}\n",normalizedContent:"# vue\n\nvue官网 https://cn.vuejs.org/\n\n\n# vue使用注意\n\n\n# vue生命周期钩子函数\n\n– beforecreate :这个时期，this变量还不能使用，在data下的数据，和methods下的方法，watcher中的事件都不能获得到。\n\n– created这个时候可以操作vue实例中的数据和各种方法，但是还不能对\"dom\"节点进行操作。\n\n– beforemounte：在挂载开始之前被调用：相关的 render 函数首次被调用\n\n– mounted：挂载完毕，这时dom节点被渲染到文档内，一些需要dom的操作在此时才能正常进行\n\n– beforeupdate：data中数据已经更新完毕，页面视图还未响应更改\n\n– updated：数据和视图都更新完毕\n\n– beforedestroy：销毁之前，实例上事件、指令等都可以使用，这里组件没有真正的销毁。\n\n– destroyed：数据、指令、等完全销毁\n\n\n# computed和watch区别?\n\ncomputed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容。 watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。\n\n\n# wacth\n\nwatch: {\n    data: {\n        immediate: true,\n        deep: true,\n        handler(newvalue, oldvalue) {\n\t\t\t// 处理函数\n        }\n    }\n},\n\n\n\n# v-html会遇到xxs攻击\n\n 1. 下载 xss 依赖\n    \n    npm install xss --save\n    \n\n 2. main.js中引入xss包并挂载到vue原型上\n    \n    import xss from \"xss\";\n    vue.prototype.xss = xss;\n    \n\n 3. 在vue.config.js中覆写html指令\n    \n    chainwebpack: config => {\n        config.module\n            .rule(\"vue\")\n            .use(\"vue-loader\")\n            .loader(\"vue-loader\")\n            .tap(options => {\n            options.compileroptions.directives = {\n                html(node, directivemeta) {\n                    (node.props || (node.props = [])).push({\n                        name: \"innerhtml\",\n                        value: `xss(_s(${directivemeta.value}))`\n                    });\n                }\n            };\n            return options;\n        });\n    }\n    \n\n\n# vue + element ui\n\nelement ui官网\n\n\n# form 表单验证\n\nform 表单 官网\n\n提示\n\n当一个 form 元素中只有一个输入框时，在该输入框中按下回车应提交该表单。如果希望阻止这一默认行为，可以在 <el-form> 标签上添加 @submit.native.prevent。\n\n# 验证bug原因只有以下两种：\n\n 1. 没有在data上定义（需要再验证之前定义好表单上的数据）\n 2. prop和v-model的字段不一致\n\n# 验证例子：\n\n<el-form :model=\"ruleform\" :rules=\"rules\" ref=\"ruleform\" label-width=\"100px\" class=\"demo-ruleform\">\n    <el-form-item label=\"活动名称\" prop=\"name\">\n        <el-input v-model=\"ruleform.name\"></el-input>\n    </el-form-item>\n    <el-form-item label=\"活动区域\" prop=\"region\">\n        <el-select v-model=\"ruleform.region\" placeholder=\"请选择活动区域\">\n            <el-option label=\"区域一\" value=\"shanghai\"></el-option>\n            <el-option label=\"区域二\" value=\"beijing\"></el-option>\n        </el-select>\n    </el-form-item>\n    <el-form-item label=\"活动时间\" required>\n        <el-col :span=\"11\">\n            <el-form-item prop=\"date1\">\n                <el-date-picker type=\"date\" placeholder=\"选择日期\" v-model=\"ruleform.date1\" style=\"width: 100%;\"></el-date-picker>\n            </el-form-item>\n        </el-col>\n        <el-col class=\"line\" :span=\"2\">-</el-col>\n        <el-col :span=\"11\">\n            <el-form-item prop=\"date2\">\n                <el-time-picker type=\"fixed-time\" placeholder=\"选择时间\" v-model=\"ruleform.date2\" style=\"width: 100%;\"></el-time-picker>\n            </el-form-item>\n        </el-col>\n    </el-form-item>\n    <el-form-item label=\"即时配送\" prop=\"delivery\">\n        <el-switch v-model=\"ruleform.delivery\"></el-switch>\n    </el-form-item>\n    <el-form-item label=\"活动性质\" prop=\"type\">\n        <el-checkbox-group v-model=\"ruleform.type\">\n            <el-checkbox label=\"美食/餐厅线上活动\" name=\"type\"></el-checkbox>\n            <el-checkbox label=\"地推活动\" name=\"type\"></el-checkbox>\n            <el-checkbox label=\"线下主题活动\" name=\"type\"></el-checkbox>\n            <el-checkbox label=\"单纯品牌曝光\" name=\"type\"></el-checkbox>\n        </el-checkbox-group>\n    </el-form-item>\n    <el-form-item label=\"特殊资源\" prop=\"resource\">\n        <el-radio-group v-model=\"ruleform.resource\">\n            <el-radio label=\"线上品牌商赞助\"></el-radio>\n            <el-radio label=\"线下场地免费\"></el-radio>\n        </el-radio-group>\n    </el-form-item>\n    <el-form-item label=\"活动形式\" prop=\"desc\">\n        <el-input type=\"textarea\" v-model=\"ruleform.desc\"></el-input>\n    </el-form-item>\n    <el-form-item>\n        <el-button type=\"primary\" @click=\"submitform('ruleform')\">立即创建</el-button>\n        <el-button @click=\"resetform('ruleform')\">重置</el-button>\n    </el-form-item>\n</el-form>\n<script>\n    export default {\n        data() {\n            return {\n                ruleform: {\n                    name: '',\n                    region: '',\n                    date1: '',\n                    date2: '',\n                    delivery: false,\n                    type: [],\n                    resource: '',\n                    desc: ''\n                },\n                rules: {\n                    name: [\n                        { required: true, message: '请输入活动名称', trigger: 'blur' },\n                        { min: 3, max: 5, message: '长度在 3 到 5 个字符', trigger: 'blur' }\n                    ],\n                    region: [\n                        { required: true, message: '请选择活动区域', trigger: 'change' }\n                    ],\n                    date1: [\n                        { type: 'date', required: true, message: '请选择日期', trigger: 'change' }\n                    ],\n                    date2: [\n                        { type: 'date', required: true, message: '请选择时间', trigger: 'change' }\n                    ],\n                    type: [\n                        { type: 'array', required: true, message: '请至少选择一个活动性质', trigger: 'change' }\n                    ],\n                    resource: [\n                        { required: true, message: '请选择活动资源', trigger: 'change' }\n                    ],\n                    desc: [\n                        { required: true, message: '请填写活动形式', trigger: 'blur' }\n                    ]\n                }\n            };\n        },\n        methods: {\n            submitform(formname) {\n                this.$refs[formname].validate((valid) => {\n                    if (valid) {\n                        alert('submit!');\n                    } else {\n                        console.log('error submit!!');\n                        return false;\n                    }\n                });\n            },\n            resetform(formname) {\n                this.$refs[formname].resetfields();\n            }\n        }\n    }\n<\/script>\n\n\n注意\n\n在wacth中调用 $refs 方法，需要在 $nexttick 函数内使用\n\nwatch: {\n    data: {\n        immediate: true,\n        deep: true,\n        handler(newvalue, oldvalue) {\n            this. $nexttick(()=>{\n            \tthis.$refs[formname].resetfields();\n            })\n        }\n    }\n},\n\n\n\n# datepicker 日期选择器\n\ndatepicker 日期选择器 官网\n\n# 限制时间的选择\n\n<el-date-picker\n                :value=\"value\"\n                :placeholder=\"data.label\" \n                type=\"date\"\n                value-format=\"yyyy-mm-dd\"\n                :picker-options=\"pickerdisabled\">\n</el-date-picker>\n\n\n在vue的data上定义范围\n\npickerdisabled: {\n    //结束时间限制\n    disableddate: (time) => {\n        let beginval = this.forminline.starttime; // this.forminline.starttime：开始时间\n        if (beginval) {\n            return (\n                time.gettime() < new date(beginval).gettime() - 86400000 ||\n                time.gettime() > date.now()\n            );\n        } else {\n            return time.gettime() > date.now(); // 不能选择大于今天的日期\n        }\n    },\n},\n\n\n\n# upload 上传\n\nupload 上传 官网\n\n\n# vue + vue-i18n\n\n1.在项目文件src下新建internationalization（自定义）文件夹\n\n\n\n2.安装国际化依赖包\n\nnpm i vue-i18n -s\n\n\n3.在internationalization（自定义）文件夹下新建文件 en.js、zh.js、index.js\n\n\n\n4.在上述index.js文件中，写入\n\nimport vue from 'vue'\nimport vuei18n from 'vue-i18n'\nimport cookies from 'js-cookie'\nimport elementenlocale from 'element-ui/lib/locale/lang/en' // element-ui lang\nimport elementzhlocale from 'element-ui/lib/locale/lang/zh-cn'// element-ui lang\nimport enlocale from './en'\nimport zhlocale from './zh'\n\nvue.use(vuei18n)\n\nconst messages = {\n    en: {\n        ...enlocale,\n        ...elementenlocale\n    },\n    zh: {\n        ...zhlocale,\n        ...elementzhlocale\n    }\n}\nexport function getlanguage() {\n    const chooselanguage = cookies.get('language')||'zh-cn'\n    console.log('当前语言',chooselanguage)\n    if (chooselanguage) return (chooselanguage === 'zh-cn' ? 'zh' : 'en')\n\n    // if has not choose language\n    const language = (navigator.language || navigator.browserlanguage).tolowercase()\n    const locales = object.keys(messages)\n    for (const locale of locales) {\n        if (language.indexof(locale) > -1) {\n            return locale\n        }\n    }\n    return 'en'\n}\nconst i18n = new vuei18n({\n    // set locale\n    // options: en | zh | es\n    locale: getlanguage(),\n    // set locale messages\n    messages\n})\n\nexport default i18n\n\n\n5.在上述zh.js/en.js文件中分别写入\n\nexport default {\n    login: {\n        wisdomlightingsystem: '智慧照明系统'\n    },\n    route: {\n        projectlog: '项目日志'\n    }\n}\n\n\nexport default {\n    login: {\n        wisdomlightingsystem: 'wisdom lighting'\n    },\n    route: {\n        projectlog: 'project log'\n    }\n}\n\n\n6.在全局的main.js文件中引入\n\n\n\n\n\n7.在页面内使用\n\n\n\n8.关于路由导航的国际化（这里是我自己的配置，仅供参考）\n\n\n\n\n\n\n\n9.最终结果\n\n\n\n\n# vue 封装 前端 @功能的实现\n\n在输入框中输入@后，弹出选人的浮框，然后选择人（可多选），选完后，关闭浮框，然后在输入框中加入@xxx，然后焦点定位刚开始输入@的位置。删除的时候，@xxx要一块删除。 分析： 1.因为要在输入框中把@xxx高亮显示，所以需要用到可编辑元素。\n\n <div contenteditable></div>\n\n\n2.用到selection和range对象\n\n开撸：\n\n<div \n     classname={styles.talkinput} \n     id=\"talkinput\" \n     contenteditable\n     onkeydown={ontalkkeydown}\n     oninput={changetalkcontent}>\n</div>\n\n\nfunction changetalkcontent(e) {\n    settalkcontent(e.target.innertext);\n    if (e.nativeevent.data === '@') { //监听输入@\n        openselect();\n    }\n}\n\n\nfunction openselect() {\n    //打开选人浮层\n    dispatch({ type: 'share/update', payload: { visible: true } });\n    let selection = window.getselection();//创建selection,用法可以直接去mdn 去查看 https://developer.mozilla.org/zh-cn/docs/web/api/selection\n    setfocusnode(selection.focusnode); // 缓存光标所在节点\n    setfocusoffset(selection.focusoffset); // 缓存光标所在节点位置\n    let inputid = document.getelementbyid('talkinput');\n    inputid.blur();\n}\n\n\n选完人后\n\nfunction onselectsubmit(val) {\n    //val 选择的人的信息\n    let userlist = val.shareduserids;\n    setdirectusers([...directusers, ...userlist]);\n    let inputid = document.getelementbyid('talkinput');\n    let selection = window.getselection();\n    let range = window.getselection().getrangeat(0);\n    //选中输入的@符号\n    range.setstart(focusnode, focusoffset - 1);\n    range.setend(focusnode, focusoffset);\n    //删除输入的@符号\n    range.deletecontents();\n\n    userlist.foreach((s) => {\n        var spannode1 = document.createelement('span');\n        var spannode2 = document.createelement('span');\n        spannode1.classname = styles.atfont;\n        spannode1.innerhtml = '@' + s.nickname;\n        spannode1.contenteditable = false;//设置为不可编辑，是为了整个@xxx一起删掉\n        spannode1.setattribute('data-userid', s.userid);\n        spannode2.innerhtml = '&nbsp;';\n        var frag = document.createdocumentfragment(),\n            node,\n            lastnode;\n        frag.appendchild(spannode1);//在 range 的起点处插入一个节点。\n        while ((node = spannode2.firstchild)) {\n            lastnode = frag.appendchild(node);\n        }\n        range.insertnode(frag);\n        selection.extend(lastnode, 1);\n        selection.collapsetoend();//将当前的选区折叠到最末尾的一个点。\n    });\n}\n\n\n删除@xxx的时候，要把@xxx一起删除\n\nfunction ontalkkeydown(e) {\n    let inputid = document.getelementbyid('talkinput');\n    let deluserid = null,\n        candel = true;\n    if (e.key == 'backspace') {//按下删除键时\n        let range = window.getselection().getrangeat(0);\n        let removenode = null;\n        //焦点在@xxx后面的时候\n        if (range.startoffset <= 1 && range.startcontainer.parentelement.classname.indexof('atfont') < 0) {\n            removenode = range.startcontainer.previouselementsibling;\n        }\n        //  点一下@xxx的时候，直接删除@xxx的时候，此时range.startcontainer是@xxx,range.startcontainer.parentelement是<span>@xxx</span>\n        if (range.startcontainer.parentelement.classname.indexof('atfont') >= 0) {\n            removenode = range.startcontainer.parentelement;\n        }\n        if (removenode) {\n            deluserid = removenode.getattribute('data-userid');\n            inputid.removechild(removenode);\n        }\n\n        let userlist = [...directusers],\n            newuserlist = [];\n        userlist.foreach((s) => {\n            if (candel && s.userid === deluserid) {\n                candel = false;\n            } else {\n                newuserlist = [...newuserlist, { ...s }];\n            }\n        });\n        setdirectusers([...newuserlist]);\n    }\n}\n\n\n结束。\n\n\n# 基于contenteditable技术实现@选人功能\n\n@功能，是一个“看起来简单”，实际上“要考虑特别多问题” 的功能需求。本文对这个常见的功能需求的实现进行了记录。\n\n之前我在小程序里在没有 contenteditable 的input中实现了一个输入 @ 字符实现 at 选人功能的需求。无米之炊: 小程序内实现一个具有“@功能at功能”的输入框。当时由于小程序缺少富文本输入框，因此只能在纯 input 里面实现人名输入和用户信息还原。\n\n如今咱们就要来实现 web 的版本了。web 端具有更加丰富的 api 给我们使用，但是其考虑的问题也会更多，因为web端用户的输入变换莫测(即用户可以使用鼠标、键盘或其他输入设备随意的选择、粘贴、控制文本框)。因此，web端如果采用拦截用户所有输入情况进行 \"虚拟抽象层\" 处理和渲染会有些力不从心。\n\n本文最终还是采用通用的方案---contenteditable来实现，下面介绍其过程和思路。\n\n明确需求\n\n要做这个需求，我们需要首先明确 at功能需求 其本质上要包含哪些必要的功能以及一些特定的前置条件，这会直接影响到我们技术方案的设计。\n\n前置条件明确\n\n我们需要向产品确认联系人中是否有 “重名” 的联系人，如联系人中是否会有 2 个叫做 “小明” 的联系人。\n\n如果不会重名，我们便可以使用一种 “类似新浪微博” 的方案，即无需管理和记录每个人的真实id，只需让用户在文本框内随意选择和输入文本和人名，等到最后用户点击保存提交微博时，将文本框内的字符串依次遍历反解(反解办法就是，先找到一个@字符作为开始，然后直到碰到一个空格作为结束，看一下该字符串是否等于某个人名账号)。\n\n由于新浪微博他的人名(账户)是唯一的，因此他便采用了如上简便的做法。从我们随意输入和粘贴一段文本之后产生的bug来看，的确如此：\n\n以上是我通过鼠标@或者文本输入插入了一些 齐鲁晚报 的人名。但是当我主动把其中某些字符删掉，或者把 \"@齐鲁晚报\" 后方的空格干掉，提交后微博便无法还原我at的人了。图上每个人名我都无法hover或点击(因为我破坏了人名反解的结构)。\n\n但是，如果我从其他地方拷贝一个 \"@齐鲁晚报\" 的字符串，然后在其后方敲入一个空格，再提交，则微博可以获取到该用户。\n\n因此，我们猜到新浪微博反解人名的办法是：寻找@字符及其后方的空格作为一个人名。我们查看新浪微博dom中是通过textarea实现的输入框，通过其 api限制以及上面的效果来看，其原理就是如我们所猜测的一样：基于输入内容的字符串进行反解而已，思路比较简单。\n\n而本文我所面向的需求前置条件是：联系人具有可重复的人名。此时的技术方案便面临一个最大的问题：如何能反解出输入框中人名的信息？举例来说：假如我们输入框中的字符串内容是 \"你好，@小明，我们一起吃饭吧，你叫上另外一个 @小明\"。 那么，提交给后台存储时，我们比如告知后台第一个小明是1号小明，第二个小明是2号小明。如何做到呢？这个我们在下文讲述。\n\n需求定义\n\nok，我们来基于 “人名可以重复” 这个前置条件，来定义一下我们的需求。用户可以在文本框中输入任意的普通字符\n\n用户可以通过输入一个 \"@\" 字符来调起一个选人浮层，选人浮层的位置必须放置在光标所在的位置，且能够根据窗口边缘进行适当的位置调整。例如下方空间不够时，则放到上方。我们来看看新浪微博：\n\n这个是默认下方空间够用的时候。当下方不够时，浮层会出现在上方：\n\n但是，经过测试，当右侧空间不够时，它并没有出现在左方：\n\n理论上，最好的方案应该是：左上、左下、右上、右下每个方向都可以放置浮层，如果任何一个位置空间不够，则换一个位置放置。其放置也是有优先级的，例如右下方和右上方同时都能放下，则右下方优先级更高。其优先级顺序应该是：右下方、右上方、左下方、左上方。\n\n当选人浮层出现后，用户可以通过键盘的“上”、“下”来操纵选人浮层上对应的人选，并可以通过“回车键”将人选填入到输入框中。当然，也可以支持鼠标选择。\n\n输入框中的人名是一个整体。即：当用户鼠标在输入框中人名附近左右移动时，光标不能放置到人名中间。同时，用户在人名后方按下“退格”键，则会把当前人名整体瞬间删除。\n\n支持模糊搜索。即：当用户输入 @ 时，弹出推荐的联系人，当他输入 \"@小\"，则浮层里要把 \"小明\" \"小红\" \"小x\" 等搜索后的联系人。 且选人完毕后，要把选中的如 \"小红\" 填入到文本框中\n\n用户输入完毕后，可以把文本框中所有字符串或人名转成对应的结构存储到后端存储。从而在其他页面可以展示。例如qq空间发表说说后，后台需要给你输入的人名发送at通知，而且要在你的qq说说页面展示你发表的内容(当你鼠标放到人名上还可以展示用户卡片)，如图：\n\n技术上要考虑的点：\n\n需求看起来简单，实际上这个功能是个前端大坑。我们看看这涉及到多少个要考虑的点，每个点都不是那么简单：如何能反解出输入框中人名的信息\n\n后台提交接口该如何设计\n\n人名检索接口设计。用户键入关键字后，要通过搜索接口实时拉取人名，api接口该如何设计\n\n如何检测@字符。如何区分是出默认人选还是按输入模糊检索。\n\n选人后如何替换掉原来的检索文案。\n\n选人浮层的定位。如何定位光标位置，如何将浮层放置在页面中最合适的位置；当浮层还没渲染时，如何知道浮层宽高从而进行位置选择\n\n中文输入bug。中文输入时，编辑器内会先出现拼音，等用户按“空格”或“回车”后变成中文，应该如何处理这种场景\n\n如何实现整个人名一次性删除\n\n人名隔离问题。即如何确保输入人名之后，再输入其他字符时自动产生一个新的textnode类型的节点，而不是插入到人名标签中\n\nplaceholder 怎样实现\n\n粘贴操作的处理。当用户粘贴富文本时，我们要不允许其粘贴或者将其粘贴内容转成纯文本。\n\n下面我们依次来说明如何基于 web前端 来说实现一个具有完整at功能的输入框。\n\n行业洞察\n\n我们来瞅瞅行业里别人是咋做的。\n\n新浪微博\n\n微博是通过一个纯的 textarea 来实现的at功能。我们可以看到，他输入的人名就是一个纯字符串，且我们可以把光标放置到人名中间，甚至我们可以删掉人名中的某个字符，从而破坏掉人名：\n\n因此，他的实现是 “仅仅将用户所选的用户id放到输入框对应位置”。他也无须对输入框中的人名建立一个用户信息的记录映射，因为他的场景比较特殊：它at出来的每个人名都是一个唯一id。所以，当他把输入框文本提交给后台时，也无须做任何处理，直接提交即可。后台可以根据字符串中的 “@” 和 “@后方的空格” 找出每个 “所谓的人名” 然后检索数据库找出其对应的用户信息。\n\n通常这种at功能还存在一个“中文输入法”的坑，就是如果你输入中文，那么此时输入法会先将拼音放置到输入框，然后等你选词完毕后再把中文换到输入框，这会带来at功能的bug。我们看看新浪微博是咋处理的：在中文输入法输入时，新浪微博为了避免我们后文提到的诡异问题，它直接屏蔽掉了中文输入时的检索能力哈哈。如图，输入中文时并不会触发选人的搜索。\n\nqq空间\n\nqq空间是用 contenteditable 的div来实现的。他把用户信息藏到了一个标签里。如图文本框中有2个同名的 catting，但他们分别是2个不同的用户。 由于空间是使用 contenteditable 实现的输入框，因此其人名通过 button 标签给包裹起来了，于是它把每个用户的id等信息藏到了button标签中。\n\nqq空间怎么处理中文输入法问题的呢，我们看看：\n\n恩，他直接在有输入法弹窗的情况下，不允许你通过键盘操纵选人面板，也就不存在互相影响的问题了，也是机智。\n\n再看看 qq 空间的 placeholder 是怎么实现的呢？我们看看他的输入框dom：\n\n发现这里有个div里放置了placeholder的内容，盖在输入框上面。该dom跟输入框div并列。当我们鼠标点击placeholder位置的时候，意味着我们打算开始输入，这时他把placeholder div隐藏，并主动聚焦到输入框的div里面，从而实现了placeholder效果。\n\n由于我们的需求背景存在人名重复，因此无法采用新浪微博这种 “基于字符串解析反解” 的方案，而必须采用类似 qq空间的 contenteditable 藏信息的方案。下面我们来分别看上文提到的各个技术点如何各个击破。\n\n如何能反解出输入框中人名的信息\n\n前文我们已经分析了能面向“人名重复”场景的解决方案，只有如下2个办法：拦截用户的输入，搞一个 虚拟抽象层，像我之前做的 小程序方案一样，维持一个特殊的内存结构。\n\n使用 contenteditable 的富文本输入框作为输入区域。这样可以将每个人的用户信息藏到文本框里的人名标签里。例如使用span或button包裹人名。\n\n第一种方案比较适合小程序场景下输入模式比较单一，只有虚拟键盘的输入；对于pc端用户输入模式多样的情况来说，实现难度极大。因此，我们采用方案2这种比较主流和简便的方案---把用户信息藏到标签里。\n\n举个栗子：你在输入框中输入了 “你好 @小明”。 那么在 contenteditable 的输入框中其实是：\n\n你好, @小明 这样，我们拿到输入框内部的innerhtml后，可以轻松的拿到每个at人名的个人信息。\n\n于是我设计了一个 ateditor 的vue组件，其 template 部分是这样的：\n\nref=\"jseditorelement\"\n\ncontenteditable=\"true\"\n\n:class=\"[placeholderclass]\"\n\n@keyup=\"oninputtext\"\n\n@keydown=\"oninputkeydown\"\n\n@blur=\"onclosedialog\"\n\n@mouseup=\"dotoggledialog\"\n\n@paste=\"doonpaste\"\n\n>\n\n{{(item.name)}}\n\n\n其中jseditorelement就是输入框，设置其contenteditable为ture，同时绑定好了各种事件进行后续的逻辑处理。\n\n其中jsdialogelement就是选人的浮层，通过visibility样式控制他是否展示，通过atdialogpos样式控制他的fixed定位的top和left坐标。\n\n后台提交接口设计\n\n当用户输入完毕，点击提交或保存时，我们的需求通常需要把文本框内部的文本和人名提取出来，且按序提交给后端存储。例如你空间或微博发布的每一条说说都要存储到后台数据库。那么，这里的接口我们可以将输入框内容抽象成1种消息结构，且该结构有2种类型。\n\nclass msg {\n    constructor(type, data) {\n\n        this.type = type; // type可以是at类型也可以是text类型\n\n        this.data = data\n\n    }\n\n}\n\n\n例如依然是 “你好，@小明” 这样的输入。那么我们提交给后台时，其数据结构是这样的:\n\nvar postmsgs = [\n\n    {\n\n        type: 'text',\n\n        data: '你好，'\n\n    },\n\n    {\n\n        type: 'at',\n\n        data: {\n\n            name: '小明',\n\n            id: 1\n\n        }\n\n    }\n\n]\n\n\n人名检索接口设计\n\n这里，我们是采用了2个不同的接口来分别实现 “获取推荐的几个联系人” 和 “根据用户输入的内容来搜索匹配的联系人”。因此，我们有如下2个接口：\n\ngetdefaultusers\n\n@paramslimit: 限制最大返回的联系人数量\n\n@returnpersons: [\n\n{ name: '小明', id: 1 },\n\n{ name: '小红', id: 2 }\n\n]\n\ngetsearchusers\n\n@paramslimit: 限制最大返回的联系人数量\n\nkeyword: 用户在@后方输入的用来搜索的文本\n\n@returnpersons: [\n\n{ name: '小明', id: 1 },\n\n{ name: '小红', id: 2 }\n\n]\n\n\n这里实际上也可以使用一个接口来实现。例如无论用户 “只输入了@”，还是输入了 \"@小\" 都通过 getsearchusers来调用，即只输入@时的keyword是空。\n\nat字符和输入的检测\n\n其实这里也比较复杂，我们不止要对 @ 字符做出特殊的反应。我们有多种不同的输入都要做出特殊的反应，如：当用户输入 @ 时，我们要调起默认选人\n\n当用户输入@，且后方跟着大于等于1个字符时，要调起搜索选人\n\n当用户鼠标点击到某个字符处，要判断光标前方字符是否有 @，且区分是调起默认选人还是搜素选人\n\n当用户键盘键入 “上箭头” “下箭头” 时，要将行为拦截并转换成对选人浮层人选的上下切换\n\n当用户输入“回车”时，要拦截并转换成对选人浮层人选的确认操作\n\n当用户输入“esc返回”时，要转成对选人浮层的关闭操作\n\n如上这些，我们主要是监听用户的 “keydown” 和 “keyup” 事件来做的。\n\n之所以有些在 keydown里做，有些在keyup里做，是因为在keyup发生的时候，用户的文字已经输入到文本框了，所以这个事件比较适合检测@字符。但是像有些按键我们是不期望他默认行为发生的，因此我需要在 keydown 的时候就拦截掉，例如回车、上下箭头。\n\n先来看，键盘事件keydown我是如何拦截的：\n\n// 键盘按下\n\noninputkeydown(e) {\n\n    if (this.isshowdialog) {\n\n        if (e.code == 'arrowdown' || e.code === 'arrowup') {\n\n            // 上下移动光标，用于调整 dialog 里的人\n\n            if (e.code == 'arrowdown') {\n\n                this.activeindex++\n\n                if (this.activeindex === this.lists.length) {\n\n                    this.activeindex = this.lists.length - 1\n\n                }\n\n            }\n\n            if (e.code == 'arrowup') {\n\n                this.activeindex--\n\n                if (this.activeindex === -1) {\n\n                    this.activeindex = 0\n\n                }\n\n            }\n\n            preventafteraction.call(this, e)\n\n        }\n\n        else if (e.code === 'enter') {\n\n            // 如果有弹窗，则代表确认选人\n\n            this.isshowdialog = false\n\n            preventafteraction.call(this, e)\n\n            this.selectperson(this.lists[this.activeindex])\n\n        }\n\n        else if (e.code === 'escape') {\n\n            this.isshowdialog = false\n\n            preventafteraction.call(this, e)\n\n        }\n\n    }\n\n    else {\n\n        // 回车给拦掉，什么都不做\n\n        if (e.code === 'enter') {\n\n            preventafteraction.call(this, e)\n\n        }\n\n    }\n\n    function preventafteraction(e) {\n\n        e.preventdefault()\n\n        this.preventkeyup = true\n\n    }\n\n},\n\n\n再来看 keyup 我是如何检测 @ 的：\n\n// 按键弹起\n\noninputtext(e) {\n\n    if (this.preventkeyup) {\n\n        this.preventkeyup = false\n\n        return\n\n    }\n\n    this.preventkeyup = false\n\n    const el = e.currenttarget\n\n    // 这是输入了@，那就直接弹选人浮层\n\n    if (e.code == 'digit2' && e.shiftkey) {\n\n        this.showdefaultdialog()\n\n    }\n\n    else {\n\n        // 这里是输入的不是@，但是可能前方有@，因此需要进行检测看看是否要展示选人浮层\n\n        this.dotoggledialog()\n\n    }\n\n},\n\n\n来看看\n\ndotoggledialog:dotoggledialog() {\n\n    const rangeinfo = this.geteditorrange()\n\n    if (!rangeinfo || !rangeinfo.range || !rangeinfo.selection) return\n\n    const curnode = rangeinfo.range.endcontainer\n\n    if (!curnode || curnode.nodename !== '#text') return\n\n    const searchstr = curnode.textcontent.slice(0, rangeinfo.selection.focusoffset)\n\n    // 判断光标位置前方是否有at，只有一个at则展示默认dialog，除了at还有关键字则展示searchdialog\n\n    const keywords = (/@([^@]*)$/).exec(searchstr)\n\n    if (keywords && keywords.length >= 2) {\n\n        // 展示搜索选人\n\n        const key_words = keywords[1]\n\n        const allmathstr = keywords[0]\n\n        if (allmathstr === '@') {\n\n            this.showdefaultdialog()\n\n        }\n\n        else {\n\n            this.showsearchdialog(key_words)\n\n        }\n\n        // 重点：记下弹窗前光标位置range\n\n        this.editorrange = rangeinfo\n\n    }\n\n    else {\n\n        // 关掉选人\n\n        this.closedialog()\n\n    }\n\n},\n\n\n这里其实就是检测本次输入完字符后，光标前方是否有@，如果只有一个@就展示默认推荐人，如果是 \"@xxx\" 这样的结构，则用xxx去检索推荐人。\n\nshowsearchdilaog的代码我就不贴了，其实就是查询接口，拿到返回的人选列表，放到当前 vue 的lists字段上。这里贴一下 geteditorrange的代码，他是用户获取当前光标选取的信息(即在弹出选人之前，把输入框中此刻的光标位置先记下来)\n\ngeteditorrange() {\n\n    let range = null;\n\n    let selection = null;\n\n    if (window.getselection) {\n\n        selection = window.getselection();\n\n        if (selection.getrangeat && selection.rangecount) {\n\n            range = selection.getrangeat(0);\n\n            return {\n\n                range,\n\n                selection,\n\n            };\n\n        } else {\n\n            return null;\n\n        }\n\n    } else {\n\n        return null;\n\n    }\n\n},\n\n\n选人浮层的定位。\n\n上文解决了浮层何时弹，现在就要解决浮层要弹在哪里的问题。我们需要在浮层isshow设置为 true之前，就要算出把浮层放在哪里。这里我们首先要解决俩问题：如何在浮层渲染之前知道当前浮层的宽高。因为我们要计算浮层边缘跟整个window窗口的边界，从而找到最合适的放置位置。\n\n如何知道当前光标的位置。因为我们的浮层必然是像一个气泡一样，以光标位置为起点展示的。\n\n对于第一个问题，基于 vue 的 nexttick 来实现即可，因为 nexttick是在vue的异步dom更新队列之后执行的，此时dom已经更新(同时我们的dialog是基于visibility实现隐藏的，因此其宽高我们实际上是能拿到的)。\n\n对于第二个问题，业界通常是使用一个隐藏标签来重放输入框内容从而计算位置。我们这里直接使用了一个现成的类库：http://ichord.github.io/caret...\n\n以下是 showdialog 函数的具体实现：\n\nshowdialog() {\n\n    this.isshowdialog = false // 先隐藏\n\n    this.$nexttick(() => {\n\n        // 等隐藏完毕，且最新lists数据dom生成后，可基于此时的dom去获取最新的dialog宽高和坐标\n\n        const el = this.$refs['jseditorelement']\n\n        const jsdialogelement = this.$refs['jsdialogelement']\n\n        if (!el) return\n\n        const caret = $(el).caret('offset')\n\n        var realposition = this._getadapterposition(caret, jsdialogelement) // 获取正确的放置坐标，防止超出边界。本文基于offset\n\n        this.atdialogpos = {\n\n            left: realposition.left + 'px',\n\n            top: realposition.top + 'px'\n\n        }\n\n        this.activeindex = 0\n\n        this.isshowdialog = true // 此时再展示出来\n\n    })\n\n},\n\n\n接下来的问题：如何将浮层放置在页面中最合适的位置。前文我们已经说了这个放置的大致最佳策略。即：左上、左下、右上、右下每个方向都可以放置浮层\n\n如果任何一个位置空间不够，则换一个位置放置。\n\n其放置也是有优先级的，例如右下方和右上方同时都能放下，则右下方优先级更高。其优先级顺序应该是：右下方、右上方、左下方、左上方。\n\n我是4个方向依次试探来实现的：\n\n_getadapterposition(caret, dialogelem) {\n\n    const fixheightgap = 5;\n\n    caret.top = caret.top - fixheightgap\n\n    caret.height = caret.height + fixheightgap + 5\n\n    const clientwidth = document.scrollingelement.clientwidth\n\n    const clientheight = document.scrollingelement.clientheight\n\n    const toclientleft = caret.left\n\n    const toclienttop = (caret.top - document.scrollingelement.scrolltop)\n\n    const toclientright = clientwidth - toclientleft\n\n    const toclientbottom = clientheight - toclienttop\n\n    const dialogsize = {\n\n        height: dialogelem.offsetheight,\n\n        width: dialogelem.offsetwidth\n\n    }\n\n    // 看是否可放右侧下方 (原点要从光标下方开始算起, 因此toclientbottom要加一下光标高度)\n\n    if (((toclientbottom - caret.height) >= dialogsize.height) && (toclientright >= dialogsize.width)) {\n\n        return {\n\n            top: toclienttop + caret.height,\n\n            left: toclientleft\n\n        }\n\n    }\n\n    else if ((toclienttop >= dialogsize.height) && (toclientright >= dialogsize.width)) {\n\n        return {\n\n            top: toclienttop - dialogsize.height,\n\n            left: toclientleft\n\n        }\n\n    }\n\n    else if (((toclientbottom - caret.height) >= dialogsize.height) && (toclientleft >= dialogsize.width)) {\n\n        return {\n\n            top: toclienttop + caret.height,\n\n            left: toclientleft - dialogsize.width\n\n        }\n\n    }\n\n    else if ((toclienttop >= dialogsize.height) && (toclientleft >= dialogsize.width)) {\n\n        return {\n\n            top: toclienttop - dialogsize.height,\n\n            left: toclientleft - dialogsize.width\n\n        }\n\n    }\n\n    else {\n\n        let left = toclientleft > toclientright ? toclientleft - dialogsize.width : toclientleft\n\n        let top = toclienttop > toclientbottom ? toclienttop - dialogsize.height : toclienttop + caret.height\n\n        return {\n\n            top,\n\n            left\n\n        }\n\n    }\n\n    return caret\n\n},\n\n\n如何实现整个人名一次性删除\n\n这里可以很复杂，也可以很简单。最简单的方案就是业界通常使用的 button 标签，尤其是 chrome 内核的浏览器，button标签方案是比较兼容的。我们可以将人名对应的用户信息 塞到 button 标签当中。但为了能在退格的时候将他整体删除且不能随意修改，我们通常对 button 标签再加点料：\n\nconst btn = document.createelement('button')\n\nbtn.dataset['person'] = json.stringify(person)\n\nbtn.textcontent = `@${person.name}`\n\nbtn.contenteditable = false\n\nbtn.addeventlistener('click', () => {\n\n    return false\n\n}, false)\n\nbtn.tabindex = '-1'\n\n\n选人后如何替换掉原来的检索文案。\n\n在弹出选人浮层的时候ontoggledialog中 ，我们有个关键的代码，就是：\n\n// 重点：记下弹窗前光标位置range\n\nthis.editorrange = rangeinfo\n\n\n由于我们之前的光标已经记下来了，因此，当选人确认后，我们要做的：就是把之前光标位置到前方@字符的内容delete删除，然后换成我们选择的人名(即我们创建的button标签)。代码如下：\n\nselectperson(person) {\n\n    person.corp_id = person.corp_id || window.corp_id;\n\n    this.isshowdialog = false\n\n    const editor = this.$refs['jseditorelement']\n\n    if (editor) {\n\n        editor.focus()\n\n        // 删掉草稿start\n\n        const editorrange = this.editorrange.range\n\n        if (!editorrange) return\n\n        const textnode = editorrange.endcontainer // 拿到末尾文本节点\n\n        const endoffset = editorrange.endoffset // 光标位置\n\n        // 找出光标前的at符号位置\n\n        const textnodevalue = textnode.nodevalue\n\n        const expres = (/@([^@]*)$/).exec(textnodevalue)\n\n        if (expres && expres.length > 1) {\n\n            editorrange.setstart(textnode, expres.index)\n\n            editorrange.setend(textnode, endoffset)\n\n            // console.log('要插入at的位置range', editorrange, editorrange.startoffset, editorrange.endoffset)\n\n            editorrange.deletecontents() // 删除草稿end\n\n            // console.log('delete后的range', editorrange, editorrange.startoffset, editorrange.endoffset)\n\n            // return\n\n            const btn = document.createelement('button')\n\n            btn.dataset['person'] = json.stringify(person)\n\n            btn.textcontent = `@${person.name}`\n\n            btn.contenteditable = false\n\n            btn.addeventlistener('click', () => {\n\n                return false\n\n            }, false)\n\n            btn.tabindex = '-1'\n\n            const bspacenode = document.createtextnode('\\u200b') // 不可见字符，为了放光标方便\n\n            this.inserthtmlatcaret([btn, bspacenode], this.editorrange.selection, this.editorrange.range)\n\n        }\n\n    }\n\n},\n\n\n人名隔离问题\n\n默认情况下，当我们的button添加到输入框之后，如果我们在 button 后方继续输入普通文本，那么文本可能会跑到button标签内部。\n\n例如，当你选择了小明之后，输入框中如果是这样的结构：\n\n你好，小明 当你在后方再输入：“一起吃饭”。那么，结构可能会变成：\n\n你好，小明一起吃饭把 新字符跑到了button标签内部，显然不符合我们的预期。因此，这里我们必须通过hack手段来解决。如何确保输入人名之后，再输入其他字符时自动产生一个新的textnode类型的节点，而不是插入到人名标签中呢？\n\n大家可能注意到上一小节代码中，我们给 inserthtmlatcaret 函数传递元素时，除了传递button，还传递了一个自己创建的 textnode节点：const bspacenode = document.createtextnode('\\u200b') // 不可见字符，为了放光标方便\n\n这个字符是一个不可见的字符，但他的确是一个字符。有了这么一个字符在 button 的后方，则我们新添加字符的话，他就是在 \\u200b位置往后添加，这样就可以实现我们期望的效果了。 关于插入什么字符，业界通常也会使用空格字符来实现，例如qq空间便是使用空格字符。\n\n而我这里为了不让领宽字符提交到后台，所以在提交之前做了下检测：// 从dom中拿出带有at信息的结构 (对于at是用button包裹，就把button里的date-person属性拿出来)\n\ngetmsgstructure: function(elem) {\n\n    elem = elem[0]\n\n    var res = []\n\n    var self = this\n\n    array.from(elem.childnodes).foreach(function(child) {\n\n        if (child.nodename === '#text') {\n\n            var str = child.nodevalue\n\n            if (str && str.length > 0) {\n\n                var lastchar = str[str.length - 1]\n\n                if (lastchar.charcodeat(0) === 0x200b) {\n\n                    // 零宽字符去掉\n\n                    str = str.slice(0, -1)\n\n                }\n\n            }\n\n            console.log('str', str)\n\n            if (str) {\n\n                res.push({type: 'text', data: str})\n\n            }\n\n        } else if (child.nodename === 'br') {\n\n            res.push({type: 'text', data: '\\n'})\n\n        } else if (child.nodename === 'button') {\n\n            res.push({type: 'at', data: json.parse(child.dataset.person)})\n\n        }\n\n        else if (child.nodename === 'span') {\n\n            res.push({type: 'text', data: child.textcontent})\n\n        }\n\n    })\n\n    res = self._defragmentation(res)\n\n    return res\n\n},\n\n\n数据碎片问题\n\n什么是数据碎片问题呢。举个栗子：\n\n例如：用户输入了 \"你好，@小明，吃了吗\" 这样一段话，当用户把“@小明” 删掉后，文本变成 “你好，吃了吗”，但实际上底层 contenteditable 文本域里面是2个 textnode：“你好，” 和 “吃了吗”。 虽然对于整体功能来说没什么大碍，但是不利于后端减少数据结构的冗余。\n\n那么这里的解决办法也比较容易，就是提交给后台之前，对同类型的 textnode 节点进行合并，减少碎片。这里简单实现了一下这个合并算法：\n\n_defragmentation(msgs) {\n\n    // msgs 就是上文说说的消息数据结构\n\n    const newmsgs = [];\n\n    msgs.foreach(msg => {\n\n        const last = newmsgs[newmsgs.length - 1];\n\n        if (last && last.type && last.type === 'text' && msg.type === 'text') {\n\n            last.data = last.data + msg.data\n\n        }\n\n        else {\n\n            if (msg && msg.type === 'text' && msg.renderlength == 0) return;\n\n            newmsgs.push(msg);\n\n        }\n\n    });\n\n    return newmsgs\n\n},\n\n\n中文输入bug\n\n中文输入时，编辑器内会先出现拼音，此时会触发输入框的 keydown，keyup等事件，从而导致我们选人浮层开始出现。可是当用户按下 回车键，我们的选人逻辑会将选中的人名放置到输入框，而中文输入法会将他的候选词放入输入框，这里会导致“选的人”和“选的词”同时出现到输入框里。\n\n应该如何处理这种场景呢？我采用的办法是，检测到中文输入选词完毕后，我们及时更新我vue组件内的光标选取变量，从而让选人事件发生后，可以正确的删除前方的文案。\n\n例如：当用户输入 \"@x\"，此时他输入法中出现了 “小，晓，笑” 等候选词，同时此时我们的选人浮层也出现了。\n\n当他按下回车，此时输入法会立刻将“小”放置到输入框，从而输入框内容变成 \"@小\"。而此时，我需要立刻将我 vue组件的 editorrange 变量更新，记录下此时光标位于 “@小” 后方。\n\n那么，接下来 回车会触发我的选人确认逻辑，此时我的逻辑会将光标位置开始到前方的@位置所有字符进行删除替换，因此 \"@小\"就变成了 “@小明”。\n\n做法：给输入框增加2个事件\n\n\"@compositionstart=\"oncompositionstart\"\n\n@compositiοnend=\"oncompositionend\"\n\n\n方法实现：\n\noncompositionstart() {\n\n    console.log('正在输入中文');\n\n},\n\n\noncompositionend(e) {\n\n    if (this.isshowdialog) {\n\n        // 重置光标位置，因为此时中文会填进去。。\n\n        this.editorrange = this.geteditorrange();\n\n    }\n\n},\n\n\nplaceholder 的实现\n\n这里，我采用了 css 的简便方案，即通过 empty 伪类选择器，检测到 div 中内容为空时，我们往输入框的 after 伪类下添加一个 文本；当光标focus到输入框的时候，我们使用 focus 伪类再清掉 after元素的内容。从而实现 placeholder 的效果。\n\n.at-editor-placeholder-cn:empty:before {\n\n    content: '填写内容，输入@以选择某人';\n\n    color: gray;\n\n}\n\n.at-editor-placeholder-cn:focus:before {\n\n    content: none;\n\n}\n\n\n粘贴的处理\n\n当用户进行“粘贴”，我们要拦截粘贴动作，并取其粘贴板上的文本内容，手工放置到光标位置。这里我在 ondopaste 函数中实现:\n\ndoonpaste(e) {\n\n    var pastedtext = undefined;\n\n    if (window.clipboarddata && window.clipboarddata.getdata) { // ie\n\n        pastedtext = window.clipboarddata.getdata('text');\n\n    } else if (e.clipboarddata && e.clipboarddata.getdata) {\n\n        pastedtext = e.clipboarddata.getdata('text/plain');\n\n    }\n\n    // 放到光标位置\n\n    const rangeinfo = this.geteditorrange()\n\n    if (rangeinfo && pastedtext) {\n\n        rangeinfo.range.deletecontents()\n\n        const newtextnode = document.createtextnode(pastedtext)\n\n        this.inserthtmlatcaret(newtextnode, rangeinfo.selection, rangeinfo.range)\n\n    }\n\n    e.preventdefault()\n\n    return false;\n\n},\n\n\n这里最主要是这一句：e.clipboarddata.getdata('text/plain');\n\n帮助我们拿到所有dom中的纯文本部分。\n\n总结\n\n至此，我们实现了一个 “看起来简单” 但 “要考虑的点特别多” 的输入框 at 功能。\n\n\n# 「多图预警」完美实现一个@功能\n\n地址：https://segmentfault.com/a/1190000042481321?utm_source=sf-hot-article\n\n\x3c!-- 富文本聊天消息输入框 --\x3e\n<div\n     class=\"chat-input\"\n     ref=\"chatinput\"\n     contenteditable=\"true\"\n     placeholder=\"请输入内容\"\n     @input=\"inputchatcontent\"\n     @blur=\"chatcontentblur\"\n     @mouseup=\"chatcontentmouseup\"\n     ></div>\n\x3c!-- 用户列表浮窗 --\x3e\n<ul\n    class=\"popper\"\n    v-show=\"isshowuserlist\"\n    ref=\"popper\"\n    :style=\"popperstyle\"\n    v-click-out-hide\n    >\n    <li v-for=\"(item, index) in userlist\" :key=\"index\" @click=\"selectuser(item)\">\n        <el-row>{{item.name}}</el-row>\n    </li>\n</ul>\n\n\nexport default {\n    methods: {\n        getrange(){\n            const selection = document.getselection();\n            const range = selection.getrangeat(0);\n            return range\n        },\n        /**\n        * 输入聊天内容\n        * @param {*} ev\n        */\n        inputchatcontent(ev) {\n            if (ev.data === '@') {\n                // 在输入@字符时候就保存一下光标\n                this.savecaret()\n                const pos = this.getcaretpos()\n                this.showuserlist()\n                this.$nexttick(() => {\n                    this.setuserlistpos(pos)\n                })\n            } else {\n                this.hideuserlist()\n            }\n        },\n\n        /**\n        * 获取光标位置\n        * @returns\n        */\n        getcaretpos() {\n            const range = this.getrange()\n            const pos = range.getboundingclientrect()\n\n            return pos\n        },\n\n        /**\n        * 设置用户列表的位置\n        * @param {*} pos\n        */\n        setuserlistpos(pos) {\n            const $popper = this.$refs.popper\n            const panelwidth = $popper.offsetwidth\n            const panelheight = $popper.offsetheight\n            const { x, y } = pos\n\n            this.popperstyle = {\n                top: y - panelheight - 20 + 'px',\n                left: x - panelwidth / 2 + 'px'\n            }\n        },\n\n        hideuserlist() {\n            this.isshowuserlist = false\n        },\n\n        showuserlist() {\n            this.isshowuserlist = true\n        },\n\n\n        /**\n        * 选择用户\n        */\n        selectuser(user) {\n            // 让失焦事件先执行\n            settimeout(() => {\n                this.hideuserlist()\n                this.insertcontent(user)\n            })\n        },\n\n        /**\n        * 恢复光标\n        */\n        restorecaret() {\n            if (this.lastrange) {\n                const selection = window.getselection()\n                selection.removeallranges()\n                selection.addrange(this.lastrange)\n            }\n        },\n\n        /**\n        * 插入内容\n        * @param {*} data\n        */\n        insertcontent(data) {\n            this.restorecaret() // 还原光标\n\n            const selection = window.getselection()\n            const range = selection.getrangeat(0)\n            range.collapse(false) // 折叠选区，光标移到最后\n            range.insertnode(data.content)\n            range.collapse(false)\n\n            selection.removeallranges()\n            selection.addrange(range)\n        },\n        /**\n        * 删除输入框中光标位置现有的@字符\n        */\n        deletecaretatcode() {\n            const range = this.getrange()\n            // 光标开始节点和光标在节点上的偏移量，找到光标准确位置，选中光标位置前一个字符范围并删除，\n            const node = range.startcontainer\n            const end = range.endoffset\n\n            // 开始节点内容最后一个字符是@，删除，否则不删除\n            if (node.textcontent[end - 1] === '@') {\n                range.setstart(node, end ? end - 1 : 0)\n                range.deletecontents()\n            }\n        },\n\n        /**\n        * 转换要插入光标位置的内容\n        * @param {*} data\n        */\n        parsecontent(data) {\n            const { type = 'text', name } = data\n            let content = null\n\n            // type 是插入内容类型，可能是文本、@标签、图片、表情等\n            if (type === 'text') {\n                content = document.createtextnode(name)\n            } else if (type === 'at') {\n                // 删除输入框中光标位置现有的@字符\n                this.deletecaretatcode()\n\n                const $span = document.createelement('span')\n                $span.contenteditable = false\n                $span.classlist.add('tag')\n                $span.innerhtml = `@${name}`\n\n                // 插入一个空格字符（\\u0010）到@标签后面，可以解决部分浏览器上光标在聊天输入框后面\n                const $space = document.createtextnode('\\u0010')\n                const frag = document.createdocumentfragment()\n\n                frag.appendchild($span)\n                frag.appendchild($space)\n\n                content = frag\n            }\n            return content\n        },\n\n        /**\n        * 插入内容\n        * @param {*} data\n        */\n        insertcontent(data) {\n            this.restorecaret() // 还原光标\n\n            const selection = window.getselection()\n            const range = selection.getrangeat(0)\n            range.collapse(false) // 折叠选区，光标移到最后\n\n            const pc = this.parsecontent(data)\n            range.insertnode(pc)\n            range.collapse(false)\n\n            selection.removeallranges()\n            selection.addrange(range)\n        }\n    }\n}\n\n\n.popper li {\n    /* 用户不能选中文本 firfox 非编辑编辑元素也可选中 */\n    user-select: none;\n    -webkit-user-select: none;\n    list-style: none;\n    padding: 10px;\n}\n",charsets:{cjk:!0}},{title:"vuex",frontmatter:{},regularPath:"/vue/vuex.html",relativePath:"vue/vuex.md",key:"v-4b9df42c",path:"/vue/vuex.html",headers:[{level:2,title:"vuex的使用例子",slug:"vuex的使用例子",normalizedTitle:"vuex的使用例子",charIndex:45},{level:2,title:"刷新的保存数据",slug:"刷新的保存数据",normalizedTitle:"刷新的保存数据",charIndex:3590}],headersStr:"vuex的使用例子 刷新的保存数据",content:'# vuex\n\nvue官网 https://vuex.vuejs.org/zh/\n\n\n# vuex的使用例子\n\n# vuex 填写 dashboardStore.js(单个)\n\nimport dashboardService from "@/services/dashboardService"; // 封装的接口\nvar dashboardStore = {\n    namespaced: true, //使用命名空间，这样只在局部使用\n    state: {\n        searchContent: \'\', // 首页-搜索内容\n        allSearchResultData: [] // 首页的展示内容\n    },\n    mutations: {\n        //首页-搜索参数 赋值\n        changeSearchContent: (state, newVal) => {\n            state.searchContent = newVal;\n        },\n        //首页-搜索参数 清空\n        removeSearchContent: (state) => {\n            state.searchContent = \'\'\n        },\n    },\n    actions: {\n        // 通过接口返回 赋值\n        textSearchForPage: async ({ commit, state }, payLoad) => {\n            let params = {\n                text: state.searchContent,\n                desc: payLoad.desc,\n            };\n            const { data, code } = await dashboardService.resultDosearch(params);\n            state.allSearchResultData = data.rows;\n        }\n    },\n};\n\nexport default dashboardStore;\n\n\n# 汇合 datamanagement.js\n\nimport dashboardStore from \'./dashboardStore\'//首页\n// 数据资产模块\nconst datamanagement = { \n    state: {\n    },\n    mutations: {},\n    actions: {},\n    modules: {\n        dashboardStore, //首页\n    },\n}\n\nexport default { datamanagement }\n\n\n# vuex 挂载 store.js\n\nimport Vue from \'vue\'\nimport Vuex from \'vuex\'\nimprt datamanagement from \'./datamanagement\'\n\nVue.use(Vuex)\n\nconst store = new Vuex.Store({...datamanagement})\n\nexport default store;\n\n\n# main.js\n\nimport store from \'store\'\nnew Vue({\n    el: \'#app\',\n    store: store,\n})\n\n\n# 监听修改搜索参数，同时修改vuex上的储存参数\n\nimport { mapState } from "vuex";\n\nexport default {\n    data() {\n        return {\n            obj:\'\'\n        }\n    },\n    computed: {\n        ...mapState("dashboardStore", {\n            searchJump: (state) => state.searchJump,\n        }),\n    },\n    watch: {\n        searchJump: {\n            handler(newval, oldval) {\n                let obj = this.obj // 搜索参数\n                // 事件处理函数 修改vuex内的数据\n                this.$store.commit("dashboardStore/changeSearchContent", obj);\n            },\n            deep: true,\n            immediate: true,\n        },\n    },\n}\n\n\n# 监听结果展示\n\nhtml代码\n\n<header v-if="allSearchResult.length !== 0">\n    <section\n             v-for="detailData in allSearchResult"\n             :key="detailData.id"\n             >\n        <div>...</div>\n    </section>\n</header>\n\n\njs代码\n\nimport { mapState } from "vuex";\n\nexport default {\n    data() {\n        return {\n            obj:\'\'\n        }\n    },\n    computed: {\n        ...mapState("dashboardStore", {\n            allSearchResult: (state) => state.allSearchResultData,  // 搜索结果获取\n            searchJump: (state) => state.searchJump,\n        }),\n    },\n    watch: {\n        searchJump: {\n            handler(newval, oldval) {\n                let obj = this.obj // 搜索参数\n                // 事件处理函数 修改vuex内的数据\n                this.$store.commit("dashboardStore/changeSearchContent", obj);\n            },\n            deep: true,\n            immediate: true,\n        },\n    },\n}\n\n\n# 调用vuex上的查询接口\n\nimport {  mapActions } from "vuex";\nexport default {\n    data() {\n        return {\n            searchContent:\'\'\n        }\n    },\n    methods: {\n        // 格式化日期\n        ...mapActions("dashboardStore", ["textSearchForPage"]),\n        search(){\n            this.$store.commit(\n                "dashboardStore/changeSearchContent",\n                this.searchContent\n            );\n            let params = {\n                searchContent: this.searchContent,\n                desc: false,\n            };\n            this.textSearchForPage(params)\n        }\n    }\n}\n\n\n\n# 刷新的保存数据\n\n在vue的app.vue的created函数添加代码：\n\nif (sessionStorage.getItem("pteTagsNav")) {\n    this.$store.replaceState(\n        Object(\n            {},\n            this.$store.state.pte_tagsNav.homeName,\n            sessionStorage.getItem("pteTagsNav")\n        )\n    );\n}\nwindow.addEventListener("beforeunload", () => {\n    sessionStorage.setItem(\n        "pteTagsNav",\n        this.$store.state.pte_tagsNav.homeName\n    );\n});\n',normalizedContent:'# vuex\n\nvue官网 https://vuex.vuejs.org/zh/\n\n\n# vuex的使用例子\n\n# vuex 填写 dashboardstore.js(单个)\n\nimport dashboardservice from "@/services/dashboardservice"; // 封装的接口\nvar dashboardstore = {\n    namespaced: true, //使用命名空间，这样只在局部使用\n    state: {\n        searchcontent: \'\', // 首页-搜索内容\n        allsearchresultdata: [] // 首页的展示内容\n    },\n    mutations: {\n        //首页-搜索参数 赋值\n        changesearchcontent: (state, newval) => {\n            state.searchcontent = newval;\n        },\n        //首页-搜索参数 清空\n        removesearchcontent: (state) => {\n            state.searchcontent = \'\'\n        },\n    },\n    actions: {\n        // 通过接口返回 赋值\n        textsearchforpage: async ({ commit, state }, payload) => {\n            let params = {\n                text: state.searchcontent,\n                desc: payload.desc,\n            };\n            const { data, code } = await dashboardservice.resultdosearch(params);\n            state.allsearchresultdata = data.rows;\n        }\n    },\n};\n\nexport default dashboardstore;\n\n\n# 汇合 datamanagement.js\n\nimport dashboardstore from \'./dashboardstore\'//首页\n// 数据资产模块\nconst datamanagement = { \n    state: {\n    },\n    mutations: {},\n    actions: {},\n    modules: {\n        dashboardstore, //首页\n    },\n}\n\nexport default { datamanagement }\n\n\n# vuex 挂载 store.js\n\nimport vue from \'vue\'\nimport vuex from \'vuex\'\nimprt datamanagement from \'./datamanagement\'\n\nvue.use(vuex)\n\nconst store = new vuex.store({...datamanagement})\n\nexport default store;\n\n\n# main.js\n\nimport store from \'store\'\nnew vue({\n    el: \'#app\',\n    store: store,\n})\n\n\n# 监听修改搜索参数，同时修改vuex上的储存参数\n\nimport { mapstate } from "vuex";\n\nexport default {\n    data() {\n        return {\n            obj:\'\'\n        }\n    },\n    computed: {\n        ...mapstate("dashboardstore", {\n            searchjump: (state) => state.searchjump,\n        }),\n    },\n    watch: {\n        searchjump: {\n            handler(newval, oldval) {\n                let obj = this.obj // 搜索参数\n                // 事件处理函数 修改vuex内的数据\n                this.$store.commit("dashboardstore/changesearchcontent", obj);\n            },\n            deep: true,\n            immediate: true,\n        },\n    },\n}\n\n\n# 监听结果展示\n\nhtml代码\n\n<header v-if="allsearchresult.length !== 0">\n    <section\n             v-for="detaildata in allsearchresult"\n             :key="detaildata.id"\n             >\n        <div>...</div>\n    </section>\n</header>\n\n\njs代码\n\nimport { mapstate } from "vuex";\n\nexport default {\n    data() {\n        return {\n            obj:\'\'\n        }\n    },\n    computed: {\n        ...mapstate("dashboardstore", {\n            allsearchresult: (state) => state.allsearchresultdata,  // 搜索结果获取\n            searchjump: (state) => state.searchjump,\n        }),\n    },\n    watch: {\n        searchjump: {\n            handler(newval, oldval) {\n                let obj = this.obj // 搜索参数\n                // 事件处理函数 修改vuex内的数据\n                this.$store.commit("dashboardstore/changesearchcontent", obj);\n            },\n            deep: true,\n            immediate: true,\n        },\n    },\n}\n\n\n# 调用vuex上的查询接口\n\nimport {  mapactions } from "vuex";\nexport default {\n    data() {\n        return {\n            searchcontent:\'\'\n        }\n    },\n    methods: {\n        // 格式化日期\n        ...mapactions("dashboardstore", ["textsearchforpage"]),\n        search(){\n            this.$store.commit(\n                "dashboardstore/changesearchcontent",\n                this.searchcontent\n            );\n            let params = {\n                searchcontent: this.searchcontent,\n                desc: false,\n            };\n            this.textsearchforpage(params)\n        }\n    }\n}\n\n\n\n# 刷新的保存数据\n\n在vue的app.vue的created函数添加代码：\n\nif (sessionstorage.getitem("ptetagsnav")) {\n    this.$store.replacestate(\n        object(\n            {},\n            this.$store.state.pte_tagsnav.homename,\n            sessionstorage.getitem("ptetagsnav")\n        )\n    );\n}\nwindow.addeventlistener("beforeunload", () => {\n    sessionstorage.setitem(\n        "ptetagsnav",\n        this.$store.state.pte_tagsnav.homename\n    );\n});\n',charsets:{cjk:!0}},{title:"deploy",frontmatter:{},regularPath:"/%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/deploy.html",relativePath:"优化问题/deploy.md",key:"v-5d26854b",path:"/%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/deploy.html",headers:[{level:2,title:"__proto__ 和 prototype 之前有什么关系？",slug:"proto-和-prototype-之前有什么关系",normalizedTitle:"<strong>proto</strong> 和 prototype 之前有什么关系？",charIndex:null},{level:2,title:"js中基础数据类型有哪几种?了解包装对象么？",slug:"js中基础数据类型有哪几种-了解包装对象么",normalizedTitle:"js中基础数据类型有哪几种?了解包装对象么？",charIndex:255},{level:2,title:"如何中断ajax请求？",slug:"如何中断ajax请求",normalizedTitle:"如何中断ajax请求？",charIndex:494},{level:2,title:"什么是同步？什么是异步？",slug:"什么是同步-什么是异步",normalizedTitle:"什么是同步？什么是异步？",charIndex:587},{level:2,title:"什么是回调?回调使用中存在什么问题?",slug:"什么是回调-回调使用中存在什么问题",normalizedTitle:"什么是回调?回调使用中存在什么问题?",charIndex:802},{level:2,title:"什么是宏任务？什么是微任务？",slug:"什么是宏任务-什么是微任务",normalizedTitle:"什么是宏任务？什么是微任务？",charIndex:1306},{level:2,title:"Promise.allSettled 了解吗？动手实现一下 Promise.allSettled?",slug:"promise-allsettled-了解吗-动手实现一下-promise-allsettled",normalizedTitle:"promise.allsettled 了解吗？动手实现一下 promise.allsettled?",charIndex:1654},{level:2,title:"如何判断当前脚本运行在浏览器还是node环境中？",slug:"如何判断当前脚本运行在浏览器还是node环境中",normalizedTitle:"如何判断当前脚本运行在浏览器还是node环境中？",charIndex:2308},{level:2,title:"介绍一下 node 常用模块，并且详细介绍下 Stream?",slug:"介绍一下-node-常用模块-并且详细介绍下-stream",normalizedTitle:"介绍一下 node 常用模块，并且详细介绍下 stream?",charIndex:2518},{level:2,title:"Node 如何和 MySQL 进行通信?",slug:"node-如何和-mysql-进行通信",normalizedTitle:"node 如何和 mysql 进行通信?",charIndex:3119},{level:2,title:"WebSocket 是怎么实现点对点通信和广播通信的？",slug:"websocket-是怎么实现点对点通信和广播通信的",normalizedTitle:"websocket 是怎么实现点对点通信和广播通信的？",charIndex:3679},{level:2,title:"说一下 CORS 的简单请求和复杂请求的区别?",slug:"说一下-cors-的简单请求和复杂请求的区别",normalizedTitle:"说一下 cors 的简单请求和复杂请求的区别?",charIndex:4842},{level:2,title:"单页面应用和多页面应用区别及优缺点?",slug:"单页面应用和多页面应用区别及优缺点",normalizedTitle:"单页面应用和多页面应用区别及优缺点?",charIndex:5759},{level:2,title:"在组件的通信中 EventBus 非常经典，你能手写实现下 EventBus 么？",slug:"在组件的通信中-eventbus-非常经典-你能手写实现下-eventbus-么",normalizedTitle:"在组件的通信中 eventbus 非常经典，你能手写实现下 eventbus 么？",charIndex:6021},{level:2,title:"请介绍一下装饰者模式，并实现？",slug:"请介绍一下装饰者模式-并实现",normalizedTitle:"请介绍一下装饰者模式，并实现？",charIndex:7113},{level:2,title:"了解js中设计模式吗？动手实现一下单例模式？",slug:"了解js中设计模式吗-动手实现一下单例模式",normalizedTitle:"了解js中设计模式吗？动手实现一下单例模式？",charIndex:7425}],headersStr:"__proto__ 和 prototype 之前有什么关系？ js中基础数据类型有哪几种?了解包装对象么？ 如何中断ajax请求？ 什么是同步？什么是异步？ 什么是回调?回调使用中存在什么问题? 什么是宏任务？什么是微任务？ Promise.allSettled 了解吗？动手实现一下 Promise.allSettled? 如何判断当前脚本运行在浏览器还是node环境中？ 介绍一下 node 常用模块，并且详细介绍下 Stream? Node 如何和 MySQL 进行通信? WebSocket 是怎么实现点对点通信和广播通信的？ 说一下 CORS 的简单请求和复杂请求的区别? 单页面应用和多页面应用区别及优缺点? 在组件的通信中 EventBus 非常经典，你能手写实现下 EventBus 么？ 请介绍一下装饰者模式，并实现？ 了解js中设计模式吗？动手实现一下单例模式？",content:'# deploy\n\n\n# __proto__ 和 prototype 之前有什么关系？\n\n所有对象都有 __proto__ 属性，函数这个特殊对象除了具有 __proto__ 属性，还有特有的原型属性prototype。prototype对象默认有两个属性，constructor属性和__proto__ 属性。prototype属性可以给函数和对象添加可共享（继承）的方法、属性，而__proto__ 是查找某函数或对象的原型链方式。constructor，这个属性包含了一个指针，指回原构造函数。\n\n\n# js中基础数据类型有哪几种?了解包装对象么？\n\n基础数据类型有6种： boolean null undefined number string symbol\n\n基础数据类型都是值 ，所以没有方法提供调用的\n\n例如：undefined.split("");那为什么比如 ”abc“.split("")类似这种调用可以被允许？原因是js中会存在包装对象，会把字符串先包装成对象然后在调用对象下的一些方法，方法调用完成之后在销毁对象，这样就完成了基础数据类型的函数调用功能。\n\n\n# 如何中断ajax请求？\n\n原生里可以通过XMLHttpRequest对象上的abort方法来中断ajax。注意abort方法不能阻止向服务器发送请求，只能停止当前ajax请求。\n\n\n# 什么是同步？什么是异步？\n\n同步和异步是一种消息通知机制\n\n– 同步阻塞: A调用B，B处理获得结果，才返回给A。A在这个过程中，一直等待B的处理结果，没有拿到结果之前，需要A（调用者）一直等待和确认调用结果是否返回，拿到结果,然后继续往下执行。\n\n做一件事，没有拿到结果之前，就一直在这等着，一直等到有结果了,再去做下边的事\n\n– 异步非阻塞: A调用B，无需等待B的结果，B通过状态，通知等来通知A或回调函数来处理。\n\n\n# 什么是回调?回调使用中存在什么问题?\n\n回调即是函数指针的调用，即是一个通过函数指针调用的函数。如下代码：\n\nfunction foo(callback){\n\tcallback && callback();\n}\n\nfn(()=>{\n\tconsole.log("我是回调函数");\n})\n\n\n\n// 使用回调函数有一个很大缺点 就是造成回调地狱，回到地狱是 为了实现某些逻辑出现函数的层层嵌套，类似如下代码：\n\nmove(ele,300,"left",function () {\n\tmove(ele,300,"top",function () {\n\t\tmove(ele,0,"left",function () {\n\t\t\tmove(ele,0,"top",function () {\n\t\t\t\tconsole.log("所有运动完毕 ");\n\t\t\t})\n\t\t})\n\t})\n});\n\n\n回调地狱会造成可读性及可维护性变差。同样每个嵌套函数耦合性强，一层变动会引起其他的结果变动。同样回调地狱如果出现错误不好处理错误。\n\n解决回调地狱问题可以通过观察者模式、promise、async /await来处理。\n\n\n# 什么是宏任务？什么是微任务？\n\n微任务：一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。 宏任务：宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合。 常见微任务：\n\n1. Promise.then\nMutaionObserver\nObject.observe（已废弃；Proxy 对象替代）\nprocess.nextTick（Node.js）\n常见宏任务 ：\n1. script (可以理解为外层同步代码)\n2. setTimeout/setInterval\n3. UI rendering/UI事件\n4. postMessage，MessageChannel\n5. setImmediate，I/O（Node.js）\n\n\n\n# Promise.allSettled 了解吗？动手实现一下 Promise.allSettled?\n\nPromise.allSettled是ES2020新特性，可以执行多个promise对象，获取多个promise对象状态，无论成功或者失败的状态。实现代码如下：\n\nfunction MyallSettled(list){\n\tlet resArr = new Array(list.length);\n\tlet num = 0\n\treturn new Promise(resolve=>{\n\t\tlist.forEach((item,key)=>{\n\t\t\tlet obj = {};\n\t\t\titem.then(res=>{\n                obj[\'status\'] = "fulfilled";\n                obj.value = res;\n\t\t\t\tresArr[key] = obj;\n\t\t\t\tnum++\n\t\t\t\tif(num===list.length){\n\t\t\t\t\tresolve(resArr); \n\t\t\t\t}\n\t\t\t},err=>{\n\t\t\t\tobj[\'status\'] = "rejected";\n\t\t\t\tobj.reson = err;\n\t\t\t\tresArr[key] = obj;\n\t\t\t\tnum++\n\t\t\t\tif(num===list.length){\n\t\t\t\t\tresolve(resArr); \n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t});\n}\n\n\n\n# 如何判断当前脚本运行在浏览器还是node环境中？\n\n可以通过判断在浏览器端或者是node端独特的全局对象来区分环境。例如：浏览器端的window 或者是node端的process 全局对象。具体代码如下 ：\n\n if( typeof process !== \'undefined\'){\n     console.log("node");\n }else{\n     console.log("浏览器");\n }\n\n\n\n# 介绍一下 node 常用模块，并且详细介绍下 Stream?\n\n常用模块如：内置模块 http，通过http来构建本地服务器，例如：\n\nconst http = require("http");\nconst server =  http.createServer((req,res)=>{\n    res.write("hello world");\n    res.end();\n})\nserver.listen(8888);\n\n\n同样也可以通过http实现服务端的网络请求。还有fs模块可以通过fs模块实现服务端的文件操作，实现服务端文件的增删改查操作。还有path模块提供各种处理路径的api。body-parser模块来处理接收post请求到服务端的数据。等等模块。stream 流是一种抽象数据结构，可以用它来读取和写入数据，通过流来读取和写入数据可以防止内存溢出，采取流方式处理数据会把数据分成64k小块数据，异步依次来进行传递，更加节约性能。问题：node里为什么有些模块需要安装，有些不需要安装？答：nodejs在安装好之后会有很多内置模块，如：path、http、util、fs模块等等。还有一些需要第三方模块支持。可以通过包管理器来安装，如：cookie、session、cheerio等第三方模块。可以在npm官网查找相关模块。https://www.npmjs.com/\n\n\n# Node 如何和 MySQL 进行通信?\n\n可以借助一些sql相关模块实现node和mysql数据库的通行，这里以mysql2模块为例，代码如下：\n\n// 第一步：安装`mysql2`模块\nnpm install --save mysql2\n\n// 第二步：连接数据库\nconst mysql = require(\'mysql2\');  \n// 引入mysql2模块\nconst connection = mysql.createConnection({\n    host: \'localhost\',  //主机地址   \n    user: \'root\',  // 数据库用户名   \n    database: \'test\'  //数据库名称\n});\n\n// 第三步：通过query来执行sql语句 ，如下：\nconnection.query( \'SELECT * FROM `table` WHERE `name` = "Page" AND `age` > 45\', function(err, results, fields) {     \n    console.log(results); // 查询到的结果\n    console.log(fields); // 获取字段的相关信息   \n})\n\n\n\n# WebSocket 是怎么实现点对点通信和广播通信的？\n\nwebSocket是一种全双工通信协议。websocket 让服务端和客户端通信变得简单。最大的特点是可以通过服务端主动推送消息到客户端。前端基于nodejs 和 WebSocket实现 点对点 及广播通信。广播通信顾名思义是类似广播一样给多个人进行广播消息。实现广播通信可以使用很多模块 主要能够把流程描述清楚就可以了。我这里采取的是socket.io模块。服务端监听socket链接：\n\nio.on("connection",(socket)=>{\n    console.log("有socket连接");\n})\n\n\n通过监听连接过来的socket对象广播对应的信息：\n\nsocket.on("addData",function(data){\t//广播除了自己之外的其他订\n    socket.broadcast.emit("addInputData",data);\n})\n\n\n客户端连接及发送对应的socket请求：\n\nlet socket = io.connect("ws://localhost:3000");  //连接socket服务器 \nsocket.emit("addData", JSON.stringify(info)); //发送socket事件点对点通信顾名思义就是一对一的通信，例如多人实时聊天，可以指定用户来发送消息 。\n\n\n点对点通信中需要注意服务端需要记录每个socket客户端的连接 ，需要将客户端及服务端socket对象关联起来。广播数据的时候，广播指定对象就可以了。如下：服务端记录每一个连接过来的socket对象，且和用户id进行关联：\n\nsocket.on("uid",data=>{\n    usersObj[data] = socket;   //通过usersObj来记录连接过来的用户\n})\n\n\n给指定的socket对象进行广播：\n\nsocket.on("user",data=>{\n    let uid = JSON.parse(data).uid;\n    userObj[uid].emit("content",data);\n})\n\n\n客户端监听点对点广播事件：\n\nsocket.on("content", function (data) {\n    console.log(data);\n})\n\n\n总结，WebSocket 区分广播通信及点对点通信核心在于区分每一个连接的socket对象。广播通信需要对于非自身的所有连接的socket对象进行通信。而点对点通信，通过关联用户及socket对象，且保存每一个socket连接，查找指定的socket对象，来达到发送指定socket连接的目的。\n\n\n# 说一下 CORS 的简单请求和复杂请求的区别?\n\nCORS(Cross-origin resource sharing)，跨域资源共享，是一份浏览器技术的规范，用来避开浏览器的同源策略。相关头部设置如下：Access-Control-Allow-Origin 指示请求的资源能共享给哪些域。 Access-Control-Allow-Credentials 指示当请求的凭证标记为 true 时，是否响应该请求。 Access-Control-Allow-Headers 用在对预请求的响应中，指示实际的请求中可以使用哪些 HTTP 头。 Access-Control-Allow-Methods 指定对预请求的响应中，哪些 HTTP 方法允许访问请求的资源。 Access-Control-Expose-Headers 指示哪些 HTTP 头的名称能在响应中列出。 Access-Control-Max-Age 指示预请求的结果能被缓存多久。 Access-Control-Request-Headers 用于发起一个预请求，告知服务器正式请求会使用那些 HTTP 头。 Access-Control-Request-Method 用于发起一个预请求，告知服务器正式请求会使用哪一种 HTTP 请求方法。 Origin 指示获取资源的请求是从什么域发起的。CORS可以分成两种简单请求和复杂请求。简单请求是满足以下下条件的请求HTTP方法是下列之一HEADGETPOSTHTTP头信息不超出以下几种字段AcceptAccept-LanguageContent-LanguageLast-Event-IDContent-Type，但仅能是下列之一application/x-www-form-urlencodedmultipart/form-datatext/plain反之就是复杂请求，复杂请求表面上看起来和简单请求使用上差不多，但实际上浏览器发送了不止一个请求。其中最先发送的是一种"预请求"，此时作为服务端，也需要返回"预回应"作为响应。预请求实际上是对服务端的一种权限请求，只有当预请求成功返回，实际请求才开始执行。\n\n\n# 单页面应用和多页面应用区别及优缺点?\n\n# 单页面应用（SPA） 单页面应用。\n\n# 优点\n\n用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小前后端分离页面转场体验好\n\n# 缺点：\n\n不利于seo导航不可用，需要自己实现导航初次加载耗时长页面复杂度提高\n\n# 多页面应用：\n\n# 优点 ：\n\n1、多页面应用对于 seo更加友好。\n\n2、更容易扩展。\n\n3、更易的数据分析。\n\n# 缺点：\n\n1、程序开发成本高。\n\n2.增加服务端压力，多页面会不停的加载。\n\n3、用户体验相对较差。\n\n\n# 在组件的通信中 EventBus 非常经典，你能手写实现下 EventBus 么？\n\nclass EventBusClass{\n    constructor() {\n        this.msgList = {}; \n    }\n    on(msgName,fn){\n        if(this.msgList.hasOwnProperty(msgName)){\n            if(typeof this.msgList[msgName] === \'function\'){\n                this.msgList[msgName] = [this.msgList[msgName],fn]\n            }else {\n                this.msgList[msgName] = [...this.msgList[msgName], fn]\n            }\n        }else{\n            this.msgList[msgName] = fn;\n        }\n    }  \n    one(msgName,fn){\n        this.msgList[msgName] = fn;\n    }  \n    emit(msgName,msg){\n        if(!this.msgList.hasOwnProperty(msgName)){\n            return\n        }\n        if(typeof this.msgList[msgName] === \'function\'){\n            this.msgList[msgName](msg);\n        }else{\n            this.msgList[msgName].map((fn)=>{\n                fn(msg);\n            })\n        }\n    }\n    off(msgName){\n        if(!this.msgList.hasOwnProperty(msgName)){\n            return;\n        }\n        delete this.msgList[msgName];\n    }\n}\nconst eventBus = new EventBusClass();\nwindow.EventBus = eventBus;\n\n\n\n# 请介绍一下装饰者模式，并实现？\n\nclass luban {\n    fire(){\n        console.log(\'这里是基础伤害\');\n    }\n}\nclass firstSkill{\n    constructor(luban){\n        this.luban = luban;\n    }\n    fire(){\n        this.luban.fire();\n        console.log(\'发射手雷\');\n    }\n}\nvar luban1 = new luban;\nluban1 = new firstSkill(luban1);\nluban1.fire();\n\n\n\n# 了解js中设计模式吗？动手实现一下单例模式？\n\nlet CreateSingle = (function(){\n    let instance;\n    return function(name){\n        if(instance){\n            return instance;\n        }\n        return instance = new Single(name);\n    } \n})(); \nlet Single = function(name){\n    this.name = name; \n} \nSingle.prototype.getName = function(){\n    console.log(this.name); \n} \nlet lili = new CreateSingle(\'lili\'); \nlet wuyou = new CreateSingle(\'wuyou\'); \nwuyou.getName()\n',normalizedContent:'# deploy\n\n\n# __proto__ 和 prototype 之前有什么关系？\n\n所有对象都有 __proto__ 属性，函数这个特殊对象除了具有 __proto__ 属性，还有特有的原型属性prototype。prototype对象默认有两个属性，constructor属性和__proto__ 属性。prototype属性可以给函数和对象添加可共享（继承）的方法、属性，而__proto__ 是查找某函数或对象的原型链方式。constructor，这个属性包含了一个指针，指回原构造函数。\n\n\n# js中基础数据类型有哪几种?了解包装对象么？\n\n基础数据类型有6种： boolean null undefined number string symbol\n\n基础数据类型都是值 ，所以没有方法提供调用的\n\n例如：undefined.split("");那为什么比如 ”abc“.split("")类似这种调用可以被允许？原因是js中会存在包装对象，会把字符串先包装成对象然后在调用对象下的一些方法，方法调用完成之后在销毁对象，这样就完成了基础数据类型的函数调用功能。\n\n\n# 如何中断ajax请求？\n\n原生里可以通过xmlhttprequest对象上的abort方法来中断ajax。注意abort方法不能阻止向服务器发送请求，只能停止当前ajax请求。\n\n\n# 什么是同步？什么是异步？\n\n同步和异步是一种消息通知机制\n\n– 同步阻塞: a调用b，b处理获得结果，才返回给a。a在这个过程中，一直等待b的处理结果，没有拿到结果之前，需要a（调用者）一直等待和确认调用结果是否返回，拿到结果,然后继续往下执行。\n\n做一件事，没有拿到结果之前，就一直在这等着，一直等到有结果了,再去做下边的事\n\n– 异步非阻塞: a调用b，无需等待b的结果，b通过状态，通知等来通知a或回调函数来处理。\n\n\n# 什么是回调?回调使用中存在什么问题?\n\n回调即是函数指针的调用，即是一个通过函数指针调用的函数。如下代码：\n\nfunction foo(callback){\n\tcallback && callback();\n}\n\nfn(()=>{\n\tconsole.log("我是回调函数");\n})\n\n\n\n// 使用回调函数有一个很大缺点 就是造成回调地狱，回到地狱是 为了实现某些逻辑出现函数的层层嵌套，类似如下代码：\n\nmove(ele,300,"left",function () {\n\tmove(ele,300,"top",function () {\n\t\tmove(ele,0,"left",function () {\n\t\t\tmove(ele,0,"top",function () {\n\t\t\t\tconsole.log("所有运动完毕 ");\n\t\t\t})\n\t\t})\n\t})\n});\n\n\n回调地狱会造成可读性及可维护性变差。同样每个嵌套函数耦合性强，一层变动会引起其他的结果变动。同样回调地狱如果出现错误不好处理错误。\n\n解决回调地狱问题可以通过观察者模式、promise、async /await来处理。\n\n\n# 什么是宏任务？什么是微任务？\n\n微任务：一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。 宏任务：宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合。 常见微任务：\n\n1. promise.then\nmutaionobserver\nobject.observe（已废弃；proxy 对象替代）\nprocess.nexttick（node.js）\n常见宏任务 ：\n1. script (可以理解为外层同步代码)\n2. settimeout/setinterval\n3. ui rendering/ui事件\n4. postmessage，messagechannel\n5. setimmediate，i/o（node.js）\n\n\n\n# promise.allsettled 了解吗？动手实现一下 promise.allsettled?\n\npromise.allsettled是es2020新特性，可以执行多个promise对象，获取多个promise对象状态，无论成功或者失败的状态。实现代码如下：\n\nfunction myallsettled(list){\n\tlet resarr = new array(list.length);\n\tlet num = 0\n\treturn new promise(resolve=>{\n\t\tlist.foreach((item,key)=>{\n\t\t\tlet obj = {};\n\t\t\titem.then(res=>{\n                obj[\'status\'] = "fulfilled";\n                obj.value = res;\n\t\t\t\tresarr[key] = obj;\n\t\t\t\tnum++\n\t\t\t\tif(num===list.length){\n\t\t\t\t\tresolve(resarr); \n\t\t\t\t}\n\t\t\t},err=>{\n\t\t\t\tobj[\'status\'] = "rejected";\n\t\t\t\tobj.reson = err;\n\t\t\t\tresarr[key] = obj;\n\t\t\t\tnum++\n\t\t\t\tif(num===list.length){\n\t\t\t\t\tresolve(resarr); \n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t});\n}\n\n\n\n# 如何判断当前脚本运行在浏览器还是node环境中？\n\n可以通过判断在浏览器端或者是node端独特的全局对象来区分环境。例如：浏览器端的window 或者是node端的process 全局对象。具体代码如下 ：\n\n if( typeof process !== \'undefined\'){\n     console.log("node");\n }else{\n     console.log("浏览器");\n }\n\n\n\n# 介绍一下 node 常用模块，并且详细介绍下 stream?\n\n常用模块如：内置模块 http，通过http来构建本地服务器，例如：\n\nconst http = require("http");\nconst server =  http.createserver((req,res)=>{\n    res.write("hello world");\n    res.end();\n})\nserver.listen(8888);\n\n\n同样也可以通过http实现服务端的网络请求。还有fs模块可以通过fs模块实现服务端的文件操作，实现服务端文件的增删改查操作。还有path模块提供各种处理路径的api。body-parser模块来处理接收post请求到服务端的数据。等等模块。stream 流是一种抽象数据结构，可以用它来读取和写入数据，通过流来读取和写入数据可以防止内存溢出，采取流方式处理数据会把数据分成64k小块数据，异步依次来进行传递，更加节约性能。问题：node里为什么有些模块需要安装，有些不需要安装？答：nodejs在安装好之后会有很多内置模块，如：path、http、util、fs模块等等。还有一些需要第三方模块支持。可以通过包管理器来安装，如：cookie、session、cheerio等第三方模块。可以在npm官网查找相关模块。https://www.npmjs.com/\n\n\n# node 如何和 mysql 进行通信?\n\n可以借助一些sql相关模块实现node和mysql数据库的通行，这里以mysql2模块为例，代码如下：\n\n// 第一步：安装`mysql2`模块\nnpm install --save mysql2\n\n// 第二步：连接数据库\nconst mysql = require(\'mysql2\');  \n// 引入mysql2模块\nconst connection = mysql.createconnection({\n    host: \'localhost\',  //主机地址   \n    user: \'root\',  // 数据库用户名   \n    database: \'test\'  //数据库名称\n});\n\n// 第三步：通过query来执行sql语句 ，如下：\nconnection.query( \'select * from `table` where `name` = "page" and `age` > 45\', function(err, results, fields) {     \n    console.log(results); // 查询到的结果\n    console.log(fields); // 获取字段的相关信息   \n})\n\n\n\n# websocket 是怎么实现点对点通信和广播通信的？\n\nwebsocket是一种全双工通信协议。websocket 让服务端和客户端通信变得简单。最大的特点是可以通过服务端主动推送消息到客户端。前端基于nodejs 和 websocket实现 点对点 及广播通信。广播通信顾名思义是类似广播一样给多个人进行广播消息。实现广播通信可以使用很多模块 主要能够把流程描述清楚就可以了。我这里采取的是socket.io模块。服务端监听socket链接：\n\nio.on("connection",(socket)=>{\n    console.log("有socket连接");\n})\n\n\n通过监听连接过来的socket对象广播对应的信息：\n\nsocket.on("adddata",function(data){\t//广播除了自己之外的其他订\n    socket.broadcast.emit("addinputdata",data);\n})\n\n\n客户端连接及发送对应的socket请求：\n\nlet socket = io.connect("ws://localhost:3000");  //连接socket服务器 \nsocket.emit("adddata", json.stringify(info)); //发送socket事件点对点通信顾名思义就是一对一的通信，例如多人实时聊天，可以指定用户来发送消息 。\n\n\n点对点通信中需要注意服务端需要记录每个socket客户端的连接 ，需要将客户端及服务端socket对象关联起来。广播数据的时候，广播指定对象就可以了。如下：服务端记录每一个连接过来的socket对象，且和用户id进行关联：\n\nsocket.on("uid",data=>{\n    usersobj[data] = socket;   //通过usersobj来记录连接过来的用户\n})\n\n\n给指定的socket对象进行广播：\n\nsocket.on("user",data=>{\n    let uid = json.parse(data).uid;\n    userobj[uid].emit("content",data);\n})\n\n\n客户端监听点对点广播事件：\n\nsocket.on("content", function (data) {\n    console.log(data);\n})\n\n\n总结，websocket 区分广播通信及点对点通信核心在于区分每一个连接的socket对象。广播通信需要对于非自身的所有连接的socket对象进行通信。而点对点通信，通过关联用户及socket对象，且保存每一个socket连接，查找指定的socket对象，来达到发送指定socket连接的目的。\n\n\n# 说一下 cors 的简单请求和复杂请求的区别?\n\ncors(cross-origin resource sharing)，跨域资源共享，是一份浏览器技术的规范，用来避开浏览器的同源策略。相关头部设置如下：access-control-allow-origin 指示请求的资源能共享给哪些域。 access-control-allow-credentials 指示当请求的凭证标记为 true 时，是否响应该请求。 access-control-allow-headers 用在对预请求的响应中，指示实际的请求中可以使用哪些 http 头。 access-control-allow-methods 指定对预请求的响应中，哪些 http 方法允许访问请求的资源。 access-control-expose-headers 指示哪些 http 头的名称能在响应中列出。 access-control-max-age 指示预请求的结果能被缓存多久。 access-control-request-headers 用于发起一个预请求，告知服务器正式请求会使用那些 http 头。 access-control-request-method 用于发起一个预请求，告知服务器正式请求会使用哪一种 http 请求方法。 origin 指示获取资源的请求是从什么域发起的。cors可以分成两种简单请求和复杂请求。简单请求是满足以下下条件的请求http方法是下列之一headgetposthttp头信息不超出以下几种字段acceptaccept-languagecontent-languagelast-event-idcontent-type，但仅能是下列之一application/x-www-form-urlencodedmultipart/form-datatext/plain反之就是复杂请求，复杂请求表面上看起来和简单请求使用上差不多，但实际上浏览器发送了不止一个请求。其中最先发送的是一种"预请求"，此时作为服务端，也需要返回"预回应"作为响应。预请求实际上是对服务端的一种权限请求，只有当预请求成功返回，实际请求才开始执行。\n\n\n# 单页面应用和多页面应用区别及优缺点?\n\n# 单页面应用（spa） 单页面应用。\n\n# 优点\n\n用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小前后端分离页面转场体验好\n\n# 缺点：\n\n不利于seo导航不可用，需要自己实现导航初次加载耗时长页面复杂度提高\n\n# 多页面应用：\n\n# 优点 ：\n\n1、多页面应用对于 seo更加友好。\n\n2、更容易扩展。\n\n3、更易的数据分析。\n\n# 缺点：\n\n1、程序开发成本高。\n\n2.增加服务端压力，多页面会不停的加载。\n\n3、用户体验相对较差。\n\n\n# 在组件的通信中 eventbus 非常经典，你能手写实现下 eventbus 么？\n\nclass eventbusclass{\n    constructor() {\n        this.msglist = {}; \n    }\n    on(msgname,fn){\n        if(this.msglist.hasownproperty(msgname)){\n            if(typeof this.msglist[msgname] === \'function\'){\n                this.msglist[msgname] = [this.msglist[msgname],fn]\n            }else {\n                this.msglist[msgname] = [...this.msglist[msgname], fn]\n            }\n        }else{\n            this.msglist[msgname] = fn;\n        }\n    }  \n    one(msgname,fn){\n        this.msglist[msgname] = fn;\n    }  \n    emit(msgname,msg){\n        if(!this.msglist.hasownproperty(msgname)){\n            return\n        }\n        if(typeof this.msglist[msgname] === \'function\'){\n            this.msglist[msgname](msg);\n        }else{\n            this.msglist[msgname].map((fn)=>{\n                fn(msg);\n            })\n        }\n    }\n    off(msgname){\n        if(!this.msglist.hasownproperty(msgname)){\n            return;\n        }\n        delete this.msglist[msgname];\n    }\n}\nconst eventbus = new eventbusclass();\nwindow.eventbus = eventbus;\n\n\n\n# 请介绍一下装饰者模式，并实现？\n\nclass luban {\n    fire(){\n        console.log(\'这里是基础伤害\');\n    }\n}\nclass firstskill{\n    constructor(luban){\n        this.luban = luban;\n    }\n    fire(){\n        this.luban.fire();\n        console.log(\'发射手雷\');\n    }\n}\nvar luban1 = new luban;\nluban1 = new firstskill(luban1);\nluban1.fire();\n\n\n\n# 了解js中设计模式吗？动手实现一下单例模式？\n\nlet createsingle = (function(){\n    let instance;\n    return function(name){\n        if(instance){\n            return instance;\n        }\n        return instance = new single(name);\n    } \n})(); \nlet single = function(name){\n    this.name = name; \n} \nsingle.prototype.getname = function(){\n    console.log(this.name); \n} \nlet lili = new createsingle(\'lili\'); \nlet wuyou = new createsingle(\'wuyou\'); \nwuyou.getname()\n',charsets:{cjk:!0}},{title:"webpack",frontmatter:{},regularPath:"/webpack/",relativePath:"webpack/README.md",key:"v-859fe96e",path:"/webpack/",headers:[{level:2,title:"Webpack 的诞生",slug:"webpack-的诞生",normalizedTitle:"webpack 的诞生",charIndex:14},{level:2,title:"nodejs",slug:"nodejs",normalizedTitle:"nodejs",charIndex:88},{level:2,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:99},{level:2,title:"起步",slug:"起步",normalizedTitle:"起步",charIndex:420},{level:3,title:"基本内容",slug:"基本内容",normalizedTitle:"基本内容",charIndex:438},{level:3,title:"开始打包",slug:"开始打包",normalizedTitle:"开始打包",charIndex:1401},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:3141},{level:2,title:"模块加载器",slug:"模块加载器",normalizedTitle:"模块加载器",charIndex:3215},{level:3,title:"加载css",slug:"加载css",normalizedTitle:"加载css",charIndex:3315},{level:3,title:"加载less",slug:"加载less",normalizedTitle:"加载less",charIndex:4368},{level:3,title:"css编译",slug:"css编译",normalizedTitle:"css编译",charIndex:5345},{level:3,title:"提取css",slug:"提取css",normalizedTitle:"提取css",charIndex:5394},{level:3,title:"加载图片",slug:"加载图片",normalizedTitle:"加载图片",charIndex:7768},{level:2,title:"管理输出",slug:"管理输出",normalizedTitle:"管理输出",charIndex:9120},{level:3,title:"自动生成html",slug:"自动生成html",normalizedTitle:"自动生成html",charIndex:9129},{level:3,title:"清除dist",slug:"清除dist",normalizedTitle:"清除dist",charIndex:10252},{level:2,title:"开发环境",slug:"开发环境",normalizedTitle:"开发环境",charIndex:10704},{level:3,title:"错误追踪",slug:"错误追踪",normalizedTitle:"错误追踪",charIndex:10785},{level:3,title:"开发服务器",slug:"开发服务器",normalizedTitle:"开发服务器",charIndex:12040},{level:2,title:"生产环境",slug:"生产环境",normalizedTitle:"生产环境",charIndex:13123},{level:3,title:"配置文件",slug:"配置文件",normalizedTitle:"配置文件",charIndex:311},{level:2,title:"进阶",slug:"进阶",normalizedTitle:"进阶",charIndex:16120},{level:3,title:"多入口和输出",slug:"多入口和输出",normalizedTitle:"多入口和输出",charIndex:16127},{level:3,title:"提取公共模块",slug:"提取公共模块",normalizedTitle:"提取公共模块",charIndex:17161}],headersStr:"Webpack 的诞生 nodejs 安装 起步 基本内容 开始打包 总结 模块加载器 加载css 加载less css编译 提取css 加载图片 管理输出 自动生成html 清除dist 开发环境 错误追踪 开发服务器 生产环境 配置文件 进阶 多入口和输出 提取公共模块",content:'# webpack\n\n\n# Webpack 的诞生\n\nwebpack的官网：\n\n 1. webpack英文官网\n\n 2. webpack中文官网 不太推荐，更新不及时\n\n\n# nodejs\n\n\n# 安装\n\n新建在项目文件夹webpack-demo，并且初始化项目\n\nnpm init\n\n\n安装webpack依赖\n\nnpm install --save-dev webpack webpack-cli\n\n\n添加启动选项\n\npackage.json\n\n"scripts": {\n    "start": "webpack --config webpack.config.js"\n}\n\n\nwebpack.config.js是默认配置文件，也就是说--config webpack.config.js选项可以忽略，那么接下来需要在根目录中新增该文件。\n\n> 注意：\n> \n> webpack还可以使用全局安装，不过不推荐，不方便统一管理。\n\n\n# 起步\n\n一个简单的使用案例\n\n\n# 基本内容\n\n准备项目文件结构如下：\n\n> 注意： 注释前面带了加号（+）的表示要新增的文件。\n\n- webpack-demo\n\t- dist\t\t\t\t\t// + 输出目录，在浏览器中运行的目录\n\t\t- index.html\t\t// + 浏览器页面入口文件\n\t- node_modules\n\t- src\t\t\t\t\t// + 开发目录\n    \t- index.js\t\t\t// + 项目入口文件 \n    - package.json\t\t\t// 项目配置文件\n    - webpack.config.js\t\t// + webpack配置文件\n\n\ndist/index.html\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>webpack demo</title>\n</head>\n<body>\n    <script src="../src/index.js"><\/script>\n</body>\n</html>\n\n\nsrc/index.js\n\n// 写入到html的内容\nvar element = document.createElement("div");\nelement.innerHTML =  `<div>hello webpack</div>`;\n\ndocument.body.appendChild(element);\n\n\nOK!，项目代码准备就绪了，在浏览器打开dist/index.html可以查看效果，但是这里有两个问题：\n\n1.为什么要把html代码写在js里面？直接写在html多简单。\n\nnodejs只认识js文件，可以使用其他模板或者框架方法来简化，比如vue，react。\n\n2.webpack呢？webpack在哪？\n\nwebpack会根据配置文件的内容要对项目进行构建打包，不用去关心具体的操作，只看结果。\n\n\n# 开始打包\n\nwebpack.config.js\n\nconst path = require(\'path\');\n\nmodule.exports = {\n    entry: \'./src/index.js\',\t\t\t\t\t// 项目入口\n    output: {\n        filename: \'bundle.js\',                  // 默认打包后的文件名 bundle.js\n        path: path.resolve(__dirname, \'dist\')   // 默认打包后的文件目录 dist\n    }\n};\n\n\n常见的错误：\n\n1.webpack配置的入口文件entry\n\n该配置可以使用相对路径，如果要使用相对路径的话前面必须要加上./，不能直接用文件夹的名字。\n\n2.webpack配置的输出目录\n\noutput.path选项的路径必须是绝对路径，可以用path.resolve方法获取到绝对路径。\n\ndist/index.html\n\n> **注意：**src 的是开发目录，会通过 webpack 把 src 目录的中资源打包到 dist 中，所以以后 index.html 和 src 目录再无瓜葛，引用的资源都来自于打包后的 dist。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>webpack demo</title>\n</head>\n<body>\n    \x3c!-- <script src="./src/index.js"><\/script> --\x3e\n    <script src="./bundle.js"><\/script>\n</body>\n</html>\n\n\n开始打包，在命令行中输入以下命令：\n\n> 注意切换到项目目录下\n\nnpm run start\n\n\n输出结果：\n\n> webpack-demo@1.0.0 start C:\\Users\\40777\\Desktop\\webpack> webpack --config webpack.config.jsHash: e184fa0a8a3d55b577bcVersion: webpack 4.39.2Time: 456msBuilt at: 2019-08-26 17:03:18    Asset      Size  Chunks             Chunk Namesbundle.js  1.04 KiB       0  [emitted]  mainEntrypoint main = bundle.js[0] ./src/index.js 196 bytes {0} [built]WARNING in configuration(配置警告)The \'mode\' option has not been set. Set \'mode\' option to \'development\' or \'production\' to enable defaults for this environment.(\'mode\' 选项还未设置。将 \'mode\' 选项设置为 \'development\' 或 \'production\'，来启用环境默认值。)\n\n\n> **注意：**上述输入即是打包成功，配置的警告不影响打包结果，可忽略。\n\ndist 目录结构:\n\n- webpack\n    -demo\t\n        - dist \t\t\t\t// 输出目录，在浏览器中运行的目录\t\t\n        - index.html\t\t// 浏览器页面入口文件\t\t\n        - bundle.js\t\t\t// + 打包后的文件\n        - // 其他文件\n\n\n\n# 总结\n\n上面是一个基本的构建过程，当然除了构建js文件外，还可以对图片，样式，字体文件等资源进行管理，切记这是一个nodejs环境的项目。\n\n\n# 模块加载器\n\n模块加载器是webpack用于加载并处理其他非js文件的文件，比如自定义模板文件，css，图片，字体等资源文件。\n\n> 注意：\n> \n> nodejs环境下默认只认识js文件。\n\n\n# 加载css\n\n新增css文件\n\n- webpack\n    -demo\n        - src\n        - index.js\n        - style.css\t// + 新增css文件    \n    \t- // 其他文件\n\n\nsrc/style.css\n\n.red { color: red;}\n\n\nsrc/index.js\n\nimport \'./style.css\';// 写入到html的内容\nvar element = document.createElement("div");\nelement.innerHTML =  `<div class="red">hello webpack</div>`;\ndocument.body.appendChild(element);\n\n\nwebpack.config.js\n\nconst path = require(\'path\');module.exports = {\n    entry: \'./src/index.js\',\n    output: {\n        filename: \'bundle.js\',\n        path: path.resolve(__dirname, \'dist\')\n    },\t    // 模块加载器配置项\n    module: {\n        rules: [\n            {\n                test: /\\.css$/, // 匹配css扩展名文件\n                use:[ // 配置loader加载器\n                    \'style-loader\', // 把css代码写入到网页中\n                    \'css-loader\' // 读取css的代码\n                    // 多个loader，顺序自后往前，一个loader只做一件事情，小而美\n                ]\n            }\n        ]\n    }\n};\n\n\n上面引用了两个加载器style-loader和css-loader，需要下载依赖包\n\nnpm install --save-dev style-loader css-loader\n\n\n再次执行打包\n\nnpm run start\n\n\n> 再次打开dist/index.html就能看能到红色的文字了。\n\n\n# 加载less\n\n新增less文件\n\n- webpack\n    -demo\n        - src\n        - index.js\n        - style.css\n        - style.less // + 新增less文件    \n        - // 其他文件\n\n\nsrc/style.less\n\n.blue { color: blue;}\n\n\nsrc/index.js\n\nimport \'./style.css\';// 导入less文件\nimport \'./style.less\'// 写入到html的内容\nvar element = document.createElement("div");\nelement.innerHTML =  ` <div class="red">hello webpack</div> <div class="blue">hello webpack and less</div>`;\ndocument.body.appendChild(element);\n\n\nwebpack.config.js\n\nconst path = require(\'path\');\nmodule.exports = {\n    // 其他配置...\n    // 模块加载器配置项\n    module: {\n        rules: [\n            // 其他配置...\n            {\n                test: /\\.less$/, // 匹配less扩展名文件\n                use:[\n                    \'style-loader\', // 把less代码写入到网页中\n                    \'css-loader\', // 读取less的代码\n                    \'less-loader\' // 解释编译less代码\n                ]\n            },\n        ]\n    }\n};\n\n\n安装依赖包\n\nnpm install --save-dev less less-loader\n\n\n执行打包\n\nnpm run start\n\n\n\n# css编译\n\npostcss 编译处理css模块，是个工具，有N个插件，具体工作的是插件\n\n\n# 提取css\n\n通过dist文件结构我们发现打包出的文件中并没有独立的css文件，那么css样式被打包到哪里去了呢？\n\n如果用编辑器打开bundle.js文件会发现内容有document.createElement("style")字样，其实css被打包到bundle.js中了。\n\n那么假如 css 的内容很多，会让 bundle.js 文件变得很大，加载变慢，性能和体验都很差，所以我们需要把 css 的内容单独拆分到一个样式文件中，使用 webpack插件ExtractTextWebpackPlugin\n\nwebpack.config.js\n\nconst path = require("path");//  导入提取样式的webpack插件\nconst ExtractTextPlugin = require("extract-text-webpack-plugin");\nmodule.exports = {\n    // 其他配置...\n    // 模块加载器配置项\n    module: {\n        rules: [     \n            {       \n                test: /\\.css$/, // 匹配css扩展名文件        \n                use:[ // 配置loader加载器         \n                    \'style-loader\',\t\t// 把css代码写入到网页中        \n                    \'css-loader\'\t\t// 读取css的代码          \n                ]         \n            },\n            {\n                test: /\\.css$/,\n                use: ExtractTextPlugin.extract({\t// 提取css\n                    fallback: "style-loader",\n                    use: ["css-loader"]\n                })\n            },        \n            {        \n                test: /\\.less$/, // 匹配less扩展名文件          \n                use:[         \n                    \'style-loader\',\t\t// 把less代码写入到网页中      \n                    \'css-loader\',\t\t// 读取less的代码         \n                    \'less-loader\'\t\t// 解释编译less代码          \n                ]        \n            },\n            {\n                test: /\\.less$/,\n                use: ExtractTextPlugin.extract({\t// 提取less\n                    fallback: "style-loader",\n                    use: ["css-loader", "less-loader"]\n                })\n            },\n            // 其他配置...\n        ]\n    },\n    plugins: [\n        new ExtractTextPlugin(\'style/style.css\') // 提取到dist的style文件夹中\n    ]\n};\n\n\n安装依赖包\n\nnpm install extract-text-webpack-plugin@next --save-dev\n\n\n> 注意：@next是下载最新版本\n\n执行打包\n\nnpm run start\n\n\n最新dist目录结构\n\n- webpack\n    -demo\n        - dist\n        - style\n        - style.css // 打包后的css文件\t\t\n    \t- // 其他文件\n\n\n需要把打包后的样式导入的index.html中\n\ndist/index.html\n\n<!DOCTYPE html>\n<html lang="en">\n    <head>\n        <meta charset="UTF-8">\n        <meta name="viewport" content="width=device-width, initial-scale=1.0">\n        <meta http-equiv="X-UA-Compatible" content="ie=edge">\n        <title>webpack demo</title>\n        \x3c!-- + 导入样式 --\x3e\n        <link rel="stylesheet" href="./style/style.css"></head>\n    <body>\n    \t<script src="./bundle.js"><\/script>\n    </body>\n</html>\n\n\n\n# 加载图片\n\n在 nodejs 环境中所有的文件都是一个模块，需要导入才能使用，图片也不例外，比如我们想要在项目中引入一张图片。\n\n- webpack\n    -demo\n        - images\n        - logo.jpg\t- // 其他文件\n\n\nsrc/index.js\n\nimport \'./style.css\';\nimport \'./style.less\'// 导入图片\nimport logo from "../images/logo.jpg"\nvar element = document.createElement("div");// 添加显示图片\nelement.innerHTML =  ` <div class="red">hello webpack</div>\t<div class="blue">hello webpack and less</div>\t<img src="${logo}"/>`;\ndocument.body.appendChild(element);\n\n\n> **注意：**能被src调用说明import的logo是一个链接。\n\nwebpack.config.js\n\n// 其他代码\nmodule.exports = {\n    // 其他配置...\n    // 模块加载器配置项\n    module: {\n        rules: [\n            // 其他配置...\n            {\n                test: /\\.(png|svg|jpg|gif)$/,\t// 匹配图片文件\n                use: [\n                    {\n                        loader: "file-loader", // 处理图片文件返回链接\n                        options: {\n                            publicPath: "./images/", //  引入图片时会在路径前面加上该选项\n                            outputPath: "images" //  输出到dist下的images目录\n                        }\n                    }\n                ]\n            }\n        ]\n    }\n};\n\n\n> **注意：**处理图片时的配置稍微复杂点了，主要是file-loader需要搭配一些选项来使用，这些选项可以自行修改，参考文档。\n\n安装依赖包\n\nnpm install --save-dev file-loader\n\n\n执行打包命令\n\nnpm run start\n\n\n最新dist目录结构\n\n- webpack\n    -demo\n        - dist\n        - images\n        - [hash字符串组成].jpg\n        - bundle.js\n        - // 其他文件\n\n\n\n# 管理输出\n\n\n# 自动生成html\n\n目前我们都是在 index.html 中手动引入打包后的资源，这种引入方式有很多缺点，比如文件名依赖问题，假如 webpack 配置中的输出文件名修改了，需要及时在 index.html 中同步修改，再者每次新增文件都要引入一遍很繁琐。\n\n可以使用 HtmlWebpackPlugin插件 自动引入打包后的资源文件到html文件，该插件需要指定一个html模板文件，并且会生成一个 index.html 文件到 dist 目录中。\n\n既然都要自动生成了，那么 dist 下 index.html 就没必要存在了，删除 dist/index.html，并且新建html模板文件.\n\n新增 public 目录存放公共资源：\n\n- webpack\n    -demo\n        - // 其他文件\n        - public\n        - index.html\n\n\npublic/index.html\n\n<!DOCTYPE html>\n<html lang="en"><head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>webpack demo</title>\n    </head>\n    <body>\n    </body>\n</html>\n\n\n安装依赖包\n\nnpm install --save-dev html-webpack-plugin\n\n\nwebpack.config.js\n\n// 其他引入\nconst HtmlWebpackPlugin = require("html-webpack-plugin");\nmodule.exports = {\n    // 其他配置\n    plugins: [\n        new ExtractTextPlugin("style/style2.css"),        // + 新增配置\n        new HtmlWebpackPlugin({\n            template: "public/index.html"\t// template指定默认html模板\n        })\n    ]\n};\n\n\n执行打包\n\nnpm run start\n\n\n此时打开dist/index.html会发现已经自动引入了资源了。\n\n\n# 清除dist\n\n使用 clean-webpack-plugin插件 在每次打包前清除下dist文件夹。\n\n安装依赖包\n\nnpm install --save-dev clean-webpack-plugin \n\n\nwebpack.config.js\n\n// 其他代码\n// 导入清除插件\nconst { CleanWebpackPlugin } = require(\'clean-webpack-plugin\');\nmodule.exports = {\n    // 其他配置\n    plugins: [\n        new ExtractTextPlugin("style/style.css"), // 调用清除打包目录插件\n        new CleanWebpackPlugin(),\n        new HtmlWebpackPlugin({\n            template: "public/index.html"\n        }),\n    ]\n};\n\n\n\n# 开发环境\n\n开发环境一般指的是我们在本地开发时候使用的场景，这种场景下代码可以快速追踪错误，不压缩文件，而且由于在本地开发，所以可以加载体积大一点文件。\n\n\n# 错误追踪\n\n我们先来做一个错误追踪的测试，新建一个error.js。\n\nsrc/error.js\n\nconst error = function(){\n    var a = 123;\n    a.push(456);\n}\nexport default error;\n\n\n> 注意： 上面的代码运行会报错，a没有push方法。\n\nsrc/index.js\n\nimport \'./style.css\';\nimport \'./style.less\'\nimport logo from "../images/logo.jpg"// + 导入错误的模块\nimport error from "./error"// 执行会报错的函数error();// 其他\n\n\n执行打包命令\n\nnpm run start\n\n\n刷新dist/index.html，可以看到以下的错误信息。\n\nUncaught TypeError: 123.push is not a function\t\t\t\t\t\t\t\t\t\tbundle.js:1     at bundle.js:1    at Module.<anonymous> (bundle.js:1)    at t (bundle.js:1)    at bundle.js:1    at bundle.js:1\n\n\n上面我们写了一个错误的函数，但是浏览器的在报错的时候提示的错误文件是bundle.js，这当然是正常的，因为这是我们最后打包出来的文件，但是我们可以通过webpack的source map准确地知道错误来自于哪个源文件。\n\nwebpack.config.js\n\n// 其他代码\nmodule.exports = {\n    // 其他配置\n    devtool: "source-map", \n    // + 生成映射源代码文件\n    // 模块加载器配置项\n    module: {\n        // 其他代码\n    },\n    // 其他配置 \n}\n\n\n> 注意： 上面的 devtool:"source-map" 配置会在dist目录中生成一个bundle.js.map文件，该文件主要的作用是把打包后的bundle.js映射到源文件上，这样就可以准确的追踪报错的源代码的位置了。\n> \n> bundle.js.map文件也会加载到页面中，并且文件体积很大，所以此模式只适用于开发环境。\n\n再次执行打包命名，查看错误提示\n\nUncaught TypeError: 123.push is not a function\t\t\t\t\t\t\t\t\t\terror.js:3     at error.js:3    at Module.<anonymous> (index.js:9)    at t (bootstrap:19)    at bootstrap:83    at bundle.js:1\n\n\n此时错误就很精确了，error.js 第3行。\n\n\n# 开发服务器\n\n目前我们修改一次代码，就要执行一遍npm run start打包，非常麻烦，webpack 提供了一个简单的开发服务器webpack-dev-server，该服务器能够帮助我们在本地开启一个开发服务器环境，并且能够监听文件的修改，每当编辑文件保存后浏览器会自动加载刷新页面。\n\n安装依赖\n\nnpm install --save-dev webpack-dev-server\n\n\nwebpack.config.js\n\n// 其他代码\nmodule.exports = {\n    // 其他配置\n    devtool: "source-map",\n    // + 开发服务配置\n    devServer: {\n        port: 8000 // 默认端口是8080\n    },\n    // 模块加载器配置项\n    module: {\n        // 其他配置\n    }\n    // 其他配置\n}\n\n\n> **注意：**可以通过文档查看 devServer 服务器配置列表\n\n上面的配置devServer可以对开发服务器进行配置，**注意：devServer不读取项目中的dist目录，而是读取服务器内存中的文件，我们不需要知道具体的存放地址，只需要知道两者输出的内容是一样的。**可以删除项目下的 dist 文件夹进行验证。\n\n下面来添加一个新的scripts命令，用于启动开发服务器。\n\npackage.json\n\n{\n    // 其他配置\n    "scripts": {\n        "start": "webpack --config webpack.config.js",\n        "dev": "webpack-dev-server --config webpack.config.js --open"\n    },\n    // 其他配置\n}\n\n\n> 注意： webpack-dev-server添加了两个配置选项：\n> \n>  1. --config webpack.config.js和webpack一样是默认配置文件，可以省略。\n> \n>  2. --open表示自动打开浏览器，该配置默认值是false。\n\n打开开发服务器命令\n\nnpm run dev\n\n\n> **注意：**启动后不要关闭命令行窗口，否则会关闭服务器，可以使用ctrl+c关闭服务器。\n\n打开浏览器访问地址http://localhost:8000/，然后尝试修改src中任何一个文件保存，浏览器就自动刷新了。\n\n\n# 生产环境\n\n生产环境和开发环境刚好相反，开发环境在本地运行，而生产环境是要产出运行在线上服务器面向用户使用的代码，因此两者的构建目标差异很大，比如打包后的文件在生产环境中要尽可能的小，逻辑代码分离，优化静态资源（压缩图片），去除 source map文件等。\n\n因此开发环境和生产环境不能共用一份webpack配置文件，需要分别指定\n\n但是两个环境还是有很多配置可以共用的，比如entry、output、module等，因此可以把公共部分的配置抽离出来放到一个独立的文件然后进行合并，我们可以使用webpack-merge工具来进行合并。\n\n> **注意：**entry、output、module这些配置在我们当前示例可以通用，但未必适合所有项目。\n\n安装依赖\n\nnpm install --save-dev webpack-merge\n\n\n开始拆分webpack.config.js文件，拆分后该文件可废弃。\n\n新建config文件夹:\n\n- webpack-demo\t\n    - config\t\t\t// 存放配置文件的文件夹\n    - webpack.base.js\t// 公共的配置\n    - webpack.dev.js\t// 开发环境的配置\t\t\n    - webpack.pro.js\t// 生成环境的配置\t\n    - // 其他文件\n\n\n\n# 配置文件\n\nconfig/webpack.base.js\n\nconst path = require("path");\nconst ExtractTextPlugin = require("extract-text-webpack-plugin");\nconst HtmlWebpackPlugin = require("html-webpack-plugin");\nconst { CleanWebpackPlugin } = require(\'clean-webpack-plugin\');\nmodule.exports = {\n    // 入口\n    entry: "./src/index.js",\n    // 输出\n    output: {\n        filename: "bundle.js",\n        path: path.resolve(__dirname, "../dist")\n        // 注意此处输出目录是父级文件夹\n    },\n    // 模块加载器\n    module: {\n        rules: [\n            {\n                test: /\\.css$/,\n                use: ExtractTextPlugin.extract({\n                    fallback: "style-loader",\n                    use: ["css-loader"]\n                })\n            },\n            {\n                test: /\\.less$/,\n                use: ExtractTextPlugin.extract({\n                    fallback: "style-loader",\n                    use: ["css-loader", "less-loader"]\n                })\n            },\n            {\n                test: /\\.(png|svg|jpg|gif)$/,\n                use: [\n                    {\n                        loader: "file-loader",\n                        options: {\n                            publicPath: "./images/",\n                            outputPath: "images"\n                        }\n                    }\n                ]\n            }\n        ]\n    },\n    plugins: [\n        // 提取css样式到单独文件\n        new ExtractTextPlugin("style/style2.css"),\n        // 每次构建前清除dist目录\n        new CleanWebpackPlugin(),\n        // 自动生成index.html到dist\n        new HtmlWebpackPlugin({\n            template: "public/index.html"\n        }),\n    ]\n}\n\n\nwebpack.dev.js\n\nconst merge = require(\'webpack-merge\');\nconst base = require(\'./webpack.base.js\');\nmodule.exports = merge(base, {\n    mode: "development",    // 生成map映射文件\n    devtool: "source-map",    // 开发服务器配置\n    devServer: {\n        port: 8000 // 默认端口是8080\n    },\n})\n\n\nwebpack.pro.js\n\nconst merge = require(\'webpack-merge\');\nconst base = require(\'./webpack.base.js\');\nmodule.exports = merge(base, {\n    mode: "production"\n})\n\n\n> **注意：**拆分完webpack.config.js后可以把该文件删除了。\n\n修改scripts启动命令，删除 start 命令，增加 build 命令用于生产环境，注意指定配置文件的路径变化\n\npackage.json\n\n{\n    // 其他配置\n    "scripts": {\n        "dev": "webpack-dev-server --config config/webpack.dev.js",\n        "build": "webpack --config config/webpack.pro.js"\n    }\n    // 其他配置\n}\n\n\nOK！以后开发的话就使用npm run dev命令，需要打包上线就运行npm run build，把dist目录丢给运维的同事部署即可（当然现在的项目工程里都有自动化部署了）。\n\n\n# 进阶\n\n\n# 多入口和输出\n\n多入口需要修改entry配置，理由很简单，**我们一个页面往往需要引入多个js文件。**在这之前我们都是把src/index.js打包成dist/bundle.js引入到项目中，那如果有多个index.js类型的文件呢？\n\n为了演示方便，我们先清空下src文件夹，再添加新文件：\n\n- webpack-demo\t- src\t\t- index.js\t\t- about.js\n\n\n> **注意：**index.js和about.js没有任何关系，都是独立的不相互引用。\n\nsrc/index.js\n\nvar element = document.createElement("span");\nelement.innerHTML =  `hello`;\ndocument.body.appendChild(element);\n\n\nsrc/about.js\n\nvar element = document.createElement("div");\nelement.innerHTML =  `about`;\ndocument.body.appendChild(element);\n\n\nconfig/webpack.base.js\n\n// 其他代码\nmodule.exports = {\n    // 用对象的方式配置多个入口\n    entry: {\n        index: "./src/index.js",\n        about: "./src/about.js"\n    },\n    output: {\n        // 修改输出路径和文件名，[name]是动态的，读取entry的属性\n        filename: "js/[name].bundle.js",\n        path: path.resolve(__dirname, "../dist")\n    },\n    // 其他代码\n}\n\n\n为了方便查看代码，我们执行npm run build命令，可以看到 dist 的结构如下\n\n- webpack-demo\n    - dist\n    - js\n    - index.bundle.js\n    - about.bundle.js\n    - index.html\n\n\n在浏览器中打开index.html可以看到同时引入两个 js 文件，使用开发服务器 npm run dev 打开效果一致。\n\n\n# 提取公共模块\n\n我们来做一个测试，把一个 jquery.js 作为公共文件放到src/utils目录中。\n\n- webpack-demo\n    - src\n    - utils \t\t// + 公共的模块\n    - jquery.js \t// + 测试用的公共文件\n    - index.js\n    - about.js\n\n\n然后把src/utils/jquery.js分别引入到 index.js 和 about.js 中。\n\nimport jquery from "./utils/jquery";// 其他代码\n\n\n执行构建命令\n\nnpm run build\n\n\n查看打包后的 about.bundle.js 和 index.bundle.js 文件源码，会发现它们都把 jquery.js 打包进去了，这样做的后果不敢想象。所以我们需要使用 CommonsChunkPlugin 插件把类似公共的依赖模块提取到一个单独的文件中。\n\nconfig/webpack.base.js\n\n// 其他代码\nmodule.exports = {\n    // 其他代码\n    // + 提取公共模块配置\n    optimization: {\n        splitChunks: {\n            chunks: \'all\'\t// 提取所有文件的共同模块\n        }\n    },\n    module: {\n        // 其他代码\n    },\n    // 其他代码\n}\n\n\n再次执行打包\n\nnpm run build\n\n\n可以看到当前项目的公共模块 jquery 的内容已经被打包到一个 独立的 about~index.bundle.js文件中了，当然这个文件名可以通过配置修改的。\n\n> **注意：**公共模块的大小必须大于 30kb才会被独立打包，jquery 的大小是 87kB。\n\n> [另一种拆分bundles的方法 dll。]',normalizedContent:'# webpack\n\n\n# webpack 的诞生\n\nwebpack的官网：\n\n 1. webpack英文官网\n\n 2. webpack中文官网 不太推荐，更新不及时\n\n\n# nodejs\n\n\n# 安装\n\n新建在项目文件夹webpack-demo，并且初始化项目\n\nnpm init\n\n\n安装webpack依赖\n\nnpm install --save-dev webpack webpack-cli\n\n\n添加启动选项\n\npackage.json\n\n"scripts": {\n    "start": "webpack --config webpack.config.js"\n}\n\n\nwebpack.config.js是默认配置文件，也就是说--config webpack.config.js选项可以忽略，那么接下来需要在根目录中新增该文件。\n\n> 注意：\n> \n> webpack还可以使用全局安装，不过不推荐，不方便统一管理。\n\n\n# 起步\n\n一个简单的使用案例\n\n\n# 基本内容\n\n准备项目文件结构如下：\n\n> 注意： 注释前面带了加号（+）的表示要新增的文件。\n\n- webpack-demo\n\t- dist\t\t\t\t\t// + 输出目录，在浏览器中运行的目录\n\t\t- index.html\t\t// + 浏览器页面入口文件\n\t- node_modules\n\t- src\t\t\t\t\t// + 开发目录\n    \t- index.js\t\t\t// + 项目入口文件 \n    - package.json\t\t\t// 项目配置文件\n    - webpack.config.js\t\t// + webpack配置文件\n\n\ndist/index.html\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>webpack demo</title>\n</head>\n<body>\n    <script src="../src/index.js"><\/script>\n</body>\n</html>\n\n\nsrc/index.js\n\n// 写入到html的内容\nvar element = document.createelement("div");\nelement.innerhtml =  `<div>hello webpack</div>`;\n\ndocument.body.appendchild(element);\n\n\nok!，项目代码准备就绪了，在浏览器打开dist/index.html可以查看效果，但是这里有两个问题：\n\n1.为什么要把html代码写在js里面？直接写在html多简单。\n\nnodejs只认识js文件，可以使用其他模板或者框架方法来简化，比如vue，react。\n\n2.webpack呢？webpack在哪？\n\nwebpack会根据配置文件的内容要对项目进行构建打包，不用去关心具体的操作，只看结果。\n\n\n# 开始打包\n\nwebpack.config.js\n\nconst path = require(\'path\');\n\nmodule.exports = {\n    entry: \'./src/index.js\',\t\t\t\t\t// 项目入口\n    output: {\n        filename: \'bundle.js\',                  // 默认打包后的文件名 bundle.js\n        path: path.resolve(__dirname, \'dist\')   // 默认打包后的文件目录 dist\n    }\n};\n\n\n常见的错误：\n\n1.webpack配置的入口文件entry\n\n该配置可以使用相对路径，如果要使用相对路径的话前面必须要加上./，不能直接用文件夹的名字。\n\n2.webpack配置的输出目录\n\noutput.path选项的路径必须是绝对路径，可以用path.resolve方法获取到绝对路径。\n\ndist/index.html\n\n> **注意：**src 的是开发目录，会通过 webpack 把 src 目录的中资源打包到 dist 中，所以以后 index.html 和 src 目录再无瓜葛，引用的资源都来自于打包后的 dist。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>webpack demo</title>\n</head>\n<body>\n    \x3c!-- <script src="./src/index.js"><\/script> --\x3e\n    <script src="./bundle.js"><\/script>\n</body>\n</html>\n\n\n开始打包，在命令行中输入以下命令：\n\n> 注意切换到项目目录下\n\nnpm run start\n\n\n输出结果：\n\n> webpack-demo@1.0.0 start c:\\users\\40777\\desktop\\webpack> webpack --config webpack.config.jshash: e184fa0a8a3d55b577bcversion: webpack 4.39.2time: 456msbuilt at: 2019-08-26 17:03:18    asset      size  chunks             chunk namesbundle.js  1.04 kib       0  [emitted]  mainentrypoint main = bundle.js[0] ./src/index.js 196 bytes {0} [built]warning in configuration(配置警告)the \'mode\' option has not been set. set \'mode\' option to \'development\' or \'production\' to enable defaults for this environment.(\'mode\' 选项还未设置。将 \'mode\' 选项设置为 \'development\' 或 \'production\'，来启用环境默认值。)\n\n\n> **注意：**上述输入即是打包成功，配置的警告不影响打包结果，可忽略。\n\ndist 目录结构:\n\n- webpack\n    -demo\t\n        - dist \t\t\t\t// 输出目录，在浏览器中运行的目录\t\t\n        - index.html\t\t// 浏览器页面入口文件\t\t\n        - bundle.js\t\t\t// + 打包后的文件\n        - // 其他文件\n\n\n\n# 总结\n\n上面是一个基本的构建过程，当然除了构建js文件外，还可以对图片，样式，字体文件等资源进行管理，切记这是一个nodejs环境的项目。\n\n\n# 模块加载器\n\n模块加载器是webpack用于加载并处理其他非js文件的文件，比如自定义模板文件，css，图片，字体等资源文件。\n\n> 注意：\n> \n> nodejs环境下默认只认识js文件。\n\n\n# 加载css\n\n新增css文件\n\n- webpack\n    -demo\n        - src\n        - index.js\n        - style.css\t// + 新增css文件    \n    \t- // 其他文件\n\n\nsrc/style.css\n\n.red { color: red;}\n\n\nsrc/index.js\n\nimport \'./style.css\';// 写入到html的内容\nvar element = document.createelement("div");\nelement.innerhtml =  `<div class="red">hello webpack</div>`;\ndocument.body.appendchild(element);\n\n\nwebpack.config.js\n\nconst path = require(\'path\');module.exports = {\n    entry: \'./src/index.js\',\n    output: {\n        filename: \'bundle.js\',\n        path: path.resolve(__dirname, \'dist\')\n    },\t    // 模块加载器配置项\n    module: {\n        rules: [\n            {\n                test: /\\.css$/, // 匹配css扩展名文件\n                use:[ // 配置loader加载器\n                    \'style-loader\', // 把css代码写入到网页中\n                    \'css-loader\' // 读取css的代码\n                    // 多个loader，顺序自后往前，一个loader只做一件事情，小而美\n                ]\n            }\n        ]\n    }\n};\n\n\n上面引用了两个加载器style-loader和css-loader，需要下载依赖包\n\nnpm install --save-dev style-loader css-loader\n\n\n再次执行打包\n\nnpm run start\n\n\n> 再次打开dist/index.html就能看能到红色的文字了。\n\n\n# 加载less\n\n新增less文件\n\n- webpack\n    -demo\n        - src\n        - index.js\n        - style.css\n        - style.less // + 新增less文件    \n        - // 其他文件\n\n\nsrc/style.less\n\n.blue { color: blue;}\n\n\nsrc/index.js\n\nimport \'./style.css\';// 导入less文件\nimport \'./style.less\'// 写入到html的内容\nvar element = document.createelement("div");\nelement.innerhtml =  ` <div class="red">hello webpack</div> <div class="blue">hello webpack and less</div>`;\ndocument.body.appendchild(element);\n\n\nwebpack.config.js\n\nconst path = require(\'path\');\nmodule.exports = {\n    // 其他配置...\n    // 模块加载器配置项\n    module: {\n        rules: [\n            // 其他配置...\n            {\n                test: /\\.less$/, // 匹配less扩展名文件\n                use:[\n                    \'style-loader\', // 把less代码写入到网页中\n                    \'css-loader\', // 读取less的代码\n                    \'less-loader\' // 解释编译less代码\n                ]\n            },\n        ]\n    }\n};\n\n\n安装依赖包\n\nnpm install --save-dev less less-loader\n\n\n执行打包\n\nnpm run start\n\n\n\n# css编译\n\npostcss 编译处理css模块，是个工具，有n个插件，具体工作的是插件\n\n\n# 提取css\n\n通过dist文件结构我们发现打包出的文件中并没有独立的css文件，那么css样式被打包到哪里去了呢？\n\n如果用编辑器打开bundle.js文件会发现内容有document.createelement("style")字样，其实css被打包到bundle.js中了。\n\n那么假如 css 的内容很多，会让 bundle.js 文件变得很大，加载变慢，性能和体验都很差，所以我们需要把 css 的内容单独拆分到一个样式文件中，使用 webpack插件extracttextwebpackplugin\n\nwebpack.config.js\n\nconst path = require("path");//  导入提取样式的webpack插件\nconst extracttextplugin = require("extract-text-webpack-plugin");\nmodule.exports = {\n    // 其他配置...\n    // 模块加载器配置项\n    module: {\n        rules: [     \n            {       \n                test: /\\.css$/, // 匹配css扩展名文件        \n                use:[ // 配置loader加载器         \n                    \'style-loader\',\t\t// 把css代码写入到网页中        \n                    \'css-loader\'\t\t// 读取css的代码          \n                ]         \n            },\n            {\n                test: /\\.css$/,\n                use: extracttextplugin.extract({\t// 提取css\n                    fallback: "style-loader",\n                    use: ["css-loader"]\n                })\n            },        \n            {        \n                test: /\\.less$/, // 匹配less扩展名文件          \n                use:[         \n                    \'style-loader\',\t\t// 把less代码写入到网页中      \n                    \'css-loader\',\t\t// 读取less的代码         \n                    \'less-loader\'\t\t// 解释编译less代码          \n                ]        \n            },\n            {\n                test: /\\.less$/,\n                use: extracttextplugin.extract({\t// 提取less\n                    fallback: "style-loader",\n                    use: ["css-loader", "less-loader"]\n                })\n            },\n            // 其他配置...\n        ]\n    },\n    plugins: [\n        new extracttextplugin(\'style/style.css\') // 提取到dist的style文件夹中\n    ]\n};\n\n\n安装依赖包\n\nnpm install extract-text-webpack-plugin@next --save-dev\n\n\n> 注意：@next是下载最新版本\n\n执行打包\n\nnpm run start\n\n\n最新dist目录结构\n\n- webpack\n    -demo\n        - dist\n        - style\n        - style.css // 打包后的css文件\t\t\n    \t- // 其他文件\n\n\n需要把打包后的样式导入的index.html中\n\ndist/index.html\n\n<!doctype html>\n<html lang="en">\n    <head>\n        <meta charset="utf-8">\n        <meta name="viewport" content="width=device-width, initial-scale=1.0">\n        <meta http-equiv="x-ua-compatible" content="ie=edge">\n        <title>webpack demo</title>\n        \x3c!-- + 导入样式 --\x3e\n        <link rel="stylesheet" href="./style/style.css"></head>\n    <body>\n    \t<script src="./bundle.js"><\/script>\n    </body>\n</html>\n\n\n\n# 加载图片\n\n在 nodejs 环境中所有的文件都是一个模块，需要导入才能使用，图片也不例外，比如我们想要在项目中引入一张图片。\n\n- webpack\n    -demo\n        - images\n        - logo.jpg\t- // 其他文件\n\n\nsrc/index.js\n\nimport \'./style.css\';\nimport \'./style.less\'// 导入图片\nimport logo from "../images/logo.jpg"\nvar element = document.createelement("div");// 添加显示图片\nelement.innerhtml =  ` <div class="red">hello webpack</div>\t<div class="blue">hello webpack and less</div>\t<img src="${logo}"/>`;\ndocument.body.appendchild(element);\n\n\n> **注意：**能被src调用说明import的logo是一个链接。\n\nwebpack.config.js\n\n// 其他代码\nmodule.exports = {\n    // 其他配置...\n    // 模块加载器配置项\n    module: {\n        rules: [\n            // 其他配置...\n            {\n                test: /\\.(png|svg|jpg|gif)$/,\t// 匹配图片文件\n                use: [\n                    {\n                        loader: "file-loader", // 处理图片文件返回链接\n                        options: {\n                            publicpath: "./images/", //  引入图片时会在路径前面加上该选项\n                            outputpath: "images" //  输出到dist下的images目录\n                        }\n                    }\n                ]\n            }\n        ]\n    }\n};\n\n\n> **注意：**处理图片时的配置稍微复杂点了，主要是file-loader需要搭配一些选项来使用，这些选项可以自行修改，参考文档。\n\n安装依赖包\n\nnpm install --save-dev file-loader\n\n\n执行打包命令\n\nnpm run start\n\n\n最新dist目录结构\n\n- webpack\n    -demo\n        - dist\n        - images\n        - [hash字符串组成].jpg\n        - bundle.js\n        - // 其他文件\n\n\n\n# 管理输出\n\n\n# 自动生成html\n\n目前我们都是在 index.html 中手动引入打包后的资源，这种引入方式有很多缺点，比如文件名依赖问题，假如 webpack 配置中的输出文件名修改了，需要及时在 index.html 中同步修改，再者每次新增文件都要引入一遍很繁琐。\n\n可以使用 htmlwebpackplugin插件 自动引入打包后的资源文件到html文件，该插件需要指定一个html模板文件，并且会生成一个 index.html 文件到 dist 目录中。\n\n既然都要自动生成了，那么 dist 下 index.html 就没必要存在了，删除 dist/index.html，并且新建html模板文件.\n\n新增 public 目录存放公共资源：\n\n- webpack\n    -demo\n        - // 其他文件\n        - public\n        - index.html\n\n\npublic/index.html\n\n<!doctype html>\n<html lang="en"><head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>webpack demo</title>\n    </head>\n    <body>\n    </body>\n</html>\n\n\n安装依赖包\n\nnpm install --save-dev html-webpack-plugin\n\n\nwebpack.config.js\n\n// 其他引入\nconst htmlwebpackplugin = require("html-webpack-plugin");\nmodule.exports = {\n    // 其他配置\n    plugins: [\n        new extracttextplugin("style/style2.css"),        // + 新增配置\n        new htmlwebpackplugin({\n            template: "public/index.html"\t// template指定默认html模板\n        })\n    ]\n};\n\n\n执行打包\n\nnpm run start\n\n\n此时打开dist/index.html会发现已经自动引入了资源了。\n\n\n# 清除dist\n\n使用 clean-webpack-plugin插件 在每次打包前清除下dist文件夹。\n\n安装依赖包\n\nnpm install --save-dev clean-webpack-plugin \n\n\nwebpack.config.js\n\n// 其他代码\n// 导入清除插件\nconst { cleanwebpackplugin } = require(\'clean-webpack-plugin\');\nmodule.exports = {\n    // 其他配置\n    plugins: [\n        new extracttextplugin("style/style.css"), // 调用清除打包目录插件\n        new cleanwebpackplugin(),\n        new htmlwebpackplugin({\n            template: "public/index.html"\n        }),\n    ]\n};\n\n\n\n# 开发环境\n\n开发环境一般指的是我们在本地开发时候使用的场景，这种场景下代码可以快速追踪错误，不压缩文件，而且由于在本地开发，所以可以加载体积大一点文件。\n\n\n# 错误追踪\n\n我们先来做一个错误追踪的测试，新建一个error.js。\n\nsrc/error.js\n\nconst error = function(){\n    var a = 123;\n    a.push(456);\n}\nexport default error;\n\n\n> 注意： 上面的代码运行会报错，a没有push方法。\n\nsrc/index.js\n\nimport \'./style.css\';\nimport \'./style.less\'\nimport logo from "../images/logo.jpg"// + 导入错误的模块\nimport error from "./error"// 执行会报错的函数error();// 其他\n\n\n执行打包命令\n\nnpm run start\n\n\n刷新dist/index.html，可以看到以下的错误信息。\n\nuncaught typeerror: 123.push is not a function\t\t\t\t\t\t\t\t\t\tbundle.js:1     at bundle.js:1    at module.<anonymous> (bundle.js:1)    at t (bundle.js:1)    at bundle.js:1    at bundle.js:1\n\n\n上面我们写了一个错误的函数，但是浏览器的在报错的时候提示的错误文件是bundle.js，这当然是正常的，因为这是我们最后打包出来的文件，但是我们可以通过webpack的source map准确地知道错误来自于哪个源文件。\n\nwebpack.config.js\n\n// 其他代码\nmodule.exports = {\n    // 其他配置\n    devtool: "source-map", \n    // + 生成映射源代码文件\n    // 模块加载器配置项\n    module: {\n        // 其他代码\n    },\n    // 其他配置 \n}\n\n\n> 注意： 上面的 devtool:"source-map" 配置会在dist目录中生成一个bundle.js.map文件，该文件主要的作用是把打包后的bundle.js映射到源文件上，这样就可以准确的追踪报错的源代码的位置了。\n> \n> bundle.js.map文件也会加载到页面中，并且文件体积很大，所以此模式只适用于开发环境。\n\n再次执行打包命名，查看错误提示\n\nuncaught typeerror: 123.push is not a function\t\t\t\t\t\t\t\t\t\terror.js:3     at error.js:3    at module.<anonymous> (index.js:9)    at t (bootstrap:19)    at bootstrap:83    at bundle.js:1\n\n\n此时错误就很精确了，error.js 第3行。\n\n\n# 开发服务器\n\n目前我们修改一次代码，就要执行一遍npm run start打包，非常麻烦，webpack 提供了一个简单的开发服务器webpack-dev-server，该服务器能够帮助我们在本地开启一个开发服务器环境，并且能够监听文件的修改，每当编辑文件保存后浏览器会自动加载刷新页面。\n\n安装依赖\n\nnpm install --save-dev webpack-dev-server\n\n\nwebpack.config.js\n\n// 其他代码\nmodule.exports = {\n    // 其他配置\n    devtool: "source-map",\n    // + 开发服务配置\n    devserver: {\n        port: 8000 // 默认端口是8080\n    },\n    // 模块加载器配置项\n    module: {\n        // 其他配置\n    }\n    // 其他配置\n}\n\n\n> **注意：**可以通过文档查看 devserver 服务器配置列表\n\n上面的配置devserver可以对开发服务器进行配置，**注意：devserver不读取项目中的dist目录，而是读取服务器内存中的文件，我们不需要知道具体的存放地址，只需要知道两者输出的内容是一样的。**可以删除项目下的 dist 文件夹进行验证。\n\n下面来添加一个新的scripts命令，用于启动开发服务器。\n\npackage.json\n\n{\n    // 其他配置\n    "scripts": {\n        "start": "webpack --config webpack.config.js",\n        "dev": "webpack-dev-server --config webpack.config.js --open"\n    },\n    // 其他配置\n}\n\n\n> 注意： webpack-dev-server添加了两个配置选项：\n> \n>  1. --config webpack.config.js和webpack一样是默认配置文件，可以省略。\n> \n>  2. --open表示自动打开浏览器，该配置默认值是false。\n\n打开开发服务器命令\n\nnpm run dev\n\n\n> **注意：**启动后不要关闭命令行窗口，否则会关闭服务器，可以使用ctrl+c关闭服务器。\n\n打开浏览器访问地址http://localhost:8000/，然后尝试修改src中任何一个文件保存，浏览器就自动刷新了。\n\n\n# 生产环境\n\n生产环境和开发环境刚好相反，开发环境在本地运行，而生产环境是要产出运行在线上服务器面向用户使用的代码，因此两者的构建目标差异很大，比如打包后的文件在生产环境中要尽可能的小，逻辑代码分离，优化静态资源（压缩图片），去除 source map文件等。\n\n因此开发环境和生产环境不能共用一份webpack配置文件，需要分别指定\n\n但是两个环境还是有很多配置可以共用的，比如entry、output、module等，因此可以把公共部分的配置抽离出来放到一个独立的文件然后进行合并，我们可以使用webpack-merge工具来进行合并。\n\n> **注意：**entry、output、module这些配置在我们当前示例可以通用，但未必适合所有项目。\n\n安装依赖\n\nnpm install --save-dev webpack-merge\n\n\n开始拆分webpack.config.js文件，拆分后该文件可废弃。\n\n新建config文件夹:\n\n- webpack-demo\t\n    - config\t\t\t// 存放配置文件的文件夹\n    - webpack.base.js\t// 公共的配置\n    - webpack.dev.js\t// 开发环境的配置\t\t\n    - webpack.pro.js\t// 生成环境的配置\t\n    - // 其他文件\n\n\n\n# 配置文件\n\nconfig/webpack.base.js\n\nconst path = require("path");\nconst extracttextplugin = require("extract-text-webpack-plugin");\nconst htmlwebpackplugin = require("html-webpack-plugin");\nconst { cleanwebpackplugin } = require(\'clean-webpack-plugin\');\nmodule.exports = {\n    // 入口\n    entry: "./src/index.js",\n    // 输出\n    output: {\n        filename: "bundle.js",\n        path: path.resolve(__dirname, "../dist")\n        // 注意此处输出目录是父级文件夹\n    },\n    // 模块加载器\n    module: {\n        rules: [\n            {\n                test: /\\.css$/,\n                use: extracttextplugin.extract({\n                    fallback: "style-loader",\n                    use: ["css-loader"]\n                })\n            },\n            {\n                test: /\\.less$/,\n                use: extracttextplugin.extract({\n                    fallback: "style-loader",\n                    use: ["css-loader", "less-loader"]\n                })\n            },\n            {\n                test: /\\.(png|svg|jpg|gif)$/,\n                use: [\n                    {\n                        loader: "file-loader",\n                        options: {\n                            publicpath: "./images/",\n                            outputpath: "images"\n                        }\n                    }\n                ]\n            }\n        ]\n    },\n    plugins: [\n        // 提取css样式到单独文件\n        new extracttextplugin("style/style2.css"),\n        // 每次构建前清除dist目录\n        new cleanwebpackplugin(),\n        // 自动生成index.html到dist\n        new htmlwebpackplugin({\n            template: "public/index.html"\n        }),\n    ]\n}\n\n\nwebpack.dev.js\n\nconst merge = require(\'webpack-merge\');\nconst base = require(\'./webpack.base.js\');\nmodule.exports = merge(base, {\n    mode: "development",    // 生成map映射文件\n    devtool: "source-map",    // 开发服务器配置\n    devserver: {\n        port: 8000 // 默认端口是8080\n    },\n})\n\n\nwebpack.pro.js\n\nconst merge = require(\'webpack-merge\');\nconst base = require(\'./webpack.base.js\');\nmodule.exports = merge(base, {\n    mode: "production"\n})\n\n\n> **注意：**拆分完webpack.config.js后可以把该文件删除了。\n\n修改scripts启动命令，删除 start 命令，增加 build 命令用于生产环境，注意指定配置文件的路径变化\n\npackage.json\n\n{\n    // 其他配置\n    "scripts": {\n        "dev": "webpack-dev-server --config config/webpack.dev.js",\n        "build": "webpack --config config/webpack.pro.js"\n    }\n    // 其他配置\n}\n\n\nok！以后开发的话就使用npm run dev命令，需要打包上线就运行npm run build，把dist目录丢给运维的同事部署即可（当然现在的项目工程里都有自动化部署了）。\n\n\n# 进阶\n\n\n# 多入口和输出\n\n多入口需要修改entry配置，理由很简单，**我们一个页面往往需要引入多个js文件。**在这之前我们都是把src/index.js打包成dist/bundle.js引入到项目中，那如果有多个index.js类型的文件呢？\n\n为了演示方便，我们先清空下src文件夹，再添加新文件：\n\n- webpack-demo\t- src\t\t- index.js\t\t- about.js\n\n\n> **注意：**index.js和about.js没有任何关系，都是独立的不相互引用。\n\nsrc/index.js\n\nvar element = document.createelement("span");\nelement.innerhtml =  `hello`;\ndocument.body.appendchild(element);\n\n\nsrc/about.js\n\nvar element = document.createelement("div");\nelement.innerhtml =  `about`;\ndocument.body.appendchild(element);\n\n\nconfig/webpack.base.js\n\n// 其他代码\nmodule.exports = {\n    // 用对象的方式配置多个入口\n    entry: {\n        index: "./src/index.js",\n        about: "./src/about.js"\n    },\n    output: {\n        // 修改输出路径和文件名，[name]是动态的，读取entry的属性\n        filename: "js/[name].bundle.js",\n        path: path.resolve(__dirname, "../dist")\n    },\n    // 其他代码\n}\n\n\n为了方便查看代码，我们执行npm run build命令，可以看到 dist 的结构如下\n\n- webpack-demo\n    - dist\n    - js\n    - index.bundle.js\n    - about.bundle.js\n    - index.html\n\n\n在浏览器中打开index.html可以看到同时引入两个 js 文件，使用开发服务器 npm run dev 打开效果一致。\n\n\n# 提取公共模块\n\n我们来做一个测试，把一个 jquery.js 作为公共文件放到src/utils目录中。\n\n- webpack-demo\n    - src\n    - utils \t\t// + 公共的模块\n    - jquery.js \t// + 测试用的公共文件\n    - index.js\n    - about.js\n\n\n然后把src/utils/jquery.js分别引入到 index.js 和 about.js 中。\n\nimport jquery from "./utils/jquery";// 其他代码\n\n\n执行构建命令\n\nnpm run build\n\n\n查看打包后的 about.bundle.js 和 index.bundle.js 文件源码，会发现它们都把 jquery.js 打包进去了，这样做的后果不敢想象。所以我们需要使用 commonschunkplugin 插件把类似公共的依赖模块提取到一个单独的文件中。\n\nconfig/webpack.base.js\n\n// 其他代码\nmodule.exports = {\n    // 其他代码\n    // + 提取公共模块配置\n    optimization: {\n        splitchunks: {\n            chunks: \'all\'\t// 提取所有文件的共同模块\n        }\n    },\n    module: {\n        // 其他代码\n    },\n    // 其他代码\n}\n\n\n再次执行打包\n\nnpm run build\n\n\n可以看到当前项目的公共模块 jquery 的内容已经被打包到一个 独立的 about~index.bundle.js文件中了，当然这个文件名可以通过配置修改的。\n\n> **注意：**公共模块的大小必须大于 30kb才会被独立打包，jquery 的大小是 87kb。\n\n> [另一种拆分bundles的方法 dll。]',charsets:{cjk:!0}},{title:"优化",frontmatter:{},regularPath:"/%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/",relativePath:"优化问题/README.md",key:"v-7f8813c0",path:"/%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/",headers:[{level:2,title:"记录一次前端优化首屏时间 70% 的优化过程~",slug:"记录一次前端优化首屏时间-70-的优化过程",normalizedTitle:"记录一次前端优化首屏时间 70% 的优化过程~",charIndex:9},{level:3,title:"项目背景",slug:"项目背景",normalizedTitle:"项目背景",charIndex:37},{level:3,title:"目标",slug:"目标",normalizedTitle:"目标",charIndex:58},{level:3,title:"方向",slug:"方向",normalizedTitle:"方向",charIndex:118},{level:3,title:"准备工作",slug:"准备工作",normalizedTitle:"准备工作",charIndex:165},{level:3,title:"开始发力",slug:"开始发力",normalizedTitle:"开始发力",charIndex:447},{level:3,title:"效果如何？",slug:"效果如何",normalizedTitle:"效果如何？",charIndex:2258},{level:2,title:"请列举的前端性能优化",slug:"请列举的前端性能优化",normalizedTitle:"请列举的前端性能优化",charIndex:2302},{level:2,title:"浅谈渲染机制",slug:"浅谈渲染机制",normalizedTitle:"浅谈渲染机制",charIndex:2319},{level:3,title:"网络",slug:"网络",normalizedTitle:"网络",charIndex:307},{level:3,title:"渲染引擎及关键渲染路径（Critical Rendering Path）",slug:"渲染引擎及关键渲染路径-critical-rendering-path",normalizedTitle:"渲染引擎及关键渲染路径（critical rendering path）",charIndex:3186},{level:2,title:"重排&&重绘",slug:"重排-重绘",normalizedTitle:"重排&amp;&amp;重绘",charIndex:null},{level:3,title:"重排",slug:"重排",normalizedTitle:"重排",charIndex:4217},{level:3,title:"重绘(repaint)",slug:"重绘-repaint",normalizedTitle:"重绘(repaint)",charIndex:5351},{level:3,title:"性能优化",slug:"性能优化",normalizedTitle:"性能优化",charIndex:2308},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:8354},{level:2,title:"防抖&&节流",slug:"防抖-节流",normalizedTitle:"防抖&amp;&amp;节流",charIndex:null},{level:3,title:"防抖（debounce）",slug:"防抖-debounce",normalizedTitle:"防抖（debounce）",charIndex:8507},{level:3,title:"节流（throttle）",slug:"节流-throttle",normalizedTitle:"节流（throttle）",charIndex:8818},{level:2,title:"cookies 、 sessionStorage和localstorage",slug:"cookies-、-sessionstorage和localstorage",normalizedTitle:"cookies 、 sessionstorage和localstorage",charIndex:9529},{level:3,title:"三者之间的差异",slug:"三者之间的差异",normalizedTitle:"三者之间的差异",charIndex:9571},{level:3,title:"Token储存",slug:"token储存",normalizedTitle:"token储存",charIndex:9920},{level:3,title:"怎么禁止让js读取cookie？怎么让cookie只在HTTPS下传输？",slug:"怎么禁止让js读取cookie-怎么让cookie只在https下传输",normalizedTitle:"怎么禁止让js读取cookie？怎么让cookie只在https下传输？",charIndex:10802},{level:2,title:"客户端缓存",slug:"客户端缓存",normalizedTitle:"客户端缓存",charIndex:11222},{level:3,title:"客户端缓存",slug:"客户端缓存-2",normalizedTitle:"客户端缓存",charIndex:11222},{level:2,title:"跨域",slug:"跨域",normalizedTitle:"跨域",charIndex:10110},{level:3,title:"浏览器为什么要阻止跨域请求?",slug:"浏览器为什么要阻止跨域请求",normalizedTitle:"浏览器为什么要阻止跨域请求?",charIndex:12341},{level:3,title:"如何解决跨域?",slug:"如何解决跨域",normalizedTitle:"如何解决跨域?",charIndex:12666}],headersStr:"记录一次前端优化首屏时间 70% 的优化过程~ 项目背景 目标 方向 准备工作 开始发力 效果如何？ 请列举的前端性能优化 浅谈渲染机制 网络 渲染引擎及关键渲染路径（Critical Rendering Path） 重排&&重绘 重排 重绘(repaint) 性能优化 总结 防抖&&节流 防抖（debounce） 节流（throttle） cookies 、 sessionStorage和localstorage 三者之间的差异 Token储存 怎么禁止让js读取cookie？怎么让cookie只在HTTPS下传输？ 客户端缓存 客户端缓存 跨域 浏览器为什么要阻止跨域请求? 如何解决跨域?",content:"# 优化\n\n\n# 记录一次前端优化首屏时间 70% 的优化过程~\n\n\n# 项目背景\n\n中小项目， vue2\n\n\n# 目标\n\n缩短白屏时间，用户能够更快的看到我的页面！\n\n> 白屏时间：从打开页面到看到页面，中间白屏停留的时间。\n\n\n# 方向\n\n1.减少资源体积，从而缩短请求时间\n\n2.减少资源请求个数，从而缩短等待时间\n\n\n# 准备工作\n\n# 如何知道打包体积？\n\n打包构建的时候，使用--report命令：\n\nnpm run build --report\n\n\n打包结束后，会在dist目录里面生成一个report html文件，里面会显示你打包体积分布情况，可以根据项目情况，侧重优化。\n\n大概长这样（图片来自网络，并非我项目实际情况）\n\n\n\n# 如何知道打包速度\n\n有的人可以通过--progress查看到打包耗时，但是对于我项目无用，使用ProgressBarPlugin插件解决\n\nconfig.plugins.push(new ProgressBarPlugin())}\n\n\n\n# 开始发力\n\n# 0.删除你没用到的代码\n\n在webpack里加上下面插件，每次serve的时候，会生成一个json文件，里面会显示你没用到的文件\n\nconfig.plugin('uselessFile')\n  .use(new UselessFile({     \n  root:path.resolve(__dirname, './src'),     \n  out:'./fileList.json',     \n  clean:false,       \n  exclude: /node_modules/ \n}))  \n}\n\n\n# 1.让没有按需引入的库按需引入\n\n比如：lodash\n\n之前的引入方式：\n\nimport lodash from 'lodash'\n\n\n使用按需引入\n\nimport find from 'lodash/find\n\n\n打包体积少了很多...\n\n# 2.引入一个库最小的资源\n\n举个例子，有一个库叫a，我们一般引入方式为\n\nimport a from 'a'\n\n\n我们可以去node_modules里面搜索查看一下资源的大小，有么有a.min.js 或者是 a.min.min.js，找个体积最小的！\n\n比如：\n\nimport vis from 'vis-network'\n\n\n改成\n\nimport vis from 'vis-network/dist/vis-network.min'\n\n\n打包体积少了很多...\n\n# 3.替换更小的库\n\n比如：moment\n\n刚开始我参考了网上的方案，在webpack里面配置，忽略不会使用到的moment部分，从而达到减少打包体积的效果：\n\nwebpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/));\n\n\n成功让打包出来的moment体积从600多k降到了160多k，成果非常显著！\n\n但是想着100多k对于我只使用了简单的时间函数来说，还是很大了，后来：\n\n> 抛弃moment，使用dayjs！\n\n然后打包出来只有6k！！！6K！！！\n\n# 4.开启Gzip\n\nconst productionGzipExtensions = ['js','css']\nconst gzipCompressPlugin = new CompressionWebpackPlugin({        \n    filename: '[path].gz[query]',     \n    algorithm: 'gzip',       \n    test: new RegExp('\\\\.(' + productionGzipExtensions.join('|') + ')$'), \n    threshold: 10240, \n    minRatio: 0.8, \n    })   \nconfig.plugins.push(gzipCompressPlugin) \n\n\n# 5.生产环境删除console等\n\n注意，安装terser-webpack-plugin版本要注意与你webpack的对应，不然会安装失败哦！我使用的是4.2.3\n\n  let terserOption = new TerserPlugin({     \n  terserOptions: {            \n  test: /\\.js(\\?.*)?$/i,        \n  exclude: /\\/node_modules/,    \n  warnings: false,           \n  mangle: true, \n  compress: {   \n     drop_console: true,             \n     drop_debugger: true,        \n     pure_funcs: ['console.log'] \n }\n )}\n config.plugins.push(terserOption)  \n\n\n# 6.生产关闭sourcemap\n\nproductionSourceMap: false\n\n\n# 7.删除prefetch\n\nconfig.plugins.delete(\"prefetch\")\n\n\n删除了这个，首次加载时间优化了好多...\n\n\n# 效果如何？\n\n首次加载速度优化70%\n\n打包体积优化60%\n\n持续优化中...\n\n\n# 请列举的前端性能优化\n\n\n\n\n# 浅谈渲染机制\n\n# 浏览器基础结构主要包括如下7部分：\n\n 1. 用户界面（User Interface）:用户所看到及与之交互的功能组件，如地址栏，返回，前进按钮等；\n 2. 浏览器引擎（Browser engine）:负责控制和管理下一级的渲染引擎；\n 3. 渲染引擎（Rendering engine）:负责解析用户请求的内容（如HTML或XML，渲染引擎会解析HTML或XML，以及相关CSS，然后返回解析后的内容）；\n 4. 网络（Networking）:负责处理网络相关的事务，如HTTP请求等；\n 5. UI后端（UI backend）:负责绘制提示框等浏览器组件，其底层使用的是操作系统的用户接口；\n 6. JavaScript解释器（JavaScript interpreter）:负责解析和执行JavaScript代码；\n 7. 数据存储（Data storage）:负责持久存储诸如cookie和缓存等应用数据。\n\n\n\n\n# 网络\n\n当用户访问页面时，浏览器需要获取用户请求内容，这个过程主要涉及浏览器网络模块：\n\n * 1.用户在地址栏输入域名，如http://baidu.com，DNS（Domain Name System，域名解析系统）服务器根据输入的域名查找对应IP，然后向该IP地址发起请求；\n\n\n\n * 2.浏览器获得并解析服务器的返回内容(HTTP response)；\n * 3.浏览器加载HTML文件及文件内包含的外部引用文件及图片，多媒体等资源。\n\n# DNS预解析（DNS prefetch）\n\n浏览器DNS解析大多时候较快，且会缓存常用域名的解析值，但是如果网站涉及多域名，在对每一个域名访问时都需要先解析出IP地址，而我们希望在跳转或者请求其他域名资源时尽量快，则可以开启域名预解析，浏览器会在空闲时提前解析声明需要预解析的\n\n\n\n# 多进程\n\n我们通常说JavaScript执行是单进程的，但是浏览器网络部分通常是有几个平行进程同时开启，但是也会有 限制，一般为2-6个。\n\n\n# 渲染引擎及关键渲染路径（Critical Rendering Path）\n\n渲染引擎所做的事是将请求内容展现给我们，默认支持HTML,XML和图片类型，对于其他诸如PDF等类型的内容则需要安装相应插件，但浏览器的展示工作流程基本是一样的。\n\n通过网络模块加载到HTML文件后渲染引擎渲染流程如下，这也通常被称作关键渲染路径（Critical Rendering Path）：\n\n * 1.构建DOM树(DOM tree)：从上到下解析HTML文档生成DOM节点树（DOM tree），也叫内容树（content tree）；\n\n * 2.构建CSSOM(CSS Object Model)树：加载解析样式生成CSSOM树；\n\n * 3.执行JavaScript：加载并执行JavaScript代码（包括内联代码或外联JavaScript文件）；\n\n * 4.构建渲染树(render tree)：根据DOM树和CSSOM树,生成渲染树(render tree)；\n   \n   渲染树：按顺序展示在屏幕上的一系列矩形，这些矩形带有字体，颜色和尺寸等视觉属性。\n\n * 5.布局（layout）：根据渲染树将节点树的每一个节点布局在屏幕上的正确位置；\n\n * 6.绘制（painting）：遍历渲染树绘制所有节点，为每一个节点适用对应的样式，这一过程是通过UI后端模块完成；\n   \n   \n   \n   为了更友好的用户体验，浏览器会尽可能快的展现内容，而不会等到文档所有内容到达才开始解析和构建/布局渲染树，而是每次处理一部分，并展现在屏幕上，这也是为什么我们经常可以看到页面加载的时候内容是从上到下一点一点展现的。\n\n# 流程图\n\nWebkit渲染引擎流程如下图：\n\n\n\nGecko渲染引擎流程如下图：\n\n\n\n如上图，Webkit浏览器和Gecko浏览器渲染流程大致相同,不同的是：\n\n * 1.Webkit浏览器中的渲染树(render tree)，在Gecko浏览器中对应的则是框架树（frame tree）,渲染对象(render object)对应的是框架（frame）;\n * 2.Webkit中的布局（Layout）过程，在Gecko中称为回流（Reflow）,本质是一样的，后文会解释回流的另一层含义–重新布局；\n * 3.Gecko中HTML和DOM树中间多了一层内容池（Content sink）,可以理解成生成DOM元素的工厂。\n\n\n# 重排&&重绘\n\n\n# 重排\n\n# 概念：\n\n当更新了元素的几何属性，那么浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排，也称为“回流”。\n\n例如我们通过JS或CSS修改了元素的宽度和高度，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。\n\n渲染树的节点发生改变，影响了该节点的几何属性，导致该节点位置发生变化，此时就会触发浏览器重排并重新生成渲染树。重排意味着节点的几何属性改变，需重新计算并生成渲染树，导致渲染树的全部或部分发生变化。\n\n重排需要更新完整的渲染流水线，所以开销也是最大的。\n\n# 常见的引起重排属性和方法\n\n任何会改变元素的位置和尺寸大小的操作，都会触发重排。常见的例子如下：\n\n * 添加或删除可见的DOM元素\n * 元素尺寸改变\n * 内容变化，比如在input框中输入文字\n * 浏览器窗口尺寸改变\n * 计算offsetTop、offsetLeft等布局信息\n * 设置style属性的值\n * 激活CSS伪类，例如 :hover\n * 查询某些属性或调用某些方法\n\n# 几何属性\n\n几何属性：包括布局、尺寸等可用数学几何衡量的属性。\n\n * 布局：display、float、position、list、table、flex、columns、grid\n * 尺寸：margin、padding、border、width、height\n\n# 获取布局信息的属性或方法\n\n获取布局信息的属性如下：\n\n * offsetTop、offsetLeft、offsetWidth、offsetHeight\n * scrollTop、scrollLeft、scrollWidth、scrollHeight\n * clientTop、clientLeft、clientWidth、clientHeight\n * getComputedStyle()\n * getBoundingClientRect()\n\n看到这里有的人可能会疑惑，我们只是获取这些属性值，并没有改变它，为什么会触发重排？\n\n现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！当你获取布局信息的操作的时候，会强制清空队列，因为队列中，可能会有影响到这些值的操作，为了给我们最精确的值，浏览器会立即重排+重绘。\n\n所以我们应避免频繁使用上述的属性。\n\n# 重排的影响范围\n\n浏览器渲染界面是基于流式布局模型的，所以触发重排时会对周围的DOM重新排列，影响的范围分两种：\n\n\n# 重绘(repaint)\n\n# 概念\n\n更新了元素的绘制属性，但没有改变布局，重新把元素外观绘制出来的过程叫做重绘。例如更改某些元素的背景颜色。\n\n重绘并没有引起元素几何属性的改变，所以就直接进入绘制阶段，然后执行之后的一系列子阶段。\n\n和重排相比，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。\n\n重排一定会伴随重绘，重绘却不一定伴随重排。\n\n# 外观属性\n\n包括界面、文字等可用状态向量描述的属性\n\n * 界面：appearance、outline、background、mask、box-shadow、box-reflect、filter、opacity、clip、border-radius、background-size、visibility\n * 文字：text、font、word\n\n\n# 性能优化\n\n重排和重绘在操作节点样式时频繁出现，同时也存在很大程度上的性能问题。重排成本比重绘成本高得多，因为一个节点的重排可能导致子节点、兄弟节点或祖先节点的重排，所以我们要尽可能减少重排次数、重排范围。\n\n# 使用visibility:hidden替换display:none\n\n通过下面四个方面来看看两者有什么区别：\n\n * 占位表现\n\n * * display:none：不占据空间\n   * visibility:hidden：占据空间\n\n * 触发影响\n\n * * display:none：触发重排重绘\n   * visibility:hidden：触发重绘\n\n * 过渡影响\n\n * * display:none：影响过渡不影响动画\n   * visibility:hidden：过渡和动画都不影响\n\n * 株连效果\n\n * * display:none：自身及其子节点全都不可见\n   * visibility:hidden：自身及其子节点都不可见，但可声明子节点visibility:visible单独显示\n\n# 避免使用Table布局\n\nTable布局可能很小的一个改动就会造成整个table重排。\n\n通常可用 ul、li、span等标签取代 table 系列标签生成表格\n\n# 避免设置多层内联样式\n\n浏览器的CSS解析器解析css文件时，对CSS规则是从右到左匹配查找，样式层级过多会影响重排重绘效率。\n\n<style>\n  span {\n    color: red;\n  }\n\n  div > a > span {\n    color: red;\n  }\n</style>\n\n<div>\n  <a href=\"https://www.baidu.com\">\n    <span>百度搜索</span>\n  </a>\n</div>\n\n\n对于第一种设置样式的方式来说，浏览器只需要找到页面中所有的 span 标签然后设置颜色，但是对于第二种设置样式的方式来说，浏览器首先需要找到所有的 span 标签，然后找到 span 标签上的 a 标签，最后再去找到 div 标签，然后给符合这种条件的 span 标签设置颜色，这样的递归过程就很复杂。所以我们应该尽可能的避免写过于具体的 CSS 选择器，然后对于 HTML 来说也尽量少的添加无意义标签，保证层级扁平。\n\n# 将频繁重绘或重排的节点设置为图层\n\n上一篇文章中我们构建完布局树之后，我们会进行分层，将页面分为很多个图层，如果不对图层添加关联，图层之间是不会相互影响的。\n\n因此，在浏览器中将频繁重排或重绘的节点设置为一张新图层，那么新图层就能够阻止节点的渲染行为影响别的节点。\n\n设置新图层的方法：\n\n * 将节点设置为video或iframe\n * 为节点添加 will-change 属性\n\n# 使用requestAnimationFrame作为动画帧\n\n动画速度越快，重排次数越多，浏览器刷新频率为60Hz，即每16.6ms更新一次，而requestAnimationFrame()正是以16.6ms的速度更新一次。所以可用requestAnimationFrame()代替setInterval()。\n\n# 对于复杂动画效果,使用绝对定位让其脱离文档流\n\n对于复杂动画效果，由于会经常的引起重排重绘，因此，我们可以使用绝对定位，让它脱离文档流。否则会引起父元素以及后续元素频繁的重排。\n\n# 动态改变类而不改变样式\n\n不要尝试每次操作DOM去改变节点样式，这样会频繁触发重排。\n\n更好的方式是使用新的类名预定义节点样式，在执行逻辑操作时收集并确认最终更换的类名集合，在适合时机一次性动态替换原来的类名集合。\n\n具体的实现可以看下HTML DOM元素属性 classList。\n\n# 避免触发同步布局事件\n\n先来看下面的代码：\n\nfor (let i = 0; i <100; i++) {\n  const top = document.getElementById('list').style.top;\n  console.log(top)\n}\n\n\n上文我们说过，当我们访问元素的一些属性的时候，会导致浏览器强制清空队列，进行强制同步布局。\n\n上面代码中每次循环操作DOM都会发生重排，应该在循环外使用变量保存一些不会变化的DOM映射值。\n\nconst top = document.getElementById('list').style.top;\nfor (let i = 0; i <100; i++) {\n  console.log(top)\n}\n\n\n# 批量修改DOM\n\n当我们需要对DOM对一系列修改的时候，可以通过以下步骤减少重排重绘次数：\n\n * 使元素脱离文档流\n * 对其进行多次修改\n * 将元素带回到文档中。\n\n该过程的第一步和第三步可能会引起重排，但是经过第一步之后，对DOM的所有修改都不会引起重排，因为它已经不在渲染树了。\n\n有三种方式可以让DOM脱离文档流：\n\n * 隐藏要操作的dom 在要操作dom之前，通过display隐藏dom，当操作完成之后，再将dom的display属性置为可见，因为不可见的元素不会触发重排和重绘。\n * 通过使用DocumentFragment创建一个dom碎片，在它上面批量操作dom，操作完成之后，再添加到文档中，这样只会触发一次重排。\n * 复制节点，在副本上工作，然后替换它。\n\n> 当然我们也可以使用框架来实现批量修改DOM，比如Vue、React。\n\n# CSS3硬件加速（GPU加速）\n\n使用CSS3硬件加速，可以让 transform、opacity、filters这些动画不会引起重拍重绘，但对于动画的其它属性，比如background-color这些，还是会引起重排重绘的，不过它还是可以提升这些动画的性能。\n\n常见的触发CSS3硬件加速的CSS属性有：\n\n * transform\n * opacity\n * filters\n * will-change\n\n启动硬件加速注意点：\n\n * 如果为太多元素使用CSS3硬件加速，会导致内存占用较大，也会从另一方面导致性能问题\n * 在GPU渲染字体会导致抗锯齿无效。这是因为GPU和CPU的算法不同。因此如果你不在动画结束的时候关闭硬件加速，会产生字体模糊。\n\n\n# 总结\n\n通过上面的学习，我们可以总结出以下几点：\n\n * 重排是因为元素的几何属性更改触发的\n * 重绘是由于元素的绘制属性更改触发的\n * 触发重排也一定会触发重绘，触发重绘不一定会触发重排\n * 重排的成本高于重绘\n * 减少重排次数、重排范围是Web性能优化的基本思路\n\n\n# 防抖&&节流\n\n\n# 防抖（debounce）\n\n防抖就是在事件触发后的n秒之后，再去执行真正需要执行的函数，如果在这n秒之内事件又被触发，则重新开始计时。\n\n防抖函数实现如下：\n\nconst  debounce = (fn, delay=500)=> {\n    let timer; return function (...args) { \n\n        clearTimeout(timer) //清空定时器\n\n        timer = setTimeout( ()=> {\n\n        fn.apply(this, args);  //改变this指向\n\n\t}, delay)  //延迟一定时间执行\n\n}}\n\n\n\n# 节流（throttle）\n\n节流就是规定好一个单位时间，触发函数一次。如果在这个单位时间内触发多次函数的话，只有一次是可被执行的。想执行多次的话，只能等到下一个周期里。\n\n实现代码如下：\n\n// 定时器版本\n\nconst trottle1 = (fn,delay=500)=>{\n\n    let timer;\n\n    return function(...args){\n\n        if(!timer){\n\n            timer = setTimeout(() => {\n\n                timer = null;\n\n                fn.apply(this,args) ;\n\n            }, delay);\n        }\n    }\n}\n\n// 时间戳版本\n\nconst trottle2 = (fn,delay=500)=>{\n\n    let oldTime = Date.now();\n\n    return function(...args){\n\n        const nowTime = Date.now();\n\n        if(nowTime - oldTime >= delay){\n\n            oldTime = Date.now();\n\n            fn.apply(this,args) ;\n\n        }\n    }\n}\n\n\n实际运用中比如，按键快频率重复触发，拖拽场景、表单验证场景resize ，scroll、onmosemove等等触发事件。 性能优化相关。\n\n\n# cookies 、 sessionStorage和localstorage\n\n\n# 三者之间的差异\n\n相同点：都存储在客户端\n\n不同点：\n\n1.存储大小\n\ncookie数据大小不能超过4k。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 2.有效时间\n\nlocalStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；\n\nsessionStorage 数据在当前浏览器窗口关闭后自动删除。\n\ncookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭\n\n3.数据与服务器之间的交互方式\n\ncookie的数据会自动的传递到服务器，服务器端也可以写cookie到客户端\n\nsessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。\n\n\n# Token储存\n\nToken 其实就是访问资源的凭证。一般是用户通过用户名和密码登录成功之后，服务器将登陆凭证做数字签名，加密之后得到的字符串作为 token。\n\n它在用户登录成功之后会返回给客户端，客户端主要有这么几种存储方式：\n\n 1. 存储在 localStorage 中，每次调用接口的时候都把它当成一个字段传给后台存储在 cookie 中，让它自动发送，不过缺点就是不能跨域拿到之后存储在localStorage 中，每次调用接口的时候放在 HTTP 请求头的 Authorization 字段里所以token 在客户端一般存放于 localStorage，cookie，或 sessionStorage 中。\n\n 2. 将token存放在webStroage中，可以通过同域的js来访问 。这样会导致很容易受到xss攻击，特别是项目中引入很多 第三方js类库的情况下。如果js脚本被盗用，攻击者就 可以轻易访问你的网站，webStroage作为一种储存机制，在传输过程中不会执行任何安全标准。\n    \n    1. XSS攻击：cross-site Scripting（跨站脚本攻击）是一种注入代码攻击 。恶意攻击者在目标网站上注入script代码，当访问者浏览网站的时候通过执行注入的script代码达到窃取用户信息，盗用用户身份等。\n\n 3. 将token存放在cookie中可以指定 httponly，来防止被Javascript读取，也可以指定secure，来保证token只在HTTPS下传输。缺点是不符合Restful 最佳实践，容易受到CSRF攻击。CSRF跨站点请求伪造(Cross—Site Request Forgery)，跟XSS攻击一样，存在巨大的危害性。\n    \n    1. 简单来说就是恶意攻击者盗用已经认证过的用户信息，以用户信息名义进行一些操作（如发邮件、转账、购买商品等等）。由于身份已经认证过，所以目标网站会认为操作都是真正的用户操作的 。CSRF并不能拿到用户信息，它只是盗用的用户凭证去进行操作。\n\n\n# 怎么禁止让js读取cookie？怎么让cookie只在HTTPS下传输？\n\n由于cookie会存放在客户端，一般情况下会保存一些凭证及状态信息，为了防止cookie泄露造成安全问题。可以这只cookie的 HttpOnly属性，那么通过程序(JS脚本、Applet等)将无法读取到Cookie信息，这样能有效的防止XSS攻击。\n\ncookie 中有个属性secure，当该属性设置为true时，表示创建的 Cookie 会被以安全的形式向服务器传输，也就是只能在 HTTPS 连接中被浏览器传递到服务器端进行会话验证，\n\n如果是 HTTP 连接则不会传递该cookie信息，所以不会被窃取到Cookie 的具体内容。就是只允许在加密的情况下将cookie加在数据包请求头部，防止cookie被带出来。\n\nsecure属性是防止信息在传递的过程中被监听捕获后信息泄漏。但是这两个属性并不能解决cookie在本机出现的信息泄漏的问题。\n\n\n# 客户端缓存\n\n\n# 客户端缓存\n\n1.强缓存服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。Cache-control（相对值） / Expries（绝对值）Expries是http1.0的标准\n\nlet nowTime = new Date();    \nnowTime.setTime(new Date().getTime() + 3600*1000);    \nctx.set(\"Expires\",nowTime.toUTCString());\n\n\n到了HTTP/1.1，Expire已经被Cache-Control替代ctx.set(\"Cache-control\",\"max-age=3600\") //设置缓存时间 3600s\n\n（1）public：所有内容都将被缓存（客户端和代理服务器都可缓存）\n\n（2）private：所有内容只有客户端可以缓存，Cache-Control的默认取值\n\n（3）no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定\n\n（4）no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存\n\n（5）max-age=xxx ：缓存内容将在xxx秒后失效Cache-Control优先级比Expires高from memory cache代表使用内存中的缓存，from disk cache则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为memory –> disk。\n\n2.协商缓存让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。\n\n出现 from disk、from memory 的 策略是强缓存。Last-Modify/if-Modify-SinceETag/if-None-Macth协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。缓存关系强缓存优于协商缓存，强缓存中 Cache-control优于 Expries，协商缓存中ETag/ If-None-Match 优先级高于 Last-Modified / If-Modified-Since。\n\n\n# 跨域\n\n\n# 浏览器为什么要阻止跨域请求?\n\n浏览器阻止跨域请求的原因是”同源策略“，”同源策略“主要解决的问题是浏览器的安全问题，同源是 协议 、域名 、端口都相同，非同源是只要协议、域名、端口有一个不同就会造成非同源。如下：\n\nhttp://www.kaikeba.com:443 //http:协议 www.kaikeba.com; 域名 443; 端口 http://www.kaikeba.com:3000\n\n如上两地址由于端口不同就造成跨域问题。\n\n非同源会造成：\n\n1.无法获取cookie、localstroage、indexedDB。\n\n2.无法访问网页中dom。\n\n3无法发送网络请求。\n\n所以浏览器阻止跨域的原因是基于网络安全考虑。\n\n\n# 如何解决跨域?\n\n解决跨域方式有很多种例如：\n\n1.jsonp跨域。\n\n2.postMessage解决跨域\n\n3.跨域资源共享（CORS）\n\n4.nginx 反向代理\n\n5.nodejs中间件正向代理\n\n7.websocket协议跨域。\n\n跨域是浏览器出于安全策略阻止非同源请求，但是每次跨域请求其实都是正常发送的，服务端也会正常返回，只是被浏览器拦截起来了。所以每次跨域请求都会到达服务端。",normalizedContent:"# 优化\n\n\n# 记录一次前端优化首屏时间 70% 的优化过程~\n\n\n# 项目背景\n\n中小项目， vue2\n\n\n# 目标\n\n缩短白屏时间，用户能够更快的看到我的页面！\n\n> 白屏时间：从打开页面到看到页面，中间白屏停留的时间。\n\n\n# 方向\n\n1.减少资源体积，从而缩短请求时间\n\n2.减少资源请求个数，从而缩短等待时间\n\n\n# 准备工作\n\n# 如何知道打包体积？\n\n打包构建的时候，使用--report命令：\n\nnpm run build --report\n\n\n打包结束后，会在dist目录里面生成一个report html文件，里面会显示你打包体积分布情况，可以根据项目情况，侧重优化。\n\n大概长这样（图片来自网络，并非我项目实际情况）\n\n\n\n# 如何知道打包速度\n\n有的人可以通过--progress查看到打包耗时，但是对于我项目无用，使用progressbarplugin插件解决\n\nconfig.plugins.push(new progressbarplugin())}\n\n\n\n# 开始发力\n\n# 0.删除你没用到的代码\n\n在webpack里加上下面插件，每次serve的时候，会生成一个json文件，里面会显示你没用到的文件\n\nconfig.plugin('uselessfile')\n  .use(new uselessfile({     \n  root:path.resolve(__dirname, './src'),     \n  out:'./filelist.json',     \n  clean:false,       \n  exclude: /node_modules/ \n}))  \n}\n\n\n# 1.让没有按需引入的库按需引入\n\n比如：lodash\n\n之前的引入方式：\n\nimport lodash from 'lodash'\n\n\n使用按需引入\n\nimport find from 'lodash/find\n\n\n打包体积少了很多...\n\n# 2.引入一个库最小的资源\n\n举个例子，有一个库叫a，我们一般引入方式为\n\nimport a from 'a'\n\n\n我们可以去node_modules里面搜索查看一下资源的大小，有么有a.min.js 或者是 a.min.min.js，找个体积最小的！\n\n比如：\n\nimport vis from 'vis-network'\n\n\n改成\n\nimport vis from 'vis-network/dist/vis-network.min'\n\n\n打包体积少了很多...\n\n# 3.替换更小的库\n\n比如：moment\n\n刚开始我参考了网上的方案，在webpack里面配置，忽略不会使用到的moment部分，从而达到减少打包体积的效果：\n\nwebpack.ignoreplugin(/^\\.\\/locale$/, /moment$/));\n\n\n成功让打包出来的moment体积从600多k降到了160多k，成果非常显著！\n\n但是想着100多k对于我只使用了简单的时间函数来说，还是很大了，后来：\n\n> 抛弃moment，使用dayjs！\n\n然后打包出来只有6k！！！6k！！！\n\n# 4.开启gzip\n\nconst productiongzipextensions = ['js','css']\nconst gzipcompressplugin = new compressionwebpackplugin({        \n    filename: '[path].gz[query]',     \n    algorithm: 'gzip',       \n    test: new regexp('\\\\.(' + productiongzipextensions.join('|') + ')$'), \n    threshold: 10240, \n    minratio: 0.8, \n    })   \nconfig.plugins.push(gzipcompressplugin) \n\n\n# 5.生产环境删除console等\n\n注意，安装terser-webpack-plugin版本要注意与你webpack的对应，不然会安装失败哦！我使用的是4.2.3\n\n  let terseroption = new terserplugin({     \n  terseroptions: {            \n  test: /\\.js(\\?.*)?$/i,        \n  exclude: /\\/node_modules/,    \n  warnings: false,           \n  mangle: true, \n  compress: {   \n     drop_console: true,             \n     drop_debugger: true,        \n     pure_funcs: ['console.log'] \n }\n )}\n config.plugins.push(terseroption)  \n\n\n# 6.生产关闭sourcemap\n\nproductionsourcemap: false\n\n\n# 7.删除prefetch\n\nconfig.plugins.delete(\"prefetch\")\n\n\n删除了这个，首次加载时间优化了好多...\n\n\n# 效果如何？\n\n首次加载速度优化70%\n\n打包体积优化60%\n\n持续优化中...\n\n\n# 请列举的前端性能优化\n\n\n\n\n# 浅谈渲染机制\n\n# 浏览器基础结构主要包括如下7部分：\n\n 1. 用户界面（user interface）:用户所看到及与之交互的功能组件，如地址栏，返回，前进按钮等；\n 2. 浏览器引擎（browser engine）:负责控制和管理下一级的渲染引擎；\n 3. 渲染引擎（rendering engine）:负责解析用户请求的内容（如html或xml，渲染引擎会解析html或xml，以及相关css，然后返回解析后的内容）；\n 4. 网络（networking）:负责处理网络相关的事务，如http请求等；\n 5. ui后端（ui backend）:负责绘制提示框等浏览器组件，其底层使用的是操作系统的用户接口；\n 6. javascript解释器（javascript interpreter）:负责解析和执行javascript代码；\n 7. 数据存储（data storage）:负责持久存储诸如cookie和缓存等应用数据。\n\n\n\n\n# 网络\n\n当用户访问页面时，浏览器需要获取用户请求内容，这个过程主要涉及浏览器网络模块：\n\n * 1.用户在地址栏输入域名，如http://baidu.com，dns（domain name system，域名解析系统）服务器根据输入的域名查找对应ip，然后向该ip地址发起请求；\n\n\n\n * 2.浏览器获得并解析服务器的返回内容(http response)；\n * 3.浏览器加载html文件及文件内包含的外部引用文件及图片，多媒体等资源。\n\n# dns预解析（dns prefetch）\n\n浏览器dns解析大多时候较快，且会缓存常用域名的解析值，但是如果网站涉及多域名，在对每一个域名访问时都需要先解析出ip地址，而我们希望在跳转或者请求其他域名资源时尽量快，则可以开启域名预解析，浏览器会在空闲时提前解析声明需要预解析的\n\n\n\n# 多进程\n\n我们通常说javascript执行是单进程的，但是浏览器网络部分通常是有几个平行进程同时开启，但是也会有 限制，一般为2-6个。\n\n\n# 渲染引擎及关键渲染路径（critical rendering path）\n\n渲染引擎所做的事是将请求内容展现给我们，默认支持html,xml和图片类型，对于其他诸如pdf等类型的内容则需要安装相应插件，但浏览器的展示工作流程基本是一样的。\n\n通过网络模块加载到html文件后渲染引擎渲染流程如下，这也通常被称作关键渲染路径（critical rendering path）：\n\n * 1.构建dom树(dom tree)：从上到下解析html文档生成dom节点树（dom tree），也叫内容树（content tree）；\n\n * 2.构建cssom(css object model)树：加载解析样式生成cssom树；\n\n * 3.执行javascript：加载并执行javascript代码（包括内联代码或外联javascript文件）；\n\n * 4.构建渲染树(render tree)：根据dom树和cssom树,生成渲染树(render tree)；\n   \n   渲染树：按顺序展示在屏幕上的一系列矩形，这些矩形带有字体，颜色和尺寸等视觉属性。\n\n * 5.布局（layout）：根据渲染树将节点树的每一个节点布局在屏幕上的正确位置；\n\n * 6.绘制（painting）：遍历渲染树绘制所有节点，为每一个节点适用对应的样式，这一过程是通过ui后端模块完成；\n   \n   \n   \n   为了更友好的用户体验，浏览器会尽可能快的展现内容，而不会等到文档所有内容到达才开始解析和构建/布局渲染树，而是每次处理一部分，并展现在屏幕上，这也是为什么我们经常可以看到页面加载的时候内容是从上到下一点一点展现的。\n\n# 流程图\n\nwebkit渲染引擎流程如下图：\n\n\n\ngecko渲染引擎流程如下图：\n\n\n\n如上图，webkit浏览器和gecko浏览器渲染流程大致相同,不同的是：\n\n * 1.webkit浏览器中的渲染树(render tree)，在gecko浏览器中对应的则是框架树（frame tree）,渲染对象(render object)对应的是框架（frame）;\n * 2.webkit中的布局（layout）过程，在gecko中称为回流（reflow）,本质是一样的，后文会解释回流的另一层含义–重新布局；\n * 3.gecko中html和dom树中间多了一层内容池（content sink）,可以理解成生成dom元素的工厂。\n\n\n# 重排&&重绘\n\n\n# 重排\n\n# 概念：\n\n当更新了元素的几何属性，那么浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排，也称为“回流”。\n\n例如我们通过js或css修改了元素的宽度和高度，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。\n\n渲染树的节点发生改变，影响了该节点的几何属性，导致该节点位置发生变化，此时就会触发浏览器重排并重新生成渲染树。重排意味着节点的几何属性改变，需重新计算并生成渲染树，导致渲染树的全部或部分发生变化。\n\n重排需要更新完整的渲染流水线，所以开销也是最大的。\n\n# 常见的引起重排属性和方法\n\n任何会改变元素的位置和尺寸大小的操作，都会触发重排。常见的例子如下：\n\n * 添加或删除可见的dom元素\n * 元素尺寸改变\n * 内容变化，比如在input框中输入文字\n * 浏览器窗口尺寸改变\n * 计算offsettop、offsetleft等布局信息\n * 设置style属性的值\n * 激活css伪类，例如 :hover\n * 查询某些属性或调用某些方法\n\n# 几何属性\n\n几何属性：包括布局、尺寸等可用数学几何衡量的属性。\n\n * 布局：display、float、position、list、table、flex、columns、grid\n * 尺寸：margin、padding、border、width、height\n\n# 获取布局信息的属性或方法\n\n获取布局信息的属性如下：\n\n * offsettop、offsetleft、offsetwidth、offsetheight\n * scrolltop、scrollleft、scrollwidth、scrollheight\n * clienttop、clientleft、clientwidth、clientheight\n * getcomputedstyle()\n * getboundingclientrect()\n\n看到这里有的人可能会疑惑，我们只是获取这些属性值，并没有改变它，为什么会触发重排？\n\n现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！当你获取布局信息的操作的时候，会强制清空队列，因为队列中，可能会有影响到这些值的操作，为了给我们最精确的值，浏览器会立即重排+重绘。\n\n所以我们应避免频繁使用上述的属性。\n\n# 重排的影响范围\n\n浏览器渲染界面是基于流式布局模型的，所以触发重排时会对周围的dom重新排列，影响的范围分两种：\n\n\n# 重绘(repaint)\n\n# 概念\n\n更新了元素的绘制属性，但没有改变布局，重新把元素外观绘制出来的过程叫做重绘。例如更改某些元素的背景颜色。\n\n重绘并没有引起元素几何属性的改变，所以就直接进入绘制阶段，然后执行之后的一系列子阶段。\n\n和重排相比，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。\n\n重排一定会伴随重绘，重绘却不一定伴随重排。\n\n# 外观属性\n\n包括界面、文字等可用状态向量描述的属性\n\n * 界面：appearance、outline、background、mask、box-shadow、box-reflect、filter、opacity、clip、border-radius、background-size、visibility\n * 文字：text、font、word\n\n\n# 性能优化\n\n重排和重绘在操作节点样式时频繁出现，同时也存在很大程度上的性能问题。重排成本比重绘成本高得多，因为一个节点的重排可能导致子节点、兄弟节点或祖先节点的重排，所以我们要尽可能减少重排次数、重排范围。\n\n# 使用visibility:hidden替换display:none\n\n通过下面四个方面来看看两者有什么区别：\n\n * 占位表现\n\n * * display:none：不占据空间\n   * visibility:hidden：占据空间\n\n * 触发影响\n\n * * display:none：触发重排重绘\n   * visibility:hidden：触发重绘\n\n * 过渡影响\n\n * * display:none：影响过渡不影响动画\n   * visibility:hidden：过渡和动画都不影响\n\n * 株连效果\n\n * * display:none：自身及其子节点全都不可见\n   * visibility:hidden：自身及其子节点都不可见，但可声明子节点visibility:visible单独显示\n\n# 避免使用table布局\n\ntable布局可能很小的一个改动就会造成整个table重排。\n\n通常可用 ul、li、span等标签取代 table 系列标签生成表格\n\n# 避免设置多层内联样式\n\n浏览器的css解析器解析css文件时，对css规则是从右到左匹配查找，样式层级过多会影响重排重绘效率。\n\n<style>\n  span {\n    color: red;\n  }\n\n  div > a > span {\n    color: red;\n  }\n</style>\n\n<div>\n  <a href=\"https://www.baidu.com\">\n    <span>百度搜索</span>\n  </a>\n</div>\n\n\n对于第一种设置样式的方式来说，浏览器只需要找到页面中所有的 span 标签然后设置颜色，但是对于第二种设置样式的方式来说，浏览器首先需要找到所有的 span 标签，然后找到 span 标签上的 a 标签，最后再去找到 div 标签，然后给符合这种条件的 span 标签设置颜色，这样的递归过程就很复杂。所以我们应该尽可能的避免写过于具体的 css 选择器，然后对于 html 来说也尽量少的添加无意义标签，保证层级扁平。\n\n# 将频繁重绘或重排的节点设置为图层\n\n上一篇文章中我们构建完布局树之后，我们会进行分层，将页面分为很多个图层，如果不对图层添加关联，图层之间是不会相互影响的。\n\n因此，在浏览器中将频繁重排或重绘的节点设置为一张新图层，那么新图层就能够阻止节点的渲染行为影响别的节点。\n\n设置新图层的方法：\n\n * 将节点设置为video或iframe\n * 为节点添加 will-change 属性\n\n# 使用requestanimationframe作为动画帧\n\n动画速度越快，重排次数越多，浏览器刷新频率为60hz，即每16.6ms更新一次，而requestanimationframe()正是以16.6ms的速度更新一次。所以可用requestanimationframe()代替setinterval()。\n\n# 对于复杂动画效果,使用绝对定位让其脱离文档流\n\n对于复杂动画效果，由于会经常的引起重排重绘，因此，我们可以使用绝对定位，让它脱离文档流。否则会引起父元素以及后续元素频繁的重排。\n\n# 动态改变类而不改变样式\n\n不要尝试每次操作dom去改变节点样式，这样会频繁触发重排。\n\n更好的方式是使用新的类名预定义节点样式，在执行逻辑操作时收集并确认最终更换的类名集合，在适合时机一次性动态替换原来的类名集合。\n\n具体的实现可以看下html dom元素属性 classlist。\n\n# 避免触发同步布局事件\n\n先来看下面的代码：\n\nfor (let i = 0; i <100; i++) {\n  const top = document.getelementbyid('list').style.top;\n  console.log(top)\n}\n\n\n上文我们说过，当我们访问元素的一些属性的时候，会导致浏览器强制清空队列，进行强制同步布局。\n\n上面代码中每次循环操作dom都会发生重排，应该在循环外使用变量保存一些不会变化的dom映射值。\n\nconst top = document.getelementbyid('list').style.top;\nfor (let i = 0; i <100; i++) {\n  console.log(top)\n}\n\n\n# 批量修改dom\n\n当我们需要对dom对一系列修改的时候，可以通过以下步骤减少重排重绘次数：\n\n * 使元素脱离文档流\n * 对其进行多次修改\n * 将元素带回到文档中。\n\n该过程的第一步和第三步可能会引起重排，但是经过第一步之后，对dom的所有修改都不会引起重排，因为它已经不在渲染树了。\n\n有三种方式可以让dom脱离文档流：\n\n * 隐藏要操作的dom 在要操作dom之前，通过display隐藏dom，当操作完成之后，再将dom的display属性置为可见，因为不可见的元素不会触发重排和重绘。\n * 通过使用documentfragment创建一个dom碎片，在它上面批量操作dom，操作完成之后，再添加到文档中，这样只会触发一次重排。\n * 复制节点，在副本上工作，然后替换它。\n\n> 当然我们也可以使用框架来实现批量修改dom，比如vue、react。\n\n# css3硬件加速（gpu加速）\n\n使用css3硬件加速，可以让 transform、opacity、filters这些动画不会引起重拍重绘，但对于动画的其它属性，比如background-color这些，还是会引起重排重绘的，不过它还是可以提升这些动画的性能。\n\n常见的触发css3硬件加速的css属性有：\n\n * transform\n * opacity\n * filters\n * will-change\n\n启动硬件加速注意点：\n\n * 如果为太多元素使用css3硬件加速，会导致内存占用较大，也会从另一方面导致性能问题\n * 在gpu渲染字体会导致抗锯齿无效。这是因为gpu和cpu的算法不同。因此如果你不在动画结束的时候关闭硬件加速，会产生字体模糊。\n\n\n# 总结\n\n通过上面的学习，我们可以总结出以下几点：\n\n * 重排是因为元素的几何属性更改触发的\n * 重绘是由于元素的绘制属性更改触发的\n * 触发重排也一定会触发重绘，触发重绘不一定会触发重排\n * 重排的成本高于重绘\n * 减少重排次数、重排范围是web性能优化的基本思路\n\n\n# 防抖&&节流\n\n\n# 防抖（debounce）\n\n防抖就是在事件触发后的n秒之后，再去执行真正需要执行的函数，如果在这n秒之内事件又被触发，则重新开始计时。\n\n防抖函数实现如下：\n\nconst  debounce = (fn, delay=500)=> {\n    let timer; return function (...args) { \n\n        cleartimeout(timer) //清空定时器\n\n        timer = settimeout( ()=> {\n\n        fn.apply(this, args);  //改变this指向\n\n\t}, delay)  //延迟一定时间执行\n\n}}\n\n\n\n# 节流（throttle）\n\n节流就是规定好一个单位时间，触发函数一次。如果在这个单位时间内触发多次函数的话，只有一次是可被执行的。想执行多次的话，只能等到下一个周期里。\n\n实现代码如下：\n\n// 定时器版本\n\nconst trottle1 = (fn,delay=500)=>{\n\n    let timer;\n\n    return function(...args){\n\n        if(!timer){\n\n            timer = settimeout(() => {\n\n                timer = null;\n\n                fn.apply(this,args) ;\n\n            }, delay);\n        }\n    }\n}\n\n// 时间戳版本\n\nconst trottle2 = (fn,delay=500)=>{\n\n    let oldtime = date.now();\n\n    return function(...args){\n\n        const nowtime = date.now();\n\n        if(nowtime - oldtime >= delay){\n\n            oldtime = date.now();\n\n            fn.apply(this,args) ;\n\n        }\n    }\n}\n\n\n实际运用中比如，按键快频率重复触发，拖拽场景、表单验证场景resize ，scroll、onmosemove等等触发事件。 性能优化相关。\n\n\n# cookies 、 sessionstorage和localstorage\n\n\n# 三者之间的差异\n\n相同点：都存储在客户端\n\n不同点：\n\n1.存储大小\n\ncookie数据大小不能超过4k。sessionstorage和localstorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5m或更大。 2.有效时间\n\nlocalstorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；\n\nsessionstorage 数据在当前浏览器窗口关闭后自动删除。\n\ncookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭\n\n3.数据与服务器之间的交互方式\n\ncookie的数据会自动的传递到服务器，服务器端也可以写cookie到客户端\n\nsessionstorage和localstorage不会自动把数据发给服务器，仅在本地保存。\n\n\n# token储存\n\ntoken 其实就是访问资源的凭证。一般是用户通过用户名和密码登录成功之后，服务器将登陆凭证做数字签名，加密之后得到的字符串作为 token。\n\n它在用户登录成功之后会返回给客户端，客户端主要有这么几种存储方式：\n\n 1. 存储在 localstorage 中，每次调用接口的时候都把它当成一个字段传给后台存储在 cookie 中，让它自动发送，不过缺点就是不能跨域拿到之后存储在localstorage 中，每次调用接口的时候放在 http 请求头的 authorization 字段里所以token 在客户端一般存放于 localstorage，cookie，或 sessionstorage 中。\n\n 2. 将token存放在webstroage中，可以通过同域的js来访问 。这样会导致很容易受到xss攻击，特别是项目中引入很多 第三方js类库的情况下。如果js脚本被盗用，攻击者就 可以轻易访问你的网站，webstroage作为一种储存机制，在传输过程中不会执行任何安全标准。\n    \n    1. xss攻击：cross-site scripting（跨站脚本攻击）是一种注入代码攻击 。恶意攻击者在目标网站上注入script代码，当访问者浏览网站的时候通过执行注入的script代码达到窃取用户信息，盗用用户身份等。\n\n 3. 将token存放在cookie中可以指定 httponly，来防止被javascript读取，也可以指定secure，来保证token只在https下传输。缺点是不符合restful 最佳实践，容易受到csrf攻击。csrf跨站点请求伪造(cross—site request forgery)，跟xss攻击一样，存在巨大的危害性。\n    \n    1. 简单来说就是恶意攻击者盗用已经认证过的用户信息，以用户信息名义进行一些操作（如发邮件、转账、购买商品等等）。由于身份已经认证过，所以目标网站会认为操作都是真正的用户操作的 。csrf并不能拿到用户信息，它只是盗用的用户凭证去进行操作。\n\n\n# 怎么禁止让js读取cookie？怎么让cookie只在https下传输？\n\n由于cookie会存放在客户端，一般情况下会保存一些凭证及状态信息，为了防止cookie泄露造成安全问题。可以这只cookie的 httponly属性，那么通过程序(js脚本、applet等)将无法读取到cookie信息，这样能有效的防止xss攻击。\n\ncookie 中有个属性secure，当该属性设置为true时，表示创建的 cookie 会被以安全的形式向服务器传输，也就是只能在 https 连接中被浏览器传递到服务器端进行会话验证，\n\n如果是 http 连接则不会传递该cookie信息，所以不会被窃取到cookie 的具体内容。就是只允许在加密的情况下将cookie加在数据包请求头部，防止cookie被带出来。\n\nsecure属性是防止信息在传递的过程中被监听捕获后信息泄漏。但是这两个属性并不能解决cookie在本机出现的信息泄漏的问题。\n\n\n# 客户端缓存\n\n\n# 客户端缓存\n\n1.强缓存服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。cache-control（相对值） / expries（绝对值）expries是http1.0的标准\n\nlet nowtime = new date();    \nnowtime.settime(new date().gettime() + 3600*1000);    \nctx.set(\"expires\",nowtime.toutcstring());\n\n\n到了http/1.1，expire已经被cache-control替代ctx.set(\"cache-control\",\"max-age=3600\") //设置缓存时间 3600s\n\n（1）public：所有内容都将被缓存（客户端和代理服务器都可缓存）\n\n（2）private：所有内容只有客户端可以缓存，cache-control的默认取值\n\n（3）no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定\n\n（4）no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存\n\n（5）max-age=xxx ：缓存内容将在xxx秒后失效cache-control优先级比expires高from memory cache代表使用内存中的缓存，from disk cache则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为memory –> disk。\n\n2.协商缓存让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率，将缓存信息中的etag和last-modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。\n\n出现 from disk、from memory 的 策略是强缓存。last-modify/if-modify-sinceetag/if-none-macth协商缓存的标识也是在响应报文的http头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：last-modified / if-modified-since和etag / if-none-match，其中etag / if-none-match的优先级比last-modified / if-modified-since高。缓存关系强缓存优于协商缓存，强缓存中 cache-control优于 expries，协商缓存中etag/ if-none-match 优先级高于 last-modified / if-modified-since。\n\n\n# 跨域\n\n\n# 浏览器为什么要阻止跨域请求?\n\n浏览器阻止跨域请求的原因是”同源策略“，”同源策略“主要解决的问题是浏览器的安全问题，同源是 协议 、域名 、端口都相同，非同源是只要协议、域名、端口有一个不同就会造成非同源。如下：\n\nhttp://www.kaikeba.com:443 //http:协议 www.kaikeba.com; 域名 443; 端口 http://www.kaikeba.com:3000\n\n如上两地址由于端口不同就造成跨域问题。\n\n非同源会造成：\n\n1.无法获取cookie、localstroage、indexeddb。\n\n2.无法访问网页中dom。\n\n3无法发送网络请求。\n\n所以浏览器阻止跨域的原因是基于网络安全考虑。\n\n\n# 如何解决跨域?\n\n解决跨域方式有很多种例如：\n\n1.jsonp跨域。\n\n2.postmessage解决跨域\n\n3.跨域资源共享（cors）\n\n4.nginx 反向代理\n\n5.nodejs中间件正向代理\n\n7.websocket协议跨域。\n\n跨域是浏览器出于安全策略阻止非同源请求，但是每次跨域请求其实都是正常发送的，服务端也会正常返回，只是被浏览器拦截起来了。所以每次跨域请求都会到达服务端。",charsets:{cjk:!0}},{frontmatter:{},regularPath:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/",relativePath:"前端问题/README.md",key:"v-f09a4384",path:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/",headersStr:null,content:" 1. 前端请求接口的几种方式总结.md\n\njs的展示\n\nhttp://c.biancheng.net/view/5845.html",normalizedContent:" 1. 前端请求接口的几种方式总结.md\n\njs的展示\n\nhttp://c.biancheng.net/view/5845.html",charsets:{cjk:!0}},{title:"数组/对象/字符串",frontmatter:{},regularPath:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/ArrObjStr.html",relativePath:"前端问题/ArrObjStr.md",key:"v-aa80698a",path:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/ArrObjStr.html",headers:[{level:2,title:"数组的基本命令",slug:"数组的基本命令",normalizedTitle:"数组的基本命令",charIndex:16},{level:3,title:".concat() 连接两个或多个数组。",slug:"concat-连接两个或多个数组。",normalizedTitle:".concat() 连接两个或多个数组。",charIndex:28},{level:3,title:".keys() 用于从数组创建一个包含数组键的可迭代对象。",slug:"keys-用于从数组创建一个包含数组键的可迭代对象。",normalizedTitle:".keys() 用于从数组创建一个包含数组键的可迭代对象。",charIndex:134},{level:3,title:".push，.unshift，.pop，.shift 对比 - (添加+删除)",slug:"push-unshift-pop-shift-对比-添加-删除",normalizedTitle:".push，.unshift，.pop，.shift 对比 - (添加+删除)",charIndex:199},{level:3,title:".splice() 和 .slice() 区别 - （splice 主要用于删除，slice 用于提取）",slug:"splice-和-slice-区别-splice-主要用于删除-slice-用于提取",normalizedTitle:".splice() 和 .slice() 区别 - （splice 主要用于删除，slice 用于提取）",charIndex:617},{level:3,title:".sort()  用于对数组的元素进行排序。",slug:"sort-用于对数组的元素进行排序。",normalizedTitle:".sort()  用于对数组的元素进行排序。",charIndex:null},{level:3,title:".filter() 创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。(过滤)",slug:"filter-创建一个新的数组-新数组中的元素是通过检查指定数组中符合条件的所有元素。-过滤",normalizedTitle:".filter() 创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。(过滤)",charIndex:1384},{level:3,title:".forEach()  用于调用数组的每个元素，并将元素传递给回调函数。",slug:"foreach-用于调用数组的每个元素-并将元素传递给回调函数。",normalizedTitle:".foreach()  用于调用数组的每个元素，并将元素传递给回调函数。",charIndex:null},{level:3,title:".map() 返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。",slug:"map-返回一个新数组-数组中的元素为原始数组元素调用函数处理后的值。",normalizedTitle:".map() 返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。",charIndex:1882},{level:3,title:".indexOf() 返回索引值",slug:"indexof-返回索引值",normalizedTitle:".indexof() 返回索引值",charIndex:2111},{level:3,title:".findIndex() 返回索引值",slug:"findindex-返回索引值",normalizedTitle:".findindex() 返回索引值",charIndex:2227},{level:3,title:".includes（） 判断一个数组是否包含一个指定的值，如果是返回 true，否则false。",slug:"includes-判断一个数组是否包含一个指定的值-如果是返回-true-否则false。",normalizedTitle:".includes（） 判断一个数组是否包含一个指定的值，如果是返回 true，否则false。",charIndex:2662},{level:3,title:"使用 indexOf 与 filter获取对象数组某一个属性值的索引值/判断是否存在",slug:"使用-indexof-与-filter获取对象数组某一个属性值的索引值-判断是否存在",normalizedTitle:"使用 indexof 与 filter获取对象数组某一个属性值的索引值/判断是否存在",charIndex:2899},{level:3,title:"数组总结",slug:"数组总结",normalizedTitle:"数组总结",charIndex:3299},{level:2,title:"JS判断是否是数组的四种做法",slug:"js判断是否是数组的四种做法",normalizedTitle:"js判断是否是数组的四种做法",charIndex:3896},{level:3,title:"通过instanceof判断",slug:"通过instanceof判断",normalizedTitle:"通过instanceof判断",charIndex:3915},{level:3,title:"通过constructor判断",slug:"通过constructor判断",normalizedTitle:"通过constructor判断",charIndex:4710},{level:3,title:"通过Object.prototype.toString.call()判断",slug:"通过object-prototype-tostring-call-判断",normalizedTitle:"通过object.prototype.tostring.call()判断",charIndex:5146},{level:3,title:"通过Array.isArray()判断",slug:"通过array-isarray-判断",normalizedTitle:"通过array.isarray()判断",charIndex:5905},{level:3,title:"最终推荐",slug:"最终推荐",normalizedTitle:"最终推荐",charIndex:6117},{level:2,title:"对数组进行去除重复值的方法",slug:"对数组进行去除重复值的方法",normalizedTitle:"对数组进行去除重复值的方法",charIndex:6383},{level:2,title:"对象基本命令",slug:"对象基本命令",normalizedTitle:"对象基本命令",charIndex:8670},{level:3,title:"对象遍历 for - in",slug:"对象遍历-for-in",normalizedTitle:"对象遍历 for - in",charIndex:8681},{level:3,title:"js三种方法合并两个对象",slug:"js三种方法合并两个对象",normalizedTitle:"js三种方法合并两个对象",charIndex:8887},{level:3,title:"Object判断是否存在该属性【是对象本身而不是继承原型链】",slug:"object判断是否存在该属性【是对象本身而不是继承原型链】",normalizedTitle:"object判断是否存在该属性【是对象本身而不是继承原型链】",charIndex:9186},{level:3,title:"使用 Object.keys + Array.filter + Array.includes 获取符合条件的对象值",slug:"使用-object-keys-array-filter-array-includes-获取符合条件的对象值",normalizedTitle:"使用 object.keys + array.filter + array.includes 获取符合条件的对象值",charIndex:9723},{level:2,title:"字符串的基本命令",slug:"字符串的基本命令",normalizedTitle:"字符串的基本命令",charIndex:10120},{level:2,title:"对字段进行判断",slug:"对字段进行判断",normalizedTitle:"对字段进行判断",charIndex:10539},{level:3,title:"字符串的前后空格清空",slug:"字符串的前后空格清空",normalizedTitle:"字符串的前后空格清空",charIndex:10551},{level:3,title:"判断传参的类型",slug:"判断传参的类型",normalizedTitle:"判断传参的类型",charIndex:10726}],headersStr:"数组的基本命令 .concat() 连接两个或多个数组。 .keys() 用于从数组创建一个包含数组键的可迭代对象。 .push，.unshift，.pop，.shift 对比 - (添加+删除) .splice() 和 .slice() 区别 - （splice 主要用于删除，slice 用于提取） .sort()  用于对数组的元素进行排序。 .filter() 创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。(过滤) .forEach()  用于调用数组的每个元素，并将元素传递给回调函数。 .map() 返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。 .indexOf() 返回索引值 .findIndex() 返回索引值 .includes（） 判断一个数组是否包含一个指定的值，如果是返回 true，否则false。 使用 indexOf 与 filter获取对象数组某一个属性值的索引值/判断是否存在 数组总结 JS判断是否是数组的四种做法 通过instanceof判断 通过constructor判断 通过Object.prototype.toString.call()判断 通过Array.isArray()判断 最终推荐 对数组进行去除重复值的方法 对象基本命令 对象遍历 for - in js三种方法合并两个对象 Object判断是否存在该属性【是对象本身而不是继承原型链】 使用 Object.keys + Array.filter + Array.includes 获取符合条件的对象值 字符串的基本命令 对字段进行判断 字符串的前后空格清空 判断传参的类型",content:"# 数组/对象/字符串\n\n\n# 数组的基本命令\n\n\n# .concat() 连接两个或多个数组。\n\n提示\n\n该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。\n\n语法： array1.concat(array2,array3,...,arrayX)\n\n\n# .keys() 用于从数组创建一个包含数组键的可迭代对象。\n\n结果：如果对象是数组返回 true，否则返回 false。\n\n\n# .push，.unshift，.pop，.shift 对比 - (添加+删除)\n\n名称    代码           解释         相当于\n后添加   .push()      可添加一个或多个   .splice(数组.length,0,添加的数据)\n后删除   .pop()       只能删除一个     .splice(-1,1)\n前添加   .unshift()   可添加一个或多个   .splice(0,0,添加的数据)\n前删除   .shift()     只能删除一个     .splice(0,1)\n\n.splice()\n\n参数1：要删除元素的索引值，第一位是 0，最后一位是 -1\n\n参数2：删除的个数，个数为 0 代表不删除\n\n参数3：添加的元素，参数3往后都代表添加的元素\n\n注意\n\n.pop() 和 .shift() 删除返回的一个数据，而 .splice() 删除返回的数组格式。\n\n\n# .splice() 和 .slice() 区别 - （splice 主要用于删除，slice 用于提取）\n\n          SPLICE *              SLICE\n主要功能      删除，可添加数据              提取\n是否影响原数组   是，原数组受影响              否，不影响原数组\n返回值       返回被删除的数据              返回提取那部分数据\n参数区别      数组.splice(开始索引值，个数)   数组.slice(开始索引值, 结束索引值)\n是否能添加数组   可以添加，第三个参数往后都是添加      仅仅提取，不能修改原数组，无法添加\n\n\n# .sort() 用于对数组的元素进行排序。\n\n::: tip说明\n\n默认排序规则是比较第一位谁小，就排到前面，第一位比较不出来就比较第二位。\n\n排序顺序可以是字母或数字，并按升序或降序。\n\n默认排序顺序为按字母升序。\n\n:::\n\n注意\n\n当数字是按字母顺序排列时\"40\"将排在\"5\"前面。\n\n使用数字排序，你必须通过一个函数作为参数来调用。\n\n函数指定数字是按照升序还是降序排列。\n\n注意\n\nsort 函数会影响原数组的数据，直接对原数组进行排序。\n\n例：\n\nconst arrs = [11,22,55,444,44,6]\n// 数组的排列（从小到大）\narr.sort((a,b) => {\n\treturn a - b\n})\n\nconsole.log(arrs)   // [6,11,22,44,55,444]\n\narrs.sort((a,b) => {\n\treruen b - a\n})\n\nconsole.log(arrs)   // [444,55,44,22,11,6]\n\n\n\n\n# .filter() 创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。(过滤)\n\n注意\n\nfilter() 不会对空数组进行检测。\n\nfilter() 不会改变原始数组。\n\n这个方法是用于筛选出数组中满足条件的元素，并组成一个新的数组返回的\n\nconst array = [1500,1200,2000,2100,1800];  \nconst arr = array.filter(function(item){\n    return item < 2000;\t// 这个代码的意思，就是筛选出array数组里面满足 < 2000 的元素，并返回\n});  \nconsole.log(arr);\t//  [1500, 1200, 1800]  \n\n\n\n# .forEach() 用于调用数组的每个元素，并将元素传递给回调函数。\n\n注意\n\nforEach() 对于空数组是不会执行回调函数的。\n\n用法：\n\n数组.forEach( function(item,index){\n    item  就是数组里面的每个元素\n    index 就是每个索引\n} );  \n\n\n\n# .map() 返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。\n\n注意\n\nmap() 不会对空数组进行检测。\n\nmap() 不会改变原始数组。\n\nconst array = [1500,1200,2000,2100,1800];  \nconst arr = array.map(function(item){\n    return '<li>' + item + '</li>';\n});  \nconsole.log(arr);  \n\n\n\n# .indexOf() 返回索引值\n\n数组名称.indexOf(数据); 查找结果只有两种情况：\n\n 1. 查找成功，返回当前查找数据的索引值\n 2. 找不到返回 -1\n\n数组名称.indexOf(数据,从哪个索引值开始);\n\n\n# .findIndex() 返回索引值\n\n获取索引值/获取到符合条件的索引值\n\n例1：\n\nlet arr = [{}]\n\n// 资产编码是否存在\nfunction isCode(){\n    var result_one = arr.findIndex(function(item) {\n        return item.label == \"资产编号\"; //返回false\n    })\n    console.log(result_one, '=result_one');\n    return result_one\n},  \n\n\n例2：\n\nlet storeList = [{id:1},{id:2}]\n\n// 使用数组的findIndex方法\nthis.storeList.findIndex(item=>{\n    // 返回一个判断，一据这个判断来返回索引值\n    return item.id == 2\n})\n\n// 这样返回索引值就是1\n\n\n\n# .includes（） 判断一个数组是否包含一个指定的值，如果是返回 true，否则false。\n\n[1, 2, 3].includes(2);     \t// true\n[1, 2, 3].includes(4);     \t// false\n[1, 2, 3].includes(3, 3);  \t// false\n[1, 2, 3].includes(3, -1); \t// true\n[1, 2, NaN].includes(NaN); \t// true\n\n\n\n# 使用 indexOf 与 filter获取对象数组某一个属性值的索引值/判断是否存在\n\nlet data = [{\n    id:1,\n    name:\"小红\"  \n},{\n    id:2,\n    name:\"小明\"  \n}];\ndata.indexOf(data.filter(d=>d.id == 1)[0]) //index：0\ndata.indexOf(data.filter(d=>d.id == 2)[0]) //index：1\ndata.indexOf(data.filter(d=>d.name == \"小红\")[0]) //index：0\ndata.indexOf(data.filter(d=>d.name == \"小明\")[0]) //index：1\ndata.indexOf(data.filter(d=>d.id == 3)[0]) // 不存在即返回-1\n\n\n\n# 数组总结\n\n会影响原数组的     功能翻译   备注\npop()       后删除    \npush()      后添加    \nshift()     前删除    \nunshift()   前添加    \nsplice()    用于删除   \nreverse()          \nsort()      排列     \n\n不会影响原数组    功能翻译         备注\nslice()    主要用来提取数组     .slide(开始索引值, 结束索引值)\nconcat()   返回连接数组       \njoin()     返回数组分隔成字符串   \n\n需要遍历数组的     功能翻译                得到的\nfindIndex   获取索引值               获取到符合条件的索引值\nFilter      过滤                  获取到符合条件的新数组\nset         es6内置的对象，天生不会有重复的   \n\n// 对 对象数组进行排序 => 根据对象中的哪个属性进行过排序\nallCity.sort((a, b) => { return a.short < b.short ? -1 : 1\n}) console.log(allCity)\n\n获取对象的所有属性名\nfindKey\nFilter\n\n\n# JS判断是否是数组的四种做法\n\n\n# 通过instanceof判断\n\ninstanceof运算符用于检验构造函数的prototype属性是否出现在对象的原型链中的任何位置，返回一个布尔值。\n\nlet a = [];\na instanceof Array; //true\nlet b = {};\nb instanceof Array; //false\n\n\n在上方代码中，instanceof运算符检测Array.prototype属性是否存在于变量a的原型链上，显然a是一个数组，拥有Array.prototype属性，所以为true。\n\n存在问题：\n\n需要注意的是，prototype属性是可以修改的，所以并不是最初判断为true就一定永远为真。\n\n其次，当我们的脚本拥有多个全局环境，例如html中拥有多个iframe对象，instanceof的验证结果可能不会符合预期，例如：\n\n//为body创建并添加一个iframe对象\nvar iframe = document.createElement('iframe');\ndocument.body.appendChild(iframe);\n//取得iframe对象的构造数组方法\nxArray = window.frames[0].Array;\n//通过构造函数获取一个实例\nvar arr = new xArray(1,2,3); \narr instanceof Array;//false\n\n\n导致这种问题是因为iframe会产生新的全局环境，它也会拥有自己的Array.prototype属性，让不同环境下的属性相同很明显是不安全的做法，所以Array.prototype !== window.frames[0].Array.prototype，想要arr instanceof Array为true，你得保证arr是由原始Array构造函数创建时才可行。\n\n\n# 通过constructor判断\n\n我们知道，实例的构造函数属性constructor指向构造函数，那么通过constructor属性也可以判断是否为一个数组。\n\nlet a = [1,3,4];\na.constructor === Array;//true\n\n\n同样，这种判断也会存在多个全局环境的问题，导致的问题与instanceof相同。\n\n//为body创建并添加一个iframe标签\nvar iframe = document.createElement('iframe');\ndocument.body.appendChild(iframe);\n//取得iframe对象的构造数组方法\nxArray = window.frames[window.frames.length-1].Array;\n//通过构造函数获取一个实例\nvar arr = new xArray(1,2,3); \narr.constructor === Array;//false\n\n\n\n# 通过Object.prototype.toString.call()判断\n\nObject.prototype.toString().call()可以获取到对象的不同类型，例如\n\nlet a = [1,2,3]\nObject.prototype.toString.call(a) === '[object Array]';//true\n\n\n它强大的地方在于不仅仅可以检验是否为数组，比如是否是一个函数，是否是数字等等\n\n//检验是否是函数\nlet a = function () {};\nObject.prototype.toString.call(a) === '[object Function]';//true\n//检验是否是数字\nlet b = 1;\nObject.prototype.toString.call(a) === '[object Number]';//true\n\n\n甚至对于多全局环境时， Object.prototype.toString().call()也能符合预期处理判断。\n\n//为body创建并添加一个iframe标签\nvar iframe = document.createElement('iframe');\ndocument.body.appendChild(iframe);\n//取得iframe对象的构造数组方法\nxArray = window.frames[window.frames.length-1].Array;\n//通过构造函数获取一个实例\nvar arr = new xArray(1,2,3); \nconsole.log(Object.prototype.toString.call(arr) === '[object Array]');//true\n\n\n\n# 通过Array.isArray()判断\n\nArray.isArray() 用于确定传递的值是否是一个数组，返回一个布尔值。\n\nlet a = [1,2,3]\nArray.isArray(a);\t//true\n\n\n简单好用，而且对于多全局环境，Array.isArray() 同样能准确判断，但有个问题，Array.isArray() 是在ES5中提出，也就是说在ES5之前可能会存在不支持此方法的情况。怎么解决呢？\n\n\n# 最终推荐\n\n当然还是用Array.isArray()，从ES5新增isArray()方法正是为了提供一个稳定可用的数组判断方法，不可能专门为此提出的好东西不用，而对于ES5之前不支持此方法的问题，我们其实可以做好兼容进行自行封装，像这样：\n\nif (!Array.isArray) {\n    Array.isArray = function(arg) {\n        return Object.prototype.toString.call(arg) === '[object Array]';\n    };\n}\n\n\n\n# 对数组进行去除重复值的方法\n\n 1. 方法一\n    \n    Array.prototype.method1 = function(){ \n        var arr=[];    //定义一个临时数组 \n        for(var i = 0; i < this.length; i++){    //循环遍历当前数组 \n            //判断当前数组下标为i的元素是否已经保存到临时数组 \n            //如果已保存，则跳过，否则将此元素保存到临时数组中 \n            if(arr.indexOf(this[i]) == -1){ \n                arr.push(this[i]); \n            } \n        } \n        return arr; \n    }\n    \n\n 2. 方法二\n    \n    Array.prototype.method2 = function(){  \n        var h={};    //定义一个hash表  \n        var arr=[];  //定义一个临时数组  \n        for(var i = 0; i < this.length; i++){    //循环遍历当前数组  \n            //对元素进行判断，看是否已经存在表中，如果存在则跳过，否则存入临时数组  \n            if(!h[this[i]]){  \n                //存入hash表  \n                h[this[i]] = true;  \n                //把当前数组元素存入到临时数组中  \n                arr.push(this[i]);  \n            }  \n        }  \n        return arr;  \n    }\n    \n\n 3. 方法三\n    \n    Array.prototype.method3 = function(){  \n        //直接定义结果数组  \n        var arr=[] ;\n        for(var i = 1; i < this.length; i++){    //从数组第二项开始循环遍历此数组  \n            //对元素进行判断：  \n            //如果数组当前元素在此数组中第一次出现的位置不是i  \n            //那么我们可以判断第i项元素是重复的，否则直接存入结果数组  \n            if(this.indexOf(this[i]) == i){  \n                arr.push(this[i]);  \n            }  \n        }  \n        return arr;  \n    }\n    \n\n 4. 方法四\n    \n    Array.prototype.method4 = function(){  \n        //将数组进行排序  \n        this.sort();  \n        //定义结果数组  \n        var arr=[];  \n        for(var i = 1; i < this.length; i++){    //从数组第二项开始循环遍历数组  \n            //判断相邻两个元素是否相等，如果相等说明数据重复，否则将元素写入结果数组  \n            if(this[i] !== arr[arr.length - 1]){  \n                arr.push(this[i]);  \n            }              \n        }  \n        return arr;  \n    }\n    \n\n 5. 方法五\n    \n    const set=new Set([1,2,3,4,4]);\n    console.log([...set]);//[1,2,3,4]; \n    //[...set]是一个扩展运算符，将一个数组转为用逗号分隔的参数列表。\n    \n\n 6. 方法六\n    \n    function dedupe(array){\n        return Array.from(new Set(array));\n        //这里的 Array.from（）方法是将两类对象转为真正的数组：类似数组的对象和可遍历的对象（包括es6新增的数据结构Set和Map）\n    }\n    \n\n 7. 方法七【我试用过的】\n    \n    function unique(arr) {\n        // arr---原数组，result新数组\n        var result = [];\n        arr.map((v) => {\n            if (!result.includes(v)) {\n                result.push(v);\n            }\n        });\n        return result;\n    },\n    \n\n 8. 总结\n\n\n# 对象基本命令\n\n\n# 对象遍历 for - in\n\nfor(const key in obj) {\n    console.log(\"属性名\",key,\"值\",obj[key])  //对象时便利属性名 key\n}\nvar arr = [11,22,33]\nfor(let i=0;i<arr.length;i++){\n    console.log(\"索引值\",i,\"值\",arr[i])   //数组是遍历索引号i\n}\n\n\n\n# js三种方法合并两个对象\n\nlet arr1 = {\n\ta:1,\n\tb:2,\n\tc:3\n};\nlet arr2 = {\n\td:4,\n\te:5,\n\ta:6\n};\n//方法一拓展运算符，后面相同的属性覆盖前一个\nlet arr3={...arr1,...arr2};\n\n//方法二Object.assign()，后面相同的属性覆盖前一个\nlet arr3=Object.assign(arr1,arr2);\n\n//方法三Object.keys()，相同的属性只取第一个\nObject.keys(arr1).forEach(key => {\n\tarr2[key] = arr1[key]\n})\n\n\n\n# Object判断是否存在该属性【是对象本身而不是继承原型链】\n\n 1. 使用in关键字。该方法可以判断对象的自有属性和继承来的属性是否存在。\n 2. 使用对象的hasOwnProperty()方法。该方法只能判断自有属性是否存在，对于继承属性会返回false。\n 3. 用undefined判断。自有属性和继承属性均可判断，如果属性的值就是undefined的话，该方法不能返回想要的结果。\n 4. 在条件语句中直接判断。如果x是undefine,null,false,\" \",0或NaN,它将保持不变\n\nObject对象原型上的hasOwnProperty()用来判断一个属性是定义在对象本身而不是继承自原型链。\n\nObject.hasOwnProperty.call(this.addDetails, key)\n\n\nobj.hasOwnProperty(key)\nObject.prototype.hasOwnProperty.call(obj, key)\nObject.hasOwnProperty.call(obj, key)\nObject.prototype.hasOwnProperty===Object.hasOwnProperty // true\n\n\n\n# 使用 Object.keys + Array.filter + Array.includes 获取符合条件的对象值\n\nlet arr1 = {\n\ta:1,\n\tb:2,\n\tc:3\n};\nlet arr2 = [\n    {id:d,d:4},\n    {id:e,e:5},\n\t{id:a,a:6}\n];\n\n// Object.keys 获取对象中所有的属性 === keys=[a,b,c]\nconst keys = Object.keys(arr1);\n\n// 遍历arr2数据，获取相同属性名的数据\nconst rows = this.arr2.filter((row) => {\n    // keys.includes 数组是否包含该值\n    return keys.includes(String(row.id));\n});\n// rows = [{id:a,a:6}]\n\n\n\n# 字符串的基本命令\n\n字符串提取其实有三个方法：.slice() .substring() .substr()，主要掌握其中 .slice() 即可。\n\n字符串.slice(开始索引值, 结束索引值)\n\n字符串.substring(开始索引值, 结束索引值)\n\n字符串.substr(开始索引值, 提取个数)\n\n命令               解释\n.charAt()        根据索引值提取字符串\n.indexOf()       字符串索引值查找\n.replace()       字符串替换\n.slice()         字符串的提取\n.split()         把字符串转换为数组\n.toLowerCase()   把所有英文转换为小写\n.toUpperCase()   把所以英文转换为大写\n.trim()          去除字符串首末位的空格\n.toFixed()       数字类型，保存小数\n\n\n# 对字段进行判断\n\n\n# 字符串的前后空格清空\n\n【通过判断类型为字符串的进行trim()处理前后空格】\n\nvalueTrans(value){\n    if (typeof (value) === 'string') {\n        return value.trim()\n    } else {\n        return value\n    }\n},\n\n\n\n# 判断传参的类型\n\n注意\n\n【number, string, undefined, function，boolean类型均能通过typeof方法判断】\n\n而array类型输出object，因为typeof方法只能判断基本类型类型（number, string, undefined，boolean），除此之外（包括Date, RegExp，null等都只是object的扩展！）都不靠谱，数组一般情况下可以用instanceof来判断。\n\nvalueTrans(value){\n    if (typeof (value) === 'number') {\n        // 数字\n        return value\n    } else if (typeof (value) === 'string') {\n        // 字符串\n        return value.trim()\n    } else if (typeof (value) === 'undefined') {\n        // undefined\n        return value\n    } else if (typeof (value) === 'function') {\n        // 函数\n        return value\n    } else if (typeof (value) === 'boolean') {\n        // 布尔值\n        return value\n    } else {\n        return value\n    }\n},\n",normalizedContent:"# 数组/对象/字符串\n\n\n# 数组的基本命令\n\n\n# .concat() 连接两个或多个数组。\n\n提示\n\n该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。\n\n语法： array1.concat(array2,array3,...,arrayx)\n\n\n# .keys() 用于从数组创建一个包含数组键的可迭代对象。\n\n结果：如果对象是数组返回 true，否则返回 false。\n\n\n# .push，.unshift，.pop，.shift 对比 - (添加+删除)\n\n名称    代码           解释         相当于\n后添加   .push()      可添加一个或多个   .splice(数组.length,0,添加的数据)\n后删除   .pop()       只能删除一个     .splice(-1,1)\n前添加   .unshift()   可添加一个或多个   .splice(0,0,添加的数据)\n前删除   .shift()     只能删除一个     .splice(0,1)\n\n.splice()\n\n参数1：要删除元素的索引值，第一位是 0，最后一位是 -1\n\n参数2：删除的个数，个数为 0 代表不删除\n\n参数3：添加的元素，参数3往后都代表添加的元素\n\n注意\n\n.pop() 和 .shift() 删除返回的一个数据，而 .splice() 删除返回的数组格式。\n\n\n# .splice() 和 .slice() 区别 - （splice 主要用于删除，slice 用于提取）\n\n          splice *              slice\n主要功能      删除，可添加数据              提取\n是否影响原数组   是，原数组受影响              否，不影响原数组\n返回值       返回被删除的数据              返回提取那部分数据\n参数区别      数组.splice(开始索引值，个数)   数组.slice(开始索引值, 结束索引值)\n是否能添加数组   可以添加，第三个参数往后都是添加      仅仅提取，不能修改原数组，无法添加\n\n\n# .sort() 用于对数组的元素进行排序。\n\n::: tip说明\n\n默认排序规则是比较第一位谁小，就排到前面，第一位比较不出来就比较第二位。\n\n排序顺序可以是字母或数字，并按升序或降序。\n\n默认排序顺序为按字母升序。\n\n:::\n\n注意\n\n当数字是按字母顺序排列时\"40\"将排在\"5\"前面。\n\n使用数字排序，你必须通过一个函数作为参数来调用。\n\n函数指定数字是按照升序还是降序排列。\n\n注意\n\nsort 函数会影响原数组的数据，直接对原数组进行排序。\n\n例：\n\nconst arrs = [11,22,55,444,44,6]\n// 数组的排列（从小到大）\narr.sort((a,b) => {\n\treturn a - b\n})\n\nconsole.log(arrs)   // [6,11,22,44,55,444]\n\narrs.sort((a,b) => {\n\treruen b - a\n})\n\nconsole.log(arrs)   // [444,55,44,22,11,6]\n\n\n\n\n# .filter() 创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。(过滤)\n\n注意\n\nfilter() 不会对空数组进行检测。\n\nfilter() 不会改变原始数组。\n\n这个方法是用于筛选出数组中满足条件的元素，并组成一个新的数组返回的\n\nconst array = [1500,1200,2000,2100,1800];  \nconst arr = array.filter(function(item){\n    return item < 2000;\t// 这个代码的意思，就是筛选出array数组里面满足 < 2000 的元素，并返回\n});  \nconsole.log(arr);\t//  [1500, 1200, 1800]  \n\n\n\n# .foreach() 用于调用数组的每个元素，并将元素传递给回调函数。\n\n注意\n\nforeach() 对于空数组是不会执行回调函数的。\n\n用法：\n\n数组.foreach( function(item,index){\n    item  就是数组里面的每个元素\n    index 就是每个索引\n} );  \n\n\n\n# .map() 返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。\n\n注意\n\nmap() 不会对空数组进行检测。\n\nmap() 不会改变原始数组。\n\nconst array = [1500,1200,2000,2100,1800];  \nconst arr = array.map(function(item){\n    return '<li>' + item + '</li>';\n});  \nconsole.log(arr);  \n\n\n\n# .indexof() 返回索引值\n\n数组名称.indexof(数据); 查找结果只有两种情况：\n\n 1. 查找成功，返回当前查找数据的索引值\n 2. 找不到返回 -1\n\n数组名称.indexof(数据,从哪个索引值开始);\n\n\n# .findindex() 返回索引值\n\n获取索引值/获取到符合条件的索引值\n\n例1：\n\nlet arr = [{}]\n\n// 资产编码是否存在\nfunction iscode(){\n    var result_one = arr.findindex(function(item) {\n        return item.label == \"资产编号\"; //返回false\n    })\n    console.log(result_one, '=result_one');\n    return result_one\n},  \n\n\n例2：\n\nlet storelist = [{id:1},{id:2}]\n\n// 使用数组的findindex方法\nthis.storelist.findindex(item=>{\n    // 返回一个判断，一据这个判断来返回索引值\n    return item.id == 2\n})\n\n// 这样返回索引值就是1\n\n\n\n# .includes（） 判断一个数组是否包含一个指定的值，如果是返回 true，否则false。\n\n[1, 2, 3].includes(2);     \t// true\n[1, 2, 3].includes(4);     \t// false\n[1, 2, 3].includes(3, 3);  \t// false\n[1, 2, 3].includes(3, -1); \t// true\n[1, 2, nan].includes(nan); \t// true\n\n\n\n# 使用 indexof 与 filter获取对象数组某一个属性值的索引值/判断是否存在\n\nlet data = [{\n    id:1,\n    name:\"小红\"  \n},{\n    id:2,\n    name:\"小明\"  \n}];\ndata.indexof(data.filter(d=>d.id == 1)[0]) //index：0\ndata.indexof(data.filter(d=>d.id == 2)[0]) //index：1\ndata.indexof(data.filter(d=>d.name == \"小红\")[0]) //index：0\ndata.indexof(data.filter(d=>d.name == \"小明\")[0]) //index：1\ndata.indexof(data.filter(d=>d.id == 3)[0]) // 不存在即返回-1\n\n\n\n# 数组总结\n\n会影响原数组的     功能翻译   备注\npop()       后删除    \npush()      后添加    \nshift()     前删除    \nunshift()   前添加    \nsplice()    用于删除   \nreverse()          \nsort()      排列     \n\n不会影响原数组    功能翻译         备注\nslice()    主要用来提取数组     .slide(开始索引值, 结束索引值)\nconcat()   返回连接数组       \njoin()     返回数组分隔成字符串   \n\n需要遍历数组的     功能翻译                得到的\nfindindex   获取索引值               获取到符合条件的索引值\nfilter      过滤                  获取到符合条件的新数组\nset         es6内置的对象，天生不会有重复的   \n\n// 对 对象数组进行排序 => 根据对象中的哪个属性进行过排序\nallcity.sort((a, b) => { return a.short < b.short ? -1 : 1\n}) console.log(allcity)\n\n获取对象的所有属性名\nfindkey\nfilter\n\n\n# js判断是否是数组的四种做法\n\n\n# 通过instanceof判断\n\ninstanceof运算符用于检验构造函数的prototype属性是否出现在对象的原型链中的任何位置，返回一个布尔值。\n\nlet a = [];\na instanceof array; //true\nlet b = {};\nb instanceof array; //false\n\n\n在上方代码中，instanceof运算符检测array.prototype属性是否存在于变量a的原型链上，显然a是一个数组，拥有array.prototype属性，所以为true。\n\n存在问题：\n\n需要注意的是，prototype属性是可以修改的，所以并不是最初判断为true就一定永远为真。\n\n其次，当我们的脚本拥有多个全局环境，例如html中拥有多个iframe对象，instanceof的验证结果可能不会符合预期，例如：\n\n//为body创建并添加一个iframe对象\nvar iframe = document.createelement('iframe');\ndocument.body.appendchild(iframe);\n//取得iframe对象的构造数组方法\nxarray = window.frames[0].array;\n//通过构造函数获取一个实例\nvar arr = new xarray(1,2,3); \narr instanceof array;//false\n\n\n导致这种问题是因为iframe会产生新的全局环境，它也会拥有自己的array.prototype属性，让不同环境下的属性相同很明显是不安全的做法，所以array.prototype !== window.frames[0].array.prototype，想要arr instanceof array为true，你得保证arr是由原始array构造函数创建时才可行。\n\n\n# 通过constructor判断\n\n我们知道，实例的构造函数属性constructor指向构造函数，那么通过constructor属性也可以判断是否为一个数组。\n\nlet a = [1,3,4];\na.constructor === array;//true\n\n\n同样，这种判断也会存在多个全局环境的问题，导致的问题与instanceof相同。\n\n//为body创建并添加一个iframe标签\nvar iframe = document.createelement('iframe');\ndocument.body.appendchild(iframe);\n//取得iframe对象的构造数组方法\nxarray = window.frames[window.frames.length-1].array;\n//通过构造函数获取一个实例\nvar arr = new xarray(1,2,3); \narr.constructor === array;//false\n\n\n\n# 通过object.prototype.tostring.call()判断\n\nobject.prototype.tostring().call()可以获取到对象的不同类型，例如\n\nlet a = [1,2,3]\nobject.prototype.tostring.call(a) === '[object array]';//true\n\n\n它强大的地方在于不仅仅可以检验是否为数组，比如是否是一个函数，是否是数字等等\n\n//检验是否是函数\nlet a = function () {};\nobject.prototype.tostring.call(a) === '[object function]';//true\n//检验是否是数字\nlet b = 1;\nobject.prototype.tostring.call(a) === '[object number]';//true\n\n\n甚至对于多全局环境时， object.prototype.tostring().call()也能符合预期处理判断。\n\n//为body创建并添加一个iframe标签\nvar iframe = document.createelement('iframe');\ndocument.body.appendchild(iframe);\n//取得iframe对象的构造数组方法\nxarray = window.frames[window.frames.length-1].array;\n//通过构造函数获取一个实例\nvar arr = new xarray(1,2,3); \nconsole.log(object.prototype.tostring.call(arr) === '[object array]');//true\n\n\n\n# 通过array.isarray()判断\n\narray.isarray() 用于确定传递的值是否是一个数组，返回一个布尔值。\n\nlet a = [1,2,3]\narray.isarray(a);\t//true\n\n\n简单好用，而且对于多全局环境，array.isarray() 同样能准确判断，但有个问题，array.isarray() 是在es5中提出，也就是说在es5之前可能会存在不支持此方法的情况。怎么解决呢？\n\n\n# 最终推荐\n\n当然还是用array.isarray()，从es5新增isarray()方法正是为了提供一个稳定可用的数组判断方法，不可能专门为此提出的好东西不用，而对于es5之前不支持此方法的问题，我们其实可以做好兼容进行自行封装，像这样：\n\nif (!array.isarray) {\n    array.isarray = function(arg) {\n        return object.prototype.tostring.call(arg) === '[object array]';\n    };\n}\n\n\n\n# 对数组进行去除重复值的方法\n\n 1. 方法一\n    \n    array.prototype.method1 = function(){ \n        var arr=[];    //定义一个临时数组 \n        for(var i = 0; i < this.length; i++){    //循环遍历当前数组 \n            //判断当前数组下标为i的元素是否已经保存到临时数组 \n            //如果已保存，则跳过，否则将此元素保存到临时数组中 \n            if(arr.indexof(this[i]) == -1){ \n                arr.push(this[i]); \n            } \n        } \n        return arr; \n    }\n    \n\n 2. 方法二\n    \n    array.prototype.method2 = function(){  \n        var h={};    //定义一个hash表  \n        var arr=[];  //定义一个临时数组  \n        for(var i = 0; i < this.length; i++){    //循环遍历当前数组  \n            //对元素进行判断，看是否已经存在表中，如果存在则跳过，否则存入临时数组  \n            if(!h[this[i]]){  \n                //存入hash表  \n                h[this[i]] = true;  \n                //把当前数组元素存入到临时数组中  \n                arr.push(this[i]);  \n            }  \n        }  \n        return arr;  \n    }\n    \n\n 3. 方法三\n    \n    array.prototype.method3 = function(){  \n        //直接定义结果数组  \n        var arr=[] ;\n        for(var i = 1; i < this.length; i++){    //从数组第二项开始循环遍历此数组  \n            //对元素进行判断：  \n            //如果数组当前元素在此数组中第一次出现的位置不是i  \n            //那么我们可以判断第i项元素是重复的，否则直接存入结果数组  \n            if(this.indexof(this[i]) == i){  \n                arr.push(this[i]);  \n            }  \n        }  \n        return arr;  \n    }\n    \n\n 4. 方法四\n    \n    array.prototype.method4 = function(){  \n        //将数组进行排序  \n        this.sort();  \n        //定义结果数组  \n        var arr=[];  \n        for(var i = 1; i < this.length; i++){    //从数组第二项开始循环遍历数组  \n            //判断相邻两个元素是否相等，如果相等说明数据重复，否则将元素写入结果数组  \n            if(this[i] !== arr[arr.length - 1]){  \n                arr.push(this[i]);  \n            }              \n        }  \n        return arr;  \n    }\n    \n\n 5. 方法五\n    \n    const set=new set([1,2,3,4,4]);\n    console.log([...set]);//[1,2,3,4]; \n    //[...set]是一个扩展运算符，将一个数组转为用逗号分隔的参数列表。\n    \n\n 6. 方法六\n    \n    function dedupe(array){\n        return array.from(new set(array));\n        //这里的 array.from（）方法是将两类对象转为真正的数组：类似数组的对象和可遍历的对象（包括es6新增的数据结构set和map）\n    }\n    \n\n 7. 方法七【我试用过的】\n    \n    function unique(arr) {\n        // arr---原数组，result新数组\n        var result = [];\n        arr.map((v) => {\n            if (!result.includes(v)) {\n                result.push(v);\n            }\n        });\n        return result;\n    },\n    \n\n 8. 总结\n\n\n# 对象基本命令\n\n\n# 对象遍历 for - in\n\nfor(const key in obj) {\n    console.log(\"属性名\",key,\"值\",obj[key])  //对象时便利属性名 key\n}\nvar arr = [11,22,33]\nfor(let i=0;i<arr.length;i++){\n    console.log(\"索引值\",i,\"值\",arr[i])   //数组是遍历索引号i\n}\n\n\n\n# js三种方法合并两个对象\n\nlet arr1 = {\n\ta:1,\n\tb:2,\n\tc:3\n};\nlet arr2 = {\n\td:4,\n\te:5,\n\ta:6\n};\n//方法一拓展运算符，后面相同的属性覆盖前一个\nlet arr3={...arr1,...arr2};\n\n//方法二object.assign()，后面相同的属性覆盖前一个\nlet arr3=object.assign(arr1,arr2);\n\n//方法三object.keys()，相同的属性只取第一个\nobject.keys(arr1).foreach(key => {\n\tarr2[key] = arr1[key]\n})\n\n\n\n# object判断是否存在该属性【是对象本身而不是继承原型链】\n\n 1. 使用in关键字。该方法可以判断对象的自有属性和继承来的属性是否存在。\n 2. 使用对象的hasownproperty()方法。该方法只能判断自有属性是否存在，对于继承属性会返回false。\n 3. 用undefined判断。自有属性和继承属性均可判断，如果属性的值就是undefined的话，该方法不能返回想要的结果。\n 4. 在条件语句中直接判断。如果x是undefine,null,false,\" \",0或nan,它将保持不变\n\nobject对象原型上的hasownproperty()用来判断一个属性是定义在对象本身而不是继承自原型链。\n\nobject.hasownproperty.call(this.adddetails, key)\n\n\nobj.hasownproperty(key)\nobject.prototype.hasownproperty.call(obj, key)\nobject.hasownproperty.call(obj, key)\nobject.prototype.hasownproperty===object.hasownproperty // true\n\n\n\n# 使用 object.keys + array.filter + array.includes 获取符合条件的对象值\n\nlet arr1 = {\n\ta:1,\n\tb:2,\n\tc:3\n};\nlet arr2 = [\n    {id:d,d:4},\n    {id:e,e:5},\n\t{id:a,a:6}\n];\n\n// object.keys 获取对象中所有的属性 === keys=[a,b,c]\nconst keys = object.keys(arr1);\n\n// 遍历arr2数据，获取相同属性名的数据\nconst rows = this.arr2.filter((row) => {\n    // keys.includes 数组是否包含该值\n    return keys.includes(string(row.id));\n});\n// rows = [{id:a,a:6}]\n\n\n\n# 字符串的基本命令\n\n字符串提取其实有三个方法：.slice() .substring() .substr()，主要掌握其中 .slice() 即可。\n\n字符串.slice(开始索引值, 结束索引值)\n\n字符串.substring(开始索引值, 结束索引值)\n\n字符串.substr(开始索引值, 提取个数)\n\n命令               解释\n.charat()        根据索引值提取字符串\n.indexof()       字符串索引值查找\n.replace()       字符串替换\n.slice()         字符串的提取\n.split()         把字符串转换为数组\n.tolowercase()   把所有英文转换为小写\n.touppercase()   把所以英文转换为大写\n.trim()          去除字符串首末位的空格\n.tofixed()       数字类型，保存小数\n\n\n# 对字段进行判断\n\n\n# 字符串的前后空格清空\n\n【通过判断类型为字符串的进行trim()处理前后空格】\n\nvaluetrans(value){\n    if (typeof (value) === 'string') {\n        return value.trim()\n    } else {\n        return value\n    }\n},\n\n\n\n# 判断传参的类型\n\n注意\n\n【number, string, undefined, function，boolean类型均能通过typeof方法判断】\n\n而array类型输出object，因为typeof方法只能判断基本类型类型（number, string, undefined，boolean），除此之外（包括date, regexp，null等都只是object的扩展！）都不靠谱，数组一般情况下可以用instanceof来判断。\n\nvaluetrans(value){\n    if (typeof (value) === 'number') {\n        // 数字\n        return value\n    } else if (typeof (value) === 'string') {\n        // 字符串\n        return value.trim()\n    } else if (typeof (value) === 'undefined') {\n        // undefined\n        return value\n    } else if (typeof (value) === 'function') {\n        // 函数\n        return value\n    } else if (typeof (value) === 'boolean') {\n        // 布尔值\n        return value\n    } else {\n        return value\n    }\n},\n",charsets:{cjk:!0}},{title:"小技巧",frontmatter:{},regularPath:"/%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/tips.html",relativePath:"优化问题/tips.md",key:"v-3bba326b",path:"/%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/tips.html",headers:[{level:2,title:"权限相关问题",slug:"权限相关问题",normalizedTitle:"权限相关问题",charIndex:10},{level:3,title:"登录权限",slug:"登录权限",normalizedTitle:"登录权限",charIndex:21},{level:3,title:"按钮权限",slug:"按钮权限",normalizedTitle:"按钮权限",charIndex:97}],headersStr:"权限相关问题 登录权限 按钮权限",content:"# 小技巧\n\n\n# 权限相关问题\n\n\n# 登录权限\n\ntoken储存在本地，每个请求都发送请求头 token\n\n封装axaj请求（导航守卫 vue-router beforeEach）\n\n\n# 按钮权限\n\n与后端配合，给设置权限的时候，通过后端的接口储存-开通了的按钮权限缩代表的字符串，在登录的时候，通过接口获取当前用户的按钮权限列表\n\n前端封装自定义指令，来进行项目整体的按钮的判断展示（当前按钮代表的字符串是否在接口返回的用户拥有的权限列表中）\n\n代码如下：\n\n把接口返回的字段进行前端重新命名，防止之后修改的方便 permissionAllData.js\n\nconst PermissionAllData = {\n    BtnAdd: \"Btn_add\",  // 前端重新命名\n    ...\n};\nexport { PermissionAllData }\n\n\n全局的权限校验方法 main.js\n\nVue.prototype.$checkAuthority = (permissionCode) => {\n    let hasPermission = false;  // 初始化权限为 false\n    const permissionLocalStorage = JSON.parse(localStorage.getItem('permissionData')) || [] // 从本地储存中获取权限数组\n    if (permissionLocalStorage instanceof Array && permissionLocalStorage.length > 0) {\n        permissionLocalStorage.forEach(item => {\n            if (item === permissionCode) {\n                hasPermission = true;\n            }\n        })\n    }\n    return hasPermission;\n}\n\n\n进行对比 authorityall.js\n\nimport { PermissionAllData } from './permissionAllData'\nimport Vue from 'pte-ui/main' // vue插件\n\nexport default {\n    inserted(el, binding, vnode) {\n        const { value } = binding;\n        const val = PermissionAllData[value]  //改造后打开\n\n        const hasPermission = Vue.prototype.$checkAuthority(val); // 进行对比\n\n        if (!hasPermission) {\n            if (el.parentNode) {\n                el.parentNode.removeChild(el);\n            } else {\n                el.innerHTML = \"\";\n            }\n        } else {\n            el && el.setAttribute(\"code\", value);\n        }\n    },\n};\n\n\n自定义指令 authorityIndex.js\n\nimport authority from './authorityall';\n\nconst install = function(Vue) {\n    Vue.directive('authority', authority);\n};\n\nif (window.Vue) {\n    window.authority = authority;\n    Vue.use(install);\n}\n\nauthority.install = install;\nexport default authority;\n\n\n挂在在vue上 main\n\nimport AuthorityDirective from './authorityIndex.js';  // 自定义指令\nVue.use(AuthorityDirective);\n\n\n使用\n\n<el-button v-authority=\"'BtnAdd'\" type=\"primary\"}}</el-button>\n",normalizedContent:"# 小技巧\n\n\n# 权限相关问题\n\n\n# 登录权限\n\ntoken储存在本地，每个请求都发送请求头 token\n\n封装axaj请求（导航守卫 vue-router beforeeach）\n\n\n# 按钮权限\n\n与后端配合，给设置权限的时候，通过后端的接口储存-开通了的按钮权限缩代表的字符串，在登录的时候，通过接口获取当前用户的按钮权限列表\n\n前端封装自定义指令，来进行项目整体的按钮的判断展示（当前按钮代表的字符串是否在接口返回的用户拥有的权限列表中）\n\n代码如下：\n\n把接口返回的字段进行前端重新命名，防止之后修改的方便 permissionalldata.js\n\nconst permissionalldata = {\n    btnadd: \"btn_add\",  // 前端重新命名\n    ...\n};\nexport { permissionalldata }\n\n\n全局的权限校验方法 main.js\n\nvue.prototype.$checkauthority = (permissioncode) => {\n    let haspermission = false;  // 初始化权限为 false\n    const permissionlocalstorage = json.parse(localstorage.getitem('permissiondata')) || [] // 从本地储存中获取权限数组\n    if (permissionlocalstorage instanceof array && permissionlocalstorage.length > 0) {\n        permissionlocalstorage.foreach(item => {\n            if (item === permissioncode) {\n                haspermission = true;\n            }\n        })\n    }\n    return haspermission;\n}\n\n\n进行对比 authorityall.js\n\nimport { permissionalldata } from './permissionalldata'\nimport vue from 'pte-ui/main' // vue插件\n\nexport default {\n    inserted(el, binding, vnode) {\n        const { value } = binding;\n        const val = permissionalldata[value]  //改造后打开\n\n        const haspermission = vue.prototype.$checkauthority(val); // 进行对比\n\n        if (!haspermission) {\n            if (el.parentnode) {\n                el.parentnode.removechild(el);\n            } else {\n                el.innerhtml = \"\";\n            }\n        } else {\n            el && el.setattribute(\"code\", value);\n        }\n    },\n};\n\n\n自定义指令 authorityindex.js\n\nimport authority from './authorityall';\n\nconst install = function(vue) {\n    vue.directive('authority', authority);\n};\n\nif (window.vue) {\n    window.authority = authority;\n    vue.use(install);\n}\n\nauthority.install = install;\nexport default authority;\n\n\n挂在在vue上 main\n\nimport authoritydirective from './authorityindex.js';  // 自定义指令\nvue.use(authoritydirective);\n\n\n使用\n\n<el-button v-authority=\"'btnadd'\" type=\"primary\"}}</el-button>\n",charsets:{cjk:!0}},{title:"axios中文文档（官方直译版）",frontmatter:{},regularPath:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/axios.html",relativePath:"前端问题/axios.md",key:"v-1eb73b85",path:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/axios.html",headers:[{level:2,title:"axios中文文档（官方直译版）",slug:"axios中文文档-官方直译版",normalizedTitle:"axios中文文档（官方直译版）",charIndex:2},{level:2,title:"axios",slug:"axios",normalizedTitle:"axios",charIndex:2},{level:3,title:"特性",slug:"特性",normalizedTitle:"特性",charIndex:151},{level:2,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:446},{level:2,title:"axios API",slug:"axios-api",normalizedTitle:"axios api",charIndex:1331},{level:3,title:"请求方法的别名",slug:"请求方法的别名",normalizedTitle:"请求方法的别名",charIndex:1796},{level:3,title:"并发",slug:"并发",normalizedTitle:"并发",charIndex:1044},{level:2,title:"创建实例",slug:"创建实例",normalizedTitle:"创建实例",charIndex:2176},{level:3,title:"实例方法",slug:"实例方法",normalizedTitle:"实例方法",charIndex:2377},{level:3,title:"请求配置",slug:"请求配置",normalizedTitle:"请求配置",charIndex:2648},{level:3,title:"响应结构",slug:"响应结构",normalizedTitle:"响应结构",charIndex:6943},{level:3,title:"配置默认值",slug:"配置默认值",normalizedTitle:"配置默认值",charIndex:7767},{level:3,title:"全局的 axios 默认值",slug:"全局的-axios-默认值",normalizedTitle:"全局的 axios 默认值",charIndex:7798},{level:3,title:"自定义实例默认值",slug:"自定义实例默认值",normalizedTitle:"自定义实例默认值",charIndex:8012},{level:3,title:"配置的优先顺序",slug:"配置的优先顺序",normalizedTitle:"配置的优先顺序",charIndex:8267},{level:3,title:"拦截器",slug:"拦截器",normalizedTitle:"拦截器",charIndex:8608},{level:3,title:"错误处理",slug:"错误处理",normalizedTitle:"错误处理",charIndex:7752},{level:3,title:"取消",slug:"取消",normalizedTitle:"取消",charIndex:253},{level:2,title:"使用 application/x-www-form-urlencoded format",slug:"使用-application-x-www-form-urlencoded-format",normalizedTitle:"使用 application/x-www-form-urlencoded format",charIndex:11218},{level:3,title:"浏览器",slug:"浏览器",normalizedTitle:"浏览器",charIndex:131},{level:3,title:"Node.js",slug:"node-js",normalizedTitle:"node.js",charIndex:11943},{level:3,title:"Semver",slug:"semver",normalizedTitle:"semver",charIndex:12125},{level:3,title:"Promises",slug:"promises",normalizedTitle:"promises",charIndex:12208},{level:3,title:"TypeScript",slug:"typescript",normalizedTitle:"typescript",charIndex:12292}],headersStr:"axios中文文档（官方直译版） axios 特性 案例 axios API 请求方法的别名 并发 创建实例 实例方法 请求配置 响应结构 配置默认值 全局的 axios 默认值 自定义实例默认值 配置的优先顺序 拦截器 错误处理 取消 使用 application/x-www-form-urlencoded format 浏览器 Node.js Semver Promises TypeScript",content:"# axios中文文档（官方直译版）\n\n网址：https://blog.csdn.net/weixin_45852922/article/details/120517972\n\n\n# axios\n\nAxios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。\n\n\n# 特性\n\n * 从浏览器中创建 XMLHttpRequests\n * 从 node.js 创建 http 请求\n * 支持 Promise API\n * 拦截请求和响应\n * 转换请求数据和响应数据\n * 取消请求\n * 自动转换 JSON 数据\n * 客户端支持防御 XSRF\n * 浏览器支持\n\n使用 npm:\n\n$ npm install axios\n\n\n使用 bower:\n\n$ bower install axios\n\n\n使用 cdn:\n\n<script src=\"https://unpkg.com/axios/dist/axios.min.js\"><\/script>\n\n\n\n# 案例\n\n执行 GET 请求\n\n// 为给定 ID 的 user 创建请求\naxios.get('/user?ID=12345')\n    .then(function (response) {\n    console.log(response);\n})\n    .catch(function (error) {\n    console.log(error);\n});\n\n// 上面的请求也可以这样做\naxios.get('/user', {\n    params: {\n        ID: 12345\n    }\n})\n    .then(function (response) {\n    console.log(response);\n})\n    .catch(function (error) {\n    console.log(error);\n});\n\n\n执行 POST 请求\n\naxios.post('/user', {\n    firstName: 'Fred',\n    lastName: 'Flintstone'\n})\n    .then(function (response) {\n    console.log(response);\n})\n    .catch(function (error) {\n    console.log(error);\n});\n\n\n执行多个并发请求\n\nfunction getUserAccount() {\n    return axios.get('/user/12345');\n}\n\nfunction getUserPermissions() {\n    return axios.get('/user/12345/permissions');\n}\n\naxios.all([getUserAccount(), getUserPermissions()])\n    .then(axios.spread(function (acct, perms) {\n    // 两个请求现在都执行完成\n}));\n\n\n\n# axios API\n\n可以通过向 axios 传递相关配置来创建请求\n\naxios(config)\n// 发送 POST 请求\naxios({\n    method: 'post',\n    url: '/user/12345',\n    data: {\n        firstName: 'Fred',\n        lastName: 'Flintstone'\n    }\n});\n// 获取远端图片\naxios({\n    method:'get',\n    url:'http://bit.ly/2mTM3nY',\n    responseType:'stream'\n})\n    .then(function(response) {\n    response.data.pipe(fs.createWriteStream('ada_lovelace.jpg'))\n});\n\n\naxios(url[, config])\n\n// 发送 GET 请求（默认的方法）\naxios('/user/12345');\n\n\n\n# 请求方法的别名\n\n为方便起见，为所有支持的请求方法提供了别名\n\naxios.request(config)\naxios.get(url[, config])\naxios.delete(url[, config])\naxios.head(url[, config])\naxios.options(url[, config])\naxios.post(url[, data[, config]])\naxios.put(url[, data[, config]])\naxios.patch(url[, data[, config]])\n\n\n注意\n\n在使用别名方法时， url、method、data 这些属性都不必在配置中指定。\n\n\n# 并发\n\n处理并发请求的助手函数\n\naxios.all(iterable)\naxios.spread(callback)\n\n\n\n# 创建实例\n\n可以使用自定义配置新建一个 axios 实例\n\naxios.create([config])\nconst instance = axios.create({\n    baseURL: 'https://some-domain.com/api/',\n    timeout: 1000,\n    headers: {'X-Custom-Header': 'foobar'}\n});\n\n\n\n# 实例方法\n\n以下是可用的实例方法。指定的配置将与实例的配置合并。\n\naxios#request(config)\naxios#get(url[, config])\naxios#delete(url[, config])\naxios#head(url[, config])\naxios#options(url[, config])\naxios#post(url[, data[, config]])\naxios#put(url[, data[, config]])\naxios#patch(url[, data[, config]])\n\n\n\n# 请求配置\n\n这些是创建请求时可以用的配置选项。只有 url 是必需的。如果没有指定 method，请求将默认使用 get 方法。\n\n{\n    // `url` 是用于请求的服务器 URL\n    url: '/user',\n\n    // `method` 是创建请求时使用的方法\n    method: 'get', // default\n\n    // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。\n    // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL\n    baseURL: 'https://some-domain.com/api/',\n\n    // `transformRequest` 允许在向服务器发送前，修改请求数据\n    // 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法\n    // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream\n    transformRequest: [function (data, headers) {\n        // 对 data 进行任意转换处理\n        return data;\n    }],\n\n    // `transformResponse` 在传递给 then/catch 前，允许修改响应数据\n    transformResponse: [function (data) {\n        // 对 data 进行任意转换处理\n        return data;\n    }],\n\n    // `headers` 是即将被发送的自定义请求头\n    headers: {'X-Requested-With': 'XMLHttpRequest'},\n\n    // `params` 是即将与请求一起发送的 URL 参数\n    // 必须是一个无格式对象(plain object)或 URLSearchParams 对象\n    params: {\n        ID: 12345\n    },\n\n    // `paramsSerializer` 是一个负责 `params` 序列化的函数\n    // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)\n    paramsSerializer: function(params) {\n        return Qs.stringify(params, {arrayFormat: 'brackets'})\n    },\n\n    // `data` 是作为请求主体被发送的数据\n    // 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH'\n    // 在没有设置 `transformRequest` 时，必须是以下类型之一：\n    // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams\n    // - 浏览器专属：FormData, File, Blob\n    // - Node 专属： Stream\n    data: {\n        firstName: 'Fred'\n    },\n\n    // `timeout` 指定请求超时的毫秒数(0 表示无超时时间)\n    // 如果请求话费了超过 `timeout` 的时间，请求将被中断\n    timeout: 1000,\n\n    // `withCredentials` 表示跨域请求时是否需要使用凭证\n    withCredentials: false, // default\n\n    // `adapter` 允许自定义处理请求，以使测试更轻松\n    // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).\n    adapter: function (config) {\n        /* ... */\n    },\n\n    // `auth` 表示应该使用 HTTP 基础验证，并提供凭据\n    // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头\n    auth: {\n        username: 'janedoe',\n        password: 's00pers3cret'\n    },\n\n    // `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'\n    responseType: 'json', // default\n\n    // `responseEncoding` indicates encoding to use for decoding responses\n    // Note: Ignored for `responseType` of 'stream' or client-side requests\n    responseEncoding: 'utf8', // default\n\n    // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称\n    xsrfCookieName: 'XSRF-TOKEN', // default\n\n    // `xsrfHeaderName` is the name of the http header that carries the xsrf token value\n    xsrfHeaderName: 'X-XSRF-TOKEN', // default\n\n    // `onUploadProgress` 允许为上传处理进度事件\n    onUploadProgress: function (progressEvent) {\n        // Do whatever you want with the native progress event\n    },\n\n    // `onDownloadProgress` 允许为下载处理进度事件\n    onDownloadProgress: function (progressEvent) {\n        // 对原生进度事件的处理\n    },\n\n    // `maxContentLength` 定义允许的响应内容的最大尺寸\n    maxContentLength: 2000,\n\n    // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte\n    validateStatus: function (status) {\n        return status >= 200 && status < 300; // default\n    },\n\n    // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目\n    // 如果设置为0，将不会 follow 任何重定向\n    maxRedirects: 5, // default\n\n    // `socketPath` defines a UNIX Socket to be used in node.js.\n    // e.g. '/var/run/docker.sock' to send requests to the docker daemon.\n    // Only either `socketPath` or `proxy` can be specified.\n    // If both are specified, `socketPath` is used.\n    socketPath: null, // default\n\n    // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：\n    // `keepAlive` 默认没有启用\n    httpAgent: new http.Agent({ keepAlive: true }),\n    httpsAgent: new https.Agent({ keepAlive: true }),\n\n    // 'proxy' 定义代理服务器的主机名称和端口\n    // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据\n    // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。\n    proxy: {\n        host: '127.0.0.1',\n        port: 9000,\n        auth: {\n            username: 'mikeymike',\n            password: 'rapunz3l'\n        }\n    },\n\n    // `cancelToken` 指定用于取消请求的 cancel token\n    // （查看后面的 Cancellation 这节了解更多）\n    cancelToken: new CancelToken(function (cancel) {\n    })\n}\n\n\n\n# 响应结构\n\n某个请求的响应包含以下信息\n\n{\n    // `data` 由服务器提供的响应\n    data: {},\n\n    // `status` 来自服务器响应的 HTTP 状态码\n    status: 200,\n\n    // `statusText` 来自服务器响应的 HTTP 状态信息\n    statusText: 'OK',\n\n    // `headers` 服务器响应的头\n    headers: {},\n\n    // `config` 是为请求提供的配置信息\n    config: {},\n    // 'request'\n    // `request` is the request that generated this response\n    // It is the last ClientRequest instance in node.js (in redirects)\n    // and an XMLHttpRequest instance the browser\n    request: {}\n}\n\n\n使用 then 时，你将接收下面这样的响应 :\n\naxios.get('/user/12345')  .then(function(response) {    console.log(response.data);    console.log(response.status);    console.log(response.statusText);    console.log(response.headers);    console.log(response.config);  });\n\n\n在使用 catch 时，或传递 rejection callback 作为 then 的第二个参数时，响应可以通过 error 对象可被使用，正如在错误处理这一节所讲。\n\n\n# 配置默认值\n\n你可以指定将被用在各个请求的配置默认值\n\n\n# 全局的 axios 默认值\n\naxios.defaults.baseURL = 'https://api.example.com';axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';\n\n\n\n# 自定义实例默认值\n\n// Set config defaults when creating the instance\nconst instance = axios.create({\n    baseURL: 'https://api.example.com'\n});\n\n// Alter defaults after instance has been created\ninstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n\n\n\n# 配置的优先顺序\n\n配置会以一个优先顺序进行合并。这个顺序是：在 lib/defaults.js 找到的库的默认值，然后是实例的 defaults 属性，最后是请求的 config 参数。后者将优先于前者。这里是一个例子：\n\n// 使用由库提供的配置的默认值来创建实例\n// 此时超时配置的默认值是 `0`\nvar instance = axios.create();\n\n// 覆写库的超时默认值\n// 现在，在超时前，所有请求都会等待 2.5 秒\ninstance.defaults.timeout = 2500;\n\n// 为已知需要花费很长时间的请求覆写超时设置\ninstance.get('/longRequest', {\n    timeout: 5000\n});\n\n\n\n# 拦截器\n\n在请求或响应被 then 或 catch 处理前拦截它们。\n\n// 添加请求拦截器\naxios.interceptors.request.use(function (config) {\n    // 在发送请求之前做些什么\n    return config;\n}, function (error) {\n    // 对请求错误做些什么\n    return Promise.reject(error);\n});\n\n// 添加响应拦截器\naxios.interceptors.response.use(function (response) {\n    // 对响应数据做点什么\n    return response;\n}, function (error) {\n    // 对响应错误做点什么\n    return Promise.reject(error);\n});\n\n\n如果你想在稍后移除拦截器，可以这样：\n\nconst myInterceptor = axios.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n\n\n可以为自定义 axios 实例添加拦截器\n\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n\n\n\n# 错误处理\n\naxios.get('/user/12345')\n    .catch(function (error) {\n    if (error.response) {\n        // The request was made and the server responded with a status code\n        // that falls out of the range of 2xx\n        console.log(error.response.data);\n        console.log(error.response.status);\n        console.log(error.response.headers);\n    } else if (error.request) {\n        // The request was made but no response was received\n        // `error.request` is an instance of XMLHttpRequest in the browser and an instance of\n        // http.ClientRequest in node.js\n        console.log(error.request);\n    } else {\n        // Something happened in setting up the request that triggered an Error\n        console.log('Error', error.message);\n    }\n    console.log(error.config);\n});\n\n\nY可以使用 validateStatus 配置选项定义一个自定义 HTTP 状态码的错误范围。\n\naxios.get('/user/12345', {\n    validateStatus: function (status) {\n        return status < 500; // Reject only if the status code is greater than or equal to 500\n    }\n})\n\n\n\n# 取消\n\n使用 cancel token 取消请求\n\nAxios 的 cancel token API 基于cancelable promises proposal，它还处于第一阶段。\n\n可以使用 CancelToken.source 工厂方法创建 cancel token，像这样：\n\nconst CancelToken = axios.CancelToken;\nconst source = CancelToken.source();\n\naxios.get('/user/12345', {\n    cancelToken: source.token\n}).catch(function(thrown) {\n    if (axios.isCancel(thrown)) {\n        console.log('Request canceled', thrown.message);\n    } else {\n        // 处理错误\n    }\n});\n\naxios.post('/user/12345', {\n    name: 'new name'\n}, {\n    cancelToken: source.token\n})\n\n// 取消请求（message 参数是可选的）\nsource.cancel('Operation canceled by the user.');\n\n\n还可以通过传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token：\n\nconst CancelToken = axios.CancelToken;\nlet cancel;\n\naxios.get('/user/12345', {\n    cancelToken: new CancelToken(function executor(c) {\n        // executor 函数接收一个 cancel 函数作为参数\n        cancel = c;\n    })\n});\n\n// cancel the request\ncancel();\n\n\n注意:\n\n可以使用同一个 cancel token 取消多个请求\n\n\n# 使用 application/x-www-form-urlencoded format\n\n默认情况下，axios将JavaScript对象序列化为JSON。 要以application / x-www-form-urlencoded格式发送数据，您可以使用以下选项之一。\n\n\n# 浏览器\n\n在浏览器中，您可以使用URLSearchParams API，如下所示：\n\nconst params = new URLSearchParams();\nparams.append('param1', 'value1');\nparams.append('param2', 'value2');\naxios.post('/foo', params);\n\n\n注意\n\n所有浏览器都不支持URLSearchParams（请参阅caniuse.com），但可以使用polyfill（确保填充全局环境）。\n\n或者，您可以使用qs库编码数据：\n\nconst qs = require('qs');\naxios.post('/foo', qs.stringify({ 'bar': 123 }));\n\n\n或者以另一种方式（ES6），\n\nimport qs from 'qs';\nconst data = { 'bar': 123 };\nconst options = {\n    method: 'POST',\n    headers: { 'content-type': 'application/x-www-form-urlencoded' },\n    data: qs.stringify(data),\n    url,\n};\naxios(options);\n\n\n\n# Node.js\n\n在node.js中，您可以使用querystring模块，如下所示：\n\nconst querystring = require('querystring');\naxios.post('http://something.com/', querystring.stringify({ foo: 'bar' }));\n\n\n您也可以使用qs库。\n\n\n# Semver\n\n在axios达到1.0版本之前，破坏性更改将以新的次要版本发布。 例如0.5.1和0.5.4将具有相同的API，但0.6.0将具有重大变化。\n\n\n# Promises\n\naxios 依赖原生的 ES6 Promise 实现而被支持. 如果你的环境不支持 ES6 Promise，你可以使用 polyfill.\n\n\n# TypeScript\n\naxios包括TypeScript定义。\n\nimport axios from 'axios';\naxios.get('/user?ID=12345');\n",normalizedContent:"# axios中文文档（官方直译版）\n\n网址：https://blog.csdn.net/weixin_45852922/article/details/120517972\n\n\n# axios\n\naxios 是一个基于 promise 的 http 库，可以用在浏览器和 node.js 中。\n\n\n# 特性\n\n * 从浏览器中创建 xmlhttprequests\n * 从 node.js 创建 http 请求\n * 支持 promise api\n * 拦截请求和响应\n * 转换请求数据和响应数据\n * 取消请求\n * 自动转换 json 数据\n * 客户端支持防御 xsrf\n * 浏览器支持\n\n使用 npm:\n\n$ npm install axios\n\n\n使用 bower:\n\n$ bower install axios\n\n\n使用 cdn:\n\n<script src=\"https://unpkg.com/axios/dist/axios.min.js\"><\/script>\n\n\n\n# 案例\n\n执行 get 请求\n\n// 为给定 id 的 user 创建请求\naxios.get('/user?id=12345')\n    .then(function (response) {\n    console.log(response);\n})\n    .catch(function (error) {\n    console.log(error);\n});\n\n// 上面的请求也可以这样做\naxios.get('/user', {\n    params: {\n        id: 12345\n    }\n})\n    .then(function (response) {\n    console.log(response);\n})\n    .catch(function (error) {\n    console.log(error);\n});\n\n\n执行 post 请求\n\naxios.post('/user', {\n    firstname: 'fred',\n    lastname: 'flintstone'\n})\n    .then(function (response) {\n    console.log(response);\n})\n    .catch(function (error) {\n    console.log(error);\n});\n\n\n执行多个并发请求\n\nfunction getuseraccount() {\n    return axios.get('/user/12345');\n}\n\nfunction getuserpermissions() {\n    return axios.get('/user/12345/permissions');\n}\n\naxios.all([getuseraccount(), getuserpermissions()])\n    .then(axios.spread(function (acct, perms) {\n    // 两个请求现在都执行完成\n}));\n\n\n\n# axios api\n\n可以通过向 axios 传递相关配置来创建请求\n\naxios(config)\n// 发送 post 请求\naxios({\n    method: 'post',\n    url: '/user/12345',\n    data: {\n        firstname: 'fred',\n        lastname: 'flintstone'\n    }\n});\n// 获取远端图片\naxios({\n    method:'get',\n    url:'http://bit.ly/2mtm3ny',\n    responsetype:'stream'\n})\n    .then(function(response) {\n    response.data.pipe(fs.createwritestream('ada_lovelace.jpg'))\n});\n\n\naxios(url[, config])\n\n// 发送 get 请求（默认的方法）\naxios('/user/12345');\n\n\n\n# 请求方法的别名\n\n为方便起见，为所有支持的请求方法提供了别名\n\naxios.request(config)\naxios.get(url[, config])\naxios.delete(url[, config])\naxios.head(url[, config])\naxios.options(url[, config])\naxios.post(url[, data[, config]])\naxios.put(url[, data[, config]])\naxios.patch(url[, data[, config]])\n\n\n注意\n\n在使用别名方法时， url、method、data 这些属性都不必在配置中指定。\n\n\n# 并发\n\n处理并发请求的助手函数\n\naxios.all(iterable)\naxios.spread(callback)\n\n\n\n# 创建实例\n\n可以使用自定义配置新建一个 axios 实例\n\naxios.create([config])\nconst instance = axios.create({\n    baseurl: 'https://some-domain.com/api/',\n    timeout: 1000,\n    headers: {'x-custom-header': 'foobar'}\n});\n\n\n\n# 实例方法\n\n以下是可用的实例方法。指定的配置将与实例的配置合并。\n\naxios#request(config)\naxios#get(url[, config])\naxios#delete(url[, config])\naxios#head(url[, config])\naxios#options(url[, config])\naxios#post(url[, data[, config]])\naxios#put(url[, data[, config]])\naxios#patch(url[, data[, config]])\n\n\n\n# 请求配置\n\n这些是创建请求时可以用的配置选项。只有 url 是必需的。如果没有指定 method，请求将默认使用 get 方法。\n\n{\n    // `url` 是用于请求的服务器 url\n    url: '/user',\n\n    // `method` 是创建请求时使用的方法\n    method: 'get', // default\n\n    // `baseurl` 将自动加在 `url` 前面，除非 `url` 是一个绝对 url。\n    // 它可以通过设置一个 `baseurl` 便于为 axios 实例的方法传递相对 url\n    baseurl: 'https://some-domain.com/api/',\n\n    // `transformrequest` 允许在向服务器发送前，修改请求数据\n    // 只能用在 'put', 'post' 和 'patch' 这几个请求方法\n    // 后面数组中的函数必须返回一个字符串，或 arraybuffer，或 stream\n    transformrequest: [function (data, headers) {\n        // 对 data 进行任意转换处理\n        return data;\n    }],\n\n    // `transformresponse` 在传递给 then/catch 前，允许修改响应数据\n    transformresponse: [function (data) {\n        // 对 data 进行任意转换处理\n        return data;\n    }],\n\n    // `headers` 是即将被发送的自定义请求头\n    headers: {'x-requested-with': 'xmlhttprequest'},\n\n    // `params` 是即将与请求一起发送的 url 参数\n    // 必须是一个无格式对象(plain object)或 urlsearchparams 对象\n    params: {\n        id: 12345\n    },\n\n    // `paramsserializer` 是一个负责 `params` 序列化的函数\n    // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)\n    paramsserializer: function(params) {\n        return qs.stringify(params, {arrayformat: 'brackets'})\n    },\n\n    // `data` 是作为请求主体被发送的数据\n    // 只适用于这些请求方法 'put', 'post', 和 'patch'\n    // 在没有设置 `transformrequest` 时，必须是以下类型之一：\n    // - string, plain object, arraybuffer, arraybufferview, urlsearchparams\n    // - 浏览器专属：formdata, file, blob\n    // - node 专属： stream\n    data: {\n        firstname: 'fred'\n    },\n\n    // `timeout` 指定请求超时的毫秒数(0 表示无超时时间)\n    // 如果请求话费了超过 `timeout` 的时间，请求将被中断\n    timeout: 1000,\n\n    // `withcredentials` 表示跨域请求时是否需要使用凭证\n    withcredentials: false, // default\n\n    // `adapter` 允许自定义处理请求，以使测试更轻松\n    // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).\n    adapter: function (config) {\n        /* ... */\n    },\n\n    // `auth` 表示应该使用 http 基础验证，并提供凭据\n    // 这将设置一个 `authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `authorization`头\n    auth: {\n        username: 'janedoe',\n        password: 's00pers3cret'\n    },\n\n    // `responsetype` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'\n    responsetype: 'json', // default\n\n    // `responseencoding` indicates encoding to use for decoding responses\n    // note: ignored for `responsetype` of 'stream' or client-side requests\n    responseencoding: 'utf8', // default\n\n    // `xsrfcookiename` 是用作 xsrf token 的值的cookie的名称\n    xsrfcookiename: 'xsrf-token', // default\n\n    // `xsrfheadername` is the name of the http header that carries the xsrf token value\n    xsrfheadername: 'x-xsrf-token', // default\n\n    // `onuploadprogress` 允许为上传处理进度事件\n    onuploadprogress: function (progressevent) {\n        // do whatever you want with the native progress event\n    },\n\n    // `ondownloadprogress` 允许为下载处理进度事件\n    ondownloadprogress: function (progressevent) {\n        // 对原生进度事件的处理\n    },\n\n    // `maxcontentlength` 定义允许的响应内容的最大尺寸\n    maxcontentlength: 2000,\n\n    // `validatestatus` 定义对于给定的http 响应状态码是 resolve 或 reject  promise 。如果 `validatestatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte\n    validatestatus: function (status) {\n        return status >= 200 && status < 300; // default\n    },\n\n    // `maxredirects` 定义在 node.js 中 follow 的最大重定向数目\n    // 如果设置为0，将不会 follow 任何重定向\n    maxredirects: 5, // default\n\n    // `socketpath` defines a unix socket to be used in node.js.\n    // e.g. '/var/run/docker.sock' to send requests to the docker daemon.\n    // only either `socketpath` or `proxy` can be specified.\n    // if both are specified, `socketpath` is used.\n    socketpath: null, // default\n\n    // `httpagent` 和 `httpsagent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：\n    // `keepalive` 默认没有启用\n    httpagent: new http.agent({ keepalive: true }),\n    httpsagent: new https.agent({ keepalive: true }),\n\n    // 'proxy' 定义代理服务器的主机名称和端口\n    // `auth` 表示 http 基础验证应当用于连接代理，并提供凭据\n    // 这将会设置一个 `proxy-authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `proxy-authorization` 头。\n    proxy: {\n        host: '127.0.0.1',\n        port: 9000,\n        auth: {\n            username: 'mikeymike',\n            password: 'rapunz3l'\n        }\n    },\n\n    // `canceltoken` 指定用于取消请求的 cancel token\n    // （查看后面的 cancellation 这节了解更多）\n    canceltoken: new canceltoken(function (cancel) {\n    })\n}\n\n\n\n# 响应结构\n\n某个请求的响应包含以下信息\n\n{\n    // `data` 由服务器提供的响应\n    data: {},\n\n    // `status` 来自服务器响应的 http 状态码\n    status: 200,\n\n    // `statustext` 来自服务器响应的 http 状态信息\n    statustext: 'ok',\n\n    // `headers` 服务器响应的头\n    headers: {},\n\n    // `config` 是为请求提供的配置信息\n    config: {},\n    // 'request'\n    // `request` is the request that generated this response\n    // it is the last clientrequest instance in node.js (in redirects)\n    // and an xmlhttprequest instance the browser\n    request: {}\n}\n\n\n使用 then 时，你将接收下面这样的响应 :\n\naxios.get('/user/12345')  .then(function(response) {    console.log(response.data);    console.log(response.status);    console.log(response.statustext);    console.log(response.headers);    console.log(response.config);  });\n\n\n在使用 catch 时，或传递 rejection callback 作为 then 的第二个参数时，响应可以通过 error 对象可被使用，正如在错误处理这一节所讲。\n\n\n# 配置默认值\n\n你可以指定将被用在各个请求的配置默认值\n\n\n# 全局的 axios 默认值\n\naxios.defaults.baseurl = 'https://api.example.com';axios.defaults.headers.common['authorization'] = auth_token;axios.defaults.headers.post['content-type'] = 'application/x-www-form-urlencoded';\n\n\n\n# 自定义实例默认值\n\n// set config defaults when creating the instance\nconst instance = axios.create({\n    baseurl: 'https://api.example.com'\n});\n\n// alter defaults after instance has been created\ninstance.defaults.headers.common['authorization'] = auth_token;\n\n\n\n# 配置的优先顺序\n\n配置会以一个优先顺序进行合并。这个顺序是：在 lib/defaults.js 找到的库的默认值，然后是实例的 defaults 属性，最后是请求的 config 参数。后者将优先于前者。这里是一个例子：\n\n// 使用由库提供的配置的默认值来创建实例\n// 此时超时配置的默认值是 `0`\nvar instance = axios.create();\n\n// 覆写库的超时默认值\n// 现在，在超时前，所有请求都会等待 2.5 秒\ninstance.defaults.timeout = 2500;\n\n// 为已知需要花费很长时间的请求覆写超时设置\ninstance.get('/longrequest', {\n    timeout: 5000\n});\n\n\n\n# 拦截器\n\n在请求或响应被 then 或 catch 处理前拦截它们。\n\n// 添加请求拦截器\naxios.interceptors.request.use(function (config) {\n    // 在发送请求之前做些什么\n    return config;\n}, function (error) {\n    // 对请求错误做些什么\n    return promise.reject(error);\n});\n\n// 添加响应拦截器\naxios.interceptors.response.use(function (response) {\n    // 对响应数据做点什么\n    return response;\n}, function (error) {\n    // 对响应错误做点什么\n    return promise.reject(error);\n});\n\n\n如果你想在稍后移除拦截器，可以这样：\n\nconst myinterceptor = axios.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myinterceptor);\n\n\n可以为自定义 axios 实例添加拦截器\n\nconst instance = axios.create();\ninstance.interceptors.request.use(function () {/*...*/});\n\n\n\n# 错误处理\n\naxios.get('/user/12345')\n    .catch(function (error) {\n    if (error.response) {\n        // the request was made and the server responded with a status code\n        // that falls out of the range of 2xx\n        console.log(error.response.data);\n        console.log(error.response.status);\n        console.log(error.response.headers);\n    } else if (error.request) {\n        // the request was made but no response was received\n        // `error.request` is an instance of xmlhttprequest in the browser and an instance of\n        // http.clientrequest in node.js\n        console.log(error.request);\n    } else {\n        // something happened in setting up the request that triggered an error\n        console.log('error', error.message);\n    }\n    console.log(error.config);\n});\n\n\ny可以使用 validatestatus 配置选项定义一个自定义 http 状态码的错误范围。\n\naxios.get('/user/12345', {\n    validatestatus: function (status) {\n        return status < 500; // reject only if the status code is greater than or equal to 500\n    }\n})\n\n\n\n# 取消\n\n使用 cancel token 取消请求\n\naxios 的 cancel token api 基于cancelable promises proposal，它还处于第一阶段。\n\n可以使用 canceltoken.source 工厂方法创建 cancel token，像这样：\n\nconst canceltoken = axios.canceltoken;\nconst source = canceltoken.source();\n\naxios.get('/user/12345', {\n    canceltoken: source.token\n}).catch(function(thrown) {\n    if (axios.iscancel(thrown)) {\n        console.log('request canceled', thrown.message);\n    } else {\n        // 处理错误\n    }\n});\n\naxios.post('/user/12345', {\n    name: 'new name'\n}, {\n    canceltoken: source.token\n})\n\n// 取消请求（message 参数是可选的）\nsource.cancel('operation canceled by the user.');\n\n\n还可以通过传递一个 executor 函数到 canceltoken 的构造函数来创建 cancel token：\n\nconst canceltoken = axios.canceltoken;\nlet cancel;\n\naxios.get('/user/12345', {\n    canceltoken: new canceltoken(function executor(c) {\n        // executor 函数接收一个 cancel 函数作为参数\n        cancel = c;\n    })\n});\n\n// cancel the request\ncancel();\n\n\n注意:\n\n可以使用同一个 cancel token 取消多个请求\n\n\n# 使用 application/x-www-form-urlencoded format\n\n默认情况下，axios将javascript对象序列化为json。 要以application / x-www-form-urlencoded格式发送数据，您可以使用以下选项之一。\n\n\n# 浏览器\n\n在浏览器中，您可以使用urlsearchparams api，如下所示：\n\nconst params = new urlsearchparams();\nparams.append('param1', 'value1');\nparams.append('param2', 'value2');\naxios.post('/foo', params);\n\n\n注意\n\n所有浏览器都不支持urlsearchparams（请参阅caniuse.com），但可以使用polyfill（确保填充全局环境）。\n\n或者，您可以使用qs库编码数据：\n\nconst qs = require('qs');\naxios.post('/foo', qs.stringify({ 'bar': 123 }));\n\n\n或者以另一种方式（es6），\n\nimport qs from 'qs';\nconst data = { 'bar': 123 };\nconst options = {\n    method: 'post',\n    headers: { 'content-type': 'application/x-www-form-urlencoded' },\n    data: qs.stringify(data),\n    url,\n};\naxios(options);\n\n\n\n# node.js\n\n在node.js中，您可以使用querystring模块，如下所示：\n\nconst querystring = require('querystring');\naxios.post('http://something.com/', querystring.stringify({ foo: 'bar' }));\n\n\n您也可以使用qs库。\n\n\n# semver\n\n在axios达到1.0版本之前，破坏性更改将以新的次要版本发布。 例如0.5.1和0.5.4将具有相同的api，但0.6.0将具有重大变化。\n\n\n# promises\n\naxios 依赖原生的 es6 promise 实现而被支持. 如果你的环境不支持 es6 promise，你可以使用 polyfill.\n\n\n# typescript\n\naxios包括typescript定义。\n\nimport axios from 'axios';\naxios.get('/user?id=12345');\n",charsets:{cjk:!0}},{title:"Vue项目中强制刷新页面的方法(3种方式)",frontmatter:{},regularPath:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2.html",relativePath:"前端问题/刷新页面.md",key:"v-43789173",path:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2.html",headers:[{level:2,title:"Vue项目中强制刷新页面的方法(3种方式)",slug:"vue项目中强制刷新页面的方法-3种方式",normalizedTitle:"vue项目中强制刷新页面的方法(3种方式)",charIndex:2},{level:3,title:"①location.reload()",slug:"_1location-reload",normalizedTitle:"①location.reload()",charIndex:28},{level:3,title:"②this.$router.go(0)",slug:"_2this-router-go-0",normalizedTitle:"②this.$router.go(0)",charIndex:51},{level:3,title:"③provide 配合 inject",slug:"_3provide-配合-inject",normalizedTitle:"③provide 配合 inject",charIndex:101}],headersStr:"Vue项目中强制刷新页面的方法(3种方式) ①location.reload() ②this.$router.go(0) ③provide 配合 inject",content:'# Vue项目中强制刷新页面的方法(3种方式)\n\n\n# ①location.reload()\n\n\n# ②this.$router.go(0)\n\n前面两种方法都有些简单粗暴，主要说一下第三种方法\n\n\n# ③provide 配合 inject\n\n首先我们需要在App.vue中修改\n\n<template>\n    <div>\n        <router-view v-if="isRouterAlive"></router-view>\n    </div>\n</template>\n\n\n通过定义reload方法，控制router-view的显隐（生成和销毁）\n\nexport default {\n    methods: {\n        reload() {\n            this.isRouterAlive = false;\n            this.$nextTick(() => {\n                this.isRouterAlive = true;\n            });\n        },\n        //...\n    },\n};\n\n\n然后在需要刷新页面的组件中注入依赖\n\nexport default {\n    name: "",\n    inject: [\'reload\'],\n    data() {\n        return {\n        };\n    },\n}\n\n\n最后直接调用reload方法就能实现页面的刷新\n\nexport default {\n    methods: {\n    reset() {\n      this.reload();\n    },\n        //...\n    },\n};\n',normalizedContent:'# vue项目中强制刷新页面的方法(3种方式)\n\n\n# ①location.reload()\n\n\n# ②this.$router.go(0)\n\n前面两种方法都有些简单粗暴，主要说一下第三种方法\n\n\n# ③provide 配合 inject\n\n首先我们需要在app.vue中修改\n\n<template>\n    <div>\n        <router-view v-if="isrouteralive"></router-view>\n    </div>\n</template>\n\n\n通过定义reload方法，控制router-view的显隐（生成和销毁）\n\nexport default {\n    methods: {\n        reload() {\n            this.isrouteralive = false;\n            this.$nexttick(() => {\n                this.isrouteralive = true;\n            });\n        },\n        //...\n    },\n};\n\n\n然后在需要刷新页面的组件中注入依赖\n\nexport default {\n    name: "",\n    inject: [\'reload\'],\n    data() {\n        return {\n        };\n    },\n}\n\n\n最后直接调用reload方法就能实现页面的刷新\n\nexport default {\n    methods: {\n    reset() {\n      this.reload();\n    },\n        //...\n    },\n};\n',charsets:{cjk:!0}},{title:"CSS",frontmatter:{},regularPath:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/cssBase.html",relativePath:"前端问题/前端基础/cssBase.md",key:"v-6fe647a2",path:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/cssBase.html",headers:[{level:2,title:"基本知识",slug:"基本知识",normalizedTitle:"基本知识",charIndex:10},{level:3,title:"盒子模型",slug:"盒子模型",normalizedTitle:"盒子模型",charIndex:19},{level:3,title:"复合选择器权重计算",slug:"复合选择器权重计算",normalizedTitle:"复合选择器权重计算",charIndex:181},{level:3,title:"margin的合并（margin天生就有bug）",slug:"margin的合并-margin天生就有bug",normalizedTitle:"margin的合并（margin天生就有bug）",charIndex:305},{level:3,title:"页面布局的稳定性",slug:"页面布局的稳定性",normalizedTitle:"页面布局的稳定性",charIndex:513},{level:3,title:"清除浮动",slug:"清除浮动",normalizedTitle:"清除浮动",charIndex:623},{level:3,title:"元素的显示与隐藏",slug:"元素的显示与隐藏",normalizedTitle:"元素的显示与隐藏",charIndex:1723},{level:3,title:"鼠标样式",slug:"鼠标样式",normalizedTitle:"鼠标样式",charIndex:1999},{level:3,title:"文字阴影",slug:"文字阴影",normalizedTitle:"文字阴影",charIndex:2216},{level:3,title:"盒子阴影",slug:"盒子阴影",normalizedTitle:"盒子阴影",charIndex:2362},{level:3,title:"垂直对齐方式 Vertical-slign",slug:"垂直对齐方式-vertical-slign",normalizedTitle:"垂直对齐方式 vertical-slign",charIndex:2578},{level:3,title:"过渡动画效果",slug:"过渡动画效果",normalizedTitle:"过渡动画效果",charIndex:2815},{level:3,title:"关键帧动画",slug:"关键帧动画",normalizedTitle:"关键帧动画",charIndex:2955},{level:2,title:"css常用代码",slug:"css常用代码",normalizedTitle:"css常用代码",charIndex:3259},{level:3,title:"css实现强制不换行/自动换行/强制换行",slug:"css实现强制不换行-自动换行-强制换行",normalizedTitle:"css实现强制不换行/自动换行/强制换行",charIndex:3271},{level:3,title:"背景颜色渐变",slug:"背景颜色渐变",normalizedTitle:"背景颜色渐变",charIndex:4334},{level:2,title:"css代码例子",slug:"css代码例子",normalizedTitle:"css代码例子",charIndex:5590},{level:3,title:"less封装",slug:"less封装",normalizedTitle:"less封装",charIndex:5602},{level:3,title:"弧度",slug:"弧度",normalizedTitle:"弧度",charIndex:5996},{level:3,title:"卡卷",slug:"卡卷",normalizedTitle:"卡卷",charIndex:6346},{level:3,title:"隐藏文本的常用两种方法",slug:"隐藏文本的常用两种方法",normalizedTitle:"隐藏文本的常用两种方法",charIndex:7201},{level:3,title:"特殊形状（三角形/圆形）",slug:"特殊形状-三角形-圆形",normalizedTitle:"特殊形状（三角形/圆形）",charIndex:7712},{level:3,title:"隐藏滚动条或更改滚动条样式",slug:"隐藏滚动条或更改滚动条样式",normalizedTitle:"隐藏滚动条或更改滚动条样式",charIndex:8156},{level:3,title:"input使用技巧",slug:"input使用技巧",normalizedTitle:"input使用技巧",charIndex:9556},{level:3,title:"虚拟框/边框图片",slug:"虚拟框-边框图片",normalizedTitle:"虚拟框/边框图片",charIndex:11321},{level:3,title:"背景background",slug:"背景background",normalizedTitle:"背景background",charIndex:12722},{level:2,title:"css兼容问题记录",slug:"css兼容问题记录",normalizedTitle:"css兼容问题记录",charIndex:14102},{level:3,title:"justify-content: space-evenly兼容低版本实现方法",slug:"justify-content-space-evenly兼容低版本实现方法",normalizedTitle:"justify-content: space-evenly兼容低版本实现方法",charIndex:14116},{level:3,title:"移动端iPhone x 安全条的高度设置（css）",slug:"移动端iphone-x-安全条的高度设置-css",normalizedTitle:"移动端iphone x 安全条的高度设置（css）",charIndex:14375}],headersStr:"基本知识 盒子模型 复合选择器权重计算 margin的合并（margin天生就有bug） 页面布局的稳定性 清除浮动 元素的显示与隐藏 鼠标样式 文字阴影 盒子阴影 垂直对齐方式 Vertical-slign 过渡动画效果 关键帧动画 css常用代码 css实现强制不换行/自动换行/强制换行 背景颜色渐变 css代码例子 less封装 弧度 卡卷 隐藏文本的常用两种方法 特殊形状（三角形/圆形） 隐藏滚动条或更改滚动条样式 input使用技巧 虚拟框/边框图片 背景background css兼容问题记录 justify-content: space-evenly兼容低版本实现方法 移动端iPhone x 安全条的高度设置（css）",content:'# CSS\n\n\n# 基本知识\n\n\n# 盒子模型\n\n 1. 影响盒子大小的因素\n    \n    边框 boeder\n    \n    内边距 padding\n\n 2. 盒子大小的计算\n    \n    盒子的真实宽度=width+左右padding+左右border\n    \n    盒子的真实高度=height+上下padding+上下border\n\n\n# 复合选择器权重计算\n\n4个n算法 （n n n n）\n\n 1. 第一个n表示 !important 的个数；\n 2. 第二个n表示 id选择器 的个数；\n 3. 第三个n表示 类选择器 的个数；\n 4. 第四个n表示 标签选择器 的个数；\n\n\n# margin的合并（margin天生就有bug）\n\n针对的都是块级元素\n\n 1. margin的垂直合并\n 2. 两个盒子在垂直方向的同一段margin的距离，以大的为准\n 3. 解决方案：没有解决方法。在页面布局的时候可以完全避免的\n 4. margin的包含垂直合并\n    1. 解决方案1：给父盒子添加边框（不是特别推荐）；\n    2. 解决方案2：给父盒子设置overflow: hidden;\n\n\n# 页面布局的稳定性\n\n在布局页面的时候，考虑到页面的整体的稳定性，我们在使用盒子模型的时候，一定要特别注意\n\n 1. 优先使用width和height\n 2. 其次使用padding\n 3. 最后使用margin\n\n\n# 清除浮动\n\n 1. 清除浮动的本质\n    \n    消除浮动所带来的影响\n\n 2. 为什么要清除浮动\n    \n    浮动的元素脱标，不占标准流的位置，影响页面的整体布局效果\n\n 3. 如何清除浮动（清除浮动的方式）\n    \n    1. 非清除浮动的方式\n       \n       给浮动的父元素添加一个高度height（不推荐）\n    \n    2. 页面布局的一个重要的点\n       \n       在页面布局的时候，我们通常是定宽不定高\n    \n    3. 给浮动的元素的父元素添加一个属性\n       \n       Overflow: hidden; （不推荐）\n    \n    4. 额外标签法\n       \n       在浮动的元素的最后添加一个标签来清除浮动\n    \n    5. 两个重要的伪元素\n       \n       ::before  在……之前 \n       ::after   在……之后 \n       \n    \n    6. 伪元素清除浮动\n       \n       .clearfix::after {\n           content: \'.\'; /*这个点的额作用是为了更好的浏览兼容*/\n           display: block; /* 伪元素是行内元素，需要转化为块级元素 */\n           clear: both; /* 清除浮动的代码 */\n           visibility: hidden; /* 用来隐藏content中的这个内容的 */\n           height: 0; /* 我们不需要伪元素的高度，将高度设置为0 */\n           line-height: 0; /* 为了更好的浏览器的兼容 */\n       }\n       \n       .clearfix {\n           *zoom: 1; /* 为了解决IE6-7这两个版本的浏览器的兼容 */\n       }\n       \n    \n    7. 双伪元素清除浮动\n       \n       .clearfix::before,\n       .clearfix::after {\n           content: \'\';\n           display: table;\n       }\n       \n       .clearfix::after {\n           clear: both;\n       }\n       \n\n\n# 元素的显示与隐藏\n\n 1. 元素的隐藏\n    \n    1. visibility:hidden; | 隐藏元素，被隐藏的元素占位置   |\n       display:  none;    | 隐藏元素，被隐藏的元素不占位置 |\n       \n\n 2. 元素的显示\n    \n    1. visibility:visible; | 显示元素                                  \n       display:block;      | 显示元素，同时将元素的显示方式转换为block \n       \n\n\n# 鼠标样式\n\n代码                  样式说明\ncursor:text;        文本光标；\ncursor:pointer;     鼠标小手\ncursor:move;        移动光标\ncursor:crosshair;   十字光标\ncursor:default;     鼠标样式跟随操作系统鼠标样式\ncursor:help;        求助光标\ncursor:ne-resize;   \n\n\n# 文字阴影\n\nText-shadow: h-shadow v-shadow blur color;\n\n\n代码         说明\nh-shadow   阴影在Y轴的移动距离\nv-shadow   阴影在X轴移动的距离\nblur       阴影的模糊程度\ncolor      颜色\n\n\n# 盒子阴影\n\nbox-shadow: h-shadow v-shadow blur spread color inset;\n\n\n代码         说明\nh-shadow   阴影在Y轴的移动距离\nv-shadow   阴影在X轴移动的距离\nblur       阴影的模糊程度\ncolor      颜色\nspread     设置阴影的尺寸\ninset      将阴影设置为内阴影（盒子的阴影默认是外阴影，无需设置）\n\n\n# 垂直对齐方式 Vertical-slign\n\n垂直对齐方式的使用：\n\n代码                       说明\nvertical-align:top;      设置和文本的顶线对齐\nvertical_align:middle;   设置和文本的中线对齐\n\n提示\n\n垂直对齐方式对块级元素是无效的\n\n垂直对齐方式主要是用来设置图片或者行内块级元素一文本的垂直对齐方式。\n\n垂直对齐方式一般使用的时候都是用来设置图片或者表单元素与文本的垂直方式的对齐。\n\n\n# 过渡动画效果\n\n# 过渡动画使用：\n\n过度动画经常和:hover 一起使用。\n\ntransition: 过度的属性 过度的时间；\n\n\n注意事项\n\ntransition大部分情况下都添加到默认状态下，transition是一个复合属性。\n\n\n\n# 练习：手风琴下拉菜单\n\n\n\n\n# 关键帧动画\n\n关键帧动画分为两部分：\n\n# 定义动画效果\n\n@keyframes 动画名称 {\n\t0% {\t}\n\t100% {\t}\n}\n\n\n注意事项\n\n动画只定义，不调用是没有效果的。\n\n# 动画调用式\n\nanimation: 动画名称 动画时间；\n\n\n# animation调用式特殊值\n\nforwards\t结束状态停止\ninfinite\t无限次播放\nalternate\t反向运动\npaused\t\t暂停动画效果\nlinear\t\t线性匀速运动\n\n\n# animation 是一个复合属性，由8个子属性组成，可通过调式工具查看。\n\n\n\n# 调用动画-8个子属性翻译\n\n复合写法\n\n\n\n8个动画属性\n\n\n\n\n# css常用代码\n\n\n# css实现强制不换行/自动换行/强制换行\n\n# 1. 强制不换行\n\ndiv{\n    white-space:nowrap;\n}\n\n\ncss 强制不换行\n\ncss中强制不换行，文本不会换行，文本会在在同一行上继续，直到遇到 br 标签为止。\n\nwhite-space:nowrap;\n\n# 2. 自动换行\n\ndiv{\n    word-wrap: break-word;\n    word-break: normal;\n}\n\n\n# 3. 强制英文单词断行\n\ndiv{\n    word-break:break-all;\n}\n\n\n# 4. CSS设置不转行：\n\ndiv{\n    overflow:hidden;  /** 隐藏 **/ \n    white-space:normal;  /** 默认 **/ \n}\n\n\nwhite-space 值说明\n\npre 换行和其他空白字符都将受到保护\n\nnowrap 强制在同一行内显示所有文本，直到文本结束或者遭遇 br 对象\n\n# 5. 设置强行换行：\n\nword-break:\n\nnormal : 依照亚洲语言和非亚洲语言的文本规则，允许在字内换行\n\nbreak-all : 该行为与亚洲语言的normal相同。也允许非亚洲语言文本行的任意字内断开。该值适合包含一些非亚洲文本的亚洲文本\n\nkeep-all : 与所有非亚洲语言的normal相同。对于中文，韩文，日文，不允许字断开。适合包含少量亚洲文本的非亚洲文本与之间的高度解决办法\n\n英文不换行\n\nCSS里加上 word-break: break-all; 问题解决。这个问题只有IE才有，在FF下测试,FF可以自己加滚动条，这样也不影响效果\n\n建议大家做Skin时，记得在body里加 word-break: break-all; 这样可以解决IE的框架被英文撑开的问题\n\n以下引用word-break的说明, 注意word-break 是IE5+专有属性\n\n语法：\n\nword-break : normal | break-all | keep-all\n\n参数：\n\nnormal : 　依照亚洲语言和非亚洲语言的文本规则，允许在字内换行\n\nbreak-all : 　该行为与亚洲语言的normal相同。也允许非亚洲语言文本行的任意字内断开。该值适合包含一些非亚洲文本的亚洲文本\n\nkeep-all : 　与所有非亚洲语言的normal相同。对于中文，韩文，日文，不允许字断开。适合包含少量亚洲文本的非亚洲文本\n\n\n# 背景颜色渐变\n\n对角线渐变：\n\nbackground: linear-gradient(to top right, #f6f5f0, #fefefd);\n\n\n如果有多个颜色渐变，颜色的参数可以有多个：\n\nbackground: linear-gradient(to top right, #CDDC39, #8BC34A, #FFEB3B);\n\n\n可以指定颜色渐变的位置：\n\nbackground: linear-gradient(to top right, #CDDC39 0%, #8BC34A 25%, #FFEB3B 100%);\n\nbackground: radial-gradient(circle, #CDDC39, #8BC34A);\n\n\n第一个参数有两个值：circle正圆，ellipse椭圆。 默认从圆心向四周渐变。也可以用两个长度数字来表示圆形，比如50px 50px。有这样几种写法：\n\ncircle at center （或者left right）\n\ncircle at 50% （这个百分比数字可以改成任意想要的位置）\n\ncircle farthest-corner （或者其他3个值。）\n\nbackground-image: -webkit-gradient(linear, left 0, right 0, from(rgb(4, 94, 170)), to(rgb(1, 152, 216)));\n\nlist-style-image: -webkit-gradient(linear, left 0, right 0, from(rgb(4, 94, 170)), to(rgb(1, 152, 216)));\n\n\n文字颜色渐变比较麻烦，并且兼容性差强人意：\n\nbackground-image: -webkit-gradient(linear, left 0, right 0, from(rgb(4, 94, 170)), to(rgb(1, 152, 216)));\n-webkit-background-clip: text; /*必需加前缀 -webkit- 才支持这个text值 */\n-webkit-text-fill-color: transparent; /*text-fill-color会覆盖color所定义的字体颜色： */\n\n\ntext-fill-color，IE果然又不兼容。移动端UC浏览器也不兼容。\n\n-webkit-background-clip: text; 非正式属性，目前（2017-07-07）仅仅FF、Chrome、Safari支持，并且必须带前缀。\n\n所以，如果您的目标用户很有可能会用IE浏览器，那么，就需要再写一个IE下能正常浏览的代码：\n\n\x3c!--[if IE]>\n<h2>IE才能看见我</h2>\n<img src="images/text-gradient.png" alt="">\n<![endif]--\x3e\n\n\n\n# css代码例子\n\n\n# less封装\n\n@bgc-white:#fff;\n@fontSize-white:30px;\n@color-white:#000;\n\n@bgc-black:#000;\n@fontSize-black:35px;\n@color-black:#fff;\n\n.whiteModule(@value){\n    @bgc:\'bgc-@{value}\';\n    @fontSize:\'fontSize-@{value}\';\n    @color:\'color-@{value}\';\n    background-color:@@bgc;\n    font-size:@@fontSize;\n    color:@@color;\n}\n\n.white {\n    .whiteModule(\'white\')\n}\n\n.black  {\n    .whiteModule(\'black\')\n}\n\n\n\n# 弧度\n\n.pure_top {\n    width: 100%;\n    height: 100px;\n    position: relative;\n    z-index: 0;\n    overflow: hidden;\n}\n\n.pure_top::after {\n    content: \'\';\n    width: 120%;\n    height: 100px;\n    position: absolute;\n    left: -10%;     //椭圆左边隐藏10%，右边隐藏10%\n    top: 0;\n    border-radius: 0 0 50% 50%;  //左上角，右上角，右下角，左下角\n    background: #1496f1;\n}\n\n\n\n\n\n# 卡卷\n\n<p class="coupon">\n    <span>200</span>优惠券\n</p>\n\n\n.coupon {\n    width: 300px;\n    height: 100px;\n    line-height: 100px;\n    margin: 50px auto;\n    text-align: center;\n    position: relative;\n    background: radial-gradient(circle at right bottom, transparent 10px, #ffffff 0) top right /50% 51px no-repeat,\n        radial-gradient(circle at left bottom, transparent 10px, #ffffff 0) top left / 50% 51px no-repeat,\n        radial-gradient(circle at right top, transparent 10px, #ffffff 0) bottom right / 50% 51px no-repeat,\n        radial-gradient(circle at left top, transparent 10px, #ffffff 0) bottom left / 50% 51px no-repeat;\n    filter: drop-shadow(2px 2px 2px rgba(0, 0, 0, .2));\n}\n.coupon span {\n    display: inline-block;\n    vertical-align: middle;\n    margin-right: 10px;\n    color: red;\n    font-size: 50px;\n    font-weight: 400;\n}\n\n\n\n\n\n# 隐藏文本的常用两种方法\n\n/* text-indent: -9999px; 或者 font-size: 0; */\n.logo {\n    width: 190px;\n    height: 80px;\n    float: left;\n    margin-top: 8px\n}\n\n.logo h1 {\n    position: relative\n}\n\n.logo h1 .logo-bd {\n    display: block;\n    margin-left: 22px;\n    padding-top: 58px;\n    width: 142px;\n    overflow: hidden;\n    background: url(http://img.alicdn.com/tfs/TB1_uT8a5ERMeJjSspiXXbZLFXa-143-59.png) 0 0 no-repeat;\n    text-indent: -9999px;\n}\n\n\n\n<h1>\n  <a href="#" role="img" class="logo-bd clearfix">淘宝网</a>\n</h1>\n\n\n\n# 特殊形状（三角形/圆形）\n\n/* 正三角 */\n.up-triangle {\n   width: 0;\n   height: 0;\n   border-style: solid;\n   border-width: 0 25px 40px 25px;\n   border-color: transparent transparent rgb(245, 129, 127) transparent;\n }\n \n /* 倒三角 */\n .down-triangle {\n   width: 0;\n   height: 0;\n   border-style: solid;\n   border-width: 40px 25px 0 25px;\n   border-color:  rgb(245, 129, 127) transparent transparent transparent;\n }\n div:last-child {\n   margin-top: 1rem;\n }\n\n\n\n\n\n# 隐藏滚动条或更改滚动条样式\n\n.scroll-container {\n   width: 500px;\n   height: 150px;\n   border: 1px solid #ddd;\n   padding: 15px;\n   overflow: auto;     /*必须*/\n }\n \n .scroll-container::-webkit-scrollbar {\n   width: 8px;\n   background: white;\n }\n \n .scroll-container::-webkit-scrollbar-corner,\n   /* 滚动条角落 */\n .scroll-container::-webkit-scrollbar-thumb,\n .scroll-container::-webkit-scrollbar-track {      /*滚动条的轨道*/\n   border-radius: 4px;\n }\n \n .scroll-container::-webkit-scrollbar-corner,\n .scroll-container::-webkit-scrollbar-track {\n   /* 滚动条轨道 */\n   background-color: rgba(180, 160, 120, 0.1);\n   box-shadow: inset 0 0 1px rgba(180, 160, 120, 0.5);\n }\n \n .scroll-container::-webkit-scrollbar-thumb {\n   /* 滚动条手柄 */\n   background-color: #00adb5;\n }\n\n\n<p class="scroll-container">\n    庭院深深，不知有多深？杨柳依依，飞扬起片片烟雾，一重重帘幕不知有多少层。豪华的车马停在贵族公子寻欢作乐的地方，她登楼向远处望去，却看不见那通向章台的大路。春已至暮，三月的雨伴随着狂风大作，再是重门将黄昏景色掩闭，也无法留住春意。泪眼汪汪问落花可知道我的心意，落花默默不语，纷乱的，零零落落一点一点飞到秋千外。庭院深深，不知有多深？杨柳依依，飞扬起片片烟雾，一重重帘幕不知有多少层。豪华的车马停在贵族公子寻欢作乐的地方，她登楼向远处望去，却看不见那通向章台的大路。春已至暮，三月的雨伴随着狂风大作，再是重门将黄昏景色掩闭，也无法留住春意。泪眼汪汪问落花可知道我的心意，落花默默不语，纷乱的，零零落落一点一点飞到秋千外。庭院深深，不知有多深？杨柳依依，飞扬起片片烟雾，一重重帘幕不知有多少层。豪华的车马停在贵族公子寻欢作乐的地方，她登楼向远处望去，却看不见那通向章台的大路。春已至暮，三月的雨伴随着狂风大作，再是重门将黄昏景色掩闭，也无法留住春意。泪眼汪汪问落花可知道我的心意，落花默默不语，纷乱的，零零落落一点一点飞到秋千外。庭院深深，不知有多深？杨柳依依，飞扬起片片烟雾，一重重帘幕不知有多少层。豪华的车马停在贵族公子寻欢作乐的地方，她登楼向远处望去，却看不见那通向章台的大路。春已至暮，三月的雨伴随着狂风大作，再是重门将黄昏景色掩闭，也无法留住春意。泪眼汪汪问落花可知道我的心意，落花默默不语，纷乱的，零零落落一点一点飞到秋千外。\n</p>\n\n\n\n\n\n# input使用技巧\n\n# 设置input 的placeholder的字体样式\n\n/* 设置input占位符的样式 */\ninput::-webkit-input-placeholder {    /* Chrome/Opera/Safari */\n    color: red;\n}\ninput::-moz-placeholder { /* Firefox 19+ */  \n    color: red;\n}\ninput:-ms-input-placeholder { /* IE 10+ */\n    color: red;\n}\ninput:-moz-placeholder { /* Firefox 18- */\n    color: red;\n}\n\n\n<input type="text" placeholder="请设置用户名">\n\n\n设置input聚焦时的样式\n\ninput:focus {   \n  background-color: red;\n}\n\n\n取消input的边框 border: none; outline: none;\n\n例子：\n\n<!DOCTYPE html>\n<html lang="en">\n    <head>\n        <meta charset="UTF-8">\n        <title>CSS高级常见技巧汇总</title>\n        <style type="text/css">\n            input::-webkit-input-placeholder {    /* Chrome/Opera/Safari */\n                color: red;\n            }\n            input::-moz-placeholder { /* Firefox 19+ */\n                color: red;\n            }\n            input:-ms-input-placeholder { /* IE 10+ */\n                color: red;\n            }\n            input:-moz-placeholder { /* Firefox 18- */\n                color: red;\n            }\n            input:focus {\n                background-color: red;\n            }\n            input{\n                border: none;\n                outline: none;\n            }\n        </style>\n    </head>\n    <body>\n        <input type="text" placeholder="请设置用户名">\n    </body>\n</html>\n\n\n\n\n# outline属性的妙用技巧\n\n区别: outline不计算大小 border计算大小\n\n* {\n    padding: 0;\n    margin: 0;\n}\nul {\n    list-style: none;\n    width: 600px;\n    margin: auto;\n}\nli {\n    padding: 10px;\n    border: 10px solid pink;\n    outline-offset: -10px;\n}\nli+li{\n    margin-top:-10px;\n}\nli:hover{\n    /* border:10px solid gold; */\n    outline:10px solid gold;\n}\n\n\n<ul>\n    <li>1</li>\n    <li>2</li>\n    <li>3</li>\n    <li>4</li>\n    <li>5</li>\n    <li>6</li>\n</ul>\n\n\n\n\n\n# 虚拟框/边框图片\n\n# 虚线框绘制技巧\n\n.dotted-line {\n  width: 800px;\n  margin: auto;\n  padding: 20px;\n  border: 1px dashed transparent;\n  background: linear-gradient(white, white) padding-box, repeating-linear-gradient(-45deg, red 0, #ccc .25em, white 0, white .75em);\n}\n\n\n<p class="dotted-line">庭院深深，不知有多深？杨柳依依，飞扬起片片烟雾，一重重帘幕不知有多少层。</p>\n\n\n\n\n# 边框图片\n\ndiv{\n    border-image:url(border.png) 30 30 round;\n    -webkit-border-image:url(border.png) 30 30 round; /* Safari 5 and older */\n    -o-border-image:url(border.png) 30 30 round; /* Opera */\n}\n\n\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset="utf-8"> \n        <title>菜鸟教程(runoob.com)</title> \n        <style> \n            div\n            {\n                border:15px solid transparent;\n                width:250px;\n                padding:10px 20px;\n            }\n\n            #round\n            {\n                -webkit-border-image:url(border.png) 30 30 round; /* Safari 5 and older */\n                -o-border-image:url(border.png) 30 30 round; /* Opera */\n                border-image:url(border.png) 30 30 round;\n            }\n\n            #stretch\n            {\n                -webkit-border-image:url(border.png) 30 30 stretch; /* Safari 5 and older */\n                -o-border-image:url(border.png) 30 30 stretch; /* Opera */\n                border-image:url(border.png) 30 30 stretch;\n            }\n        </style>\n    </head>\n    <body>\n\n\n\n\n\n# 背景background\n\n# background-origin\n\n\n\n例子：\n\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset="utf-8"> \n        <title>菜鸟教程(runoob.com)</title>\n        <style> \n            div\n            {\n                border:1px solid black;\n                padding:35px;\n                background-image:url(\'smiley.gif\');\n                background-repeat:no-repeat;\n                background-position:left;\n            }\n            #div1\n            {\n                background-origin:border-box;\n            }\n            #div2\n            {\n                background-origin:content-box;\n            }\n        </style>\n    </head>\n    <body>\n\n        <p>背景图像边界框的相对位置：</p>\n        <div id="div1">\n            Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat. Ut wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat.\n        </div>\n\n        <p>背景图像的相对位置的内容框：</p>\n        <div id="div2">\n            Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat. Ut wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat.\n        </div>\n\n    </body>\n</html>\n\n\n\n\n\n# css兼容问题记录\n\n\n# justify-content: space-evenly兼容低版本实现方法\n\ndiv {\n    display: flex;\n    justify-content: space-between;\n\n    &:before,\n    &:after {\n        content: \'\';\n        display: block;\n    }\n}\n// 相当于\ndiv {\n    display: flex;\n    justify-content: space-evenly;\n}\n\n\n\n\n\n# 移动端iPhone x 安全条的高度设置（css）\n\npadding-bottom: constant(safe-area-inset-bottom);///兼容 IOS<11.2/\n\npadding-bottom: env(safe-area-inset-bottom);///兼容 IOS>11.2/\n\n\n注意\n\nconstant与env顺序不能改变，先constant再env',normalizedContent:'# css\n\n\n# 基本知识\n\n\n# 盒子模型\n\n 1. 影响盒子大小的因素\n    \n    边框 boeder\n    \n    内边距 padding\n\n 2. 盒子大小的计算\n    \n    盒子的真实宽度=width+左右padding+左右border\n    \n    盒子的真实高度=height+上下padding+上下border\n\n\n# 复合选择器权重计算\n\n4个n算法 （n n n n）\n\n 1. 第一个n表示 !important 的个数；\n 2. 第二个n表示 id选择器 的个数；\n 3. 第三个n表示 类选择器 的个数；\n 4. 第四个n表示 标签选择器 的个数；\n\n\n# margin的合并（margin天生就有bug）\n\n针对的都是块级元素\n\n 1. margin的垂直合并\n 2. 两个盒子在垂直方向的同一段margin的距离，以大的为准\n 3. 解决方案：没有解决方法。在页面布局的时候可以完全避免的\n 4. margin的包含垂直合并\n    1. 解决方案1：给父盒子添加边框（不是特别推荐）；\n    2. 解决方案2：给父盒子设置overflow: hidden;\n\n\n# 页面布局的稳定性\n\n在布局页面的时候，考虑到页面的整体的稳定性，我们在使用盒子模型的时候，一定要特别注意\n\n 1. 优先使用width和height\n 2. 其次使用padding\n 3. 最后使用margin\n\n\n# 清除浮动\n\n 1. 清除浮动的本质\n    \n    消除浮动所带来的影响\n\n 2. 为什么要清除浮动\n    \n    浮动的元素脱标，不占标准流的位置，影响页面的整体布局效果\n\n 3. 如何清除浮动（清除浮动的方式）\n    \n    1. 非清除浮动的方式\n       \n       给浮动的父元素添加一个高度height（不推荐）\n    \n    2. 页面布局的一个重要的点\n       \n       在页面布局的时候，我们通常是定宽不定高\n    \n    3. 给浮动的元素的父元素添加一个属性\n       \n       overflow: hidden; （不推荐）\n    \n    4. 额外标签法\n       \n       在浮动的元素的最后添加一个标签来清除浮动\n    \n    5. 两个重要的伪元素\n       \n       ::before  在……之前 \n       ::after   在……之后 \n       \n    \n    6. 伪元素清除浮动\n       \n       .clearfix::after {\n           content: \'.\'; /*这个点的额作用是为了更好的浏览兼容*/\n           display: block; /* 伪元素是行内元素，需要转化为块级元素 */\n           clear: both; /* 清除浮动的代码 */\n           visibility: hidden; /* 用来隐藏content中的这个内容的 */\n           height: 0; /* 我们不需要伪元素的高度，将高度设置为0 */\n           line-height: 0; /* 为了更好的浏览器的兼容 */\n       }\n       \n       .clearfix {\n           *zoom: 1; /* 为了解决ie6-7这两个版本的浏览器的兼容 */\n       }\n       \n    \n    7. 双伪元素清除浮动\n       \n       .clearfix::before,\n       .clearfix::after {\n           content: \'\';\n           display: table;\n       }\n       \n       .clearfix::after {\n           clear: both;\n       }\n       \n\n\n# 元素的显示与隐藏\n\n 1. 元素的隐藏\n    \n    1. visibility:hidden; | 隐藏元素，被隐藏的元素占位置   |\n       display:  none;    | 隐藏元素，被隐藏的元素不占位置 |\n       \n\n 2. 元素的显示\n    \n    1. visibility:visible; | 显示元素                                  \n       display:block;      | 显示元素，同时将元素的显示方式转换为block \n       \n\n\n# 鼠标样式\n\n代码                  样式说明\ncursor:text;        文本光标；\ncursor:pointer;     鼠标小手\ncursor:move;        移动光标\ncursor:crosshair;   十字光标\ncursor:default;     鼠标样式跟随操作系统鼠标样式\ncursor:help;        求助光标\ncursor:ne-resize;   \n\n\n# 文字阴影\n\ntext-shadow: h-shadow v-shadow blur color;\n\n\n代码         说明\nh-shadow   阴影在y轴的移动距离\nv-shadow   阴影在x轴移动的距离\nblur       阴影的模糊程度\ncolor      颜色\n\n\n# 盒子阴影\n\nbox-shadow: h-shadow v-shadow blur spread color inset;\n\n\n代码         说明\nh-shadow   阴影在y轴的移动距离\nv-shadow   阴影在x轴移动的距离\nblur       阴影的模糊程度\ncolor      颜色\nspread     设置阴影的尺寸\ninset      将阴影设置为内阴影（盒子的阴影默认是外阴影，无需设置）\n\n\n# 垂直对齐方式 vertical-slign\n\n垂直对齐方式的使用：\n\n代码                       说明\nvertical-align:top;      设置和文本的顶线对齐\nvertical_align:middle;   设置和文本的中线对齐\n\n提示\n\n垂直对齐方式对块级元素是无效的\n\n垂直对齐方式主要是用来设置图片或者行内块级元素一文本的垂直对齐方式。\n\n垂直对齐方式一般使用的时候都是用来设置图片或者表单元素与文本的垂直方式的对齐。\n\n\n# 过渡动画效果\n\n# 过渡动画使用：\n\n过度动画经常和:hover 一起使用。\n\ntransition: 过度的属性 过度的时间；\n\n\n注意事项\n\ntransition大部分情况下都添加到默认状态下，transition是一个复合属性。\n\n\n\n# 练习：手风琴下拉菜单\n\n\n\n\n# 关键帧动画\n\n关键帧动画分为两部分：\n\n# 定义动画效果\n\n@keyframes 动画名称 {\n\t0% {\t}\n\t100% {\t}\n}\n\n\n注意事项\n\n动画只定义，不调用是没有效果的。\n\n# 动画调用式\n\nanimation: 动画名称 动画时间；\n\n\n# animation调用式特殊值\n\nforwards\t结束状态停止\ninfinite\t无限次播放\nalternate\t反向运动\npaused\t\t暂停动画效果\nlinear\t\t线性匀速运动\n\n\n# animation 是一个复合属性，由8个子属性组成，可通过调式工具查看。\n\n\n\n# 调用动画-8个子属性翻译\n\n复合写法\n\n\n\n8个动画属性\n\n\n\n\n# css常用代码\n\n\n# css实现强制不换行/自动换行/强制换行\n\n# 1. 强制不换行\n\ndiv{\n    white-space:nowrap;\n}\n\n\ncss 强制不换行\n\ncss中强制不换行，文本不会换行，文本会在在同一行上继续，直到遇到 br 标签为止。\n\nwhite-space:nowrap;\n\n# 2. 自动换行\n\ndiv{\n    word-wrap: break-word;\n    word-break: normal;\n}\n\n\n# 3. 强制英文单词断行\n\ndiv{\n    word-break:break-all;\n}\n\n\n# 4. css设置不转行：\n\ndiv{\n    overflow:hidden;  /** 隐藏 **/ \n    white-space:normal;  /** 默认 **/ \n}\n\n\nwhite-space 值说明\n\npre 换行和其他空白字符都将受到保护\n\nnowrap 强制在同一行内显示所有文本，直到文本结束或者遭遇 br 对象\n\n# 5. 设置强行换行：\n\nword-break:\n\nnormal : 依照亚洲语言和非亚洲语言的文本规则，允许在字内换行\n\nbreak-all : 该行为与亚洲语言的normal相同。也允许非亚洲语言文本行的任意字内断开。该值适合包含一些非亚洲文本的亚洲文本\n\nkeep-all : 与所有非亚洲语言的normal相同。对于中文，韩文，日文，不允许字断开。适合包含少量亚洲文本的非亚洲文本与之间的高度解决办法\n\n英文不换行\n\ncss里加上 word-break: break-all; 问题解决。这个问题只有ie才有，在ff下测试,ff可以自己加滚动条，这样也不影响效果\n\n建议大家做skin时，记得在body里加 word-break: break-all; 这样可以解决ie的框架被英文撑开的问题\n\n以下引用word-break的说明, 注意word-break 是ie5+专有属性\n\n语法：\n\nword-break : normal | break-all | keep-all\n\n参数：\n\nnormal : 　依照亚洲语言和非亚洲语言的文本规则，允许在字内换行\n\nbreak-all : 　该行为与亚洲语言的normal相同。也允许非亚洲语言文本行的任意字内断开。该值适合包含一些非亚洲文本的亚洲文本\n\nkeep-all : 　与所有非亚洲语言的normal相同。对于中文，韩文，日文，不允许字断开。适合包含少量亚洲文本的非亚洲文本\n\n\n# 背景颜色渐变\n\n对角线渐变：\n\nbackground: linear-gradient(to top right, #f6f5f0, #fefefd);\n\n\n如果有多个颜色渐变，颜色的参数可以有多个：\n\nbackground: linear-gradient(to top right, #cddc39, #8bc34a, #ffeb3b);\n\n\n可以指定颜色渐变的位置：\n\nbackground: linear-gradient(to top right, #cddc39 0%, #8bc34a 25%, #ffeb3b 100%);\n\nbackground: radial-gradient(circle, #cddc39, #8bc34a);\n\n\n第一个参数有两个值：circle正圆，ellipse椭圆。 默认从圆心向四周渐变。也可以用两个长度数字来表示圆形，比如50px 50px。有这样几种写法：\n\ncircle at center （或者left right）\n\ncircle at 50% （这个百分比数字可以改成任意想要的位置）\n\ncircle farthest-corner （或者其他3个值。）\n\nbackground-image: -webkit-gradient(linear, left 0, right 0, from(rgb(4, 94, 170)), to(rgb(1, 152, 216)));\n\nlist-style-image: -webkit-gradient(linear, left 0, right 0, from(rgb(4, 94, 170)), to(rgb(1, 152, 216)));\n\n\n文字颜色渐变比较麻烦，并且兼容性差强人意：\n\nbackground-image: -webkit-gradient(linear, left 0, right 0, from(rgb(4, 94, 170)), to(rgb(1, 152, 216)));\n-webkit-background-clip: text; /*必需加前缀 -webkit- 才支持这个text值 */\n-webkit-text-fill-color: transparent; /*text-fill-color会覆盖color所定义的字体颜色： */\n\n\ntext-fill-color，ie果然又不兼容。移动端uc浏览器也不兼容。\n\n-webkit-background-clip: text; 非正式属性，目前（2017-07-07）仅仅ff、chrome、safari支持，并且必须带前缀。\n\n所以，如果您的目标用户很有可能会用ie浏览器，那么，就需要再写一个ie下能正常浏览的代码：\n\n\x3c!--[if ie]>\n<h2>ie才能看见我</h2>\n<img src="images/text-gradient.png" alt="">\n<![endif]--\x3e\n\n\n\n# css代码例子\n\n\n# less封装\n\n@bgc-white:#fff;\n@fontsize-white:30px;\n@color-white:#000;\n\n@bgc-black:#000;\n@fontsize-black:35px;\n@color-black:#fff;\n\n.whitemodule(@value){\n    @bgc:\'bgc-@{value}\';\n    @fontsize:\'fontsize-@{value}\';\n    @color:\'color-@{value}\';\n    background-color:@@bgc;\n    font-size:@@fontsize;\n    color:@@color;\n}\n\n.white {\n    .whitemodule(\'white\')\n}\n\n.black  {\n    .whitemodule(\'black\')\n}\n\n\n\n# 弧度\n\n.pure_top {\n    width: 100%;\n    height: 100px;\n    position: relative;\n    z-index: 0;\n    overflow: hidden;\n}\n\n.pure_top::after {\n    content: \'\';\n    width: 120%;\n    height: 100px;\n    position: absolute;\n    left: -10%;     //椭圆左边隐藏10%，右边隐藏10%\n    top: 0;\n    border-radius: 0 0 50% 50%;  //左上角，右上角，右下角，左下角\n    background: #1496f1;\n}\n\n\n\n\n\n# 卡卷\n\n<p class="coupon">\n    <span>200</span>优惠券\n</p>\n\n\n.coupon {\n    width: 300px;\n    height: 100px;\n    line-height: 100px;\n    margin: 50px auto;\n    text-align: center;\n    position: relative;\n    background: radial-gradient(circle at right bottom, transparent 10px, #ffffff 0) top right /50% 51px no-repeat,\n        radial-gradient(circle at left bottom, transparent 10px, #ffffff 0) top left / 50% 51px no-repeat,\n        radial-gradient(circle at right top, transparent 10px, #ffffff 0) bottom right / 50% 51px no-repeat,\n        radial-gradient(circle at left top, transparent 10px, #ffffff 0) bottom left / 50% 51px no-repeat;\n    filter: drop-shadow(2px 2px 2px rgba(0, 0, 0, .2));\n}\n.coupon span {\n    display: inline-block;\n    vertical-align: middle;\n    margin-right: 10px;\n    color: red;\n    font-size: 50px;\n    font-weight: 400;\n}\n\n\n\n\n\n# 隐藏文本的常用两种方法\n\n/* text-indent: -9999px; 或者 font-size: 0; */\n.logo {\n    width: 190px;\n    height: 80px;\n    float: left;\n    margin-top: 8px\n}\n\n.logo h1 {\n    position: relative\n}\n\n.logo h1 .logo-bd {\n    display: block;\n    margin-left: 22px;\n    padding-top: 58px;\n    width: 142px;\n    overflow: hidden;\n    background: url(http://img.alicdn.com/tfs/tb1_ut8a5ermejjsspixxbzlfxa-143-59.png) 0 0 no-repeat;\n    text-indent: -9999px;\n}\n\n\n\n<h1>\n  <a href="#" role="img" class="logo-bd clearfix">淘宝网</a>\n</h1>\n\n\n\n# 特殊形状（三角形/圆形）\n\n/* 正三角 */\n.up-triangle {\n   width: 0;\n   height: 0;\n   border-style: solid;\n   border-width: 0 25px 40px 25px;\n   border-color: transparent transparent rgb(245, 129, 127) transparent;\n }\n \n /* 倒三角 */\n .down-triangle {\n   width: 0;\n   height: 0;\n   border-style: solid;\n   border-width: 40px 25px 0 25px;\n   border-color:  rgb(245, 129, 127) transparent transparent transparent;\n }\n div:last-child {\n   margin-top: 1rem;\n }\n\n\n\n\n\n# 隐藏滚动条或更改滚动条样式\n\n.scroll-container {\n   width: 500px;\n   height: 150px;\n   border: 1px solid #ddd;\n   padding: 15px;\n   overflow: auto;     /*必须*/\n }\n \n .scroll-container::-webkit-scrollbar {\n   width: 8px;\n   background: white;\n }\n \n .scroll-container::-webkit-scrollbar-corner,\n   /* 滚动条角落 */\n .scroll-container::-webkit-scrollbar-thumb,\n .scroll-container::-webkit-scrollbar-track {      /*滚动条的轨道*/\n   border-radius: 4px;\n }\n \n .scroll-container::-webkit-scrollbar-corner,\n .scroll-container::-webkit-scrollbar-track {\n   /* 滚动条轨道 */\n   background-color: rgba(180, 160, 120, 0.1);\n   box-shadow: inset 0 0 1px rgba(180, 160, 120, 0.5);\n }\n \n .scroll-container::-webkit-scrollbar-thumb {\n   /* 滚动条手柄 */\n   background-color: #00adb5;\n }\n\n\n<p class="scroll-container">\n    庭院深深，不知有多深？杨柳依依，飞扬起片片烟雾，一重重帘幕不知有多少层。豪华的车马停在贵族公子寻欢作乐的地方，她登楼向远处望去，却看不见那通向章台的大路。春已至暮，三月的雨伴随着狂风大作，再是重门将黄昏景色掩闭，也无法留住春意。泪眼汪汪问落花可知道我的心意，落花默默不语，纷乱的，零零落落一点一点飞到秋千外。庭院深深，不知有多深？杨柳依依，飞扬起片片烟雾，一重重帘幕不知有多少层。豪华的车马停在贵族公子寻欢作乐的地方，她登楼向远处望去，却看不见那通向章台的大路。春已至暮，三月的雨伴随着狂风大作，再是重门将黄昏景色掩闭，也无法留住春意。泪眼汪汪问落花可知道我的心意，落花默默不语，纷乱的，零零落落一点一点飞到秋千外。庭院深深，不知有多深？杨柳依依，飞扬起片片烟雾，一重重帘幕不知有多少层。豪华的车马停在贵族公子寻欢作乐的地方，她登楼向远处望去，却看不见那通向章台的大路。春已至暮，三月的雨伴随着狂风大作，再是重门将黄昏景色掩闭，也无法留住春意。泪眼汪汪问落花可知道我的心意，落花默默不语，纷乱的，零零落落一点一点飞到秋千外。庭院深深，不知有多深？杨柳依依，飞扬起片片烟雾，一重重帘幕不知有多少层。豪华的车马停在贵族公子寻欢作乐的地方，她登楼向远处望去，却看不见那通向章台的大路。春已至暮，三月的雨伴随着狂风大作，再是重门将黄昏景色掩闭，也无法留住春意。泪眼汪汪问落花可知道我的心意，落花默默不语，纷乱的，零零落落一点一点飞到秋千外。\n</p>\n\n\n\n\n\n# input使用技巧\n\n# 设置input 的placeholder的字体样式\n\n/* 设置input占位符的样式 */\ninput::-webkit-input-placeholder {    /* chrome/opera/safari */\n    color: red;\n}\ninput::-moz-placeholder { /* firefox 19+ */  \n    color: red;\n}\ninput:-ms-input-placeholder { /* ie 10+ */\n    color: red;\n}\ninput:-moz-placeholder { /* firefox 18- */\n    color: red;\n}\n\n\n<input type="text" placeholder="请设置用户名">\n\n\n设置input聚焦时的样式\n\ninput:focus {   \n  background-color: red;\n}\n\n\n取消input的边框 border: none; outline: none;\n\n例子：\n\n<!doctype html>\n<html lang="en">\n    <head>\n        <meta charset="utf-8">\n        <title>css高级常见技巧汇总</title>\n        <style type="text/css">\n            input::-webkit-input-placeholder {    /* chrome/opera/safari */\n                color: red;\n            }\n            input::-moz-placeholder { /* firefox 19+ */\n                color: red;\n            }\n            input:-ms-input-placeholder { /* ie 10+ */\n                color: red;\n            }\n            input:-moz-placeholder { /* firefox 18- */\n                color: red;\n            }\n            input:focus {\n                background-color: red;\n            }\n            input{\n                border: none;\n                outline: none;\n            }\n        </style>\n    </head>\n    <body>\n        <input type="text" placeholder="请设置用户名">\n    </body>\n</html>\n\n\n\n\n# outline属性的妙用技巧\n\n区别: outline不计算大小 border计算大小\n\n* {\n    padding: 0;\n    margin: 0;\n}\nul {\n    list-style: none;\n    width: 600px;\n    margin: auto;\n}\nli {\n    padding: 10px;\n    border: 10px solid pink;\n    outline-offset: -10px;\n}\nli+li{\n    margin-top:-10px;\n}\nli:hover{\n    /* border:10px solid gold; */\n    outline:10px solid gold;\n}\n\n\n<ul>\n    <li>1</li>\n    <li>2</li>\n    <li>3</li>\n    <li>4</li>\n    <li>5</li>\n    <li>6</li>\n</ul>\n\n\n\n\n\n# 虚拟框/边框图片\n\n# 虚线框绘制技巧\n\n.dotted-line {\n  width: 800px;\n  margin: auto;\n  padding: 20px;\n  border: 1px dashed transparent;\n  background: linear-gradient(white, white) padding-box, repeating-linear-gradient(-45deg, red 0, #ccc .25em, white 0, white .75em);\n}\n\n\n<p class="dotted-line">庭院深深，不知有多深？杨柳依依，飞扬起片片烟雾，一重重帘幕不知有多少层。</p>\n\n\n\n\n# 边框图片\n\ndiv{\n    border-image:url(border.png) 30 30 round;\n    -webkit-border-image:url(border.png) 30 30 round; /* safari 5 and older */\n    -o-border-image:url(border.png) 30 30 round; /* opera */\n}\n\n\n<!doctype html>\n<html>\n    <head>\n        <meta charset="utf-8"> \n        <title>菜鸟教程(runoob.com)</title> \n        <style> \n            div\n            {\n                border:15px solid transparent;\n                width:250px;\n                padding:10px 20px;\n            }\n\n            #round\n            {\n                -webkit-border-image:url(border.png) 30 30 round; /* safari 5 and older */\n                -o-border-image:url(border.png) 30 30 round; /* opera */\n                border-image:url(border.png) 30 30 round;\n            }\n\n            #stretch\n            {\n                -webkit-border-image:url(border.png) 30 30 stretch; /* safari 5 and older */\n                -o-border-image:url(border.png) 30 30 stretch; /* opera */\n                border-image:url(border.png) 30 30 stretch;\n            }\n        </style>\n    </head>\n    <body>\n\n\n\n\n\n# 背景background\n\n# background-origin\n\n\n\n例子：\n\n<!doctype html>\n<html>\n    <head>\n        <meta charset="utf-8"> \n        <title>菜鸟教程(runoob.com)</title>\n        <style> \n            div\n            {\n                border:1px solid black;\n                padding:35px;\n                background-image:url(\'smiley.gif\');\n                background-repeat:no-repeat;\n                background-position:left;\n            }\n            #div1\n            {\n                background-origin:border-box;\n            }\n            #div2\n            {\n                background-origin:content-box;\n            }\n        </style>\n    </head>\n    <body>\n\n        <p>背景图像边界框的相对位置：</p>\n        <div id="div1">\n            lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat. ut wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat.\n        </div>\n\n        <p>背景图像的相对位置的内容框：</p>\n        <div id="div2">\n            lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat. ut wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat.\n        </div>\n\n    </body>\n</html>\n\n\n\n\n\n# css兼容问题记录\n\n\n# justify-content: space-evenly兼容低版本实现方法\n\ndiv {\n    display: flex;\n    justify-content: space-between;\n\n    &:before,\n    &:after {\n        content: \'\';\n        display: block;\n    }\n}\n// 相当于\ndiv {\n    display: flex;\n    justify-content: space-evenly;\n}\n\n\n\n\n\n# 移动端iphone x 安全条的高度设置（css）\n\npadding-bottom: constant(safe-area-inset-bottom);///兼容 ios<11.2/\n\npadding-bottom: env(safe-area-inset-bottom);///兼容 ios>11.2/\n\n\n注意\n\nconstant与env顺序不能改变，先constant再env',charsets:{cjk:!0}},{title:"html",frontmatter:{},regularPath:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/htmlBase.html",relativePath:"前端问题/前端基础/htmlBase.md",key:"v-a4934214",path:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/htmlBase.html",headers:[{level:2,title:"html的介绍",slug:"html的介绍",normalizedTitle:"html的介绍",charIndex:11},{level:2,title:"html的标签",slug:"html的标签",normalizedTitle:"html的标签",charIndex:181},{level:2,title:"html的超链接",slug:"html的超链接",normalizedTitle:"html的超链接",charIndex:1266},{level:2,title:"html的列表",slug:"html的列表",normalizedTitle:"html的列表",charIndex:1532},{level:2,title:"html的表格",slug:"html的表格",normalizedTitle:"html的表格",charIndex:2074},{level:2,title:"html的表单",slug:"html的表单",normalizedTitle:"html的表单",charIndex:2520},{level:2,title:"input的快捷使用",slug:"input的快捷使用",normalizedTitle:"input的快捷使用",charIndex:5636}],headersStr:"html的介绍 html的标签 html的超链接 html的列表 html的表格 html的表单 input的快捷使用",content:'# html\n\n\n# html的介绍\n\n1.五大浏览器：\n\n\tIE \t \t\t Trident\n\tChrome  \t blik\n\tFirefox  \t Grcko\n\tSafari  \t webkit\n\tOpera \t \t presto\n\n\n2.Web标准：\n\n\t结构标准: \tHTML\n\t表现标准:\tCSS\n\t行为标准:\tJavaScript (JS)\n\n\n\n# html的标签\n\n 1. HTML 基本结构：\n\n<!doctype html>\n    <html>\n        <head>\n        \t<title></title>\n        </head>\n        <body>\n        </body>\n    </html>\n\n\n 2. 标题标签：\n\n<h1></h1>\n<h2></h2>\n<h3></h3>\n<h4></h4>\n<h5></h5>\n<h6></h6>\n\n\n 3. 段落标签：\n\n<p></p>\n\n\n 4. 水平线标签:\n\n<hr>\n\n\n 5. 标签的分类:\n\n1. 单标签（单身狗）\n例如：<hr />和<br />等\n\n2. 双标签\n例如：<head></head>和<body></body>等\n\n\n 6. 标签的关系:\n\n1. 嵌套关系（父子关系）\n例如：<head></head>和<title></title>\n\n2. 并列关系（兄弟关系）\n例如：<head></head>和<body></body>\n\n\n 7. 换行标签：\n\n<br>\n\n\n 8. 文本格式化标签：\n\n1. 加粗：\n<strong></strong>\n<b></b>\n\n2. 斜体：\n<em></em>\n<i></i>\n\n3. 加下划线：\n<ins></ins>\n<u></u>\n\n4. 加删除线：\n<del></del>\n<s></s>\n\n\n 9. 标签的语义化：\n\n见标签大致知道这个标签的意义\n\n\n 10. 两个重要的无语义的标签：\n\n<div></div>       \t主要用于分割成几个模块\n\n<span></span>    \t主要用于字体形式\n\n\n\n 11. 图片标签：\n\n1. 语法：\n\t<img >\t\n\n2. 属性：\n    src:\t设置需要显示的图片路径\n    width:\t设置标签的宽度\n    height:\t设置标签的高度\n    title:\t鼠标悬停到图片上的文字提示\n    alt:\t当图片无法正常显示时的文字提示\n\n\n\n 12. 注释：\n\n语法：  \n\x3c!--需要注释的内容--\x3e\n\n\n 13. 路径标签：\n\n1. 绝对路径：\n    磁盘目录下的路径\n    网络地址上的路径\n\n2. 相对路径：\n    1. 访问资料与HTML文件在同一目录下，路径=./直接设置文件名称\n    2. 访问资料在HTML文件夹的上一目录，路径=./文件所在的文件夹名称/文件名\n    3. 访问资料在HTML文件夹的上一目录，路径=../文件名称\n\n\n\n# html的超链接\n\n 1. a标签\n\n语法：<a></a>\n\n<a herf="跳转页面的路径"></a>\n\n\n 2. 空链接\n\n<a herf="#"></a>\n\n\n 3. a标签的作用\n\n 4. 1. 页面的跳转\n    2. 在当前页面的定位（锚点）\n    3. 下载\n\n 5. 在浏览器打开的方式（target属性）\n\n 6. 1. 在当前窗口打开新页面(_self)\n    2. 在新窗口打开新页面(_blank)\n    3. 在head标签设置base标签，在base标签设置target属性（整体设置）\n\n\n# html的列表\n\n 1. 无序列表\n    \n    1. 语法\n       \n       <ul>\n       \t<li> </li>\n       </ul>\n       \n    \n    2. 注意事项：ul中只能放li，li中可以放其他标签\n    \n    3. 去除列表前面的圆点：list-style:none;\n\n 2. 有序列表\n    \n    1. 语法\n       \n       <ol>\n           <li>\n           </li>\n       </ol>\n       \n    \n    2. 注意事项：ol中只能放li，li中可以放其他标签\n\n 3. 自定义列表\n    \n    1. 语法\n       \n       <dl>\n           <dt></dt>\n           <dd></dd>\n           <dd></dd>\n       </dl>\n       \n    \n    2. 注意事项：\n       \n       1. dl中只能放dt和dd\n       2. dd中可以放其他标签\n       3. 一般一个dl中只有一个dt，但是可以有多个dd\n\n\n# html的表格\n\n 1. 表格的标签\n    \n    表格：\ttable \n    行：\ttr \n    单元格：\t td \n    表头:\t thead  \n    表格主体：\ttbody \n    表头中的单元格：\t th \n    表格标题： \tcaption \n    \n\n 2. 表格的属性\n    \n    border：\t边框 \n    cellspacing： \t设置边框与边框之间的间距\n    cellpadding：\t 设置边框与内容之间的间距 \n    align：\t设置表格的水平位置 left  right  center \n    \n\n 3. 表格结构\n    \n    表头标签\t<thead></thead>\n    表格主体标签\t<tbody></tbody>\n    \n\n 4. 单元格合并标签\n    \n    \t跨行合并：\t rowspan\n    \t跨列合并：\t colspan \n    \t合并原则：\t 从上到下、从左到右 \n    \n\n\n# html的表单\n\n 1. 组成\n    \n    1. 提示信息\n    2. 表单域\n    3. 表单元素\n\n 2. 表单域\n    \n    1. 语法：\n    \n      <form action="url地址" method="提交方式" name="表单名称">\n                各种表单控件,如input,select,textarea\n      </form>\n    \n    \n    2. 常用属性\n       \n       Action 在表单收集到信息后，需要将信息传递给服务器进行处理，action属性用于指定接收并处理表单数据的服务器程序的url地址。 method 用于设置表单数据的提交方式，其取值为get或post。 name 用于指定表单的名称，以区分同一个页面中的多个表单。\n\n 3. 表单元素\n    \n    1. input系列表单元素\n       \n       1. 语法\n          \n          <input type="">\n          \n       \n       2. 属性Type\n          \n          type="text": \t单行文本输入框 \n          type="password": \t密码框\n          type="radio": \t单选框(单选按钮中有一个属性： name)\n          type="checkbox" \t复选框\n          type="button"  \t表示普通按钮\n          type="submit":\t 提交按钮\n          type="reset": \t 重置\n          type="image" : \t图片按钮\n          type="file":\t 文件域(一般都是用来做文件上传使用的)\n          name：\t控件的名称\n          value：\tinput控件中默认的文本值\n          size：\tinput控件在页面中显示的宽度\n          checked：\t默认选项\n          maxlength：\t控件允许输入的最多字符数\n          \n       \n       TIP\n       \n       单选按钮中有一个属性： name\n       \n       设置默认选中 checked="checked"\n       \n       属性： 设置按钮的显示文本 value\n       \n       **通过属性：****src:**设置图片路径\n\n\n\n 2. 拓展点\n\n ```\n fieldset: 表单内元素分组\n \tlenged: 分组元素添加标题\n \tdatalist:定义选项列表 \n \t\t1. html5新增的标签\n \t\t2. 必须配合input一起使用\n \t\t3. 对于input需要设置list属性\n \tlabel: 为input标签定义标记(关联)\n \t\t1. 概念：label 标签为 input 元素定义标注（标记）\n \t\t2. 作用：用于绑定一个表单元素, 当点击label标签的时候, 被绑定的表单元素就会获得输入焦点\n \t\t3. 绑定语法\n \t\t\ta) for 属性规定 label 与哪个表单元素绑定\n \t\t\tb) <label for="male">Male</label>\n \t\t\t<input type="radio" name="sex" id="male" value="male">男\n ```\n\n\n 3. 文本域\n    \n    1. 概念：可以输入的文本比较的多\n    \n    2. 语法\n       \n       <textarea rows="20" cols="30"></textarea>\n       \n    \n    3. 文本内容\n       \n       \n       \n    \n    4. 文本域中有两个属性：\n       \n       cols:\t 一行可以显示的字符数\n       rows: \t可以显示的行数\n       \n\n 4. 下拉列表\n    \n    1. 语法\n       \n       <select>\n                <option></option>\n        </select>\n       \n    \n    2. 当前项即为默认选中项 selected="selected"\n\n 5. HTML新增标签\n    \n    1. 常用新标签（布局标签）\n       \n       header：\t定义文档的页眉\n       nav：\t定义导航链接的部分\n       footer：\t定义文档或节的页脚\n       article：\t标签规定独立的自包含内容\n       section：\t定义文档中的节（section、区段）\n       aside：\t定义其所处内容之外的内容\n       main：\t主体内容区域\n       \n    \n    2. 常用新属性\n       \n       placeholder\t占位符提供可描述输入字段预期值的提示信息\n       autofocu\t规定当页面加载时 input 元素应该自动获得焦点\n       multiple\t多文件上传\n       autocomplete\t规定表单是否应该启用自动完成功能\n       required\t必填项\n       accesskey\t规定激活（使元素获得焦点）元素的快捷键\n       \n       \n       1. input新增的type****属性值\n          \n          type="email"\t邮箱\n          type="tel"\t电话号码\n          type="url"\t输入url格式\n          type="number"\t数字\n          type="search"\t搜索框（体现语义化）\n          type="range"\t自由拖动滑块\n          type="time"\t时间\n          type="date"\t日历\n          type="datetime"\t\n          type="month"\t月\n          type="week"\t周\n          \n    \n    3. 多媒体标签\n       \n       embed：\t标签定义嵌入的内容\n       先上传，再分享\n       audio：\t播放音频\n       autoplay \t自动播放\n       controls \t是否显不默认播放控件\n       loop \t循环播放\n       video：\t播放视频\n       autoplay \t自动播放\n       Controls\t 是否显示默认播放控件\n       loop \t循环播放\n       width \t设置播放窗口宽度\n       height \t设置播放窗口的高度\n       \n       \n       \n       TIP\n       \n       disabled 禁用属性\n\n\n# input的快捷使用\n\n 1. 使用input进行赋值操作\n    \n    const oInput = document.createElement(\'input\') \n    oInput.value = "复制的值" \n    document.body.appendChild(oInput) \n    oInput.select() \n    document.execCommand(\'Copy\') \n    oInput.style.display = \'none\' \n    document.body.removeChild(oInput)\n    \n\n 2. input 不可编辑的3种情况\n    \n    1. disabled 属性规定应该禁用 input 元素，被禁用的 input 元素，不可编辑，不可复制，不可选择，不能接收焦点,后台也不会接收到传值。设置后文字的颜色会变成灰色。disabled 属性无法与 <input type="hidden"> 一起使用。示例：<input type="text" disabled="disabled" />\n    2. readonly 属性规定输入字段为只读可复制，但是，用户可以使用Tab键切换到该字段，可选择,可以接收焦点，还可以选中或拷贝其文本。后台会接收到传值. readonly 属性可以防止用户对值进行修改。readonly 属性可与 <input type="text"> 或 <input type="password"> 配合使用。 示例：<input type="text" readonly="readonly">\n    3. readonly unselectable="on" 该属性跟disable类似，input 元素，不可编辑，不可复制，不可选择，不能接收焦点，设置后文字的颜色也会变成灰色，但是后台可以接收到传值。 示例：<input type="text" readonly unselectable="on" >',normalizedContent:'# html\n\n\n# html的介绍\n\n1.五大浏览器：\n\n\tie \t \t\t trident\n\tchrome  \t blik\n\tfirefox  \t grcko\n\tsafari  \t webkit\n\topera \t \t presto\n\n\n2.web标准：\n\n\t结构标准: \thtml\n\t表现标准:\tcss\n\t行为标准:\tjavascript (js)\n\n\n\n# html的标签\n\n 1. html 基本结构：\n\n<!doctype html>\n    <html>\n        <head>\n        \t<title></title>\n        </head>\n        <body>\n        </body>\n    </html>\n\n\n 2. 标题标签：\n\n<h1></h1>\n<h2></h2>\n<h3></h3>\n<h4></h4>\n<h5></h5>\n<h6></h6>\n\n\n 3. 段落标签：\n\n<p></p>\n\n\n 4. 水平线标签:\n\n<hr>\n\n\n 5. 标签的分类:\n\n1. 单标签（单身狗）\n例如：<hr />和<br />等\n\n2. 双标签\n例如：<head></head>和<body></body>等\n\n\n 6. 标签的关系:\n\n1. 嵌套关系（父子关系）\n例如：<head></head>和<title></title>\n\n2. 并列关系（兄弟关系）\n例如：<head></head>和<body></body>\n\n\n 7. 换行标签：\n\n<br>\n\n\n 8. 文本格式化标签：\n\n1. 加粗：\n<strong></strong>\n<b></b>\n\n2. 斜体：\n<em></em>\n<i></i>\n\n3. 加下划线：\n<ins></ins>\n<u></u>\n\n4. 加删除线：\n<del></del>\n<s></s>\n\n\n 9. 标签的语义化：\n\n见标签大致知道这个标签的意义\n\n\n 10. 两个重要的无语义的标签：\n\n<div></div>       \t主要用于分割成几个模块\n\n<span></span>    \t主要用于字体形式\n\n\n\n 11. 图片标签：\n\n1. 语法：\n\t<img >\t\n\n2. 属性：\n    src:\t设置需要显示的图片路径\n    width:\t设置标签的宽度\n    height:\t设置标签的高度\n    title:\t鼠标悬停到图片上的文字提示\n    alt:\t当图片无法正常显示时的文字提示\n\n\n\n 12. 注释：\n\n语法：  \n\x3c!--需要注释的内容--\x3e\n\n\n 13. 路径标签：\n\n1. 绝对路径：\n    磁盘目录下的路径\n    网络地址上的路径\n\n2. 相对路径：\n    1. 访问资料与html文件在同一目录下，路径=./直接设置文件名称\n    2. 访问资料在html文件夹的上一目录，路径=./文件所在的文件夹名称/文件名\n    3. 访问资料在html文件夹的上一目录，路径=../文件名称\n\n\n\n# html的超链接\n\n 1. a标签\n\n语法：<a></a>\n\n<a herf="跳转页面的路径"></a>\n\n\n 2. 空链接\n\n<a herf="#"></a>\n\n\n 3. a标签的作用\n\n 4. 1. 页面的跳转\n    2. 在当前页面的定位（锚点）\n    3. 下载\n\n 5. 在浏览器打开的方式（target属性）\n\n 6. 1. 在当前窗口打开新页面(_self)\n    2. 在新窗口打开新页面(_blank)\n    3. 在head标签设置base标签，在base标签设置target属性（整体设置）\n\n\n# html的列表\n\n 1. 无序列表\n    \n    1. 语法\n       \n       <ul>\n       \t<li> </li>\n       </ul>\n       \n    \n    2. 注意事项：ul中只能放li，li中可以放其他标签\n    \n    3. 去除列表前面的圆点：list-style:none;\n\n 2. 有序列表\n    \n    1. 语法\n       \n       <ol>\n           <li>\n           </li>\n       </ol>\n       \n    \n    2. 注意事项：ol中只能放li，li中可以放其他标签\n\n 3. 自定义列表\n    \n    1. 语法\n       \n       <dl>\n           <dt></dt>\n           <dd></dd>\n           <dd></dd>\n       </dl>\n       \n    \n    2. 注意事项：\n       \n       1. dl中只能放dt和dd\n       2. dd中可以放其他标签\n       3. 一般一个dl中只有一个dt，但是可以有多个dd\n\n\n# html的表格\n\n 1. 表格的标签\n    \n    表格：\ttable \n    行：\ttr \n    单元格：\t td \n    表头:\t thead  \n    表格主体：\ttbody \n    表头中的单元格：\t th \n    表格标题： \tcaption \n    \n\n 2. 表格的属性\n    \n    border：\t边框 \n    cellspacing： \t设置边框与边框之间的间距\n    cellpadding：\t 设置边框与内容之间的间距 \n    align：\t设置表格的水平位置 left  right  center \n    \n\n 3. 表格结构\n    \n    表头标签\t<thead></thead>\n    表格主体标签\t<tbody></tbody>\n    \n\n 4. 单元格合并标签\n    \n    \t跨行合并：\t rowspan\n    \t跨列合并：\t colspan \n    \t合并原则：\t 从上到下、从左到右 \n    \n\n\n# html的表单\n\n 1. 组成\n    \n    1. 提示信息\n    2. 表单域\n    3. 表单元素\n\n 2. 表单域\n    \n    1. 语法：\n    \n      <form action="url地址" method="提交方式" name="表单名称">\n                各种表单控件,如input,select,textarea\n      </form>\n    \n    \n    2. 常用属性\n       \n       action 在表单收集到信息后，需要将信息传递给服务器进行处理，action属性用于指定接收并处理表单数据的服务器程序的url地址。 method 用于设置表单数据的提交方式，其取值为get或post。 name 用于指定表单的名称，以区分同一个页面中的多个表单。\n\n 3. 表单元素\n    \n    1. input系列表单元素\n       \n       1. 语法\n          \n          <input type="">\n          \n       \n       2. 属性type\n          \n          type="text": \t单行文本输入框 \n          type="password": \t密码框\n          type="radio": \t单选框(单选按钮中有一个属性： name)\n          type="checkbox" \t复选框\n          type="button"  \t表示普通按钮\n          type="submit":\t 提交按钮\n          type="reset": \t 重置\n          type="image" : \t图片按钮\n          type="file":\t 文件域(一般都是用来做文件上传使用的)\n          name：\t控件的名称\n          value：\tinput控件中默认的文本值\n          size：\tinput控件在页面中显示的宽度\n          checked：\t默认选项\n          maxlength：\t控件允许输入的最多字符数\n          \n       \n       tip\n       \n       单选按钮中有一个属性： name\n       \n       设置默认选中 checked="checked"\n       \n       属性： 设置按钮的显示文本 value\n       \n       **通过属性：****src:**设置图片路径\n\n\n\n 2. 拓展点\n\n ```\n fieldset: 表单内元素分组\n \tlenged: 分组元素添加标题\n \tdatalist:定义选项列表 \n \t\t1. html5新增的标签\n \t\t2. 必须配合input一起使用\n \t\t3. 对于input需要设置list属性\n \tlabel: 为input标签定义标记(关联)\n \t\t1. 概念：label 标签为 input 元素定义标注（标记）\n \t\t2. 作用：用于绑定一个表单元素, 当点击label标签的时候, 被绑定的表单元素就会获得输入焦点\n \t\t3. 绑定语法\n \t\t\ta) for 属性规定 label 与哪个表单元素绑定\n \t\t\tb) <label for="male">male</label>\n \t\t\t<input type="radio" name="sex" id="male" value="male">男\n ```\n\n\n 3. 文本域\n    \n    1. 概念：可以输入的文本比较的多\n    \n    2. 语法\n       \n       <textarea rows="20" cols="30"></textarea>\n       \n    \n    3. 文本内容\n       \n       \n       \n    \n    4. 文本域中有两个属性：\n       \n       cols:\t 一行可以显示的字符数\n       rows: \t可以显示的行数\n       \n\n 4. 下拉列表\n    \n    1. 语法\n       \n       <select>\n                <option></option>\n        </select>\n       \n    \n    2. 当前项即为默认选中项 selected="selected"\n\n 5. html新增标签\n    \n    1. 常用新标签（布局标签）\n       \n       header：\t定义文档的页眉\n       nav：\t定义导航链接的部分\n       footer：\t定义文档或节的页脚\n       article：\t标签规定独立的自包含内容\n       section：\t定义文档中的节（section、区段）\n       aside：\t定义其所处内容之外的内容\n       main：\t主体内容区域\n       \n    \n    2. 常用新属性\n       \n       placeholder\t占位符提供可描述输入字段预期值的提示信息\n       autofocu\t规定当页面加载时 input 元素应该自动获得焦点\n       multiple\t多文件上传\n       autocomplete\t规定表单是否应该启用自动完成功能\n       required\t必填项\n       accesskey\t规定激活（使元素获得焦点）元素的快捷键\n       \n       \n       1. input新增的type****属性值\n          \n          type="email"\t邮箱\n          type="tel"\t电话号码\n          type="url"\t输入url格式\n          type="number"\t数字\n          type="search"\t搜索框（体现语义化）\n          type="range"\t自由拖动滑块\n          type="time"\t时间\n          type="date"\t日历\n          type="datetime"\t\n          type="month"\t月\n          type="week"\t周\n          \n    \n    3. 多媒体标签\n       \n       embed：\t标签定义嵌入的内容\n       先上传，再分享\n       audio：\t播放音频\n       autoplay \t自动播放\n       controls \t是否显不默认播放控件\n       loop \t循环播放\n       video：\t播放视频\n       autoplay \t自动播放\n       controls\t 是否显示默认播放控件\n       loop \t循环播放\n       width \t设置播放窗口宽度\n       height \t设置播放窗口的高度\n       \n       \n       \n       tip\n       \n       disabled 禁用属性\n\n\n# input的快捷使用\n\n 1. 使用input进行赋值操作\n    \n    const oinput = document.createelement(\'input\') \n    oinput.value = "复制的值" \n    document.body.appendchild(oinput) \n    oinput.select() \n    document.execcommand(\'copy\') \n    oinput.style.display = \'none\' \n    document.body.removechild(oinput)\n    \n\n 2. input 不可编辑的3种情况\n    \n    1. disabled 属性规定应该禁用 input 元素，被禁用的 input 元素，不可编辑，不可复制，不可选择，不能接收焦点,后台也不会接收到传值。设置后文字的颜色会变成灰色。disabled 属性无法与 <input type="hidden"> 一起使用。示例：<input type="text" disabled="disabled" />\n    2. readonly 属性规定输入字段为只读可复制，但是，用户可以使用tab键切换到该字段，可选择,可以接收焦点，还可以选中或拷贝其文本。后台会接收到传值. readonly 属性可以防止用户对值进行修改。readonly 属性可与 <input type="text"> 或 <input type="password"> 配合使用。 示例：<input type="text" readonly="readonly">\n    3. readonly unselectable="on" 该属性跟disable类似，input 元素，不可编辑，不可复制，不可选择，不能接收焦点，设置后文字的颜色也会变成灰色，但是后台可以接收到传值。 示例：<input type="text" readonly unselectable="on" >',charsets:{cjk:!0}},{frontmatter:{},regularPath:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/reactBase.html",relativePath:"前端问题/前端基础/reactBase.md",key:"v-68c3d022",path:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/reactBase.html",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"canvas",frontmatter:{},regularPath:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/canvas.html",relativePath:"前端问题/前端基础/canvas.md",key:"v-7464d17e",path:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/canvas.html",headers:[{level:2,title:"动态生成流程图",slug:"动态生成流程图",normalizedTitle:"动态生成流程图",charIndex:13},{level:2,title:"动态生成树",slug:"动态生成树",normalizedTitle:"动态生成树",charIndex:38409}],headersStr:"动态生成流程图 动态生成树",content:"# canvas\n\n\n# 动态生成流程图\n\n代码\n\nvar canvasFunc = function(canvas, widthValue, heightValue) {\n    if (canvas.getContext) {\n        console.log(\"你的浏览器支持Canvas!\");\n        let cxt = canvas.getContext(\"2d\")\n        initCanvas(cxt, canvas, widthValue, heightValue)\n    } else {\n        console.log(\"你的浏览器不支持Canvas!\");\n    }\n}\n\nfunction hoverSingleChart(singleData) {\n    console.log(\"---------鼠标事件-----------\");\n    console.log(singleData);\n}\n\n// 初始化\nfunction initCanvas(cxt, canvas, canWidth, canHeight) {\n    // init\n    var init = { top: 32, spaceH: 70 }; // 开始第一层\n    var row2 = {\n        y: init.top + init.spaceH,\n        data: [\n            {\n                type: 'Step',\n                text: '业务名称1',\n                name: 'step_2_1',\n                arrowArr: [\n                    {\n                        arrow: 'drawBottomToTop',\n                        to: 'step_3_1'\n                    }\n                ],\n                x: '',\n                y: '',\n                requestData: {}\n            },\n            {\n                type: 'Step',\n                text: '业务名称2',\n                name: 'step_2_2',\n                arrowArr: [\n                    {\n                        arrow: 'drawBottomToLeft',\n                        to: 'step_3_2'\n                    }\n                ]\n            },\n            {\n                type: 'Step',\n                text: '业务名称3',\n                name: 'step_2_3',\n                arrowArr: [\n                    {\n                        arrow: 'drawBottomToRight',\n                        to: 'step_3_2'\n                    }\n                ]\n            },\n            {\n                type: 'Step',\n                name: 'step_2_4',\n                text: '业务名称4',\n                arrowArr: [\n                    {\n                        arrow: 'drawBottomToTop',\n                        to: 'step_7_1'\n                    }\n                ]\n            }\n        ]\n    };\n    row2.data = calChartX(canWidth, row2.data, row2.y);\n    var flowData = [\n        {\n            row: 1,\n            y: init.top,\n            data: [\n                {\n                    type: 'Start',\n                    text: '开始',\n                    name: 'step_1_1',\n                    arrowArr: [\n                        {\n                            arrow: 'drawBottomToTop',\n                            to: 'step_2_1'\n                        },\n                        {\n                            arrow: 'drawBottomToTop',\n                            to: 'step_2_2'\n                        },\n                        {\n                            arrow: 'drawBottomToTop',\n                            to: 'step_2_3'\n                        }, {\n                            arrow: 'drawBottomToTop',\n                            to: 'step_2_4'\n                        }\n                    ],\n                    x: canWidth / 2,\n                    y: ''\n                }\n            ]\n        },\n        {\n            row: 2,\n            y: init.top + init.spaceH,\n            data: row2.data,\n            method: {\n                onmousemove: null,\n                onmouseleave: null,\n                onclick: hoverSingleChart\n            }\n        },\n        {\n            row: 3,\n            y: '',\n            data: [{\n                type: 'Step',\n                text: '业务名称4',\n                x: row2.data[0].x,\n                name: 'step_3_1',\n                arrowArr: [\n                    {\n                        arrow: 'drawBottomToTop',\n                        to: 'step_4_1'\n                    }\n                ]\n            }, {\n                type: 'Step',\n                text: '业务名称5',\n                name: 'step_3_2',\n                x: canWidth / 2,\n                arrowArr: [\n                    {\n                        arrow: 'drawBottomToTop',\n                        to: 'step_4_2'\n                    }\n                ]\n            }]\n        },\n        {\n            row: 4,\n            y: '',\n            data: [{\n                type: 'Step',\n                text: '业务名称6',\n                x: row2.data[0].x,\n                name: 'step_4_1',\n                arrowArr: [\n                    {\n                        arrow: 'drawBottomToTop',\n                        to: 'step_5_1'\n                    }\n                ]\n            }, {\n                type: 'Step',\n                text: '业务名称7',\n                name: 'step_4_2',\n                x: canWidth / 2,\n                arrowArr: [\n                    {\n                        arrow: 'drawBottomToTop',\n                        to: 'step_5_2'\n                    }\n                ]\n            }]\n        },\n        {\n            row: 5,\n            y: '',\n            data: [{\n                type: 'Step',\n                text: '业务名称8',\n                x: row2.data[0].x,\n                name: 'step_5_1',\n                arrowArr: [\n                    {\n                        arrow: 'drawBottomToTop',\n                        to: 'step_6_1'\n                    }\n                ]\n            }, {\n                type: 'Step',\n                text: '业务名称9',\n                name: 'step_5_2',\n                x: canWidth / 2,\n                arrowArr: [\n                    {\n                        arrow: 'drawBottomToTop',\n                        to: 'step_6_2'\n                    },\n                    {\n                        arrow: 'drawBottomToTop',\n                        to: 'step_6_3'\n                    }\n                ]\n            }]\n        },\n        {\n            row: 6,\n            y: '',\n            data: [{\n                type: 'Step',\n                text: '业务名称10',\n                x: row2.data[0].x,\n                name: 'step_6_1',\n                arrowArr: [\n                    {\n                        arrow: 'drawBottomToLeft',\n                        to: 'step_7_1'\n                    }\n                ]\n            }, {\n                type: 'Step',\n                text: '业务名称11',\n                name: 'step_6_2',\n                x: row2.data[1].x,\n                arrowArr: [\n                    {\n                        arrow: 'drawBottomToTop',\n                        to: 'step_7_1'\n                    }\n                ]\n            }, {\n                type: 'Step',\n                text: '业务名称12',\n                name: 'step_6_3',\n                x: row2.data[2].x,\n                arrowArr: [\n                    {\n                        arrow: 'drawBottomToTop',\n                        to: 'step_7_1'\n                    }\n                ]\n            }]\n        },\n        {\n            row: 7,\n            y: init.top + init.spaceH * 6 + 10,\n            data: [{\n                type: 'Condition',\n                text: '判断条件',\n                x: canWidth / 2,\n                name: 'step_7_1',\n                arrowArr: [\n                    {\n                        arrow: 'drawBottomToTop',\n                        to: 'step_8_1'\n                    },\n                    {\n                        arrow: 'drawBottomToTop',\n                        to: 'step_8_3'\n                    },\n                    {\n                        arrow: 'drawLeftToLeft',\n                        to: 'step_6_2'\n                    },\n                    {\n                        arrow: 'drawRightToTop',\n                        to: 'step_8_6'\n                    }\n                ]\n            }]\n        },\n        {\n            row: 8,\n            y: init.top + init.spaceH * 7 + 30,\n            isAverage: true, //平均计算x\n            data: [\n                {\n                    type: 'Step',\n                    text: '业务名称12',\n                    name: 'step_8_1',\n                    arrowArr: [\n                        {\n                            arrow: 'drawLeftToLeft',\n                            to: 'step_6_1'\n                        }\n                    ],\n                    requestData: {},\n                    method: {\n                        onmousemove: null,\n                        onmouseleave: null,\n                        onclick: null\n                    }\n                },\n                {\n                    type: 'Step',\n                    text: '业务名称4',\n                    name: 'step_8_2',\n                    arrowArr: [\n                        {\n                            arrow: 'drawRightToLeft',\n                            to: 'step_8_3'\n                        }\n                    ]\n                },\n                {\n                    type: 'Step',\n                    text: '业务名称4',\n                    name: 'step_8_3',\n                    arrowArr: [\n                        {\n                            arrow: 'drawRightToLeft',\n                            to: 'step_8_4'\n                        }\n                    ]\n                },\n                {\n                    type: 'Step',\n                    name: 'step_8_4',\n                    text: '业务名称4',\n                    arrowArr: [\n                        {\n                            arrow: 'drawRightToLeft',\n                            to: 'step_8_5'\n                        }\n                    ]\n                },\n                {\n                    type: 'Step',\n                    name: 'step_8_5',\n                    text: '业务名称4',\n                    arrowArr: [\n                        {\n                            arrow: 'drawRightToLeft',\n                            to: 'step_8_6'\n                        }\n                    ]\n                },\n                {\n                    type: 'Step',\n                    name: 'step_8_6',\n                    text: '业务名称4',\n                    arrowArr: [\n                        {\n                            arrow: 'drawBottomToTop',\n                            to: 'step_9_1'\n                        }\n                    ]\n                }\n            ]\n        },\n        {\n            row: 9,\n            y: init.top + init.spaceH * 8 + 30,\n            isAverage: true,\n            data: [\n                {\n                    type: 'Step',\n                    text: '业务名称4',\n                    name: 'step_9_1',\n                    arrowArr: [\n                        {\n                            arrow: 'drawRightToLeft',\n                            to: 'step_9_2'\n                        }\n                    ],\n                    requestData: {},\n                    method: {\n                        onmousemove: null,\n                        onmouseleave: null,\n                        onclick: hoverSingleChart\n                    }\n                },\n                {\n                    type: 'Step',\n                    text: '业务名称4',\n                    name: 'step_9_2',\n                    arrowArr: [\n                        {\n                            arrow: 'drawRightToLeft',\n                            to: 'step_9_3'\n                        }\n                    ]\n                },\n                {\n                    type: 'Step',\n                    text: '业务名称4',\n                    name: 'step_9_3',\n                    arrowArr: [\n                        {\n                            arrow: 'drawRightToLeft',\n                            to: 'step_9_4'\n                        }\n                    ]\n                },\n                {\n                    type: 'Step',\n                    name: 'step_9_4',\n                    text: '业务名称4',\n                    arrowArr: [\n                        {\n                            arrow: 'drawRightToLeft',\n                            to: 'step_9_5'\n                        }\n                    ]\n                },\n                {\n                    type: 'End',\n                    name: 'step_9_5',\n                    text: '结束',\n                    arrowArr: []\n                }\n            ]\n        }\n    ];\n    drawFlowChart(cxt, canvas, flowData, init.top, init.spaceH);\n}\n\n\n//画流程图\n//画所有的图形：画图和画对应的箭头\nfunction drawFlowChart(context, canvas, flowdata, initTop, initSpaceH) {\n    //1、判断是否有需要平均计算x的数据\n    flowdata.forEach(function(row) {\n        if (row.isAverage) {\n            row.data = calChartX(canvas.width, row.data, row.y);\n        }\n    });\n    //2、先要画完所有的图形\n    flowdata.forEach(function(row, rowIndex) {\n        row.y = row.y ? row.y : (rowIndex == 0 ? initTop + initSpaceH : initTop + initSpaceH * rowIndex);\n        row = drawRowChart(context, row);  //画图形\n    });\n    //3、添加要指向的对象，必须要在画完所有图形之后\n    flowdata.forEach(function(row) {\n        row.data.forEach(function(item) {\n            if (item.arrowArr && item.arrowArr.length) {\n                item.arrowArr.forEach(function(mItem) {\n                    mItem = addToObj(mItem, flowdata);\n                })\n            }\n        })\n    });\n    //4、给所有图形画上对应的画箭头，必须要在前两步完成之后\n    flowdata.forEach(function(row, rowIndex) {\n        row.data.forEach(function(item) {\n            if (item.arrowArr && item.arrowArr.length) {\n                drawSingleArrow(context, item);//画箭头\n            }\n        })\n    });\n    //5、给所有元素添加点击和悬浮事件\n    addMethod(canvas, flowdata)\n}\n//当一行有n个图形并且需要平均排列时用此方法计算每个图形的x\nfunction calChartX(canvasW, data, dataY) {\n    var startW = 80;\n    var stepW = 120;\n    var CondW = 30;\n    var count = 0;\n    for (var i = 0; i < data.length; i++) {\n        if (data[i].type == 'Step') {\n            count += stepW;\n        } else if (data[i].type == 'Start' || data[i].type == 'End') {\n            count += startW;\n        } else if (data[i].type == 'Condition') {\n            count += CondW;\n        }\n    }\n    //spaceW 计算一行中每个图形的平均间距\n    var spaceW = parseInt((canvasW - count) / (data.length + 1));\n    //计算坐标x\n    var prevDiv = [], curW = 0;\n    for (var i = 0; i < data.length; i++) {\n        if (data[i].type == 'Step') {\n            prevDiv.push(stepW);\n            curW = stepW / 2;\n        } else if (data[i].type == 'Start' || data[i].type == 'End') {\n            prevDiv.push(startW);\n            curW = startW / 2;\n        } else if (data[i].type == 'Condition') {\n            prevDiv.push(CondW);\n            curW = CondW / 2;\n        }\n        var preLength = 0;\n        for (var j = 0; j < i; j++) {\n            preLength += prevDiv[j];\n        }\n        var x = spaceW * (i + 1) + preLength + curW;\n        var y = data[i].y;\n        data[i]['x'] = x;\n        data[i]['y'] = y || dataY;\n    }\n    return data;\n}\n//生成每列对应的图形\nfunction drawRowChart(context, row) {\n    row.data.forEach(function(item, index) {\n        var s = null;\n        item.y = item.y ? item.y : row.y;\n        if (item.type == 'Step') {\n            s = new Step(context, item.x, item.y, item);\n        } else if (item.type == 'Condition') {\n            s = new Condition(context, item.x, item.y, item);\n        } else if (item.type == 'End') {\n            s = new End(context, item.x, item.y, item);\n        } else if (item.type == 'Start') {\n            s = new Start(context, item.x, item.y, item);\n        }\n        item.chartObj = s;\n    })\n    return row;\n}\n//绘制单个的图形\nfunction drawSingleChart(context, item) {\n    var s = '';\n    if (item.type == 'Step') {\n        s = new Step(context, item.x, item.y, item);\n    } else if (item.type == 'Condition') {\n        s = new Condition(context, item.x, item.y, item);\n    } else if (item.type == 'End') {\n        s = new End(context, item.x, item.y, item);\n    } else if (item.type == 'Start') {\n        s = new Start(context, item.x, item.y, item);\n    }\n    item.chartObj = s;\n    return item;\n}\n//每个对象的坐标范围\nfunction calRange(obj) {\n    var newObj = {\n        minX: obj.x - obj.w / 2,\n        maxX: obj.x + obj.w / 2,\n        minY: obj.y - obj.h / 2,\n        maxY: obj.y + obj.h / 2\n    }\n    return newObj;\n}\n//处理每一个箭头需要指向的对象\nfunction addToObj(arrObj, flowData) {\n    flowData.forEach(function(rows) {\n        rows.data.forEach(function(item) {\n            if (item.name == arrObj.to) {\n                arrObj.to = item.chartObj;\n            }\n        })\n    })\n    return arrObj;\n}\n//画每个图形的箭头指向\nfunction drawSingleArrow(context, data) {\n    var step1 = data.chartObj;\n    console.log(step1, '===step1');\n    if (data.arrowArr && data.arrowArr.length) {\n        data.arrowArr.forEach(function(item) {\n            step1[item.arrow](item.to, context);\n        })\n    }\n}\n//清除单个图形\nfunction repaintSingleChart(context, item) {\n    var range = item.chartObj.range;\n    //清除之前画的图形\n    context.clearRect(range.minX - 1, range.minY - 1, item.chartObj.w + 2, item.chartObj.h + 3);\n}\n//给所有图形添加事件\nfunction addMethod(canvas, flowData) {\n    //给所有图形添加点击事件\n    canvas.onclick = function(ev) {\n        ev = ev || window.event;\n        let ua = navigator.userAgent.toLowerCase();\n        let isIE = ua.indexOf(\"compatible\") > -1 && ua.indexOf(\"msie\") > -1 && !ua.indexOf(\"opera\") > -1; //IE浏览器\n        let isEdge = ua.indexOf(\"Edge\") > -1;\n        let isIE11 = ua.toLowerCase().match(/rv:([\\d.]+)\\) like gecko/);\n        let curx = (isIE || isEdge || isIE11) ? ev.offsetX : ev.layerX;\n        let cury = (isIE || isEdge || isIE11) ? ev.offsetY : ev.layerY;\n        flowData.forEach(function(row, listIndex) {\n            row.data.forEach(function(item) {\n                let range = item.chartObj.range;\n                if (curx >= range.minX && curx <= range.maxX && cury >= range.minY && cury <= range.maxY) {\n                    let clickMethod = null;\n                    if (row.method && row.method.onclick) { //如果每行定义了事件\n                        //判断每个元素是否有单独定义事件，如果有，取改元素定义的事件，如果没有取每行定义的事件\n                        if (item.method && item.method.onclick) {\n                            clickMethod = item.method.onclick\n                        } else {\n                            clickMethod = row.method.onclick\n                        }\n                    } else {\n                        if (item.method && item.method.onclick) {\n                            clickMethod = item.method.onclick\n                        } else {\n                            clickMethod = null;\n                        }\n                    }\n                    if (clickMethod instanceof Function) {\n                        clickMethod(item);\n                    }\n                }\n            })\n        });\n    };\n    var timer = null;\n    //给所有图形添加mousemove事件\n    canvas.onmousemove = function(ev) {\n        ev = ev || window.event;\n        let ua = navigator.userAgent.toLowerCase();\n        let isIE = ua.indexOf(\"compatible\") > -1 && ua.indexOf(\"msie\") > -1 && !ua.indexOf(\"opera\") > -1; //IE浏览器\n        let isEdge = ua.indexOf(\"Edge\") > -1;\n        let isIE11 = ua.toLowerCase().match(/rv:([\\d.]+)\\) like gecko/);\n        let curx = (isIE || isEdge || isIE11) ? ev.offsetX : ev.layerX;\n        let cury = (isIE || isEdge || isIE11) ? ev.offsetY : ev.layerY;\n        clearTimeout(timer);\n        flowData.forEach(function(row, listIndex) {\n            row.data.forEach(function(item) {\n                let range = item.chartObj.range;\n                if (curx >= range.minX && curx <= range.maxX && cury >= range.minY && cury <= range.maxY) {\n                    let clickMethod = null;\n                    if (row.method && row.method.onmousemove) { //如果每行定义了事件\n                        //判断每个元素是否有单独定义事件，如果有，取改元素定义的事件，如果没有取每行定义的事件\n                        if (item.method && item.method.onmousemove) {\n                            clickMethod = item.method.onmousemove\n                        } else {\n                            clickMethod = row.method.onmousemove\n                        }\n                    } else {\n                        if (item.method && item.method.onmousemove) {\n                            clickMethod = item.method.onmousemove\n                        } else {\n                            clickMethod = null;\n                        }\n                    }\n                    if (clickMethod instanceof Function) {\n                        timer = setTimeout(function() {\n                            clickMethod(item);\n                        }, 1000)\n                    }\n                }\n            })\n        });\n    }\n    //给所有图形添加mouseleave事件\n    canvas.onmouseleave = function(ev) {\n        ev = ev || window.event;\n        let ua = navigator.userAgent.toLowerCase();\n        let isIE = ua.indexOf(\"compatible\") > -1 && ua.indexOf(\"msie\") > -1 && !ua.indexOf(\"opera\") > -1; //IE浏览器\n        let isEdge = ua.indexOf(\"Edge\") > -1;\n        let isIE11 = ua.toLowerCase().match(/rv:([\\d.]+)\\) like gecko/);\n        let curx = (isIE || isEdge || isIE11) ? ev.offsetX : ev.layerX;\n        let cury = (isIE || isEdge || isIE11) ? ev.offsetY : ev.layerY;\n        clearTimeout(timer);\n        flowData.forEach(function(row) {\n            row.data.forEach(function(item) {\n                let range = item.chartObj.range;\n                if (curx >= range.minX && curx <= range.maxX && cury >= range.minY && cury <= range.maxY) {\n                    let clickMethod = null;\n                    if (row.method && row.method.onmouseleave) { //如果每行定义了事件\n                        //判断每个元素是否有单独定义事件，如果有，取改元素定义的事件，如果没有取每行定义的事件\n                        if (item.method && item.method.onmouseleave) {\n                            clickMethod = item.method.onmouseleave\n                        } else {\n                            clickMethod = row.method.onmouseleave\n                        }\n                    } else {\n                        if (item.method && item.method.onmouseleave) {\n                            clickMethod = item.method.onmouseleave\n                        } else {\n                            clickMethod = null;\n                        }\n                    }\n                    if (clickMethod instanceof Function) {\n                        clickMethod(item);\n                    }\n                }\n            })\n        });\n    }\n}\n\n/////////////////////////////////////////基本画图形start////////////////////////////////////////////////////////\n//画圆角矩形\nfunction drawRoundRect(context, x, y, w, h, item, radius) {\n    radius = radius || 20;\n    context.beginPath();\n    context.arc(x + radius, y + radius, radius, Math.PI, Math.PI * 3 / 2);\n    context.lineTo(w - radius + x, y);\n    context.arc(w - radius + x, radius + y, radius, Math.PI * 3 / 2, Math.PI * 2);\n    context.lineTo(w + x, h + y - radius);\n    context.arc(w - radius + x, h - radius + y, radius, 0, Math.PI * 1 / 2);\n    context.lineTo(radius + x, h + y);\n    context.arc(radius + x, h - radius + y, radius, Math.PI * 1 / 2, Math.PI);\n    context.closePath();\n    context.fillStyle = item.color ? (item.color.bgColor ? item.color.bgColor : 'rgba(91,155,213,0.5)') : 'white'; //背景颜色\n    context.fill();\n    context.strokeStyle = item.color ? (item.color.borderColor ? item.color.borderColor : '#5B9BD5') : '#5B9BD5'; //边框颜色\n    context.font = 'normal 14px 微软雅黑';\n    context.fillStyle = item.color ? (item.color.fontColor ? item.color.fontColor : '#5B9BD5') : '#5B9BD5'; //文字颜色\n    context.textAlign = \"center\";\n    context.fillText(item.text, x + w / 2, y + h / 2 + 6);\n    context.stroke();\n}\n//画菱形\nfunction drawRhombus(context, x, y, l, h, item) {\n    context.beginPath();\n    context.moveTo(x, y + h);\n    context.lineTo(x - l * 2 - 40, y);\n    context.lineTo(x, y - h);\n    context.lineTo(x + l * 2 + 40, y);\n    context.closePath();\n    context.strokeStyle = item.color ? (item.color.borderColor ? item.color.borderColor : '#5B9BD5') : '#5B9BD5'; //边框颜色\n    context.fillStyle = item.color ? (item.color.bgColor ? item.color.bgColor : 'rgba(91,155,213,0.5)') : 'white'; //背景颜色\n    context.fill();\n    context.fillStyle = item.color ? (item.color.fontColor ? item.color.fontColor : '#5B9BD5') : '#5B9BD5'; //文字颜色\n    context.font = 'normal 14px 微软雅黑';\n    context.fillText(item.text, x, y + 3);\n    context.stroke();\n}\n//计算文本的宽高\nfunction textSize(fontSize, fontFamily, text) {\n    var span = document.createElement(\"span\");\n    var result = {};\n    result.width = span.offsetWidth;\n    result.height = span.offsetHeight;\n    span.style.visibility = \"hidden\";\n    span.style.fontSize = fontSize;\n    span.style.fontFamily = fontFamily;\n    span.style.display = \"inline-block\";\n    document.body.appendChild(span);\n    if (typeof span.textContent !== \"undefined\") {\n        span.textContent = text;\n    } else {\n        span.innerText = text;\n    }\n    result.width = parseFloat(window.getComputedStyle(span).width) - result.width;\n    result.height = parseFloat(window.getComputedStyle(span).height) - result.height;\n    return result;\n}\n//Start 圆角矩形对象\nfunction Start(context, x, y, item, h, w) {\n    this.flag = 'start';\n    var textStyle = textSize('14px', '微软雅黑', item.text);\n    w = parseInt(textStyle.width) + 30;\n    this.h = h || 40;\n    this.w = w || 2 * this.h;\n    this.x = x;\n    this.y = y;\n    this.text = item.text;\n    this.range = calRange(this);\n    drawRoundRect(context, x - this.w / 2, y - this.h / 2, this.w, this.h, item);\n}\n//End 圆角矩形对象\nfunction End(context, x, y, item, h, w) {\n    this.flag = 'end';\n    var textStyle = textSize('14px', '微软雅黑', item.text);\n    w = parseInt(textStyle.width) + 30;\n    this.h = h || 40;\n    this.w = w || 2 * this.h;\n    this.x = x;\n    this.y = y;\n    this.text = item.text;\n    this.range = calRange(this);\n    drawRoundRect(context, x - this.w / 2, y - this.h / 2, this.w, this.h, item, 20);\n}\n//Step 矩形对象\nfunction Step(context, x, y, item) {\n    this.flag = \"step\";\n    var textStyle = textSize('14px', '微软雅黑', item.text);\n    var w = parseInt(textStyle.width) + 30;\n    this.h = 40;\n    this.w = w;\n    this.x = x;\n    this.y = y;\n    this.text = item.text;\n    this.range = calRange(this);\n    context.strokeStyle = item.color ? (item.color.borderColor ? item.color.borderColor : '#5B9BD5') : '#5B9BD5'; //边框颜色\n    context.strokeRect(x - this.w / 2, y - this.h / 2, this.w, this.h);\n    context.fillStyle = item.color ? (item.color.bgColor ? item.color.bgColor : 'rgba(91,155,213,0.5)') : 'white'; //背景颜色\n    context.fillRect(x - this.w / 2, y - this.h / 2, this.w, this.h);\n    context.fillStyle = item.color ? (item.color.fontColor ? item.color.fontColor : '#5B9BD5') : '#5B9BD5'; //文字颜色\n    context.textAlign = 'center';\n    context.font = 'normal 14px 微软雅黑';\n    if (item.text) { context.fillText(item.text, x, y + 4); }\n}\n//Condition 菱形对象\nfunction Condition(context, x, y, item) {\n    this.flag = \"condition\";\n    var textStyle = textSize('14px', '微软雅黑', item.text);\n    console.log(textStyle, '===textStyle');\n    var w = parseInt(textStyle.width) / 4;\n    this.l = w;\n    this.h = 40;\n    this.w = w;\n    this.x = x;\n    this.y = y;\n    this.text = item.text;\n    this.range = calRange(this);\n    drawRhombus(context, x, y, this.l, this.h, item);\n}\n\n/////////////////////////////////////////基本画图形end////////////////////////////////////////////////////////\n\n\n\n////////////////////////////////////////////画箭头/////////////////////////////////////////////////////////////\n//箭头从start圆角矩形bottom——>top\nStart.prototype.drawBottomToTop = function(obj, context) {\n    if (obj.flag == \"step\") {\n        let arrow = new Arrow(this.x, this.y + this.h / 2, obj.x, obj.y - obj.h / 2);\n        arrow.drawBottomToTop(context);\n    } else if (obj.flag == \"condition\") {\n        let arrow = new Arrow(this.x, this.y + this.h / 2, obj.x, obj.y - obj.l);\n        arrow.drawBottomToTop(context);\n    }\n}\n\n//箭头从step矩形bottom——>right\nStep.prototype.drawBottomToRight = function(obj, context) {\n    var arrow = null;\n    if (obj.flag == \"step\") {\n        arrow = new Arrow(this.x, this.y + this.h / 2, obj.x + obj.w / 2, obj.y);\n    } else if (obj.flag == \"condition\") {\n        arrow = new Arrow(this.x, this.y + this.h / 2, obj.x + obj.l * 2 + 40, obj.y);\n    } else if (obj.flag == \"start\" || obj.flag == \"end\") {\n        arrow = new Arrow(this.x, this.y + this.h / 2, obj.x + obj.w / 2, obj.y);\n    }\n    arrow.drawBottomToRight(context);\n}\n//箭头从step矩形bottom——>left\nStep.prototype.drawBottomToLeft = function(obj, context) {\n    var arrow = null;\n    if (obj.flag == \"step\") {\n        arrow = new Arrow(this.x, this.y + this.h / 2, obj.x - obj.w / 2, obj.y);\n    } else if (obj.flag == \"condition\") {\n        arrow = new Arrow(this.x, this.y + this.h / 2, obj.x - obj.l * 2 - 40, obj.y);\n    } else if (obj.flag == \"start\" || obj.flag == \"end\") {\n        arrow = new Arrow(this.x, this.y + this.h / 2, obj.x - obj.w / 2, obj.y);\n    }\n    arrow.drawBottomToRight(context);\n}\n//箭头从step矩形bottom——>top\nStep.prototype.drawBottomToTop = function(obj, context) {\n    if (obj.flag == \"step\") {\n        let arrow = new Arrow(this.x, this.y + this.h / 2, obj.x, obj.y - obj.h / 2);\n        arrow.drawBottomToTop(context);\n    } else if (obj.flag == \"condition\") {\n        let arrow = new Arrow(this.x, this.y + this.h / 2, obj.x, obj.y - obj.h);\n        arrow.drawBottomToTop(context);\n    }\n}\n//箭头从step矩形right——>left\nStep.prototype.drawRightToLeft = function(obj, context) {\n    var arrow = null;\n    if (obj.flag == \"step\") {\n        arrow = new Arrow(this.x + this.w / 2, this.y, obj.x - obj.w / 2, obj.y);\n    } else if (obj.flag == \"condition\") {\n        arrow = new Arrow(this.x + this.w / 2, this.y, obj.x - obj.l * 2 - 40, obj.y);\n    } else if (obj.flag == \"start\" || obj.flag == \"end\") {\n        arrow = new Arrow(this.x + this.w / 2, this.y, obj.x - obj.w / 2, obj.y);\n    }\n    arrow.drawLeftToRightOrRightToLeft(context);\n}\n//箭头从step矩形right——>right\nStep.prototype.drawRightToRight = function(obj, context) {\n    var arrow = null;\n    if (obj.flag == \"step\") {\n        arrow = new Arrow(this.x + this.w / 2, this.y, obj.x + obj.w / 2, obj.y);\n    } else if (obj.flag == \"condition\") {\n        arrow = new Arrow(this.x + this.w / 2, this.y, obj.x + obj.l * 2 + 40, obj.y);\n    } else if (obj.flag == \"start\" || obj.flag == \"end\") {\n        arrow = new Arrow(this.x + this.w / 2, this.y, obj.x + obj.w / 2, obj.y);\n    }\n    arrow.drawRightToRight(context);\n}\n//箭头从step矩形left——>left\nStep.prototype.drawLeftToLeft = function(obj, context) {\n    var arrow = null;\n    if (obj.flag == \"step\") {\n        arrow = new Arrow(this.x - this.w / 2, this.y, obj.x - obj.w / 2, obj.y);\n    } else if (obj.flag == \"condition\") {\n        arrow = new Arrow(this.x - this.w / 2, this.y, obj.x - obj.l * 2 - 40, obj.y);\n    } else if (obj.flag == \"start\" || obj.flag == \"end\") {\n        arrow = new Arrow(this.x - this.w / 2, this.y, obj.x - obj.w / 2, obj.y);\n    }\n    arrow.drawLeftToLeft(context);\n}\n\n//箭头从Condition菱形Bottom——>top\nCondition.prototype.drawBottomToTop = function(obj, context) {\n    if (obj.flag == \"step\") {\n        let arrow = new Arrow(this.x, this.y + this.h, obj.x, obj.y - obj.h / 2);\n        arrow.drawBottomToTop(context);\n    } else if (obj.flag == \"condition\") {\n        let arrow = new Arrow(this.x, this.y + this.l, obj.x, obj.y - obj.l);\n        arrow.drawBottomToTop(context);\n    }\n}\n//箭头从Condition菱形right——>top\nCondition.prototype.drawRightToTop = function(obj, context) {\n    if (obj.flag == \"step\") {\n        let arrow = new Arrow(this.x + this.l * 2 + 40, this.y, obj.x, obj.y - obj.h / 2);\n        arrow.drawLeftOrRightToTop(context);\n    } else if (obj.flag == \"condition\") {\n        let arrow = new Arrow(this.x + this.l * 2 + 40, this.y, obj.x, obj.y - obj.l);\n        arrow.drawLeftOrRightToTop(context);\n    }\n}\n//箭头从Condition菱形left——>top\nCondition.prototype.drawLeftToTop = function(obj, context) {\n    if (obj.flag == \"step\") {\n        let arrow = new Arrow(this.x - this.l * 2 - 40, this.y, obj.x, obj.y - obj.h / 2);\n        arrow.drawLeftOrRightToTop(context);\n    } else if (obj.flag == \"condition\") {\n        let arrow = new Arrow(this.x - this.l * 2 - 40, this.y, obj.x, obj.y - obj.l);\n        arrow.drawLeftOrRightToTop(context);\n    }\n}\n//箭头从Condition菱形right——>left\nCondition.prototype.drawRightToLeft = function(obj, context) {\n    if (obj.flag == \"step\") {\n        let arrow = new Arrow(this.x + this.l * 2 + 40, this.y, obj.x - this.w / 2, obj.y);\n        arrow.drawLeftToRightOrRightToLeft(context);\n    } else if (obj.flag == \"condition\") {\n        let arrow = new Arrow(this.x + this.l * 2 + 40, this.y, obj.x - this.l * 2, obj.y);\n        arrow.drawLeftToRightOrRightToLeft(context);\n    }\n}\n//箭头从Condition菱形left——>right\nCondition.prototype.drawLeftToRight = function(obj, context) {\n    if (obj.flag == \"step\") {\n        let arrow = new Arrow(this.x - this.l * 2 - 40, this.y, obj.x + this.w / 2, obj.y);\n        arrow.drawLeftToRightOrRightToLeft(context);\n    } else if (obj.flag == \"condition\") {\n        let arrow = new Arrow(this.x - this.l * 2 - 40, this.y, obj.x + this.l * 2, obj.y);\n        arrow.drawLeftToRightOrRightToLeft(context);\n    }\n}\n//箭头从Condition菱形right——>right\nCondition.prototype.drawRightToRight = function(obj, context) {\n    if (obj.flag == \"step\") {\n        let arrow = new Arrow(this.x + this.l * 2 + 40, this.y, obj.x + this.w / 2 + 40, obj.y);\n        arrow.drawRightToRight(context);\n    } else if (obj.flag == \"condition\") {\n        let arrow = new Arrow(this.x + this.l * 2 + 40, this.y, obj.x + this.l * 2 + 40, obj.y);\n        arrow.drawRightToRight(context);\n    }\n}\n//箭头从Condition菱形left——>left\nCondition.prototype.drawLeftToLeft = function(obj, context) {\n    if (obj.flag == \"step\") {\n        let arrow = new Arrow(this.x - this.l * 2 - 40, this.y, obj.x - this.w / 2 - 40, obj.y);\n        arrow.drawLeftToLeft(context);\n    } else if (obj.flag == \"condition\") {\n        let arrow = new Arrow(this.x - this.l * 2 - 40, this.y, obj.x - this.l * 2 - 40, obj.y);\n        arrow.drawLeftToLeft(context);\n    }\n}\n\n\n/////////////////////////////////////////画箭头start/////////////////////////////////////\nfunction Arrow(x1, y1, x2, y2) {\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n    this.tmpX1 = null;\n    this.tmpY1 = null;\n    this.tmpX2 = null;\n    this.tmpY2 = null;\n    this.color = \"#5B9BD5\";\n}\nArrow.prototype.setColor = function(color) {\n    this.color = color;\n}\n/**\n *\n * @param {Object} x1起始点横坐标\n * @param {Object} y1起始点纵坐标\n * @param {Object} x2结束点横坐标\n * @param {Object} y2结束点纵坐标\n */\nArrow.prototype.setP = function(x1, y1, x2, y2) {\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n}\n//第一个拐点\nArrow.prototype.setP1 = function(tmpX1, tmpY1) {\n    this.tmpX1 = tmpX1;\n    this.tmpY1 = tmpY1;\n}\n//第二个拐点\nArrow.prototype.setP2 = function(tmpX2, tmpY2) {\n    this.tmpX2 = tmpX2;\n    this.tmpY2 = tmpY2;\n}\nArrow.prototype.drawBottomToTop = function(ctx) {\n    if (this.x1 != this.x2) {\n        this.setP1(this.x1, (this.y1 + this.y2) / 2);\n        this.setP2(this.x2, (this.y1 + this.y2) / 2);\n        this.draw(ctx);\n    } else {\n        this.draw(ctx);\n    }\n}\nArrow.prototype.drawLeftOrRightToTop = function(ctx) {\n    this.setP1(this.x2, this.y1);\n    this.draw(ctx);\n}\nArrow.prototype.drawLeftToRightOrRightToLeft = function(ctx) {\n    if (this.y1 != this.y2) {\n        this.setP1((this.x1 + this.x2) / 2, this.y1);\n        this.setP2((this.x1 + this.x2) / 2, this.y2);\n        this.draw(ctx);\n    } else {\n        this.draw(ctx);\n    }\n}\nArrow.prototype.drawRightToRight = function(ctx) {\n    if (this.y1 != this.y2) {\n        // this.setP1((this.x1 + this.x2) / 2 + 100, this.y1);\n        // this.setP2((this.x1 + this.x2) / 2 + 100, this.y2);\n        if (this.x1 > this.x2) {\n            this.setP1(this.x1 + 20, this.y1);\n            this.setP2(this.x1 + 20, this.y2);\n        } else {\n            this.setP1(this.x2 + 20, this.y1);\n            this.setP2(this.x2 + 20, this.y2);\n        }\n        this.draw(ctx);\n    } else {\n        this.draw(ctx);\n    }\n}\nArrow.prototype.drawLeftToLeft = function(ctx) {\n    if (this.y1 != this.y2) {\n        // this.setP1((this.x1 + this.x2) / 2 - 100, this.y1);\n        // this.setP2((this.x1 + this.x2) / 2 - 100, this.y2);\n        if (this.x1 < this.x2) {\n            this.setP1(this.x1 - 20, this.y1);\n            this.setP2(this.x1 - 20, this.y2);\n        } else {\n            this.setP1(this.x2 - 20, this.y1);\n            this.setP2(this.x2 - 20, this.y2);\n        }\n        this.draw(ctx);\n    } else {\n        this.draw(ctx);\n    }\n}\nArrow.prototype.drawBottomToRight = function(ctx) {\n    if (this.y1 != this.y2) {\n        this.setP1(this.x1, this.y2);\n        this.draw(ctx);\n    } else {\n        this.draw(ctx);\n    }\n}\nArrow.prototype.draw = function(ctx) {\n    // arbitrary styling\n    ctx.strokeStyle = this.color;\n    ctx.fillStyle = this.color;\n    // draw the line\n    ctx.beginPath();\n    ctx.moveTo(this.x1, this.y1);\n    if (this.tmpX1 != null && this.tmpY1 != null && this.tmpX2 != null && this.tmpY2 != null) {\n        ctx.lineTo(this.tmpX1, this.tmpY1);\n        ctx.closePath();\n        ctx.stroke();\n        ctx.beginPath();\n        ctx.moveTo(this.tmpX1, this.tmpY1)\n        ctx.lineTo(this.tmpX2, this.tmpY2);\n        ctx.closePath();\n        ctx.stroke();\n        ctx.beginPath();\n        ctx.moveTo(this.tmpX2, this.tmpY2);\n        ctx.lineTo(this.x2, this.y2);\n        ctx.closePath();\n        ctx.stroke();\n        let endRadians = Math.atan((this.y2 - this.tmpY2) / (this.x2 - this.tmpX2));\n        endRadians += ((this.x2 >= this.tmpX2) ? 90 : -90) * Math.PI / 180;\n        this.drawArrowhead(ctx, this.x2, this.y2, endRadians);\n    } else if (this.tmpX1 != null && this.tmpY1 != null && this.tmpX2 == null && this.tmpY2 == null) {\n        ctx.lineTo(this.tmpX1, this.tmpY1);\n        ctx.closePath();\n        ctx.stroke();\n        ctx.beginPath();\n        ctx.moveTo(this.tmpX1, this.tmpY1)\n        ctx.lineTo(this.x2, this.y2);\n        ctx.closePath();\n        ctx.stroke();\n        let endRadians = Math.atan((this.y2 - this.tmpY1) / (this.x2 - this.tmpX1));\n        endRadians += ((this.x2 >= this.tmpX1) ? 90 : -90) * Math.PI / 180;\n        this.drawArrowhead(ctx, this.x2, this.y2, endRadians);\n    } else if (this.tmpX1 == null && this.tmpY1 == null && this.tmpX2 == null && this.tmpY2 == null) {\n        ctx.lineTo(this.x2, this.y2);\n        ctx.closePath();\n        ctx.stroke();\n        let endRadians = Math.atan((this.y2 - this.y1) / (this.x2 - this.x1));\n        endRadians += ((this.x2 >= this.x1) ? 90 : -90) * Math.PI / 180;\n        this.drawArrowhead(ctx, this.x2, this.y2, endRadians);\n    }\n}\nArrow.prototype.drawArrowhead = function(ctx, x, y, radians) {\n    ctx.save();\n    ctx.beginPath();\n    ctx.translate(x, y);\n    ctx.rotate(radians);\n    ctx.moveTo(0, 0);\n    ctx.lineTo(5, 10);\n    ctx.lineTo(-5, 10);\n    ctx.closePath();\n    ctx.restore();\n    ctx.fill();\n}\n\nmodule.exports = canvasFunc;\n\n\n\nvar canvas = this.$refs.myCanvas;\ncanvasF(canvas, elWidthValue, elHeightValue); //调用封装的canvas函数\n\n\n\n# 动态生成树\n\nvar canvasFunc = function(canvas, widthValue, heightValue) {\n    if (canvas.getContext) {\n        console.log(\"你的浏览器支持Canvas!\");\n        let ctx = canvas.getContext(\"2d\")\n\n        init(canvas, widthValue, heightValue)\n    } else {\n        console.log(\"你的浏览器不支持Canvas!\");\n    }\n}\n\nvar Vector = function(x, y) {\n    this.x = x || 0;\n\n    this.y = y || 0;\n};\n\nVector.prototype = {\n\n    add: function(v) {\n        this.x += v.x;\n\n        this.y += v.y;\n\n        return this;\n    },\n\n    length: function() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    },\n\n    rotate: function(theta) {\n        var x = this.x;\n\n        var y = this.y;\n\n        this.x = Math.cos(theta) * this.x - Math.sin(theta) * this.y;\n\n        this.y = Math.sin(theta) * this.x + Math.cos(theta) * this.y;\n\n        //this.x = Math.cos(theta) * x - Math.sin(theta) * y;\n\n        //this.y = Math.sin(theta) * x + Math.cos(theta) * y;\n\n        return this;\n    },\n\n    mult: function(f) {\n        this.x *= f;\n\n        this.y *= f;\n\n        return this;\n    }\n\n};\n\n\n\nvar Leaf = function(p, r, c, ctx) {\n    this.p = p || null;\n\n    this.r = r || 0;\n\n    this.c = c || 'rgba(255,255,255,1.0)';\n\n    this.ctx = ctx;\n}\n\n\n\nLeaf.prototype = {\n\n    render: function() {\n        var that = this;\n\n        var ctx = this.ctx;\n\n        var f = Branch.random(1, 2)\n\n        for (var i = 0; i < 5; i++) {\n            (function(r) {\n                setTimeout(function() {\n                    ctx.beginPath();\n\n                    ctx.fillStyle = that.color;\n\n                    ctx.moveTo(that.p.x, that.p.y);\n\n                    ctx.arc(that.p.x, that.p.y, r, 0, Branch.circle, true);\n\n                    ctx.fill();\n                }, r * 60);\n            })(i);\n        }\n    }\n\n}\n\n\n\n\n// 单独树的建立\nvar Branch = function(p, v, r, c, t) {\n    this.p = p || null;\n\n    this.v = v || null;\n\n    this.r = r || 0;\n\n    this.length = 0;\n\n    this.generation = 1;\n\n    this.tree = t || null;\n\n    this.color = c || 'rgba(255,255,255,1.0)';\n\n    this.register();\n};\n\n\n\nBranch.prototype = {\n\n    register: function() {\n        this.tree.addBranch(this); // 增加树枝（分支）\n    },\n\n    draw: function() {\n        var ctx = this.tree.ctx;\n\n        ctx.beginPath();\n\n        ctx.fillStyle = this.color;\n\n        ctx.moveTo(this.p.x, this.p.y);\n\n        ctx.arc(this.p.x, this.p.y, this.r, 0, Branch.circle, true);\n\n        ctx.fill();\n    },\n\n    modify: function() {\n        var angle = 0.18 - (0.10 / this.generation);\n\n        this.p.add(this.v);\n\n        this.length += this.v.length();\n\n        this.r *= 0.99;\n\n        this.v.rotate(Branch.random(-angle, angle)); //.mult(0.996);\n\n        if (this.r < 0.8 || this.generation > 10) {\n            this.tree.removeBranch(this);\n\n            var l = new Leaf(this.p, 10, this.color, this.tree.ctx);\n\n            l.render();\n        }\n    },\n\n    grow: function() {\n        this.draw();\n\n        this.modify();\n\n        this.fork();\n    },\n\n    fork: function() {\n        var p = this.length - Branch.random(100, 200); // + (this.generation * 10);\n\n        if (p > 0) {\n            var n = Math.round(Branch.random(1, 3));\n\n            this.tree.stat.fork += n - 1;\n\n            for (var i = 0; i < n; i++) {\n                Branch.clone(this);\n            }\n\n            this.tree.removeBranch(this);\n        }\n    }\n\n};\n\n\n\nBranch.circle = 2 * Math.PI;\n\n// 随机点\nBranch.random = function(min, max) {\n    return Math.random() * (max - min) + min;\n};\n\nBranch.clone = function(b) {\n    var r = new Branch(new Vector(b.p.x, b.p.y), new Vector(b.v.x, b.v.y), b.r, b.color, b.tree);\n\n    r.generation = b.generation + 1;\n\n    return r;\n};\n\nBranch.rgba = function(r, g, b, a) {\n    return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n};\n\n// 随机颜色\nBranch.randomrgba = function(min, max, a) {\n    return Branch.rgba(Math.round(Branch.random(min, max)), Math.round(Branch.random(min, max)), Math.round(Branch.random(min, max)), a);\n};\n\n\n\n// 建立树\nvar Tree = function() {\n    var branches = [];\n\n    var timer;\n\n    this.stat = {\n\n        fork: 0,\n\n        length: 0\n\n    };\n\n    this.addBranch = function(b) {\n        branches.push(b);\n    };\n\n    this.removeBranch = function(b) {\n        for (var i = 0; i < branches.length; i++) {\n            if (branches[i] === b) {\n                branches.splice(i, 1);\n\n                return;\n            }\n        }\n    };\n\n    this.render = function(fn) {\n        var that = this;\n\n        timer = setInterval(function() {\n            fn.apply(that, arguments);\n\n            if (branches.length > 0) {\n                for (var i = 0; i < branches.length; i++) {\n                    branches[i].grow();\n                }\n            } else {\n\n                //clearInterval(timer);\n\n            }\n        }, 1000 / 30);\n    };\n\n    // 树调用\n    this.init = function(ctx) {\n        this.ctx = ctx;\n    };\n\n    this.abort = function() {\n        branches = [];\n\n        this.stat = {\n\n            fork: 0,\n\n            length: 0\n\n        }\n    };\n};\n\n\n\n\n// 初始化\nfunction init(canvas, canvas_width, canvas_height) {\n    // init\n\n    var center_x = canvas_width / 2;\n\n    var stretch_factor = 600 / canvas_height;\n\n    var y_speed = 3 / stretch_factor;\n\n    var $statMsg = $(\"#statMsg\");\n\n    // tx\n\n    // var canvas = $('#canvas')[0];\n\n    canvas.width = canvas_width;\n\n    canvas.height = canvas_height;\n\n    var ctx = canvas.getContext(\"2d\");\n\n    ctx.globalCompositeOperation = \"lighter\";\n\n    // tree\n\n    var t = new Tree(); // 实例\n\n    t.init(ctx); // 把定义的ctx复制到实例上\n\n    // 遍历生成树\n    for (var i = 0; i < 5; i++) {\n        new Branch(new Vector(center_x, canvas_height), new Vector(Math.random(-1, 1), -y_speed), 15 / stretch_factor, Branch.randomrgba(0, 255, 0.3), t);\n    }\n\n    t.render(function() {\n        $statMsg.html(this.stat.fork);\n    });\n}\n\nmodule.exports = canvasFunc;\n\n\nvar canvas = this.$refs.myCanvas;\ncanvasF(canvas, elWidthValue, elHeightValue); //调用封装的canvas函数\n",normalizedContent:"# canvas\n\n\n# 动态生成流程图\n\n代码\n\nvar canvasfunc = function(canvas, widthvalue, heightvalue) {\n    if (canvas.getcontext) {\n        console.log(\"你的浏览器支持canvas!\");\n        let cxt = canvas.getcontext(\"2d\")\n        initcanvas(cxt, canvas, widthvalue, heightvalue)\n    } else {\n        console.log(\"你的浏览器不支持canvas!\");\n    }\n}\n\nfunction hoversinglechart(singledata) {\n    console.log(\"---------鼠标事件-----------\");\n    console.log(singledata);\n}\n\n// 初始化\nfunction initcanvas(cxt, canvas, canwidth, canheight) {\n    // init\n    var init = { top: 32, spaceh: 70 }; // 开始第一层\n    var row2 = {\n        y: init.top + init.spaceh,\n        data: [\n            {\n                type: 'step',\n                text: '业务名称1',\n                name: 'step_2_1',\n                arrowarr: [\n                    {\n                        arrow: 'drawbottomtotop',\n                        to: 'step_3_1'\n                    }\n                ],\n                x: '',\n                y: '',\n                requestdata: {}\n            },\n            {\n                type: 'step',\n                text: '业务名称2',\n                name: 'step_2_2',\n                arrowarr: [\n                    {\n                        arrow: 'drawbottomtoleft',\n                        to: 'step_3_2'\n                    }\n                ]\n            },\n            {\n                type: 'step',\n                text: '业务名称3',\n                name: 'step_2_3',\n                arrowarr: [\n                    {\n                        arrow: 'drawbottomtoright',\n                        to: 'step_3_2'\n                    }\n                ]\n            },\n            {\n                type: 'step',\n                name: 'step_2_4',\n                text: '业务名称4',\n                arrowarr: [\n                    {\n                        arrow: 'drawbottomtotop',\n                        to: 'step_7_1'\n                    }\n                ]\n            }\n        ]\n    };\n    row2.data = calchartx(canwidth, row2.data, row2.y);\n    var flowdata = [\n        {\n            row: 1,\n            y: init.top,\n            data: [\n                {\n                    type: 'start',\n                    text: '开始',\n                    name: 'step_1_1',\n                    arrowarr: [\n                        {\n                            arrow: 'drawbottomtotop',\n                            to: 'step_2_1'\n                        },\n                        {\n                            arrow: 'drawbottomtotop',\n                            to: 'step_2_2'\n                        },\n                        {\n                            arrow: 'drawbottomtotop',\n                            to: 'step_2_3'\n                        }, {\n                            arrow: 'drawbottomtotop',\n                            to: 'step_2_4'\n                        }\n                    ],\n                    x: canwidth / 2,\n                    y: ''\n                }\n            ]\n        },\n        {\n            row: 2,\n            y: init.top + init.spaceh,\n            data: row2.data,\n            method: {\n                onmousemove: null,\n                onmouseleave: null,\n                onclick: hoversinglechart\n            }\n        },\n        {\n            row: 3,\n            y: '',\n            data: [{\n                type: 'step',\n                text: '业务名称4',\n                x: row2.data[0].x,\n                name: 'step_3_1',\n                arrowarr: [\n                    {\n                        arrow: 'drawbottomtotop',\n                        to: 'step_4_1'\n                    }\n                ]\n            }, {\n                type: 'step',\n                text: '业务名称5',\n                name: 'step_3_2',\n                x: canwidth / 2,\n                arrowarr: [\n                    {\n                        arrow: 'drawbottomtotop',\n                        to: 'step_4_2'\n                    }\n                ]\n            }]\n        },\n        {\n            row: 4,\n            y: '',\n            data: [{\n                type: 'step',\n                text: '业务名称6',\n                x: row2.data[0].x,\n                name: 'step_4_1',\n                arrowarr: [\n                    {\n                        arrow: 'drawbottomtotop',\n                        to: 'step_5_1'\n                    }\n                ]\n            }, {\n                type: 'step',\n                text: '业务名称7',\n                name: 'step_4_2',\n                x: canwidth / 2,\n                arrowarr: [\n                    {\n                        arrow: 'drawbottomtotop',\n                        to: 'step_5_2'\n                    }\n                ]\n            }]\n        },\n        {\n            row: 5,\n            y: '',\n            data: [{\n                type: 'step',\n                text: '业务名称8',\n                x: row2.data[0].x,\n                name: 'step_5_1',\n                arrowarr: [\n                    {\n                        arrow: 'drawbottomtotop',\n                        to: 'step_6_1'\n                    }\n                ]\n            }, {\n                type: 'step',\n                text: '业务名称9',\n                name: 'step_5_2',\n                x: canwidth / 2,\n                arrowarr: [\n                    {\n                        arrow: 'drawbottomtotop',\n                        to: 'step_6_2'\n                    },\n                    {\n                        arrow: 'drawbottomtotop',\n                        to: 'step_6_3'\n                    }\n                ]\n            }]\n        },\n        {\n            row: 6,\n            y: '',\n            data: [{\n                type: 'step',\n                text: '业务名称10',\n                x: row2.data[0].x,\n                name: 'step_6_1',\n                arrowarr: [\n                    {\n                        arrow: 'drawbottomtoleft',\n                        to: 'step_7_1'\n                    }\n                ]\n            }, {\n                type: 'step',\n                text: '业务名称11',\n                name: 'step_6_2',\n                x: row2.data[1].x,\n                arrowarr: [\n                    {\n                        arrow: 'drawbottomtotop',\n                        to: 'step_7_1'\n                    }\n                ]\n            }, {\n                type: 'step',\n                text: '业务名称12',\n                name: 'step_6_3',\n                x: row2.data[2].x,\n                arrowarr: [\n                    {\n                        arrow: 'drawbottomtotop',\n                        to: 'step_7_1'\n                    }\n                ]\n            }]\n        },\n        {\n            row: 7,\n            y: init.top + init.spaceh * 6 + 10,\n            data: [{\n                type: 'condition',\n                text: '判断条件',\n                x: canwidth / 2,\n                name: 'step_7_1',\n                arrowarr: [\n                    {\n                        arrow: 'drawbottomtotop',\n                        to: 'step_8_1'\n                    },\n                    {\n                        arrow: 'drawbottomtotop',\n                        to: 'step_8_3'\n                    },\n                    {\n                        arrow: 'drawlefttoleft',\n                        to: 'step_6_2'\n                    },\n                    {\n                        arrow: 'drawrighttotop',\n                        to: 'step_8_6'\n                    }\n                ]\n            }]\n        },\n        {\n            row: 8,\n            y: init.top + init.spaceh * 7 + 30,\n            isaverage: true, //平均计算x\n            data: [\n                {\n                    type: 'step',\n                    text: '业务名称12',\n                    name: 'step_8_1',\n                    arrowarr: [\n                        {\n                            arrow: 'drawlefttoleft',\n                            to: 'step_6_1'\n                        }\n                    ],\n                    requestdata: {},\n                    method: {\n                        onmousemove: null,\n                        onmouseleave: null,\n                        onclick: null\n                    }\n                },\n                {\n                    type: 'step',\n                    text: '业务名称4',\n                    name: 'step_8_2',\n                    arrowarr: [\n                        {\n                            arrow: 'drawrighttoleft',\n                            to: 'step_8_3'\n                        }\n                    ]\n                },\n                {\n                    type: 'step',\n                    text: '业务名称4',\n                    name: 'step_8_3',\n                    arrowarr: [\n                        {\n                            arrow: 'drawrighttoleft',\n                            to: 'step_8_4'\n                        }\n                    ]\n                },\n                {\n                    type: 'step',\n                    name: 'step_8_4',\n                    text: '业务名称4',\n                    arrowarr: [\n                        {\n                            arrow: 'drawrighttoleft',\n                            to: 'step_8_5'\n                        }\n                    ]\n                },\n                {\n                    type: 'step',\n                    name: 'step_8_5',\n                    text: '业务名称4',\n                    arrowarr: [\n                        {\n                            arrow: 'drawrighttoleft',\n                            to: 'step_8_6'\n                        }\n                    ]\n                },\n                {\n                    type: 'step',\n                    name: 'step_8_6',\n                    text: '业务名称4',\n                    arrowarr: [\n                        {\n                            arrow: 'drawbottomtotop',\n                            to: 'step_9_1'\n                        }\n                    ]\n                }\n            ]\n        },\n        {\n            row: 9,\n            y: init.top + init.spaceh * 8 + 30,\n            isaverage: true,\n            data: [\n                {\n                    type: 'step',\n                    text: '业务名称4',\n                    name: 'step_9_1',\n                    arrowarr: [\n                        {\n                            arrow: 'drawrighttoleft',\n                            to: 'step_9_2'\n                        }\n                    ],\n                    requestdata: {},\n                    method: {\n                        onmousemove: null,\n                        onmouseleave: null,\n                        onclick: hoversinglechart\n                    }\n                },\n                {\n                    type: 'step',\n                    text: '业务名称4',\n                    name: 'step_9_2',\n                    arrowarr: [\n                        {\n                            arrow: 'drawrighttoleft',\n                            to: 'step_9_3'\n                        }\n                    ]\n                },\n                {\n                    type: 'step',\n                    text: '业务名称4',\n                    name: 'step_9_3',\n                    arrowarr: [\n                        {\n                            arrow: 'drawrighttoleft',\n                            to: 'step_9_4'\n                        }\n                    ]\n                },\n                {\n                    type: 'step',\n                    name: 'step_9_4',\n                    text: '业务名称4',\n                    arrowarr: [\n                        {\n                            arrow: 'drawrighttoleft',\n                            to: 'step_9_5'\n                        }\n                    ]\n                },\n                {\n                    type: 'end',\n                    name: 'step_9_5',\n                    text: '结束',\n                    arrowarr: []\n                }\n            ]\n        }\n    ];\n    drawflowchart(cxt, canvas, flowdata, init.top, init.spaceh);\n}\n\n\n//画流程图\n//画所有的图形：画图和画对应的箭头\nfunction drawflowchart(context, canvas, flowdata, inittop, initspaceh) {\n    //1、判断是否有需要平均计算x的数据\n    flowdata.foreach(function(row) {\n        if (row.isaverage) {\n            row.data = calchartx(canvas.width, row.data, row.y);\n        }\n    });\n    //2、先要画完所有的图形\n    flowdata.foreach(function(row, rowindex) {\n        row.y = row.y ? row.y : (rowindex == 0 ? inittop + initspaceh : inittop + initspaceh * rowindex);\n        row = drawrowchart(context, row);  //画图形\n    });\n    //3、添加要指向的对象，必须要在画完所有图形之后\n    flowdata.foreach(function(row) {\n        row.data.foreach(function(item) {\n            if (item.arrowarr && item.arrowarr.length) {\n                item.arrowarr.foreach(function(mitem) {\n                    mitem = addtoobj(mitem, flowdata);\n                })\n            }\n        })\n    });\n    //4、给所有图形画上对应的画箭头，必须要在前两步完成之后\n    flowdata.foreach(function(row, rowindex) {\n        row.data.foreach(function(item) {\n            if (item.arrowarr && item.arrowarr.length) {\n                drawsinglearrow(context, item);//画箭头\n            }\n        })\n    });\n    //5、给所有元素添加点击和悬浮事件\n    addmethod(canvas, flowdata)\n}\n//当一行有n个图形并且需要平均排列时用此方法计算每个图形的x\nfunction calchartx(canvasw, data, datay) {\n    var startw = 80;\n    var stepw = 120;\n    var condw = 30;\n    var count = 0;\n    for (var i = 0; i < data.length; i++) {\n        if (data[i].type == 'step') {\n            count += stepw;\n        } else if (data[i].type == 'start' || data[i].type == 'end') {\n            count += startw;\n        } else if (data[i].type == 'condition') {\n            count += condw;\n        }\n    }\n    //spacew 计算一行中每个图形的平均间距\n    var spacew = parseint((canvasw - count) / (data.length + 1));\n    //计算坐标x\n    var prevdiv = [], curw = 0;\n    for (var i = 0; i < data.length; i++) {\n        if (data[i].type == 'step') {\n            prevdiv.push(stepw);\n            curw = stepw / 2;\n        } else if (data[i].type == 'start' || data[i].type == 'end') {\n            prevdiv.push(startw);\n            curw = startw / 2;\n        } else if (data[i].type == 'condition') {\n            prevdiv.push(condw);\n            curw = condw / 2;\n        }\n        var prelength = 0;\n        for (var j = 0; j < i; j++) {\n            prelength += prevdiv[j];\n        }\n        var x = spacew * (i + 1) + prelength + curw;\n        var y = data[i].y;\n        data[i]['x'] = x;\n        data[i]['y'] = y || datay;\n    }\n    return data;\n}\n//生成每列对应的图形\nfunction drawrowchart(context, row) {\n    row.data.foreach(function(item, index) {\n        var s = null;\n        item.y = item.y ? item.y : row.y;\n        if (item.type == 'step') {\n            s = new step(context, item.x, item.y, item);\n        } else if (item.type == 'condition') {\n            s = new condition(context, item.x, item.y, item);\n        } else if (item.type == 'end') {\n            s = new end(context, item.x, item.y, item);\n        } else if (item.type == 'start') {\n            s = new start(context, item.x, item.y, item);\n        }\n        item.chartobj = s;\n    })\n    return row;\n}\n//绘制单个的图形\nfunction drawsinglechart(context, item) {\n    var s = '';\n    if (item.type == 'step') {\n        s = new step(context, item.x, item.y, item);\n    } else if (item.type == 'condition') {\n        s = new condition(context, item.x, item.y, item);\n    } else if (item.type == 'end') {\n        s = new end(context, item.x, item.y, item);\n    } else if (item.type == 'start') {\n        s = new start(context, item.x, item.y, item);\n    }\n    item.chartobj = s;\n    return item;\n}\n//每个对象的坐标范围\nfunction calrange(obj) {\n    var newobj = {\n        minx: obj.x - obj.w / 2,\n        maxx: obj.x + obj.w / 2,\n        miny: obj.y - obj.h / 2,\n        maxy: obj.y + obj.h / 2\n    }\n    return newobj;\n}\n//处理每一个箭头需要指向的对象\nfunction addtoobj(arrobj, flowdata) {\n    flowdata.foreach(function(rows) {\n        rows.data.foreach(function(item) {\n            if (item.name == arrobj.to) {\n                arrobj.to = item.chartobj;\n            }\n        })\n    })\n    return arrobj;\n}\n//画每个图形的箭头指向\nfunction drawsinglearrow(context, data) {\n    var step1 = data.chartobj;\n    console.log(step1, '===step1');\n    if (data.arrowarr && data.arrowarr.length) {\n        data.arrowarr.foreach(function(item) {\n            step1[item.arrow](item.to, context);\n        })\n    }\n}\n//清除单个图形\nfunction repaintsinglechart(context, item) {\n    var range = item.chartobj.range;\n    //清除之前画的图形\n    context.clearrect(range.minx - 1, range.miny - 1, item.chartobj.w + 2, item.chartobj.h + 3);\n}\n//给所有图形添加事件\nfunction addmethod(canvas, flowdata) {\n    //给所有图形添加点击事件\n    canvas.onclick = function(ev) {\n        ev = ev || window.event;\n        let ua = navigator.useragent.tolowercase();\n        let isie = ua.indexof(\"compatible\") > -1 && ua.indexof(\"msie\") > -1 && !ua.indexof(\"opera\") > -1; //ie浏览器\n        let isedge = ua.indexof(\"edge\") > -1;\n        let isie11 = ua.tolowercase().match(/rv:([\\d.]+)\\) like gecko/);\n        let curx = (isie || isedge || isie11) ? ev.offsetx : ev.layerx;\n        let cury = (isie || isedge || isie11) ? ev.offsety : ev.layery;\n        flowdata.foreach(function(row, listindex) {\n            row.data.foreach(function(item) {\n                let range = item.chartobj.range;\n                if (curx >= range.minx && curx <= range.maxx && cury >= range.miny && cury <= range.maxy) {\n                    let clickmethod = null;\n                    if (row.method && row.method.onclick) { //如果每行定义了事件\n                        //判断每个元素是否有单独定义事件，如果有，取改元素定义的事件，如果没有取每行定义的事件\n                        if (item.method && item.method.onclick) {\n                            clickmethod = item.method.onclick\n                        } else {\n                            clickmethod = row.method.onclick\n                        }\n                    } else {\n                        if (item.method && item.method.onclick) {\n                            clickmethod = item.method.onclick\n                        } else {\n                            clickmethod = null;\n                        }\n                    }\n                    if (clickmethod instanceof function) {\n                        clickmethod(item);\n                    }\n                }\n            })\n        });\n    };\n    var timer = null;\n    //给所有图形添加mousemove事件\n    canvas.onmousemove = function(ev) {\n        ev = ev || window.event;\n        let ua = navigator.useragent.tolowercase();\n        let isie = ua.indexof(\"compatible\") > -1 && ua.indexof(\"msie\") > -1 && !ua.indexof(\"opera\") > -1; //ie浏览器\n        let isedge = ua.indexof(\"edge\") > -1;\n        let isie11 = ua.tolowercase().match(/rv:([\\d.]+)\\) like gecko/);\n        let curx = (isie || isedge || isie11) ? ev.offsetx : ev.layerx;\n        let cury = (isie || isedge || isie11) ? ev.offsety : ev.layery;\n        cleartimeout(timer);\n        flowdata.foreach(function(row, listindex) {\n            row.data.foreach(function(item) {\n                let range = item.chartobj.range;\n                if (curx >= range.minx && curx <= range.maxx && cury >= range.miny && cury <= range.maxy) {\n                    let clickmethod = null;\n                    if (row.method && row.method.onmousemove) { //如果每行定义了事件\n                        //判断每个元素是否有单独定义事件，如果有，取改元素定义的事件，如果没有取每行定义的事件\n                        if (item.method && item.method.onmousemove) {\n                            clickmethod = item.method.onmousemove\n                        } else {\n                            clickmethod = row.method.onmousemove\n                        }\n                    } else {\n                        if (item.method && item.method.onmousemove) {\n                            clickmethod = item.method.onmousemove\n                        } else {\n                            clickmethod = null;\n                        }\n                    }\n                    if (clickmethod instanceof function) {\n                        timer = settimeout(function() {\n                            clickmethod(item);\n                        }, 1000)\n                    }\n                }\n            })\n        });\n    }\n    //给所有图形添加mouseleave事件\n    canvas.onmouseleave = function(ev) {\n        ev = ev || window.event;\n        let ua = navigator.useragent.tolowercase();\n        let isie = ua.indexof(\"compatible\") > -1 && ua.indexof(\"msie\") > -1 && !ua.indexof(\"opera\") > -1; //ie浏览器\n        let isedge = ua.indexof(\"edge\") > -1;\n        let isie11 = ua.tolowercase().match(/rv:([\\d.]+)\\) like gecko/);\n        let curx = (isie || isedge || isie11) ? ev.offsetx : ev.layerx;\n        let cury = (isie || isedge || isie11) ? ev.offsety : ev.layery;\n        cleartimeout(timer);\n        flowdata.foreach(function(row) {\n            row.data.foreach(function(item) {\n                let range = item.chartobj.range;\n                if (curx >= range.minx && curx <= range.maxx && cury >= range.miny && cury <= range.maxy) {\n                    let clickmethod = null;\n                    if (row.method && row.method.onmouseleave) { //如果每行定义了事件\n                        //判断每个元素是否有单独定义事件，如果有，取改元素定义的事件，如果没有取每行定义的事件\n                        if (item.method && item.method.onmouseleave) {\n                            clickmethod = item.method.onmouseleave\n                        } else {\n                            clickmethod = row.method.onmouseleave\n                        }\n                    } else {\n                        if (item.method && item.method.onmouseleave) {\n                            clickmethod = item.method.onmouseleave\n                        } else {\n                            clickmethod = null;\n                        }\n                    }\n                    if (clickmethod instanceof function) {\n                        clickmethod(item);\n                    }\n                }\n            })\n        });\n    }\n}\n\n/////////////////////////////////////////基本画图形start////////////////////////////////////////////////////////\n//画圆角矩形\nfunction drawroundrect(context, x, y, w, h, item, radius) {\n    radius = radius || 20;\n    context.beginpath();\n    context.arc(x + radius, y + radius, radius, math.pi, math.pi * 3 / 2);\n    context.lineto(w - radius + x, y);\n    context.arc(w - radius + x, radius + y, radius, math.pi * 3 / 2, math.pi * 2);\n    context.lineto(w + x, h + y - radius);\n    context.arc(w - radius + x, h - radius + y, radius, 0, math.pi * 1 / 2);\n    context.lineto(radius + x, h + y);\n    context.arc(radius + x, h - radius + y, radius, math.pi * 1 / 2, math.pi);\n    context.closepath();\n    context.fillstyle = item.color ? (item.color.bgcolor ? item.color.bgcolor : 'rgba(91,155,213,0.5)') : 'white'; //背景颜色\n    context.fill();\n    context.strokestyle = item.color ? (item.color.bordercolor ? item.color.bordercolor : '#5b9bd5') : '#5b9bd5'; //边框颜色\n    context.font = 'normal 14px 微软雅黑';\n    context.fillstyle = item.color ? (item.color.fontcolor ? item.color.fontcolor : '#5b9bd5') : '#5b9bd5'; //文字颜色\n    context.textalign = \"center\";\n    context.filltext(item.text, x + w / 2, y + h / 2 + 6);\n    context.stroke();\n}\n//画菱形\nfunction drawrhombus(context, x, y, l, h, item) {\n    context.beginpath();\n    context.moveto(x, y + h);\n    context.lineto(x - l * 2 - 40, y);\n    context.lineto(x, y - h);\n    context.lineto(x + l * 2 + 40, y);\n    context.closepath();\n    context.strokestyle = item.color ? (item.color.bordercolor ? item.color.bordercolor : '#5b9bd5') : '#5b9bd5'; //边框颜色\n    context.fillstyle = item.color ? (item.color.bgcolor ? item.color.bgcolor : 'rgba(91,155,213,0.5)') : 'white'; //背景颜色\n    context.fill();\n    context.fillstyle = item.color ? (item.color.fontcolor ? item.color.fontcolor : '#5b9bd5') : '#5b9bd5'; //文字颜色\n    context.font = 'normal 14px 微软雅黑';\n    context.filltext(item.text, x, y + 3);\n    context.stroke();\n}\n//计算文本的宽高\nfunction textsize(fontsize, fontfamily, text) {\n    var span = document.createelement(\"span\");\n    var result = {};\n    result.width = span.offsetwidth;\n    result.height = span.offsetheight;\n    span.style.visibility = \"hidden\";\n    span.style.fontsize = fontsize;\n    span.style.fontfamily = fontfamily;\n    span.style.display = \"inline-block\";\n    document.body.appendchild(span);\n    if (typeof span.textcontent !== \"undefined\") {\n        span.textcontent = text;\n    } else {\n        span.innertext = text;\n    }\n    result.width = parsefloat(window.getcomputedstyle(span).width) - result.width;\n    result.height = parsefloat(window.getcomputedstyle(span).height) - result.height;\n    return result;\n}\n//start 圆角矩形对象\nfunction start(context, x, y, item, h, w) {\n    this.flag = 'start';\n    var textstyle = textsize('14px', '微软雅黑', item.text);\n    w = parseint(textstyle.width) + 30;\n    this.h = h || 40;\n    this.w = w || 2 * this.h;\n    this.x = x;\n    this.y = y;\n    this.text = item.text;\n    this.range = calrange(this);\n    drawroundrect(context, x - this.w / 2, y - this.h / 2, this.w, this.h, item);\n}\n//end 圆角矩形对象\nfunction end(context, x, y, item, h, w) {\n    this.flag = 'end';\n    var textstyle = textsize('14px', '微软雅黑', item.text);\n    w = parseint(textstyle.width) + 30;\n    this.h = h || 40;\n    this.w = w || 2 * this.h;\n    this.x = x;\n    this.y = y;\n    this.text = item.text;\n    this.range = calrange(this);\n    drawroundrect(context, x - this.w / 2, y - this.h / 2, this.w, this.h, item, 20);\n}\n//step 矩形对象\nfunction step(context, x, y, item) {\n    this.flag = \"step\";\n    var textstyle = textsize('14px', '微软雅黑', item.text);\n    var w = parseint(textstyle.width) + 30;\n    this.h = 40;\n    this.w = w;\n    this.x = x;\n    this.y = y;\n    this.text = item.text;\n    this.range = calrange(this);\n    context.strokestyle = item.color ? (item.color.bordercolor ? item.color.bordercolor : '#5b9bd5') : '#5b9bd5'; //边框颜色\n    context.strokerect(x - this.w / 2, y - this.h / 2, this.w, this.h);\n    context.fillstyle = item.color ? (item.color.bgcolor ? item.color.bgcolor : 'rgba(91,155,213,0.5)') : 'white'; //背景颜色\n    context.fillrect(x - this.w / 2, y - this.h / 2, this.w, this.h);\n    context.fillstyle = item.color ? (item.color.fontcolor ? item.color.fontcolor : '#5b9bd5') : '#5b9bd5'; //文字颜色\n    context.textalign = 'center';\n    context.font = 'normal 14px 微软雅黑';\n    if (item.text) { context.filltext(item.text, x, y + 4); }\n}\n//condition 菱形对象\nfunction condition(context, x, y, item) {\n    this.flag = \"condition\";\n    var textstyle = textsize('14px', '微软雅黑', item.text);\n    console.log(textstyle, '===textstyle');\n    var w = parseint(textstyle.width) / 4;\n    this.l = w;\n    this.h = 40;\n    this.w = w;\n    this.x = x;\n    this.y = y;\n    this.text = item.text;\n    this.range = calrange(this);\n    drawrhombus(context, x, y, this.l, this.h, item);\n}\n\n/////////////////////////////////////////基本画图形end////////////////////////////////////////////////////////\n\n\n\n////////////////////////////////////////////画箭头/////////////////////////////////////////////////////////////\n//箭头从start圆角矩形bottom——>top\nstart.prototype.drawbottomtotop = function(obj, context) {\n    if (obj.flag == \"step\") {\n        let arrow = new arrow(this.x, this.y + this.h / 2, obj.x, obj.y - obj.h / 2);\n        arrow.drawbottomtotop(context);\n    } else if (obj.flag == \"condition\") {\n        let arrow = new arrow(this.x, this.y + this.h / 2, obj.x, obj.y - obj.l);\n        arrow.drawbottomtotop(context);\n    }\n}\n\n//箭头从step矩形bottom——>right\nstep.prototype.drawbottomtoright = function(obj, context) {\n    var arrow = null;\n    if (obj.flag == \"step\") {\n        arrow = new arrow(this.x, this.y + this.h / 2, obj.x + obj.w / 2, obj.y);\n    } else if (obj.flag == \"condition\") {\n        arrow = new arrow(this.x, this.y + this.h / 2, obj.x + obj.l * 2 + 40, obj.y);\n    } else if (obj.flag == \"start\" || obj.flag == \"end\") {\n        arrow = new arrow(this.x, this.y + this.h / 2, obj.x + obj.w / 2, obj.y);\n    }\n    arrow.drawbottomtoright(context);\n}\n//箭头从step矩形bottom——>left\nstep.prototype.drawbottomtoleft = function(obj, context) {\n    var arrow = null;\n    if (obj.flag == \"step\") {\n        arrow = new arrow(this.x, this.y + this.h / 2, obj.x - obj.w / 2, obj.y);\n    } else if (obj.flag == \"condition\") {\n        arrow = new arrow(this.x, this.y + this.h / 2, obj.x - obj.l * 2 - 40, obj.y);\n    } else if (obj.flag == \"start\" || obj.flag == \"end\") {\n        arrow = new arrow(this.x, this.y + this.h / 2, obj.x - obj.w / 2, obj.y);\n    }\n    arrow.drawbottomtoright(context);\n}\n//箭头从step矩形bottom——>top\nstep.prototype.drawbottomtotop = function(obj, context) {\n    if (obj.flag == \"step\") {\n        let arrow = new arrow(this.x, this.y + this.h / 2, obj.x, obj.y - obj.h / 2);\n        arrow.drawbottomtotop(context);\n    } else if (obj.flag == \"condition\") {\n        let arrow = new arrow(this.x, this.y + this.h / 2, obj.x, obj.y - obj.h);\n        arrow.drawbottomtotop(context);\n    }\n}\n//箭头从step矩形right——>left\nstep.prototype.drawrighttoleft = function(obj, context) {\n    var arrow = null;\n    if (obj.flag == \"step\") {\n        arrow = new arrow(this.x + this.w / 2, this.y, obj.x - obj.w / 2, obj.y);\n    } else if (obj.flag == \"condition\") {\n        arrow = new arrow(this.x + this.w / 2, this.y, obj.x - obj.l * 2 - 40, obj.y);\n    } else if (obj.flag == \"start\" || obj.flag == \"end\") {\n        arrow = new arrow(this.x + this.w / 2, this.y, obj.x - obj.w / 2, obj.y);\n    }\n    arrow.drawlefttorightorrighttoleft(context);\n}\n//箭头从step矩形right——>right\nstep.prototype.drawrighttoright = function(obj, context) {\n    var arrow = null;\n    if (obj.flag == \"step\") {\n        arrow = new arrow(this.x + this.w / 2, this.y, obj.x + obj.w / 2, obj.y);\n    } else if (obj.flag == \"condition\") {\n        arrow = new arrow(this.x + this.w / 2, this.y, obj.x + obj.l * 2 + 40, obj.y);\n    } else if (obj.flag == \"start\" || obj.flag == \"end\") {\n        arrow = new arrow(this.x + this.w / 2, this.y, obj.x + obj.w / 2, obj.y);\n    }\n    arrow.drawrighttoright(context);\n}\n//箭头从step矩形left——>left\nstep.prototype.drawlefttoleft = function(obj, context) {\n    var arrow = null;\n    if (obj.flag == \"step\") {\n        arrow = new arrow(this.x - this.w / 2, this.y, obj.x - obj.w / 2, obj.y);\n    } else if (obj.flag == \"condition\") {\n        arrow = new arrow(this.x - this.w / 2, this.y, obj.x - obj.l * 2 - 40, obj.y);\n    } else if (obj.flag == \"start\" || obj.flag == \"end\") {\n        arrow = new arrow(this.x - this.w / 2, this.y, obj.x - obj.w / 2, obj.y);\n    }\n    arrow.drawlefttoleft(context);\n}\n\n//箭头从condition菱形bottom——>top\ncondition.prototype.drawbottomtotop = function(obj, context) {\n    if (obj.flag == \"step\") {\n        let arrow = new arrow(this.x, this.y + this.h, obj.x, obj.y - obj.h / 2);\n        arrow.drawbottomtotop(context);\n    } else if (obj.flag == \"condition\") {\n        let arrow = new arrow(this.x, this.y + this.l, obj.x, obj.y - obj.l);\n        arrow.drawbottomtotop(context);\n    }\n}\n//箭头从condition菱形right——>top\ncondition.prototype.drawrighttotop = function(obj, context) {\n    if (obj.flag == \"step\") {\n        let arrow = new arrow(this.x + this.l * 2 + 40, this.y, obj.x, obj.y - obj.h / 2);\n        arrow.drawleftorrighttotop(context);\n    } else if (obj.flag == \"condition\") {\n        let arrow = new arrow(this.x + this.l * 2 + 40, this.y, obj.x, obj.y - obj.l);\n        arrow.drawleftorrighttotop(context);\n    }\n}\n//箭头从condition菱形left——>top\ncondition.prototype.drawlefttotop = function(obj, context) {\n    if (obj.flag == \"step\") {\n        let arrow = new arrow(this.x - this.l * 2 - 40, this.y, obj.x, obj.y - obj.h / 2);\n        arrow.drawleftorrighttotop(context);\n    } else if (obj.flag == \"condition\") {\n        let arrow = new arrow(this.x - this.l * 2 - 40, this.y, obj.x, obj.y - obj.l);\n        arrow.drawleftorrighttotop(context);\n    }\n}\n//箭头从condition菱形right——>left\ncondition.prototype.drawrighttoleft = function(obj, context) {\n    if (obj.flag == \"step\") {\n        let arrow = new arrow(this.x + this.l * 2 + 40, this.y, obj.x - this.w / 2, obj.y);\n        arrow.drawlefttorightorrighttoleft(context);\n    } else if (obj.flag == \"condition\") {\n        let arrow = new arrow(this.x + this.l * 2 + 40, this.y, obj.x - this.l * 2, obj.y);\n        arrow.drawlefttorightorrighttoleft(context);\n    }\n}\n//箭头从condition菱形left——>right\ncondition.prototype.drawlefttoright = function(obj, context) {\n    if (obj.flag == \"step\") {\n        let arrow = new arrow(this.x - this.l * 2 - 40, this.y, obj.x + this.w / 2, obj.y);\n        arrow.drawlefttorightorrighttoleft(context);\n    } else if (obj.flag == \"condition\") {\n        let arrow = new arrow(this.x - this.l * 2 - 40, this.y, obj.x + this.l * 2, obj.y);\n        arrow.drawlefttorightorrighttoleft(context);\n    }\n}\n//箭头从condition菱形right——>right\ncondition.prototype.drawrighttoright = function(obj, context) {\n    if (obj.flag == \"step\") {\n        let arrow = new arrow(this.x + this.l * 2 + 40, this.y, obj.x + this.w / 2 + 40, obj.y);\n        arrow.drawrighttoright(context);\n    } else if (obj.flag == \"condition\") {\n        let arrow = new arrow(this.x + this.l * 2 + 40, this.y, obj.x + this.l * 2 + 40, obj.y);\n        arrow.drawrighttoright(context);\n    }\n}\n//箭头从condition菱形left——>left\ncondition.prototype.drawlefttoleft = function(obj, context) {\n    if (obj.flag == \"step\") {\n        let arrow = new arrow(this.x - this.l * 2 - 40, this.y, obj.x - this.w / 2 - 40, obj.y);\n        arrow.drawlefttoleft(context);\n    } else if (obj.flag == \"condition\") {\n        let arrow = new arrow(this.x - this.l * 2 - 40, this.y, obj.x - this.l * 2 - 40, obj.y);\n        arrow.drawlefttoleft(context);\n    }\n}\n\n\n/////////////////////////////////////////画箭头start/////////////////////////////////////\nfunction arrow(x1, y1, x2, y2) {\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n    this.tmpx1 = null;\n    this.tmpy1 = null;\n    this.tmpx2 = null;\n    this.tmpy2 = null;\n    this.color = \"#5b9bd5\";\n}\narrow.prototype.setcolor = function(color) {\n    this.color = color;\n}\n/**\n *\n * @param {object} x1起始点横坐标\n * @param {object} y1起始点纵坐标\n * @param {object} x2结束点横坐标\n * @param {object} y2结束点纵坐标\n */\narrow.prototype.setp = function(x1, y1, x2, y2) {\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n}\n//第一个拐点\narrow.prototype.setp1 = function(tmpx1, tmpy1) {\n    this.tmpx1 = tmpx1;\n    this.tmpy1 = tmpy1;\n}\n//第二个拐点\narrow.prototype.setp2 = function(tmpx2, tmpy2) {\n    this.tmpx2 = tmpx2;\n    this.tmpy2 = tmpy2;\n}\narrow.prototype.drawbottomtotop = function(ctx) {\n    if (this.x1 != this.x2) {\n        this.setp1(this.x1, (this.y1 + this.y2) / 2);\n        this.setp2(this.x2, (this.y1 + this.y2) / 2);\n        this.draw(ctx);\n    } else {\n        this.draw(ctx);\n    }\n}\narrow.prototype.drawleftorrighttotop = function(ctx) {\n    this.setp1(this.x2, this.y1);\n    this.draw(ctx);\n}\narrow.prototype.drawlefttorightorrighttoleft = function(ctx) {\n    if (this.y1 != this.y2) {\n        this.setp1((this.x1 + this.x2) / 2, this.y1);\n        this.setp2((this.x1 + this.x2) / 2, this.y2);\n        this.draw(ctx);\n    } else {\n        this.draw(ctx);\n    }\n}\narrow.prototype.drawrighttoright = function(ctx) {\n    if (this.y1 != this.y2) {\n        // this.setp1((this.x1 + this.x2) / 2 + 100, this.y1);\n        // this.setp2((this.x1 + this.x2) / 2 + 100, this.y2);\n        if (this.x1 > this.x2) {\n            this.setp1(this.x1 + 20, this.y1);\n            this.setp2(this.x1 + 20, this.y2);\n        } else {\n            this.setp1(this.x2 + 20, this.y1);\n            this.setp2(this.x2 + 20, this.y2);\n        }\n        this.draw(ctx);\n    } else {\n        this.draw(ctx);\n    }\n}\narrow.prototype.drawlefttoleft = function(ctx) {\n    if (this.y1 != this.y2) {\n        // this.setp1((this.x1 + this.x2) / 2 - 100, this.y1);\n        // this.setp2((this.x1 + this.x2) / 2 - 100, this.y2);\n        if (this.x1 < this.x2) {\n            this.setp1(this.x1 - 20, this.y1);\n            this.setp2(this.x1 - 20, this.y2);\n        } else {\n            this.setp1(this.x2 - 20, this.y1);\n            this.setp2(this.x2 - 20, this.y2);\n        }\n        this.draw(ctx);\n    } else {\n        this.draw(ctx);\n    }\n}\narrow.prototype.drawbottomtoright = function(ctx) {\n    if (this.y1 != this.y2) {\n        this.setp1(this.x1, this.y2);\n        this.draw(ctx);\n    } else {\n        this.draw(ctx);\n    }\n}\narrow.prototype.draw = function(ctx) {\n    // arbitrary styling\n    ctx.strokestyle = this.color;\n    ctx.fillstyle = this.color;\n    // draw the line\n    ctx.beginpath();\n    ctx.moveto(this.x1, this.y1);\n    if (this.tmpx1 != null && this.tmpy1 != null && this.tmpx2 != null && this.tmpy2 != null) {\n        ctx.lineto(this.tmpx1, this.tmpy1);\n        ctx.closepath();\n        ctx.stroke();\n        ctx.beginpath();\n        ctx.moveto(this.tmpx1, this.tmpy1)\n        ctx.lineto(this.tmpx2, this.tmpy2);\n        ctx.closepath();\n        ctx.stroke();\n        ctx.beginpath();\n        ctx.moveto(this.tmpx2, this.tmpy2);\n        ctx.lineto(this.x2, this.y2);\n        ctx.closepath();\n        ctx.stroke();\n        let endradians = math.atan((this.y2 - this.tmpy2) / (this.x2 - this.tmpx2));\n        endradians += ((this.x2 >= this.tmpx2) ? 90 : -90) * math.pi / 180;\n        this.drawarrowhead(ctx, this.x2, this.y2, endradians);\n    } else if (this.tmpx1 != null && this.tmpy1 != null && this.tmpx2 == null && this.tmpy2 == null) {\n        ctx.lineto(this.tmpx1, this.tmpy1);\n        ctx.closepath();\n        ctx.stroke();\n        ctx.beginpath();\n        ctx.moveto(this.tmpx1, this.tmpy1)\n        ctx.lineto(this.x2, this.y2);\n        ctx.closepath();\n        ctx.stroke();\n        let endradians = math.atan((this.y2 - this.tmpy1) / (this.x2 - this.tmpx1));\n        endradians += ((this.x2 >= this.tmpx1) ? 90 : -90) * math.pi / 180;\n        this.drawarrowhead(ctx, this.x2, this.y2, endradians);\n    } else if (this.tmpx1 == null && this.tmpy1 == null && this.tmpx2 == null && this.tmpy2 == null) {\n        ctx.lineto(this.x2, this.y2);\n        ctx.closepath();\n        ctx.stroke();\n        let endradians = math.atan((this.y2 - this.y1) / (this.x2 - this.x1));\n        endradians += ((this.x2 >= this.x1) ? 90 : -90) * math.pi / 180;\n        this.drawarrowhead(ctx, this.x2, this.y2, endradians);\n    }\n}\narrow.prototype.drawarrowhead = function(ctx, x, y, radians) {\n    ctx.save();\n    ctx.beginpath();\n    ctx.translate(x, y);\n    ctx.rotate(radians);\n    ctx.moveto(0, 0);\n    ctx.lineto(5, 10);\n    ctx.lineto(-5, 10);\n    ctx.closepath();\n    ctx.restore();\n    ctx.fill();\n}\n\nmodule.exports = canvasfunc;\n\n\n\nvar canvas = this.$refs.mycanvas;\ncanvasf(canvas, elwidthvalue, elheightvalue); //调用封装的canvas函数\n\n\n\n# 动态生成树\n\nvar canvasfunc = function(canvas, widthvalue, heightvalue) {\n    if (canvas.getcontext) {\n        console.log(\"你的浏览器支持canvas!\");\n        let ctx = canvas.getcontext(\"2d\")\n\n        init(canvas, widthvalue, heightvalue)\n    } else {\n        console.log(\"你的浏览器不支持canvas!\");\n    }\n}\n\nvar vector = function(x, y) {\n    this.x = x || 0;\n\n    this.y = y || 0;\n};\n\nvector.prototype = {\n\n    add: function(v) {\n        this.x += v.x;\n\n        this.y += v.y;\n\n        return this;\n    },\n\n    length: function() {\n        return math.sqrt(this.x * this.x + this.y * this.y);\n    },\n\n    rotate: function(theta) {\n        var x = this.x;\n\n        var y = this.y;\n\n        this.x = math.cos(theta) * this.x - math.sin(theta) * this.y;\n\n        this.y = math.sin(theta) * this.x + math.cos(theta) * this.y;\n\n        //this.x = math.cos(theta) * x - math.sin(theta) * y;\n\n        //this.y = math.sin(theta) * x + math.cos(theta) * y;\n\n        return this;\n    },\n\n    mult: function(f) {\n        this.x *= f;\n\n        this.y *= f;\n\n        return this;\n    }\n\n};\n\n\n\nvar leaf = function(p, r, c, ctx) {\n    this.p = p || null;\n\n    this.r = r || 0;\n\n    this.c = c || 'rgba(255,255,255,1.0)';\n\n    this.ctx = ctx;\n}\n\n\n\nleaf.prototype = {\n\n    render: function() {\n        var that = this;\n\n        var ctx = this.ctx;\n\n        var f = branch.random(1, 2)\n\n        for (var i = 0; i < 5; i++) {\n            (function(r) {\n                settimeout(function() {\n                    ctx.beginpath();\n\n                    ctx.fillstyle = that.color;\n\n                    ctx.moveto(that.p.x, that.p.y);\n\n                    ctx.arc(that.p.x, that.p.y, r, 0, branch.circle, true);\n\n                    ctx.fill();\n                }, r * 60);\n            })(i);\n        }\n    }\n\n}\n\n\n\n\n// 单独树的建立\nvar branch = function(p, v, r, c, t) {\n    this.p = p || null;\n\n    this.v = v || null;\n\n    this.r = r || 0;\n\n    this.length = 0;\n\n    this.generation = 1;\n\n    this.tree = t || null;\n\n    this.color = c || 'rgba(255,255,255,1.0)';\n\n    this.register();\n};\n\n\n\nbranch.prototype = {\n\n    register: function() {\n        this.tree.addbranch(this); // 增加树枝（分支）\n    },\n\n    draw: function() {\n        var ctx = this.tree.ctx;\n\n        ctx.beginpath();\n\n        ctx.fillstyle = this.color;\n\n        ctx.moveto(this.p.x, this.p.y);\n\n        ctx.arc(this.p.x, this.p.y, this.r, 0, branch.circle, true);\n\n        ctx.fill();\n    },\n\n    modify: function() {\n        var angle = 0.18 - (0.10 / this.generation);\n\n        this.p.add(this.v);\n\n        this.length += this.v.length();\n\n        this.r *= 0.99;\n\n        this.v.rotate(branch.random(-angle, angle)); //.mult(0.996);\n\n        if (this.r < 0.8 || this.generation > 10) {\n            this.tree.removebranch(this);\n\n            var l = new leaf(this.p, 10, this.color, this.tree.ctx);\n\n            l.render();\n        }\n    },\n\n    grow: function() {\n        this.draw();\n\n        this.modify();\n\n        this.fork();\n    },\n\n    fork: function() {\n        var p = this.length - branch.random(100, 200); // + (this.generation * 10);\n\n        if (p > 0) {\n            var n = math.round(branch.random(1, 3));\n\n            this.tree.stat.fork += n - 1;\n\n            for (var i = 0; i < n; i++) {\n                branch.clone(this);\n            }\n\n            this.tree.removebranch(this);\n        }\n    }\n\n};\n\n\n\nbranch.circle = 2 * math.pi;\n\n// 随机点\nbranch.random = function(min, max) {\n    return math.random() * (max - min) + min;\n};\n\nbranch.clone = function(b) {\n    var r = new branch(new vector(b.p.x, b.p.y), new vector(b.v.x, b.v.y), b.r, b.color, b.tree);\n\n    r.generation = b.generation + 1;\n\n    return r;\n};\n\nbranch.rgba = function(r, g, b, a) {\n    return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n};\n\n// 随机颜色\nbranch.randomrgba = function(min, max, a) {\n    return branch.rgba(math.round(branch.random(min, max)), math.round(branch.random(min, max)), math.round(branch.random(min, max)), a);\n};\n\n\n\n// 建立树\nvar tree = function() {\n    var branches = [];\n\n    var timer;\n\n    this.stat = {\n\n        fork: 0,\n\n        length: 0\n\n    };\n\n    this.addbranch = function(b) {\n        branches.push(b);\n    };\n\n    this.removebranch = function(b) {\n        for (var i = 0; i < branches.length; i++) {\n            if (branches[i] === b) {\n                branches.splice(i, 1);\n\n                return;\n            }\n        }\n    };\n\n    this.render = function(fn) {\n        var that = this;\n\n        timer = setinterval(function() {\n            fn.apply(that, arguments);\n\n            if (branches.length > 0) {\n                for (var i = 0; i < branches.length; i++) {\n                    branches[i].grow();\n                }\n            } else {\n\n                //clearinterval(timer);\n\n            }\n        }, 1000 / 30);\n    };\n\n    // 树调用\n    this.init = function(ctx) {\n        this.ctx = ctx;\n    };\n\n    this.abort = function() {\n        branches = [];\n\n        this.stat = {\n\n            fork: 0,\n\n            length: 0\n\n        }\n    };\n};\n\n\n\n\n// 初始化\nfunction init(canvas, canvas_width, canvas_height) {\n    // init\n\n    var center_x = canvas_width / 2;\n\n    var stretch_factor = 600 / canvas_height;\n\n    var y_speed = 3 / stretch_factor;\n\n    var $statmsg = $(\"#statmsg\");\n\n    // tx\n\n    // var canvas = $('#canvas')[0];\n\n    canvas.width = canvas_width;\n\n    canvas.height = canvas_height;\n\n    var ctx = canvas.getcontext(\"2d\");\n\n    ctx.globalcompositeoperation = \"lighter\";\n\n    // tree\n\n    var t = new tree(); // 实例\n\n    t.init(ctx); // 把定义的ctx复制到实例上\n\n    // 遍历生成树\n    for (var i = 0; i < 5; i++) {\n        new branch(new vector(center_x, canvas_height), new vector(math.random(-1, 1), -y_speed), 15 / stretch_factor, branch.randomrgba(0, 255, 0.3), t);\n    }\n\n    t.render(function() {\n        $statmsg.html(this.stat.fork);\n    });\n}\n\nmodule.exports = canvasfunc;\n\n\nvar canvas = this.$refs.mycanvas;\ncanvasf(canvas, elwidthvalue, elheightvalue); //调用封装的canvas函数\n",charsets:{cjk:!0}},{title:"前端使用json-server实现模拟数据",frontmatter:{},regularPath:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE.html",relativePath:"前端问题/模拟数据.md",key:"v-a651494e",path:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE.html",headers:[{level:2,title:"前端使用json-server实现模拟数据",slug:"前端使用json-server实现模拟数据",normalizedTitle:"前端使用json-server实现模拟数据",charIndex:2},{level:3,title:"基本使用",slug:"基本使用",normalizedTitle:"基本使用",charIndex:28},{level:3,title:"二、关于其他的补充",slug:"二、关于其他的补充",normalizedTitle:"二、关于其他的补充",charIndex:402},{level:3,title:"三、实现非标准的restfull api方式的接口",slug:"三、实现非标准的restfull-api方式的接口",normalizedTitle:"三、实现非标准的restfull api方式的接口",charIndex:880},{level:3,title:"3、测试登录接口",slug:"_3、测试登录接口",normalizedTitle:"3、测试登录接口",charIndex:1529}],headersStr:"前端使用json-server实现模拟数据 基本使用 二、关于其他的补充 三、实现非标准的restfull api方式的接口 3、测试登录接口",content:'# 前端使用json-server实现模拟数据\n\n\n# 基本使用\n\n1、在项目中安装包\n\nnpm install json-server -D\n\n\n2、在项目的根目录下创建一个文件夹及一个json文件__json_server_mock__/db.json\n\n{\n  "user": []\n}\n\n\n3、在package.json中配置启动脚本\n\n"scripts": {\n    "mock": "json-server ./__json_server_mock__/db.json --watch --port 6000"\n },\n\n\n4、使用api接口测试工具根据restful api规范的方式来提交数据\n\n\n\n5、观察db.json文件是否有数据\n\n6、使用json-server的主要是要先到db.json文件中创建类似表的key,比如上面创建一个user的节点，可以简单理解为数据表\n\n\n# 二、关于其他的补充\n\n1、根据字段排序返回数据\n\n# 根据字段id降序查询数据\n\nlocalhost:6000/user?_sort=id&_order=desc\n\n# 如果多个字段排序,字段间用,分开\n\nlocalhost:6000/user?_sort=id,username&_order=desc,desc\n\n\n2、分页查询数据\n\n# _start开始查询的 _limit查询的数量\n\nlocalhost:6000/user?_start=1&_limit=2\n\n\n3、一些常见的操作符\n\n_gte大于，_lte小于， _ne非， _like 模糊查询\n\n# username模糊查询带有五\n\nlocalhost:6000/user?username_like=五\n\n# 查询id大于等于3的\n\nlocalhost:6000/user?id_gte=3\n\n\n4、多个id的查询\n\nlocalhost:6000/user?id=1&id=3\n\n\n5、全文模糊查询\n\n# 模糊查询里面有五的\n\nlocalhost:6000/user?q=五\n\n\n\n# 三、实现非标准的restfull api方式的接口\n\n正常的json-server只能实现标准的restfull api的操作，对于非标准的，比如登录和注册就不能实现了，这时候就要我们使用中间件来操作\n\n1、在__json_server_mock__/文件夹下创建一个中间件的文件\n\nmodule.exports = (req, res, next) => {\n  if (req.method === "POST" && req.path === "/login") {\n    if (req.body.username === "admin" && req.body.password === "123456") {\n      return res.status(200).json({\n        user: {\n          token: "123",\n        },\n      });\n    } else {\n      return res.status(400).json({ message: "用户名或者密码错误" });\n    }\n  }\n  next();\n};\n\n\n2、配置启动脚本\n\n"json-api": "json-server __json_server_mock__/db.json --watch --port 5000 --middlewares ./__json_server_mock__/middleware.js"\n\n\n\n# 3、测试登录接口',normalizedContent:'# 前端使用json-server实现模拟数据\n\n\n# 基本使用\n\n1、在项目中安装包\n\nnpm install json-server -d\n\n\n2、在项目的根目录下创建一个文件夹及一个json文件__json_server_mock__/db.json\n\n{\n  "user": []\n}\n\n\n3、在package.json中配置启动脚本\n\n"scripts": {\n    "mock": "json-server ./__json_server_mock__/db.json --watch --port 6000"\n },\n\n\n4、使用api接口测试工具根据restful api规范的方式来提交数据\n\n\n\n5、观察db.json文件是否有数据\n\n6、使用json-server的主要是要先到db.json文件中创建类似表的key,比如上面创建一个user的节点，可以简单理解为数据表\n\n\n# 二、关于其他的补充\n\n1、根据字段排序返回数据\n\n# 根据字段id降序查询数据\n\nlocalhost:6000/user?_sort=id&_order=desc\n\n# 如果多个字段排序,字段间用,分开\n\nlocalhost:6000/user?_sort=id,username&_order=desc,desc\n\n\n2、分页查询数据\n\n# _start开始查询的 _limit查询的数量\n\nlocalhost:6000/user?_start=1&_limit=2\n\n\n3、一些常见的操作符\n\n_gte大于，_lte小于， _ne非， _like 模糊查询\n\n# username模糊查询带有五\n\nlocalhost:6000/user?username_like=五\n\n# 查询id大于等于3的\n\nlocalhost:6000/user?id_gte=3\n\n\n4、多个id的查询\n\nlocalhost:6000/user?id=1&id=3\n\n\n5、全文模糊查询\n\n# 模糊查询里面有五的\n\nlocalhost:6000/user?q=五\n\n\n\n# 三、实现非标准的restfull api方式的接口\n\n正常的json-server只能实现标准的restfull api的操作，对于非标准的，比如登录和注册就不能实现了，这时候就要我们使用中间件来操作\n\n1、在__json_server_mock__/文件夹下创建一个中间件的文件\n\nmodule.exports = (req, res, next) => {\n  if (req.method === "post" && req.path === "/login") {\n    if (req.body.username === "admin" && req.body.password === "123456") {\n      return res.status(200).json({\n        user: {\n          token: "123",\n        },\n      });\n    } else {\n      return res.status(400).json({ message: "用户名或者密码错误" });\n    }\n  }\n  next();\n};\n\n\n2、配置启动脚本\n\n"json-api": "json-server __json_server_mock__/db.json --watch --port 5000 --middlewares ./__json_server_mock__/middleware.js"\n\n\n\n# 3、测试登录接口',charsets:{cjk:!0}},{title:"introduce",frontmatter:{},regularPath:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/",relativePath:"前端问题/前端基础/README.md",key:"v-7e14e6f9",path:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/",headersStr:null,content:"# introduce",normalizedContent:"# introduce",charsets:{}},{title:"js",frontmatter:{},regularPath:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/jsBase.html",relativePath:"前端问题/前端基础/jsBase.md",key:"v-fef8d78c",path:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/jsBase.html",headers:[{level:2,title:"iframe子页面跳转，父页面跳出子页面返回上一页",slug:"iframe子页面跳转-父页面跳出子页面返回上一页",normalizedTitle:"iframe子页面跳转，父页面跳出子页面返回上一页",charIndex:9},{level:2,title:"Date日期对象",slug:"date日期对象",normalizedTitle:"date日期对象",charIndex:500},{level:2,title:"js随机生成1-100的数",slug:"js随机生成1-100的数",normalizedTitle:"js随机生成1-100的数",charIndex:3083},{level:2,title:"js下载文档",slug:"js下载文档",normalizedTitle:"js下载文档",charIndex:3145},{level:3,title:"window.open下载文件",slug:"window-open下载文件",normalizedTitle:"window.open下载文件",charIndex:3156},{level:3,title:"a标签下载文件",slug:"a标签下载文件",normalizedTitle:"a标签下载文件",charIndex:3261},{level:3,title:"input标签下载文件",slug:"input标签下载文件",normalizedTitle:"input标签下载文件",charIndex:3773},{level:3,title:"axios下载文件",slug:"axios下载文件",normalizedTitle:"axios下载文件",charIndex:4561},{level:3,title:"xhr下载文件",slug:"xhr下载文件",normalizedTitle:"xhr下载文件",charIndex:7269},{level:2,title:"js计算字符串的长度",slug:"js计算字符串的长度",normalizedTitle:"js计算字符串的长度",charIndex:9589},{level:2,title:"数字要用千分位来表示，三位数之间要用逗号分隔",slug:"数字要用千分位来表示-三位数之间要用逗号分隔",normalizedTitle:"数字要用千分位来表示，三位数之间要用逗号分隔",charIndex:10165},{level:2,title:"对数据进行重新排序",slug:"对数据进行重新排序",normalizedTitle:"对数据进行重新排序",charIndex:10496},{level:3,title:"对象数组的排序",slug:"对象数组的排序",normalizedTitle:"对象数组的排序",charIndex:10510},{level:3,title:"自定义数据进行排列",slug:"自定义数据进行排列",normalizedTitle:"自定义数据进行排列",charIndex:10835},{level:3,title:"数组从大到小排序，去除重复值",slug:"数组从大到小排序-去除重复值",normalizedTitle:"数组从大到小排序，去除重复值",charIndex:11221},{level:2,title:"循环的终止",slug:"循环的终止",normalizedTitle:"循环的终止",charIndex:11892},{level:3,title:"break和continue的区别",slug:"break和continue的区别",normalizedTitle:"break和continue的区别",charIndex:11902},{level:2,title:"XSS攻击防范",slug:"xss攻击防范",normalizedTitle:"xss攻击防范",charIndex:12387},{level:3,title:"前端安全系列之xss攻击防范",slug:"前端安全系列之xss攻击防范",normalizedTitle:"前端安全系列之xss攻击防范",charIndex:12399},{level:3,title:"v-html防止xss注入",slug:"v-html防止xss注入",normalizedTitle:"v-html防止xss注入",charIndex:14022},{level:2,title:"this相关",slug:"this相关",normalizedTitle:"this相关",charIndex:14336},{level:3,title:"call(), .apply() .bind() 的区别和作用？bind 方法如何来实现？",slug:"call-apply-bind-的区别和作用-bind-方法如何来实现",normalizedTitle:"call(), .apply() .bind() 的区别和作用？bind 方法如何来实现？",charIndex:14347},{level:3,title:"如何判断this？箭头函数的this是什么？",slug:"如何判断this-箭头函数的this是什么",normalizedTitle:"如何判断this？箭头函数的this是什么？",charIndex:15214},{level:2,title:"js 禁止退出当前页面",slug:"js-禁止退出当前页面",normalizedTitle:"js 禁止退出当前页面",charIndex:15979},{level:2,title:"清除网页历史记录，屏蔽后退按钮!",slug:"清除网页历史记录-屏蔽后退按钮",normalizedTitle:"清除网页历史记录，屏蔽后退按钮!",charIndex:16905},{level:2,title:"微信链接重定向之后后退两次才能退出当前页面问题解决",slug:"微信链接重定向之后后退两次才能退出当前页面问题解决",normalizedTitle:"微信链接重定向之后后退两次才能退出当前页面问题解决",charIndex:16965}],headersStr:"iframe子页面跳转，父页面跳出子页面返回上一页 Date日期对象 js随机生成1-100的数 js下载文档 window.open下载文件 a标签下载文件 input标签下载文件 axios下载文件 xhr下载文件 js计算字符串的长度 数字要用千分位来表示，三位数之间要用逗号分隔 对数据进行重新排序 对象数组的排序 自定义数据进行排列 数组从大到小排序，去除重复值 循环的终止 break和continue的区别 XSS攻击防范 前端安全系列之xss攻击防范 v-html防止xss注入 this相关 call(), .apply() .bind() 的区别和作用？bind 方法如何来实现？ 如何判断this？箭头函数的this是什么？ js 禁止退出当前页面 清除网页历史记录，屏蔽后退按钮! 微信链接重定向之后后退两次才能退出当前页面问题解决",content:'# js\n\n\n# iframe子页面跳转，父页面跳出子页面返回上一页\n\n保留当前的历史记录的length\n\ndata() {\n    return {\n        rlen: history.length,\n    }\n}\n\n\n事件：把iframe清除，并计算需要回退的页面\n\nremoveChildIframes() {\n    var iframes = document.getElementsByTagName("iframe");\n    for (var i = iframes.length - 1; i >= 0; i--) {\n        iframes[i].parentNode.removeChild(iframes[i]);\n    }\n    this.$nextTick(() => {\n        let len = this.rlen - history.length - 1; // -1是不进入iframe页面的下级页面直接退出的话，执行后退一步的操作\n        window.history.go(len);\n    });\n},\n\n\n\n# Date日期对象\n\nW3C https://www.w3school.com.cn/js/js_dates.asp\n\nlayDate 日期与时间组件 https://www.layui.com/laydate/\n\n创建日期对象语法\n\nvar now = new Date()\n\n\n时间的获取\n\nvar now = new Date()\nvar nian = now.getFullYear()   // 从日期对象中获取年份\nvar nian = now.getMonth()+1   // 从日期对象中获取月份\nvar nian = now.getDate()   // 从日期对象中获取日  \nvar nian = now.getHours()   // 从日期对象中获取小时 \nvar nian = now.getMinutes()   // 从日期对象中获取分\nvar nian = now.getSeconds()   // 从日期对象中获取秒\nvar nian = now.getMilliseconds()   // 从日期对象中获取毫秒\nvar nian = Math.floor((this.getMonth()+3)/3)   // 从日期对象中获取季度\n\n\n# 将当前的日期转换为"年月日"的格式\n\n// 转换成 年月日时分秒 这种格式：yyyy-MM-dd hh:mm:ss 或者 yyyy-MM-dd\nDate.prototype.format = function(fmt) { \n    var o = { \n        "M+" : this.getMonth()+1,                 //月份 \n        "d+" : this.getDate(),                    //日 \n        "h+" : this.getHours(),                   //小时 \n        "m+" : this.getMinutes(),                 //分 \n        "s+" : this.getSeconds(),                 //秒 \n        "q+" : Math.floor((this.getMonth()+3)/3), //季度 \n        "S"  : this.getMilliseconds()             //毫秒 \n    }; \n    if(/(y+)/.test(fmt)) {\n        fmt=fmt.replace(RegExp.$1, (this.getFullYear()+"").substr(4 - RegExp.$1.length)); \n    }\n    for(var k in o) {\n        if(new RegExp("("+ k +")").test(fmt)){\n            fmt = fmt.replace(RegExp.$1, (RegExp.$1.length==1) ? (o[k]) : (("00"+ o[k]).substr((""+ o[k]).length)));\n        }\n    }\n    return fmt; \n}\n\n// 调用\nvar time1 = new Date().format("yyyy-MM-dd hh:mm:ss");\nconsole.log(time1);  // 2021-06-07 10:41:00\n\nvar time2 = new Date().format("yyyy-MM-dd");\nconsole.log(time2); // 2021-06-07\n\n\n# 将指定的日期转换为"年月日"的格式\n\nvar oldTime = (new Date("2012/12/25 20:11:11")).getTime();\nvar curTime = new Date(oldTime).format("yyyy-MM-dd");\nconsole.log(curTime);  // 2021-06-07\n\n\n# 将 "时间戳" 转换为 "年月日" 的格式\n\nvar da = 1402233166999;\nda = new Date(da);\nvar year = da.getFullYear()+\'年\';\nvar month = da.getMonth()+1+\'月\';\nvar date = da.getDate()+\'日\';\nconsole.log([year,month,date].join(\'-\')); // 2014年-6月-8日\n\n\n# 判断当前时间的三天范围\n\nisShowHandle(d) {\n    let td = new Date();\n    td = new Date(td.getFullYear(), td.getMonth(), td.getDate());\n    let od = new Date(d);\n    od = new Date(od.getFullYear(), od.getMonth(), od.getDate());\n    const xc = (od - td) / 1000 / 60 / 60 / 24;\n    if (xc < -2) {\n        return false;\n    } else if (xc < -1) {\n        return true;\n    } else if (xc < 0) {\n        return true;\n    } else if (xc == 0) {\n        return true;\n    } else if (xc < 2) {\n        return false;\n    } else if (xc < 3) {\n        return false;\n    } else {\n        return false;\n    }\n},\n\n\n\n\n# js随机生成1-100的数\n\nMath.floor(Math.random() * (100 - 1) + 1)\n\n\n\n# js下载文档\n\n\n# window.open下载文件\n\nwindow.open("https://codeload.github.com/douban/douban-client/legacy.zip/master");\n\n\n\n# a标签下载文件\n\n// 下载\nfunction exportClick() {\n    let FileName = this.listData.fileName;\n    let fileId = this.listData.fileId;\n    let objectUrl = `${DAMP}/uploadAndDownLoadFile/downloadfile?fileId=${fileId}`; // 接口\n    const elink = document.createElement("a");\n    elink.download = FileName; //下载文件名称,\n    elink.style.display = "none";\n    elink.href = objectUrl;\n    document.body.appendChild(elink);\n    elink.click();\n    URL.revokeObjectURL(elink.href); // 释放URL 对象\n    document.body.removeChild(elink);\n}\n\n\n\n# input标签下载文件\n\n\nlet objectUrl = REPORT_API + "/decision/view/report";\nconst form = document.createElement("form");\nform.style.display = "none";\nform.setAttribute("target", "_blank");\nform.setAttribute("method", "get");\nform.setAttribute("action", objectUrl);\nconst input = document.createElement("input");\ninput.setAttribute("type", "hidden");\n// 对于get请求 最终会拼成http://192.168.66.183:13666/download?name=HAP.pdf\ninput.setAttribute("reportNo", this.report.reportNo);\ninput.setAttribute("dmp-token", getToken());\ninput.setAttribute("viewlet", this.report.rptDocPathPad);\ninput.setAttribute("op", "export");\ninput.setAttribute("format", format);\ninput.setAttribute("sessionID", sid);\nform.appendChild(input);\ndocument.body.appendChild(form);\nform.submit();\ndocument.body.removeChild(form);\n\n\n\n# axios下载文件\n\nconst form = new FormData();\nform.append("reportNo", this.report.reportNo);\nform.append("dmp-token", getToken());\nform.append("viewlet", this.report.rptDocPathPad);\nform.append("op", "export");\nform.append("format", format);\nform.append("sessionID", sid);\nlet objectUrl = REPORT_API + "/decision/view/report";\nlet fileName = this.getLastdata(this.report.rptDocPathPad, formats);\nthis.$axiosDownload(objectUrl, form, fileName,formats,"GET");\n\n\n// axios的post请求 公用方法下载文件（header传参添加语言）\nexport function axiosDownload(url, data, fileName, formats, method = \'POST\') {\n    // console.log(url, url, _this, fileName, method);\n    let typeFormats = "application/x-xls"\n    if (formats == "pdf") {\n        typeFormats = "application/pdf"\n    }\n    axios({\n        method,\n        url, //接口地址\n        data, //接口参数\n        responseType: "blob",\n        headers: {\n            token: getToken(),\n            // token: localStorage.getItem("access_token"),\n            "Content-Type": typeFormats,\n            // "X-Edsp-Language": Tools.getCurLocale(),\n            // "X-Edsp-Language": "en-US,fr-CA",\n            "X-Edsp-Language": "en-US",\n        },\n    })\n        .then(function(res) {\n        console.log(res, "=====res====axiosDownload");\n        const data = res.data\n        if (data.type === \'application/json\') {\n            let reader = new FileReader()\n            reader.addEventListener(\'loadend\', () => {\n                const { message } = JSON.parse(reader.result)\n                _this.$message({\n                    message: message || _this.$i18ns("ExportFail"),\n                    type: "warning",\n                });\n            })\n            reader.readAsText(data, \'utf-8\')\n        } else {\n            if (!fileName) {\n                fileName =\n                    res.headers["content-disposition"].split("filename=")[1];\n            }\n            let typeFormats = "application/x-xls"\n            if (formats == "pdf") {\n                typeFormats = "application/pdf"\n            }\n            let blob = new Blob([res.data], { type: typeFormats });\n            console.log(blob,"========blob");\n            if (window.navigator.msSaveOrOpenBlob) {\n                navigator.msSaveBlob(blob, fileName);\n            } else {\n                var link = document.createElement("a");\n                link.href = window.URL.createObjectURL(blob);\n                link.download = decodeURI(fileName);\n                link.click();\n                window.URL.revokeObjectURL(link.href);\n            }\n        }\n    })\n        .catch(function(res) {\n        // _this.$message({\n        //   message: _this.$i18ns("ExportFail"),\n        //   type: "warning",\n        // });\n    });\n}\n\n\n\n\n# xhr下载文件\n\n/* \nurl:链接\nformats：格式\ndocName：文件名\n*/\nexport function xhrDownload(url, formats,docName) {\n    // msSaveOrOpenBlob --- 下载并打开；msSaveBlob --- 下载\n    // var isBrowserIE = window.navigator && window.navigator.msSaveOrOpenBlob;\n    var isBrowserIE = window.navigator && window.navigator.msSaveBlob;\n\n    // var dataHref = \'https://example.com/doc.pdf\';\n    var dataHref = url;\n    var xhr = new XMLHttpRequest();\n    let typeFormats = "application/x-xls"\n    if (formats == "pdf") {\n        typeFormats = "application/pdf"\n    }\n    xhr.open(\'GET\', dataHref, true);\n    xhr.setRequestHeader(\'Content-Type\', typeFormats);\n    xhr.setRequestHeader(\'Authorization\', \'Bearer \' + getToken());\n    xhr.responseType = isBrowserIE ? \'blob\' : \'arraybuffer\';\n    xhr.onload = function(e) {\n        if (this.status == 200) {\n            //For IE11\n            if (isBrowserIE) {\n                // Create a new Blob object using the response data of the onload object\n                var blob = new Blob([this.response], { type: typeFormats });\n                // var bool = window.navigator.msSaveOrOpenBlob(blob, docName);\n                var bool = window.navigator.msSaveBlob(blob, docName);\n\n                if (!bool) {\n                    alert("Download failed, Please try again later");\n                }\n            } else {\n                var uInt8Array = new Uint8Array(this.response);\n                var i = uInt8Array.length;\n                var binaryString = new Array(i);\n                while (i--) {\n                    binaryString[i] = String.fromCharCode(uInt8Array[i]);\n                }\n                var data = binaryString.join(\'\');\n\n                var base64 = window.btoa(data);\n\n                var dataUrl = \'data:application/octet-stream;charset=utf-16le;base64,\' + base64;\n                var element = document.createElement(\'a\');\n                element.setAttribute(\'href\', dataUrl);\n                element.setAttribute(\'download\', docName);\n                element.style.display = \'none\';\n                document.body.appendChild(element);\n                element.click();\n                document.body.removeChild(element);\n            }\n        } else {\n            alert("Download failed, Please try again later");\n            closeWindow();\n        }\n    };\n\n    xhr.send();\n}\n\n\n\n# js计算字符串的长度\n\n生成span标签输入内容，然后获取span标签的width，从而得到str的width\n\ngetTextWidthAndHeight(str, fontSize = \'11px\') {\n    var span = document.createElement("text");\n    span.style.display = \'inline-block\'\n    span.innerHTML = str;\n    span.style.fontSize = fontSize;\n    // span.style.lineHeight = "1em";\n    span.style.padding = "0px";\n    span.style.margin = "0px";\n    document.documentElement.appendChild(span)\n    var obj = span.getBoundingClientRect()\n    var width = obj.width;\n    var height = obj.height;\n    span.remove()\n    return {\n        width,\n        height\n    }\n}\n\n\n\n\n# 数字要用千分位来表示，三位数之间要用逗号分隔\n\nfunction format_number(n){\n  var b = parseInt(n).toString();\n  var len = b.length;\n  if(len<=3){return b;}\n  var r=len%3;\n  // b.slice(r,len).match(/\\d{3}/g).join(",") 每三位数加一个逗号。\n  return r > 0 ? b.slice(0,r)+","+b.slice(r,len).match(/\\d{3}/g).join(",")\n  : b.slice(r,len).match(/\\d{3}/g).join(",");\n}\n\n\n\n# 对数据进行重新排序\n\n\n# 对象数组的排序\n\n原数组：\n\nlet arr1 = [\n    {count:1,name:\'小米\'},\n    {count:3,name:\'华为\'},\n    {count:2,name:\'苹果\'}\n]\n\n\nfunction sortBy (field) {\n    //根据传过来的字段进行排序\n    return (x, y) => {\n        return x[field] - y[field]\n    }\n}\n\n\n排序后的数组：\n\narr1.sort(sortBy(\'count\')) \n//[{count:1,name:\'小米\'},{count:2,name:\'苹果\'},{count:3,name:\'华为\'}]\n\n\n\n# 自定义数据进行排列\n\nsortArr(word) {\n    let new_word = [...word]\n    const obj = { \'主\': 0, \'领\': 1, \'报\': 2, \'客\': 3, \'决\': 4, \'挖\': 5, \'外\': 6 };\n    for (let index in word) {\n        let word1 = word[index].instName;\n        let word3 = obj[word1[0]];\n        new_word[index].sortId = word3;\n    }\n    new_word.sort((a, b) => {\n        return a.sortId - b.sortId\n    });\n    return new_word\n},\n\n\n\n# 数组从大到小排序，去除重复值\n\n# 编写一个方法，该方法接收两个参数，分别为 k 和 一个无序的纯数字数组。该方法在执行后，会返回数组中第 k 大的数字。特别注意，如果数组中，有两位数值一样的数字，同数值数字排名并列。如 [3,1,3,2,5,4,5] 中，第 1 大的数字为 5，第2大的数字为 4，第5大的数字为 1？\n\n这道题目考察数组的常用基本操作方法。思路是先做数组内部值的排序，排序完成之后因为需要由大到小所以在反转下数组 。最后在做数组的去重处理，最终返还答案。实现代码如下：\n\nfunction getNum(k, arr) {\n    // 排列数组及反转\n    let res = arr.sort((a,b)=>b-a);\n    // 将数组转化成set去重\n    let set = new Set(res);\n    // 将类数组转回数组\n    let newArr = Array.from(set);\n    if (typeof newArr[k-1] !== "undefined") {\n        // 返回查找到的数据\n        return newArr[k-1];\n    } else {\n        // 未找到数据排除错误\n        throw Error("未找到对应数据");\n    }\n}\nlet arr = [3, 1, 3, 2, 5, 4, 5];\nlet res = getNum(1, arr);\nconsole.log(res);\n\n\n\n# 循环的终止\n\n\n# break和continue的区别\n\n 1. 语句作用不同\n    1. break：在分支结构程序设计中用break语句可以使流程跳出switch结构，继续执行switch语句下面的一个语句；break语句可以用来从循环体内中途跳出循环体，即提前结束循环操作，接着执行循环下面的语句。\n    2. continue：continue语句是跳过循环体中剩余的语句而强制执行下一次循环操作。其作用为结束本次循环，即跳过循环体中下面尚未执行的语句，接着进行下一次是否执行循环的判定。\n 2. 用法不同\n    1. break：在循环语句中，break语句一般都是与if语句一起使用；break语句不能用于循环语句和switch语句之外的任何其它语句中。\n    2. continue：continue语句只能用在循环语句中。一般都是与if语句一起使用。\n 3. 判断不同\n    1. break：break语句是结束整个循环过程，不再判断执行循环的条件是否成立。\n    2. continue：continue语句只结束本次循环，而不是终止整个循环的执行\n\n\n# XSS攻击防范\n\n\n# 前端安全系列之xss攻击防范\n\n 1.  使用textContent\n 2.  使用html转义\n     1. 把js中的标签转成字符\n 3.  对于链接转跳 禁止含有‘Javascript:’开头的字符\n 4.  标签属性中含有恶意执行代码 JavaScript\n 5.  如果用户输入的文本进行过滤很容易照成注入漏洞\n 6.  什么是xss攻击\n     1. cross-site scriping(跨站脚本攻击)为和css区分所以叫xss攻击\n 7.  xss攻击的本质\n     1. 代码未经过滤，混入正常代码中，浏览器无法分辨，导致恶意代码被执行\n 8.  在处理输入时，以下内容都不可信\n     1. 来自用户的UGC信息\n     2. 来自第三方的链接\n     3. URL参数\n     4. POST参数\n     5. referer（可能来自不可信的来源）\n     6. cookie（可能来自其他子域注入）\n 9.  XSS分类\n     1. 根据攻击来源可分为三种：储存型、反射型、DOM型；\n        1. 储存型\n           1. 攻击者将恶意代码提交到目标网站的数据库中，用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在HTML中返回给浏览器\n           2. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行，恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作\n           3. 常见操作带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等\n        2. 反射型\n           1. 攻击者构造出特殊的URL，其中包含恶意代码，用户打开带有恶意代码的URL时，网站服务端将恶意代码从URL中取出，拼接在HTML中返回给浏览器\n           2. 反射型XSS跟储存型XSS的区别是：储存型XSS的恶意代码存在数据库里，反射型XSS的恶意代码存在URL里\n           3. 反射型XSS漏洞常见于通过URL传递参数的功能，如：网站搜索、跳转等\n        3. DOM型\n           1. 攻击者构造出特殊的URL，其中包含恶意代码，用户打开带有恶意代码的URL，用户浏览器接收到响应后解析执行，前端JavaScript取出URL中的恶意代码并执行\n           2. DOM型XSS跟前两种XSS的区别：DOM型XSS攻击中，取出和执行恶意代码由浏览器端完成，属于前端JavaScript自身的安全漏洞，而其他两种XSS都属于服务端的安全漏洞\n 10. XSS攻击预防\n     1. 包含两大要素\n        1. 攻击者提交恶意代码\n        2. 浏览器执行恶意代码\n     2. 两种方式\n        1. 纯前端渲染（当前主流形式）\n           1. 浏览器先加载一个静态HTML，此HTML中不包含任务跟业务相关的数据，然后浏览器执行HTML中的JavaScript，JavaScript通过Ajax加载业务数据，调用DOM API更新到页面上\n           2. 但纯前端渲染还需注意避免DOM型XSS漏洞\n           3. 使用.innerHTML、.outerHTML、document.write()要小心；应尽量使用textContent；如果用vue/react技术栈，并且不适用x-html、dangerouslyInnerHTML功能，就在前端render阶段避免innerHTML、outerHTML的XSS隐患\n        2. 转义HTML\n           1. Java工程里，常用的转义库为org.owasp.encoder\n\n\n# v-html防止xss注入\n\nvue-dompurify-html 插件\n\n# 安装\ncnpm install vue-dompurify-html\n\n# 引⼊\nimport VueDOMPurifyHTML from\'vue-dompurify-html\'\nVue.use(VueDOMPurifyHTML)\n\n# 使用\n<div v-dompurify-html="rawHtml"></div>\n\n\n为什么使⽤vue-dompurify-html，不⽤XSS插件呢？\n\n因为使⽤XSS插件他会把除了标签和内容之外的所有东西都给过滤掉，⽐如class，style这样过滤掉后富⽂本的样式就没有了，美观度⼀下就降低了\n\n\n# this相关\n\n\n# call(), .apply() .bind() 的区别和作用？bind 方法如何来实现？\n\ncall 、apply 、bind 作用是 改变函数执行时的上下文，简而言之就是改变函数运行时的this指向。区别在于调用方式及参数传递上。具体如下：\n\nfunction fn(...args){\n\tconsole.log(this,args);\n}\n\nfn(1,2);  // fn函数默认this指向是 window对象\nlet obj = {\n    myname:"张三"\n}\nfn.call(obj,1,2);  // this 会变成 传入的obj ，args 会变成[1,2];\nfn.apply(obj,[1,2]); // this会变成传入的obj ，传入的参数必须是一个数组；\nfn.bind(obj)(1,2); // this 也会变成传入的obj ，bind不是立即执行需要执行一次\n\n\n综上所述call、apply、bind都可以改变this指向，区别在于 参数传递方式不同，call、apply是立即执行bind不是立即执行。 bind实现如下：\n\nFunction.prototype.myBind = function (context) {\n   // 判断调用对象是否为函数\n   if (typeof this !== "function") {\n     throw new TypeError("Error");\n   }\n\n   // 获取参数\n   var args = [...arguments].slice(1),\n     fn = this;\n\n   return function Fn() {\n\n     // 根据调用方式，传入不同绑定值\n     return fn.apply(this instanceof Fn ? new fn(...arguments) : context, args.concat(...arguments));\n\n   }\n\n }\n\n\n\n# 如何判断this？箭头函数的this是什么？\n\n可以分成三种场景来描述this。 1、函数直接调用中的this。例如：\n\n function foo(){\n    console.log(this);\n}\nfoo();\n\n\n如上this会指向window，需要注意下在严格模式下this会是undefined情况，同样也需要注意在script标签type="module"下也回是undefined。 2.在对象里调用的情况：如下：\n\nlet obj = {\n    myname:"对象",\n    foo:function(){\n        console.log(this);\n    }\n}\nobj.foo(); //this会指向调用的对象\n\n\n3.在构造函数及类中this会指向实例化的对象。如下：\n\nfunction Person(){\n    this.name = "张三"\n}\nPerson.prototype.foo = function(){\n    console.log(this);\n}\n\nlet zhangsan = new Person();\nzhangsan.foo(); //this指向实例化对象zhangsan\n\n\nclass Animal{\n    constructor(name){\n        this.name = name;\n    }\n    foo(){\n        console.log(this);\n    }\n}\n\nlet xiaoqiang = new Animal("小强");\nxiaoqiang.foo(); //this 会指向xiaoqiang\n\n\n最后箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this。\n\n\n# js 禁止退出当前页面\n\nwindow.history.pushState() // 意思是 给窗体添加一条历史记录 //history 历史的意思，pushState () 推动状态 ，方法意思是在历史记录中增加一条新的记录；\n\nwindow.history.replaceState() //replaceState () 替换状态，方法意思是将当前的历史记录给替换掉，传说中的夺舍重生！\n\n* 这两方法分别有 3 个参数： * state：一个与指定网址相关的状态对象，popstate 事件触发时，该对象会传入回调函数。如果不需要这个对象，此处可以填 null。 * title：新页面的标题，但是所有浏览器目前都忽略这个值，就像你保存页面要你输入标题，因此这里可以填 null。 * url：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。一般使用 #，来存放当前地址 * * popstate 事件 ：每当活动历史记录条目在同一文档的两个历史记录条目之间发生变化时，就会将事件分派到窗口。 * 也就是说窗体加载时不会触发 popstate 事件，只有当地址栏发生改变时才会触发 popstate 事件\n\n<script>\n　　function pushHistory() {\n　　　　var state = {\n　　　　　　title: "title",\n　　　　　　url: "#"\n　　　　};\n　　window.history.pushState(state, "title", "#"); // 大家都应该知道 #就代表当前连接，这里是 给地址栏添加一条当前地址的历史记录\n　　}\n　　pushHistory(); // 页面第一次加载，先给地址栏赋个历史记录\n　　// 由于上面只能赋值一次，所以需要通过 popstate 事件触发时，来进行回调这个方法\n　　window.addEventListener("popstate", function(e) { // 给窗体添加一个 popstate 事件触发时 来回调历史记录方法\n　　　　pushHistory();\n　　})\n<\/script>\n\n\n\n# 清除网页历史记录，屏蔽后退按钮!\n\nwindow.history.forward(1); ===== 前进一页\n\n\n# 微信链接重定向之后后退两次才能退出当前页面问题解决\n\n需求：微信内多个H5页面分享出去指定到同一链接\n\n具体实现方式：纯前端实现多个微信H5页面分享出去指定到同一连接；\n\n页面重定向之后发现在微信里点击后退之后，又会重新返回这个页面，必须要连续快速的点击返回才能退出关闭浏览器，\n\n这个用户体验就非常不好，\n\n我们可以手动给浏览器新加一条空的浏览记录‘#’，\n\n然后监控这个#链接，当返回到这个链接的时候，说明用户已经做了后退操作，然后调用微信的jsdk方法来关闭微信浏览器，\n\n这样就实现了点击一次后退就直接退出；\n\n$(function(){\n    pushHistory(); \n    window.addEventListener("popstate", function(e) { \n        wx.closeWindow();\n    }, false); \n    function pushHistory() { \n        var state = { \n            title: "title", \n            url: "#"\n        }; \n        window.history.pushState(state, "title", "#"); \n    } \n})\n',normalizedContent:'# js\n\n\n# iframe子页面跳转，父页面跳出子页面返回上一页\n\n保留当前的历史记录的length\n\ndata() {\n    return {\n        rlen: history.length,\n    }\n}\n\n\n事件：把iframe清除，并计算需要回退的页面\n\nremovechildiframes() {\n    var iframes = document.getelementsbytagname("iframe");\n    for (var i = iframes.length - 1; i >= 0; i--) {\n        iframes[i].parentnode.removechild(iframes[i]);\n    }\n    this.$nexttick(() => {\n        let len = this.rlen - history.length - 1; // -1是不进入iframe页面的下级页面直接退出的话，执行后退一步的操作\n        window.history.go(len);\n    });\n},\n\n\n\n# date日期对象\n\nw3c https://www.w3school.com.cn/js/js_dates.asp\n\nlaydate 日期与时间组件 https://www.layui.com/laydate/\n\n创建日期对象语法\n\nvar now = new date()\n\n\n时间的获取\n\nvar now = new date()\nvar nian = now.getfullyear()   // 从日期对象中获取年份\nvar nian = now.getmonth()+1   // 从日期对象中获取月份\nvar nian = now.getdate()   // 从日期对象中获取日  \nvar nian = now.gethours()   // 从日期对象中获取小时 \nvar nian = now.getminutes()   // 从日期对象中获取分\nvar nian = now.getseconds()   // 从日期对象中获取秒\nvar nian = now.getmilliseconds()   // 从日期对象中获取毫秒\nvar nian = math.floor((this.getmonth()+3)/3)   // 从日期对象中获取季度\n\n\n# 将当前的日期转换为"年月日"的格式\n\n// 转换成 年月日时分秒 这种格式：yyyy-mm-dd hh:mm:ss 或者 yyyy-mm-dd\ndate.prototype.format = function(fmt) { \n    var o = { \n        "m+" : this.getmonth()+1,                 //月份 \n        "d+" : this.getdate(),                    //日 \n        "h+" : this.gethours(),                   //小时 \n        "m+" : this.getminutes(),                 //分 \n        "s+" : this.getseconds(),                 //秒 \n        "q+" : math.floor((this.getmonth()+3)/3), //季度 \n        "s"  : this.getmilliseconds()             //毫秒 \n    }; \n    if(/(y+)/.test(fmt)) {\n        fmt=fmt.replace(regexp.$1, (this.getfullyear()+"").substr(4 - regexp.$1.length)); \n    }\n    for(var k in o) {\n        if(new regexp("("+ k +")").test(fmt)){\n            fmt = fmt.replace(regexp.$1, (regexp.$1.length==1) ? (o[k]) : (("00"+ o[k]).substr((""+ o[k]).length)));\n        }\n    }\n    return fmt; \n}\n\n// 调用\nvar time1 = new date().format("yyyy-mm-dd hh:mm:ss");\nconsole.log(time1);  // 2021-06-07 10:41:00\n\nvar time2 = new date().format("yyyy-mm-dd");\nconsole.log(time2); // 2021-06-07\n\n\n# 将指定的日期转换为"年月日"的格式\n\nvar oldtime = (new date("2012/12/25 20:11:11")).gettime();\nvar curtime = new date(oldtime).format("yyyy-mm-dd");\nconsole.log(curtime);  // 2021-06-07\n\n\n# 将 "时间戳" 转换为 "年月日" 的格式\n\nvar da = 1402233166999;\nda = new date(da);\nvar year = da.getfullyear()+\'年\';\nvar month = da.getmonth()+1+\'月\';\nvar date = da.getdate()+\'日\';\nconsole.log([year,month,date].join(\'-\')); // 2014年-6月-8日\n\n\n# 判断当前时间的三天范围\n\nisshowhandle(d) {\n    let td = new date();\n    td = new date(td.getfullyear(), td.getmonth(), td.getdate());\n    let od = new date(d);\n    od = new date(od.getfullyear(), od.getmonth(), od.getdate());\n    const xc = (od - td) / 1000 / 60 / 60 / 24;\n    if (xc < -2) {\n        return false;\n    } else if (xc < -1) {\n        return true;\n    } else if (xc < 0) {\n        return true;\n    } else if (xc == 0) {\n        return true;\n    } else if (xc < 2) {\n        return false;\n    } else if (xc < 3) {\n        return false;\n    } else {\n        return false;\n    }\n},\n\n\n\n\n# js随机生成1-100的数\n\nmath.floor(math.random() * (100 - 1) + 1)\n\n\n\n# js下载文档\n\n\n# window.open下载文件\n\nwindow.open("https://codeload.github.com/douban/douban-client/legacy.zip/master");\n\n\n\n# a标签下载文件\n\n// 下载\nfunction exportclick() {\n    let filename = this.listdata.filename;\n    let fileid = this.listdata.fileid;\n    let objecturl = `${damp}/uploadanddownloadfile/downloadfile?fileid=${fileid}`; // 接口\n    const elink = document.createelement("a");\n    elink.download = filename; //下载文件名称,\n    elink.style.display = "none";\n    elink.href = objecturl;\n    document.body.appendchild(elink);\n    elink.click();\n    url.revokeobjecturl(elink.href); // 释放url 对象\n    document.body.removechild(elink);\n}\n\n\n\n# input标签下载文件\n\n\nlet objecturl = report_api + "/decision/view/report";\nconst form = document.createelement("form");\nform.style.display = "none";\nform.setattribute("target", "_blank");\nform.setattribute("method", "get");\nform.setattribute("action", objecturl);\nconst input = document.createelement("input");\ninput.setattribute("type", "hidden");\n// 对于get请求 最终会拼成http://192.168.66.183:13666/download?name=hap.pdf\ninput.setattribute("reportno", this.report.reportno);\ninput.setattribute("dmp-token", gettoken());\ninput.setattribute("viewlet", this.report.rptdocpathpad);\ninput.setattribute("op", "export");\ninput.setattribute("format", format);\ninput.setattribute("sessionid", sid);\nform.appendchild(input);\ndocument.body.appendchild(form);\nform.submit();\ndocument.body.removechild(form);\n\n\n\n# axios下载文件\n\nconst form = new formdata();\nform.append("reportno", this.report.reportno);\nform.append("dmp-token", gettoken());\nform.append("viewlet", this.report.rptdocpathpad);\nform.append("op", "export");\nform.append("format", format);\nform.append("sessionid", sid);\nlet objecturl = report_api + "/decision/view/report";\nlet filename = this.getlastdata(this.report.rptdocpathpad, formats);\nthis.$axiosdownload(objecturl, form, filename,formats,"get");\n\n\n// axios的post请求 公用方法下载文件（header传参添加语言）\nexport function axiosdownload(url, data, filename, formats, method = \'post\') {\n    // console.log(url, url, _this, filename, method);\n    let typeformats = "application/x-xls"\n    if (formats == "pdf") {\n        typeformats = "application/pdf"\n    }\n    axios({\n        method,\n        url, //接口地址\n        data, //接口参数\n        responsetype: "blob",\n        headers: {\n            token: gettoken(),\n            // token: localstorage.getitem("access_token"),\n            "content-type": typeformats,\n            // "x-edsp-language": tools.getcurlocale(),\n            // "x-edsp-language": "en-us,fr-ca",\n            "x-edsp-language": "en-us",\n        },\n    })\n        .then(function(res) {\n        console.log(res, "=====res====axiosdownload");\n        const data = res.data\n        if (data.type === \'application/json\') {\n            let reader = new filereader()\n            reader.addeventlistener(\'loadend\', () => {\n                const { message } = json.parse(reader.result)\n                _this.$message({\n                    message: message || _this.$i18ns("exportfail"),\n                    type: "warning",\n                });\n            })\n            reader.readastext(data, \'utf-8\')\n        } else {\n            if (!filename) {\n                filename =\n                    res.headers["content-disposition"].split("filename=")[1];\n            }\n            let typeformats = "application/x-xls"\n            if (formats == "pdf") {\n                typeformats = "application/pdf"\n            }\n            let blob = new blob([res.data], { type: typeformats });\n            console.log(blob,"========blob");\n            if (window.navigator.mssaveoropenblob) {\n                navigator.mssaveblob(blob, filename);\n            } else {\n                var link = document.createelement("a");\n                link.href = window.url.createobjecturl(blob);\n                link.download = decodeuri(filename);\n                link.click();\n                window.url.revokeobjecturl(link.href);\n            }\n        }\n    })\n        .catch(function(res) {\n        // _this.$message({\n        //   message: _this.$i18ns("exportfail"),\n        //   type: "warning",\n        // });\n    });\n}\n\n\n\n\n# xhr下载文件\n\n/* \nurl:链接\nformats：格式\ndocname：文件名\n*/\nexport function xhrdownload(url, formats,docname) {\n    // mssaveoropenblob --- 下载并打开；mssaveblob --- 下载\n    // var isbrowserie = window.navigator && window.navigator.mssaveoropenblob;\n    var isbrowserie = window.navigator && window.navigator.mssaveblob;\n\n    // var datahref = \'https://example.com/doc.pdf\';\n    var datahref = url;\n    var xhr = new xmlhttprequest();\n    let typeformats = "application/x-xls"\n    if (formats == "pdf") {\n        typeformats = "application/pdf"\n    }\n    xhr.open(\'get\', datahref, true);\n    xhr.setrequestheader(\'content-type\', typeformats);\n    xhr.setrequestheader(\'authorization\', \'bearer \' + gettoken());\n    xhr.responsetype = isbrowserie ? \'blob\' : \'arraybuffer\';\n    xhr.onload = function(e) {\n        if (this.status == 200) {\n            //for ie11\n            if (isbrowserie) {\n                // create a new blob object using the response data of the onload object\n                var blob = new blob([this.response], { type: typeformats });\n                // var bool = window.navigator.mssaveoropenblob(blob, docname);\n                var bool = window.navigator.mssaveblob(blob, docname);\n\n                if (!bool) {\n                    alert("download failed, please try again later");\n                }\n            } else {\n                var uint8array = new uint8array(this.response);\n                var i = uint8array.length;\n                var binarystring = new array(i);\n                while (i--) {\n                    binarystring[i] = string.fromcharcode(uint8array[i]);\n                }\n                var data = binarystring.join(\'\');\n\n                var base64 = window.btoa(data);\n\n                var dataurl = \'data:application/octet-stream;charset=utf-16le;base64,\' + base64;\n                var element = document.createelement(\'a\');\n                element.setattribute(\'href\', dataurl);\n                element.setattribute(\'download\', docname);\n                element.style.display = \'none\';\n                document.body.appendchild(element);\n                element.click();\n                document.body.removechild(element);\n            }\n        } else {\n            alert("download failed, please try again later");\n            closewindow();\n        }\n    };\n\n    xhr.send();\n}\n\n\n\n# js计算字符串的长度\n\n生成span标签输入内容，然后获取span标签的width，从而得到str的width\n\ngettextwidthandheight(str, fontsize = \'11px\') {\n    var span = document.createelement("text");\n    span.style.display = \'inline-block\'\n    span.innerhtml = str;\n    span.style.fontsize = fontsize;\n    // span.style.lineheight = "1em";\n    span.style.padding = "0px";\n    span.style.margin = "0px";\n    document.documentelement.appendchild(span)\n    var obj = span.getboundingclientrect()\n    var width = obj.width;\n    var height = obj.height;\n    span.remove()\n    return {\n        width,\n        height\n    }\n}\n\n\n\n\n# 数字要用千分位来表示，三位数之间要用逗号分隔\n\nfunction format_number(n){\n  var b = parseint(n).tostring();\n  var len = b.length;\n  if(len<=3){return b;}\n  var r=len%3;\n  // b.slice(r,len).match(/\\d{3}/g).join(",") 每三位数加一个逗号。\n  return r > 0 ? b.slice(0,r)+","+b.slice(r,len).match(/\\d{3}/g).join(",")\n  : b.slice(r,len).match(/\\d{3}/g).join(",");\n}\n\n\n\n# 对数据进行重新排序\n\n\n# 对象数组的排序\n\n原数组：\n\nlet arr1 = [\n    {count:1,name:\'小米\'},\n    {count:3,name:\'华为\'},\n    {count:2,name:\'苹果\'}\n]\n\n\nfunction sortby (field) {\n    //根据传过来的字段进行排序\n    return (x, y) => {\n        return x[field] - y[field]\n    }\n}\n\n\n排序后的数组：\n\narr1.sort(sortby(\'count\')) \n//[{count:1,name:\'小米\'},{count:2,name:\'苹果\'},{count:3,name:\'华为\'}]\n\n\n\n# 自定义数据进行排列\n\nsortarr(word) {\n    let new_word = [...word]\n    const obj = { \'主\': 0, \'领\': 1, \'报\': 2, \'客\': 3, \'决\': 4, \'挖\': 5, \'外\': 6 };\n    for (let index in word) {\n        let word1 = word[index].instname;\n        let word3 = obj[word1[0]];\n        new_word[index].sortid = word3;\n    }\n    new_word.sort((a, b) => {\n        return a.sortid - b.sortid\n    });\n    return new_word\n},\n\n\n\n# 数组从大到小排序，去除重复值\n\n# 编写一个方法，该方法接收两个参数，分别为 k 和 一个无序的纯数字数组。该方法在执行后，会返回数组中第 k 大的数字。特别注意，如果数组中，有两位数值一样的数字，同数值数字排名并列。如 [3,1,3,2,5,4,5] 中，第 1 大的数字为 5，第2大的数字为 4，第5大的数字为 1？\n\n这道题目考察数组的常用基本操作方法。思路是先做数组内部值的排序，排序完成之后因为需要由大到小所以在反转下数组 。最后在做数组的去重处理，最终返还答案。实现代码如下：\n\nfunction getnum(k, arr) {\n    // 排列数组及反转\n    let res = arr.sort((a,b)=>b-a);\n    // 将数组转化成set去重\n    let set = new set(res);\n    // 将类数组转回数组\n    let newarr = array.from(set);\n    if (typeof newarr[k-1] !== "undefined") {\n        // 返回查找到的数据\n        return newarr[k-1];\n    } else {\n        // 未找到数据排除错误\n        throw error("未找到对应数据");\n    }\n}\nlet arr = [3, 1, 3, 2, 5, 4, 5];\nlet res = getnum(1, arr);\nconsole.log(res);\n\n\n\n# 循环的终止\n\n\n# break和continue的区别\n\n 1. 语句作用不同\n    1. break：在分支结构程序设计中用break语句可以使流程跳出switch结构，继续执行switch语句下面的一个语句；break语句可以用来从循环体内中途跳出循环体，即提前结束循环操作，接着执行循环下面的语句。\n    2. continue：continue语句是跳过循环体中剩余的语句而强制执行下一次循环操作。其作用为结束本次循环，即跳过循环体中下面尚未执行的语句，接着进行下一次是否执行循环的判定。\n 2. 用法不同\n    1. break：在循环语句中，break语句一般都是与if语句一起使用；break语句不能用于循环语句和switch语句之外的任何其它语句中。\n    2. continue：continue语句只能用在循环语句中。一般都是与if语句一起使用。\n 3. 判断不同\n    1. break：break语句是结束整个循环过程，不再判断执行循环的条件是否成立。\n    2. continue：continue语句只结束本次循环，而不是终止整个循环的执行\n\n\n# xss攻击防范\n\n\n# 前端安全系列之xss攻击防范\n\n 1.  使用textcontent\n 2.  使用html转义\n     1. 把js中的标签转成字符\n 3.  对于链接转跳 禁止含有‘javascript:’开头的字符\n 4.  标签属性中含有恶意执行代码 javascript\n 5.  如果用户输入的文本进行过滤很容易照成注入漏洞\n 6.  什么是xss攻击\n     1. cross-site scriping(跨站脚本攻击)为和css区分所以叫xss攻击\n 7.  xss攻击的本质\n     1. 代码未经过滤，混入正常代码中，浏览器无法分辨，导致恶意代码被执行\n 8.  在处理输入时，以下内容都不可信\n     1. 来自用户的ugc信息\n     2. 来自第三方的链接\n     3. url参数\n     4. post参数\n     5. referer（可能来自不可信的来源）\n     6. cookie（可能来自其他子域注入）\n 9.  xss分类\n     1. 根据攻击来源可分为三种：储存型、反射型、dom型；\n        1. 储存型\n           1. 攻击者将恶意代码提交到目标网站的数据库中，用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在html中返回给浏览器\n           2. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行，恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作\n           3. 常见操作带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等\n        2. 反射型\n           1. 攻击者构造出特殊的url，其中包含恶意代码，用户打开带有恶意代码的url时，网站服务端将恶意代码从url中取出，拼接在html中返回给浏览器\n           2. 反射型xss跟储存型xss的区别是：储存型xss的恶意代码存在数据库里，反射型xss的恶意代码存在url里\n           3. 反射型xss漏洞常见于通过url传递参数的功能，如：网站搜索、跳转等\n        3. dom型\n           1. 攻击者构造出特殊的url，其中包含恶意代码，用户打开带有恶意代码的url，用户浏览器接收到响应后解析执行，前端javascript取出url中的恶意代码并执行\n           2. dom型xss跟前两种xss的区别：dom型xss攻击中，取出和执行恶意代码由浏览器端完成，属于前端javascript自身的安全漏洞，而其他两种xss都属于服务端的安全漏洞\n 10. xss攻击预防\n     1. 包含两大要素\n        1. 攻击者提交恶意代码\n        2. 浏览器执行恶意代码\n     2. 两种方式\n        1. 纯前端渲染（当前主流形式）\n           1. 浏览器先加载一个静态html，此html中不包含任务跟业务相关的数据，然后浏览器执行html中的javascript，javascript通过ajax加载业务数据，调用dom api更新到页面上\n           2. 但纯前端渲染还需注意避免dom型xss漏洞\n           3. 使用.innerhtml、.outerhtml、document.write()要小心；应尽量使用textcontent；如果用vue/react技术栈，并且不适用x-html、dangerouslyinnerhtml功能，就在前端render阶段避免innerhtml、outerhtml的xss隐患\n        2. 转义html\n           1. java工程里，常用的转义库为org.owasp.encoder\n\n\n# v-html防止xss注入\n\nvue-dompurify-html 插件\n\n# 安装\ncnpm install vue-dompurify-html\n\n# 引⼊\nimport vuedompurifyhtml from\'vue-dompurify-html\'\nvue.use(vuedompurifyhtml)\n\n# 使用\n<div v-dompurify-html="rawhtml"></div>\n\n\n为什么使⽤vue-dompurify-html，不⽤xss插件呢？\n\n因为使⽤xss插件他会把除了标签和内容之外的所有东西都给过滤掉，⽐如class，style这样过滤掉后富⽂本的样式就没有了，美观度⼀下就降低了\n\n\n# this相关\n\n\n# call(), .apply() .bind() 的区别和作用？bind 方法如何来实现？\n\ncall 、apply 、bind 作用是 改变函数执行时的上下文，简而言之就是改变函数运行时的this指向。区别在于调用方式及参数传递上。具体如下：\n\nfunction fn(...args){\n\tconsole.log(this,args);\n}\n\nfn(1,2);  // fn函数默认this指向是 window对象\nlet obj = {\n    myname:"张三"\n}\nfn.call(obj,1,2);  // this 会变成 传入的obj ，args 会变成[1,2];\nfn.apply(obj,[1,2]); // this会变成传入的obj ，传入的参数必须是一个数组；\nfn.bind(obj)(1,2); // this 也会变成传入的obj ，bind不是立即执行需要执行一次\n\n\n综上所述call、apply、bind都可以改变this指向，区别在于 参数传递方式不同，call、apply是立即执行bind不是立即执行。 bind实现如下：\n\nfunction.prototype.mybind = function (context) {\n   // 判断调用对象是否为函数\n   if (typeof this !== "function") {\n     throw new typeerror("error");\n   }\n\n   // 获取参数\n   var args = [...arguments].slice(1),\n     fn = this;\n\n   return function fn() {\n\n     // 根据调用方式，传入不同绑定值\n     return fn.apply(this instanceof fn ? new fn(...arguments) : context, args.concat(...arguments));\n\n   }\n\n }\n\n\n\n# 如何判断this？箭头函数的this是什么？\n\n可以分成三种场景来描述this。 1、函数直接调用中的this。例如：\n\n function foo(){\n    console.log(this);\n}\nfoo();\n\n\n如上this会指向window，需要注意下在严格模式下this会是undefined情况，同样也需要注意在script标签type="module"下也回是undefined。 2.在对象里调用的情况：如下：\n\nlet obj = {\n    myname:"对象",\n    foo:function(){\n        console.log(this);\n    }\n}\nobj.foo(); //this会指向调用的对象\n\n\n3.在构造函数及类中this会指向实例化的对象。如下：\n\nfunction person(){\n    this.name = "张三"\n}\nperson.prototype.foo = function(){\n    console.log(this);\n}\n\nlet zhangsan = new person();\nzhangsan.foo(); //this指向实例化对象zhangsan\n\n\nclass animal{\n    constructor(name){\n        this.name = name;\n    }\n    foo(){\n        console.log(this);\n    }\n}\n\nlet xiaoqiang = new animal("小强");\nxiaoqiang.foo(); //this 会指向xiaoqiang\n\n\n最后箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this。\n\n\n# js 禁止退出当前页面\n\nwindow.history.pushstate() // 意思是 给窗体添加一条历史记录 //history 历史的意思，pushstate () 推动状态 ，方法意思是在历史记录中增加一条新的记录；\n\nwindow.history.replacestate() //replacestate () 替换状态，方法意思是将当前的历史记录给替换掉，传说中的夺舍重生！\n\n* 这两方法分别有 3 个参数： * state：一个与指定网址相关的状态对象，popstate 事件触发时，该对象会传入回调函数。如果不需要这个对象，此处可以填 null。 * title：新页面的标题，但是所有浏览器目前都忽略这个值，就像你保存页面要你输入标题，因此这里可以填 null。 * url：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。一般使用 #，来存放当前地址 * * popstate 事件 ：每当活动历史记录条目在同一文档的两个历史记录条目之间发生变化时，就会将事件分派到窗口。 * 也就是说窗体加载时不会触发 popstate 事件，只有当地址栏发生改变时才会触发 popstate 事件\n\n<script>\n　　function pushhistory() {\n　　　　var state = {\n　　　　　　title: "title",\n　　　　　　url: "#"\n　　　　};\n　　window.history.pushstate(state, "title", "#"); // 大家都应该知道 #就代表当前连接，这里是 给地址栏添加一条当前地址的历史记录\n　　}\n　　pushhistory(); // 页面第一次加载，先给地址栏赋个历史记录\n　　// 由于上面只能赋值一次，所以需要通过 popstate 事件触发时，来进行回调这个方法\n　　window.addeventlistener("popstate", function(e) { // 给窗体添加一个 popstate 事件触发时 来回调历史记录方法\n　　　　pushhistory();\n　　})\n<\/script>\n\n\n\n# 清除网页历史记录，屏蔽后退按钮!\n\nwindow.history.forward(1); ===== 前进一页\n\n\n# 微信链接重定向之后后退两次才能退出当前页面问题解决\n\n需求：微信内多个h5页面分享出去指定到同一链接\n\n具体实现方式：纯前端实现多个微信h5页面分享出去指定到同一连接；\n\n页面重定向之后发现在微信里点击后退之后，又会重新返回这个页面，必须要连续快速的点击返回才能退出关闭浏览器，\n\n这个用户体验就非常不好，\n\n我们可以手动给浏览器新加一条空的浏览记录‘#’，\n\n然后监控这个#链接，当返回到这个链接的时候，说明用户已经做了后退操作，然后调用微信的jsdk方法来关闭微信浏览器，\n\n这样就实现了点击一次后退就直接退出；\n\n$(function(){\n    pushhistory(); \n    window.addeventlistener("popstate", function(e) { \n        wx.closewindow();\n    }, false); \n    function pushhistory() { \n        var state = { \n            title: "title", \n            url: "#"\n        }; \n        window.history.pushstate(state, "title", "#"); \n    } \n})\n',charsets:{cjk:!0}},{title:"瀑布流",frontmatter:{},regularPath:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E7%80%91%E5%B8%83%E6%B5%81.html",relativePath:"前端问题/瀑布流.md",key:"v-8d05fbae",path:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E7%80%91%E5%B8%83%E6%B5%81.html",headers:[{level:2,title:"1.介绍",slug:"_1-介绍",normalizedTitle:"1.介绍",charIndex:10},{level:3,title:"1.说明：",slug:"_1-说明",normalizedTitle:"1.说明：",charIndex:19},{level:3,title:"2.特点",slug:"_2-特点",normalizedTitle:"2.特点",charIndex:147},{level:3,title:"3.优缺点",slug:"_3-优缺点",normalizedTitle:"3.优缺点",charIndex:190},{level:2,title:"2.纯css实现",slug:"_2-纯css实现",normalizedTitle:"2.纯css实现",charIndex:368},{level:3,title:"方案一：column多行布局",slug:"方案一-column多行布局",normalizedTitle:"方案一：column多行布局",charIndex:381},{level:3,title:"方案二：flex 弹性布局",slug:"方案二-flex-弹性布局",normalizedTitle:"方案二：flex 弹性布局",charIndex:1019},{level:2,title:"3.css+javascript实现",slug:"_3-css-javascript实现",normalizedTitle:"3.css+javascript实现",charIndex:1958},{level:3,title:"方案一：position定位",slug:"方案一-position定位",normalizedTitle:"方案一：position定位",charIndex:2017},{level:3,title:"方案二：js 两列布局实现",slug:"方案二-js-两列布局实现",normalizedTitle:"方案二：js 两列布局实现",charIndex:3500},{level:3,title:"方案三：column+javascript",slug:"方案三-column-javascript",normalizedTitle:"方案三：column+javascript",charIndex:5002},{level:2,title:"4.插件实现：插件vue-waterfall2",slug:"_4-插件实现-插件vue-waterfall2",normalizedTitle:"4.插件实现：插件vue-waterfall2",charIndex:6209},{level:3,title:"1.安装依赖",slug:"_1-安装依赖",normalizedTitle:"1.安装依赖",charIndex:6289},{level:3,title:"2.引入",slug:"_2-引入",normalizedTitle:"2.引入",charIndex:6337}],headersStr:"1.介绍 1.说明： 2.特点 3.优缺点 2.纯css实现 方案一：column多行布局 方案二：flex 弹性布局 3.css+javascript实现 方案一：position定位 方案二：js 两列布局实现 方案三：column+javascript 4.插件实现：插件vue-waterfall2 1.安装依赖 2.引入",content:'# 瀑布流\n\n\n# 1.介绍\n\n\n# 1.说明：\n\n * 页面上是一种 参差不齐 的多栏布局，类似上图所示随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部，大部分为图片，图片 固定 宽度，高度 不一，根据原比例缩放到宽度达到固定的要求，每行排满后，新的图片添加到后面\n\n\n# 2.特点\n\n * 固定宽度，高度不一\n * 岑参不齐的布局\n * 以图片为主\n\n\n# 3.优缺点\n\n# 1.优点\n\n * 节省空间：降低页面的复杂\n * 对于 触屏设备非常友好：通过向上滑动浏览，交互方式更符合直觉\n * 良好的视觉体验：浏览时不会被页面整整齐齐的高度影响，参差不齐，降低浏览的疲劳\n\n# 2.缺点\n\n * 内容总长度 无法掌握\n * 数据过多时，容易造成页面 加载的负荷\n * 再次加载时 很难定位上一次浏览的内容\n\n\n# 2.纯css实现\n\n\n# 方案一：column多行布局\n\n注意\n\ncolumn-count 方式，这种方式IE浏览器不支持（10以下）更适合手机端使用\n\n缺点是：图片是先从上到下排列，再从左到右排列的；而由于排列顺序是先 从上到下， 再左到右，只能用于数据固定， 无法动态的加载追加，对于滚动到底部加载新数据则无法实现。\n\n有时候页面会出现在前几列的最后一个元素的内容被自动断开，一部分在当前列尾，一部分在下一列的列头。这时候子元素可以用 break-inside设置为不被截断 avoid来控制\n\nbreak-inside: avoid; // 不被截断 默认值是auto，会被截断\n\n\ncolumn实现瀑布流主要依赖两个属性\n\ncolumn-count 属性，是控制屏幕分为多少列。\n\ncolumn-gap 属性，是控制列与列之间的距离。\n\n# css代码\n\nbody {\n  margin:0 auto;\n  width:500px;\n}\n.box{\n  column-count: 4;//显示的列数（几列显示）\n  column-gap: 10px;//每列之间的间隔距离\n}\n\n\n# html代码\n\n<body>\n  <div class="box">\n    //这里可以是文字  或者图片 样式自己设置\n    <img src="xx.png">\n    <img src="xx.png">\n    <img src="xx.png">\n  </div>\n</body>\n\n\n\n# 方案二：flex 弹性布局\n\n注意\n\nflex布局方式，使用order可以做到先从左到右，再从上到下显示\n\n缺点：需要预先设定flex容器的高度，且调整页面大小时会出现一些间距过大等适配的问题\n\n# css代码\n\nbody {\n  margin:0 auto;\n  width: 720px;\n}\n.box{\n  display: flex;//flex布局\n  flex-flow: column wrap;//这里进行竖排方式  注意：这里不能用横排否则图片大小不一致情况下无法错位排列\n  height: 1000px;//设置高度使图片进行折行排列\n}\nimg {\n  display: block;\n  width: 25%;//设置25%是想让图片排列4排这里和高度值做个联动\n  height: auto;\n  padding: 2px;\n}\n/*使用order设置图片的排列顺序，从左到右，再从上到下*/ \n/*主要是这里起到作用否则还是上下顺序*/ \nimg:nth-child(4n+1) {order: 1;}\nimg:nth-child(4n+2) {order: 2;}\nimg:nth-child(4n+3) {order: 3;}\nimg:nth-child(4n+4) {order: 4;}\n\n\n# html代码\n\n<body>\n  <div class="box">\n    //这里可以是文字  或者图片 样式自己设置\n    <img src="xx.png">\n    <img src="xx.png">\n    <img src="xx.png">\n  </div>\n</body>\n\n\nflex属性说明\n\nflex 实现瀑布流需要将最外层元素设置为 display: flex，\n\n使用弹性布局flex-flow:column wrap 使其纵向排列并且换行换行\n\n设置 height: 100vh 填充屏幕的高度，也可以设置为单位为 px 的高度，来容纳子元素。\n\n每一列的宽度可用 calc 函数来设置，即 width: calc(100%/3 - 20px)。分成等宽的 3 列减掉左右两遍的 margin 距离。\n\n\n# 3.css+javascript实现\n\n注意\n\n低版本的时候属性无效，这时候就需要javascript来参与\n\n\n# 方案一：position定位\n\n思路\n\njs记录左右两列的所有元素并计算总高度，决定下一个元素的放置位置（注意：元素与元素之间不能用margin,因为这样会影响定位）\n\n# html代码\n\n\x3c!--瀑布流容器--\x3e\n<ul id="content" class="force-column  listcom"></ul>\n\n\n# javascript代码\n\nfunction warterfall(parent, box) {\n  //瀑布流函数,该函数将图片定位到上一行高度最小图片下方,接数据,更新dom后,重新执行该函数\n  //将main下的所有class为box的元素取出来\n  var oParent = $(\'#\'+parent);\n  var oBoxs =oParent.find(\'.\'+box);\n  //计算整个页面显示的列数(页面宽/box的宽);\n  var oBoxW = oBoxs.eq(0).width();\n  var cols = 2;\n  var hArr = [];\n  for (var i = 0; i < oBoxs.length; i++) {\n    var currentBox=oBoxs.eq(i);\n    if (i < cols) {\n      // 将前2张图片的宽度记录到hArr数组中(第一行的高度)\n      hArr.push(currentBox.height());\n    } else {\n      //从第二行开始就开始找最小的高度了，决定待插入图片该插入到哪里\n      // 找到高度最小的值\n      var minH = hArr[0]>hArr[1]?hArr[1]:hArr[0];\n      var index = hArr.indexOf(minH);\n      // 设置最小高度的图片的style为绝对定位，并设置top和left\n      currentBox.css({\n        \'position\':\'absolute\',\n        \'top\': minH ,\n        \'left\': oBoxW * index\n      });\n      //高度叠加\n      hArr[index] += currentBox.height();\n    }\n  }\n};\nfunction forList(list){\n  var HTML = "";\n  for(var i=0;i<list.length;i++){\n    HTML+=\'<li class="item" data="\'+i+\'">\' ;\n    HTML+=\'<div class="box-item">\' ;\n    HTML+=\'<img src="\'+list[i].sIMG+\'" alt=""><div class="text">\'+list[i].sTitle+\'</div>\';\n    HTML+= \'</div>\';\n    HTML+= \'</li>\';\n  }\n  $("#content").append(HTML);\n  setTimeout(function(){\n    warterfall("content", "item");\n  },3000)\n}\nforList(lists1);\n$(".btn").on(\'click\',function () {\n  forList(lists1)\n})\n\n\n\n# 方案二：js 两列布局实现\n\n思路\n\n左右分为两个容器，根据容器的高度（相对低的那一个）决定下一个元素应该放在哪个容器内，这样视觉就实现了瀑布流的效果\n\n# html代码\n\n\x3c!--瀑布流容器--\x3e\n<div id="box"></div>\n\n\n# javascript代码\n\n//接口获取数据，循环展示\nfunction forList(list){\n  var HTML = "";\n  for(var i=0;i<list.length;i++){\n    HTML+=\'<li class="item" data="\'+i+\'">\' ;\n    HTML+=\'<div class="box-item">\' ;\n    HTML+=\'<img src="\'+list[i].sIMG+\'" alt=""><div class="text">\'+list[i].sTitle+\'</div>\';\n    HTML+= \'</div>\';\n    HTML+= \'</li>\';\n  }\n\n  /**\n\t* HTML ;拼接后的字符串\n\t* #box，存放瀑布流的容器\n\t*/\n  // 调用瀑布流函数\n  warterfall(HTML,\'#box\')\n}\n//拉取数据\nforList(lists1);\n// 瀑布流函数\nfunction warterfall(HTML,content) {\n  //生成左右两个容器及暂时存放元素的容器（hidebox）\n  if($(content+\' ul\').length<=0){\n    $(content).append(\'<ul class="left"></ul><ul class="right"></ul><ul id="hidebox" style="display: none;"></ul>\');\n  }\n  //数据先放在一个隐藏的容器，\n  $("#hidebox").html(HTML);\n\n  //取出元素\n  var  items=$("#hidebox li");\n  //获取左右两个容器\n  var leftbox=$(content+\' .left\');\n  var rightbox=$(content+\' .right\');\n  //设置延迟，保证图片加载完成，避免影响左右容器高度的计算，导致数据放到错误的位置\n  setTimeout(function () {\n    // 左边容器高度\n    var leftDivHeight = leftbox.height();\n    // 右边容器高度\n    var rightDivHeight =rightbox.height();\n    items.each(function (index,item) {\n      //瀑布流函数,该函数计算左右容器的总高度，决定把下一个元素放在哪个容器里面\n      //获取左右容器高度\n      leftDivHeight = leftbox.height();\n      rightDivHeight =  rightbox.height();\n      //把下一个元素放在高度低的容器里面\n      if(leftDivHeight<=rightDivHeight) {\n        leftbox.append(item);\n        return;\n      }\n      rightbox.append(item);\n    })\n  },500)\n};\n\n\n\n# 方案三：column+javascript\n\nTIP\n\n处理纯css无法动态的加载追加的缺点\n\nhtml代码\n\n\x3c!--瀑布流容器--\x3e\n<div class="sideBoxFor_box">\n  <div class="sideBoxItem"></div>\n</div>\n\n\ncss代码\n\n.sideBoxFor_box {\n  column-count: 4;\n  column-gap: 15px;\n}\n\n\njavascript代码\n\n// 获取所有的子元素\nvar items = document.querySelectorAll(\'.sideBoxItem\');\n// 定义一个数组，保存每一列的高度\nvar columnHeights = [0, 0, 0, 0];\n// 遍历每一个子元素\nfor (var i = 0; i < items.length; i++) {\n  // 找出最小高度的那一列\n  var minHeight = Math.min.apply(null, columnHeights);\n  console.log(minHeight, "===minHeight");\n  var minIndex = columnHeights.indexOf(minHeight);\n  // 设置该子元素的样式，让其位于最小高度那一列\n  items[i].style.order = minIndex + 1;\n  items[i].style.columnSpan = \'1\'; // 防止被拉伸到两列\n  items[i].style.columnFill = \'balance\'; // 填充所有列\n  items[i].style.webkitColumnBreakInside = \'avoid\'; // 确保不被分列\n  items[i].style.breakInside = \'avoid\';\n  items[i].style.marginBottom = \'20px\';\n  items[i].style.gridColumnStart = minIndex + 1;\n  items[i].style.gridColumnEnd = minIndex + 2;\n  items[i].style.gridRow = columnHeights[minIndex] + items[i].offsetHeight + \'px\';\n  items[i].style.gridRowEnd = columnHeights[minIndex] + items[i].offsetHeight + \'px\';\n  // 更新该列的高度\n  columnHeights[minIndex] += items[i].offsetHeight + 20;\n}\n\n\n\n# 4.插件实现：插件vue-waterfall2\n\n用插件vue-waterfall2 不是很建议使用，一般用于图片的加载，但是复杂的业务就不是很ok了\n\n\n# 1.安装依赖\n\nnpm i vue-waterfall2@latest --save\n\n\n\n# 2.引入\n\nimport waterfall from \'vue-waterfall2\'\nVue.use(waterfall)\n',normalizedContent:'# 瀑布流\n\n\n# 1.介绍\n\n\n# 1.说明：\n\n * 页面上是一种 参差不齐 的多栏布局，类似上图所示随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部，大部分为图片，图片 固定 宽度，高度 不一，根据原比例缩放到宽度达到固定的要求，每行排满后，新的图片添加到后面\n\n\n# 2.特点\n\n * 固定宽度，高度不一\n * 岑参不齐的布局\n * 以图片为主\n\n\n# 3.优缺点\n\n# 1.优点\n\n * 节省空间：降低页面的复杂\n * 对于 触屏设备非常友好：通过向上滑动浏览，交互方式更符合直觉\n * 良好的视觉体验：浏览时不会被页面整整齐齐的高度影响，参差不齐，降低浏览的疲劳\n\n# 2.缺点\n\n * 内容总长度 无法掌握\n * 数据过多时，容易造成页面 加载的负荷\n * 再次加载时 很难定位上一次浏览的内容\n\n\n# 2.纯css实现\n\n\n# 方案一：column多行布局\n\n注意\n\ncolumn-count 方式，这种方式ie浏览器不支持（10以下）更适合手机端使用\n\n缺点是：图片是先从上到下排列，再从左到右排列的；而由于排列顺序是先 从上到下， 再左到右，只能用于数据固定， 无法动态的加载追加，对于滚动到底部加载新数据则无法实现。\n\n有时候页面会出现在前几列的最后一个元素的内容被自动断开，一部分在当前列尾，一部分在下一列的列头。这时候子元素可以用 break-inside设置为不被截断 avoid来控制\n\nbreak-inside: avoid; // 不被截断 默认值是auto，会被截断\n\n\ncolumn实现瀑布流主要依赖两个属性\n\ncolumn-count 属性，是控制屏幕分为多少列。\n\ncolumn-gap 属性，是控制列与列之间的距离。\n\n# css代码\n\nbody {\n  margin:0 auto;\n  width:500px;\n}\n.box{\n  column-count: 4;//显示的列数（几列显示）\n  column-gap: 10px;//每列之间的间隔距离\n}\n\n\n# html代码\n\n<body>\n  <div class="box">\n    //这里可以是文字  或者图片 样式自己设置\n    <img src="xx.png">\n    <img src="xx.png">\n    <img src="xx.png">\n  </div>\n</body>\n\n\n\n# 方案二：flex 弹性布局\n\n注意\n\nflex布局方式，使用order可以做到先从左到右，再从上到下显示\n\n缺点：需要预先设定flex容器的高度，且调整页面大小时会出现一些间距过大等适配的问题\n\n# css代码\n\nbody {\n  margin:0 auto;\n  width: 720px;\n}\n.box{\n  display: flex;//flex布局\n  flex-flow: column wrap;//这里进行竖排方式  注意：这里不能用横排否则图片大小不一致情况下无法错位排列\n  height: 1000px;//设置高度使图片进行折行排列\n}\nimg {\n  display: block;\n  width: 25%;//设置25%是想让图片排列4排这里和高度值做个联动\n  height: auto;\n  padding: 2px;\n}\n/*使用order设置图片的排列顺序，从左到右，再从上到下*/ \n/*主要是这里起到作用否则还是上下顺序*/ \nimg:nth-child(4n+1) {order: 1;}\nimg:nth-child(4n+2) {order: 2;}\nimg:nth-child(4n+3) {order: 3;}\nimg:nth-child(4n+4) {order: 4;}\n\n\n# html代码\n\n<body>\n  <div class="box">\n    //这里可以是文字  或者图片 样式自己设置\n    <img src="xx.png">\n    <img src="xx.png">\n    <img src="xx.png">\n  </div>\n</body>\n\n\nflex属性说明\n\nflex 实现瀑布流需要将最外层元素设置为 display: flex，\n\n使用弹性布局flex-flow:column wrap 使其纵向排列并且换行换行\n\n设置 height: 100vh 填充屏幕的高度，也可以设置为单位为 px 的高度，来容纳子元素。\n\n每一列的宽度可用 calc 函数来设置，即 width: calc(100%/3 - 20px)。分成等宽的 3 列减掉左右两遍的 margin 距离。\n\n\n# 3.css+javascript实现\n\n注意\n\n低版本的时候属性无效，这时候就需要javascript来参与\n\n\n# 方案一：position定位\n\n思路\n\njs记录左右两列的所有元素并计算总高度，决定下一个元素的放置位置（注意：元素与元素之间不能用margin,因为这样会影响定位）\n\n# html代码\n\n\x3c!--瀑布流容器--\x3e\n<ul id="content" class="force-column  listcom"></ul>\n\n\n# javascript代码\n\nfunction warterfall(parent, box) {\n  //瀑布流函数,该函数将图片定位到上一行高度最小图片下方,接数据,更新dom后,重新执行该函数\n  //将main下的所有class为box的元素取出来\n  var oparent = $(\'#\'+parent);\n  var oboxs =oparent.find(\'.\'+box);\n  //计算整个页面显示的列数(页面宽/box的宽);\n  var oboxw = oboxs.eq(0).width();\n  var cols = 2;\n  var harr = [];\n  for (var i = 0; i < oboxs.length; i++) {\n    var currentbox=oboxs.eq(i);\n    if (i < cols) {\n      // 将前2张图片的宽度记录到harr数组中(第一行的高度)\n      harr.push(currentbox.height());\n    } else {\n      //从第二行开始就开始找最小的高度了，决定待插入图片该插入到哪里\n      // 找到高度最小的值\n      var minh = harr[0]>harr[1]?harr[1]:harr[0];\n      var index = harr.indexof(minh);\n      // 设置最小高度的图片的style为绝对定位，并设置top和left\n      currentbox.css({\n        \'position\':\'absolute\',\n        \'top\': minh ,\n        \'left\': oboxw * index\n      });\n      //高度叠加\n      harr[index] += currentbox.height();\n    }\n  }\n};\nfunction forlist(list){\n  var html = "";\n  for(var i=0;i<list.length;i++){\n    html+=\'<li class="item" data="\'+i+\'">\' ;\n    html+=\'<div class="box-item">\' ;\n    html+=\'<img src="\'+list[i].simg+\'" alt=""><div class="text">\'+list[i].stitle+\'</div>\';\n    html+= \'</div>\';\n    html+= \'</li>\';\n  }\n  $("#content").append(html);\n  settimeout(function(){\n    warterfall("content", "item");\n  },3000)\n}\nforlist(lists1);\n$(".btn").on(\'click\',function () {\n  forlist(lists1)\n})\n\n\n\n# 方案二：js 两列布局实现\n\n思路\n\n左右分为两个容器，根据容器的高度（相对低的那一个）决定下一个元素应该放在哪个容器内，这样视觉就实现了瀑布流的效果\n\n# html代码\n\n\x3c!--瀑布流容器--\x3e\n<div id="box"></div>\n\n\n# javascript代码\n\n//接口获取数据，循环展示\nfunction forlist(list){\n  var html = "";\n  for(var i=0;i<list.length;i++){\n    html+=\'<li class="item" data="\'+i+\'">\' ;\n    html+=\'<div class="box-item">\' ;\n    html+=\'<img src="\'+list[i].simg+\'" alt=""><div class="text">\'+list[i].stitle+\'</div>\';\n    html+= \'</div>\';\n    html+= \'</li>\';\n  }\n\n  /**\n\t* html ;拼接后的字符串\n\t* #box，存放瀑布流的容器\n\t*/\n  // 调用瀑布流函数\n  warterfall(html,\'#box\')\n}\n//拉取数据\nforlist(lists1);\n// 瀑布流函数\nfunction warterfall(html,content) {\n  //生成左右两个容器及暂时存放元素的容器（hidebox）\n  if($(content+\' ul\').length<=0){\n    $(content).append(\'<ul class="left"></ul><ul class="right"></ul><ul id="hidebox" style="display: none;"></ul>\');\n  }\n  //数据先放在一个隐藏的容器，\n  $("#hidebox").html(html);\n\n  //取出元素\n  var  items=$("#hidebox li");\n  //获取左右两个容器\n  var leftbox=$(content+\' .left\');\n  var rightbox=$(content+\' .right\');\n  //设置延迟，保证图片加载完成，避免影响左右容器高度的计算，导致数据放到错误的位置\n  settimeout(function () {\n    // 左边容器高度\n    var leftdivheight = leftbox.height();\n    // 右边容器高度\n    var rightdivheight =rightbox.height();\n    items.each(function (index,item) {\n      //瀑布流函数,该函数计算左右容器的总高度，决定把下一个元素放在哪个容器里面\n      //获取左右容器高度\n      leftdivheight = leftbox.height();\n      rightdivheight =  rightbox.height();\n      //把下一个元素放在高度低的容器里面\n      if(leftdivheight<=rightdivheight) {\n        leftbox.append(item);\n        return;\n      }\n      rightbox.append(item);\n    })\n  },500)\n};\n\n\n\n# 方案三：column+javascript\n\ntip\n\n处理纯css无法动态的加载追加的缺点\n\nhtml代码\n\n\x3c!--瀑布流容器--\x3e\n<div class="sideboxfor_box">\n  <div class="sideboxitem"></div>\n</div>\n\n\ncss代码\n\n.sideboxfor_box {\n  column-count: 4;\n  column-gap: 15px;\n}\n\n\njavascript代码\n\n// 获取所有的子元素\nvar items = document.queryselectorall(\'.sideboxitem\');\n// 定义一个数组，保存每一列的高度\nvar columnheights = [0, 0, 0, 0];\n// 遍历每一个子元素\nfor (var i = 0; i < items.length; i++) {\n  // 找出最小高度的那一列\n  var minheight = math.min.apply(null, columnheights);\n  console.log(minheight, "===minheight");\n  var minindex = columnheights.indexof(minheight);\n  // 设置该子元素的样式，让其位于最小高度那一列\n  items[i].style.order = minindex + 1;\n  items[i].style.columnspan = \'1\'; // 防止被拉伸到两列\n  items[i].style.columnfill = \'balance\'; // 填充所有列\n  items[i].style.webkitcolumnbreakinside = \'avoid\'; // 确保不被分列\n  items[i].style.breakinside = \'avoid\';\n  items[i].style.marginbottom = \'20px\';\n  items[i].style.gridcolumnstart = minindex + 1;\n  items[i].style.gridcolumnend = minindex + 2;\n  items[i].style.gridrow = columnheights[minindex] + items[i].offsetheight + \'px\';\n  items[i].style.gridrowend = columnheights[minindex] + items[i].offsetheight + \'px\';\n  // 更新该列的高度\n  columnheights[minindex] += items[i].offsetheight + 20;\n}\n\n\n\n# 4.插件实现：插件vue-waterfall2\n\n用插件vue-waterfall2 不是很建议使用，一般用于图片的加载，但是复杂的业务就不是很ok了\n\n\n# 1.安装依赖\n\nnpm i vue-waterfall2@latest --save\n\n\n\n# 2.引入\n\nimport waterfall from \'vue-waterfall2\'\nvue.use(waterfall)\n',charsets:{cjk:!0}},{title:"可拖拽移动的悬浮图标",frontmatter:{},regularPath:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E6%82%AC%E6%B5%AE%E5%B0%8F%E5%9B%BE%E6%A0%87.html",relativePath:"前端问题/悬浮小图标.md",key:"v-72f0afd8",path:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E6%82%AC%E6%B5%AE%E5%B0%8F%E5%9B%BE%E6%A0%87.html",headers:[{level:2,title:"方案一：",slug:"方案一",normalizedTitle:"方案一：",charIndex:17},{level:3,title:"html",slug:"html",normalizedTitle:"html",charIndex:26},{level:3,title:"css",slug:"css",normalizedTitle:"css",charIndex:431},{level:3,title:"javascript",slug:"javascript",normalizedTitle:"javascript",charIndex:740},{level:2,title:"方案二：",slug:"方案二",normalizedTitle:"方案二：",charIndex:4873},{level:3,title:"html",slug:"html-2",normalizedTitle:"html",charIndex:26},{level:3,title:"javascript",slug:"javascript-2",normalizedTitle:"javascript",charIndex:740},{level:2,title:"方案三：",slug:"方案三",normalizedTitle:"方案三：",charIndex:6465},{level:3,title:"html",slug:"html-3",normalizedTitle:"html",charIndex:26},{level:3,title:"javascript",slug:"javascript-3",normalizedTitle:"javascript",charIndex:740}],headersStr:"方案一： html css javascript 方案二： html javascript 方案三： html javascript",content:'# 可拖拽移动的悬浮图标\n\n\n# 方案一：\n\n\n# html\n\n<div class="viewAssetDetail" ref="pageDiv" @mousemove="demo_move" @mouseup="demo_up"\n     :class="{ zlevelTop: mouseDownState }">\n  <div class="moreModal" ref="actionMgr" :style="position" @mousedown="demo_down">\n    \x3c!--  触发器 --\x3e\n    <div class="imgMore color-font">\n      <span @click="demo_click">\n        <i class="iconfont2 icon-gouwuchekong"></i>\n      </span>\n    </div>\n  </div>\n</div>\n\n\n\n# css\n\n.moreModal {\n  /* 如果碰到滑动问题，1.3 请检查 z-index。z-index需比web大一级*/\n  z-index: 1999;\n  position: absolute;\n  width: 50px;\n  height: 50px;\n  border-radius: 50%;\n  line-height: 40px;\n  text-align: center;\n  color: #fff;\n  // opacity: 0.6;\n}\n.moreModal:hover {\n  opacity: 1;\n}\n.zlevelTop {\n  z-index: 9999;\n}\n\n\n\n# javascript\n\nexport default {\n  name: "clone-on-control",\n  display: "Clone on Control",\n  instruction: "Press Ctrl to clone element from list 1",\n  order: 4,\n  created() {},\n  watch: {},\n  data() {\n    return {\n      position: {\n        //初始位置\n        top: "1.25rem",\n        right: "0rem",\n      },\n      menuOpen: false, //  菜单展开状态\n      mouseDownState: false, //  鼠标点击状态\n      iX: 0,\n      iY: 0,\n      dX: 0,\n      dY: 500, //  初始定位\n      lastMoveIndex: 0, //  拖拽计数\n      curMoveIndex: 0, //  历史计数\n      activeName: "first",\n      activelayoutId: "",\n      marginStyle: " 0 0 0 275px",\n    };\n  },\n  methods: {\n    //  鼠标按下\n    demo_down(event) {\n      //  如果打开了菜单，则不做响应\n      if (this.menuOpen) {\n        this.mouseDownState = false;\n        return;\n      }\n      // console.log("demo_down", event);\n      /* 此处判断  pc 或 移动端 得到 event 事件 */\n      var touch;\n      if (event.touches) {\n        touch = event.touches[0];\n      } else {\n        touch = event;\n      }\n      // 鼠标点击 面向页面 的 x坐标 y坐标\n      let { clientX, clientY } = touch;\n      // 鼠标x坐标 - 拖拽按钮x坐标  得到鼠标 距离 拖拽按钮 的间距\n      this.iX = clientX - this.$refs.actionMgr.offsetLeft;\n      // 鼠标y坐标 - 拖拽按钮y坐标  得到鼠标 距离 拖拽按钮 的间距\n      this.iY = clientY - this.$refs.actionMgr.offsetTop;\n      // 设置当前 状态为 鼠标按下\n      this.mouseDownState = true;\n    },\n    //  鼠标拖拽\n    demo_move(event) {\n      //鼠标按下 切移动中\n      if (this.mouseDownState) {\n        // console.log("demo_move", event);\n        /* 此处判断  pc 或 移动端 得到 event 事件 */\n        var touch;\n        if (event.touches) {\n          touch = event.touches[0];\n        } else {\n          touch = event;\n        }\n        // 鼠标移动时 面向页面 的 x坐标 y坐标\n        let { clientX, clientY } = touch;\n        //当前页面全局容器 dom 元素  获取容器 宽高\n        let { clientHeight: pageDivY, clientWidth: pageDivX } =\n            this.$refs.pageDiv;\n        /* 鼠标坐标 - 鼠标与拖拽按钮的 间距坐标  得到 拖拽按钮的 左上角 x轴y轴坐标 */\n        let [x, y] = [clientX - this.iX, clientY - this.iY];\n        //拖拽按钮 dom 元素  获取 宽高 style 对象\n        let {\n          clientHeight: actionMgrY,\n          clientWidth: actionMgrX,\n          style: actionMgrStyle,\n        } = this.$refs.actionMgr;\n        /* 此处判断 拖拽按钮 如果超出 屏幕宽高 或者 小于\n                 设置 屏幕最大 x=全局容器x y=全局容器y 否则 设置 为 x=0 y=0\n              */\n        if (x > pageDivX - actionMgrX) x = pageDivX - actionMgrX;\n        else if (x < 0) x = 0;\n        if (y > pageDivY - actionMgrY) y = pageDivY - actionMgrY;\n        else if (y < 0) y = 0;\n        this.dX = x;\n        this.dY = y;\n        // 计算后坐标  设置 按钮位置\n        actionMgrStyle.left = `${x}px`;\n        actionMgrStyle.top = `${y}px`;\n        actionMgrStyle.bottom = "auto";\n        actionMgrStyle.right = "auto";\n        // 菜单位置\n        // let { style: menuBoxStyle } = this.$refs.menuBox;\n        // if (x < 125) {\n        //   menuBoxStyle.left = "5px";\n        //   menuBoxStyle.right = "";\n        //   this.marginStyle = "0 0 0 5px";\n        // } else if (pageDivX - x < 220) {\n        //   menuBoxStyle.right = "5px";\n        //   menuBoxStyle.left = "";\n        //   this.marginStyle = "0 0 0 275px";\n        // } else {\n        //   menuBoxStyle.left = "";\n        //   menuBoxStyle.right = "";\n        //   this.marginStyle = "0 auto";\n        // }\n        //  move Index\n        this.lastMoveIndex++;\n        //  当按下键滑动时， 阻止屏幕滑动事件\n        event.preventDefault();\n      }\n    },\n    // 鼠标抬起\n    demo_up(event) {\n      // console.log("demo_up", event);\n      //  拖拽按钮 dom 元素  获取 宽高 style 对象\n      let {\n        offsetTop: actionMgrY,\n        offsetLeft: actionMgrX,\n        style: actionMgrStyle,\n      } = this.$refs.actionMgr;\n      //当前页面全局容器 dom 元素  获取容器 宽高\n      actionMgrStyle.top = actionMgrY + "px";\n      actionMgrStyle.left = actionMgrX + "px";\n      // 计算后坐标  设置 按钮位置\n      this.mouseDownState = false;\n    },\n    // 单击事件\n    demo_click() {\n      //  mouseup 后会激活click事件\n      //  如果上一次down事件到下一次click事件中经历10次以下move，则视为纯点击事件\n      if (this.lastMoveIndex - this.curMoveIndex <= 10) {\n        //  点击事件\n        this.menuOpen = !this.menuOpen;\n        if (this.menuOpen) {\n          //  打开菜单\n        }\n      }\n      this.curMoveIndex = this.lastMoveIndex;\n    },\n  },\n};\n\n\n\n# 方案二：\n\n\n# html\n\n<div class="ys-float-btn" \n     :style="{\'width\': itemWidth+\'px\',\'height\': itemHeight+\'px\',\'left\': left+\'px\',\'top\': top+\'px\'}"    \n     ref="div"    \n     @touchstart.prevent="(e) => {dragStart(e)}"     \n     @touchend.prevent="(e) => {dragEnd(e)}"     \n     @touchmove.prevent="(e) => {dragProgress(e)}"    \n     >    \n  <img src="./../assets/fc-icon.png" />\n</div>\n\n\n\n# javascript\n\nexport default {\n  // 代码直接在 vue 项目里，可自行改为js/jquery 写法\n  data () {\n    return {\n      gapWidth: 10,\n      itemWidth: 20, // 图标的宽度\n      itemHeight: 30 // 图标的高度\n    }\n  },\n  created() {      \n    this.clientWidth = document.documentElement.clientWidth;     \n    this.clientHeight = document.documentElement.clientHeight;      \n    this.left = this.clientWidth - this.itemWidth - this.gapWidth;      \n    this.top = this.clientHeight*0.8;   \n  }，\n  methods: {    \n    dragStart(e) {        \n      this.$refs.div.style.transition = \'none\';\n    },\n    dragEnd(e) {        \n      this.$refs.div.style.transition = \'all 0.3s\';        \n      if (this.left > this.clientWidth/2) {          \n        this.left = this.clientWidth - this.itemWidth - this.gapWidth;\n      } else {          \n        this.left = this.gapWidth;        \n      }      \n    },      \n    dragProgress(e) {        \n      if (e.targetTouches.length === 1) {          \n        let touch = event.targetTouches[0];          \n        this.left = touch.clientX - this.itemWidth/2;              \n        this.top = touch.clientY - this.itemHeight/2;        \n      }      \n    }\n\t},\n}\n\n\n以上代码既可以上下也可以左右移动，如果只想让可上下移动，就去掉 left 相关的设置和计算。\n\n\n# 方案三：\n\n\n# html\n\n<div class="service" @click="toKefu" @mousedown="down" @touchstart="down" @mousemove="move"\n     @touchmove="move" @mouseup="end" @touchend="end" ref="kefu">\n  <img src="../assets/images/icon-service.png" />\n</div>\n\n\n\n# javascript\n\nexport default {\n  data() {\n    return {\n      flags: false, //控制使用\n      position: {\n        x: 0,\n        y: 0,\n      },\n      nx: "",\n      ny: "",\n      dx: "",\n      dy: "",\n      xPum: "",\n      yPum: "",\n    };\n  }\n  methods: {\n  down() {\n    this.flags = true;\n    var touch;\n    if (event.touches) {\n      touch = event.touches[0];\n    } else {\n      touch = event;\n    }\n    this.position.x = touch.clientX;\n    this.position.y = touch.clientY;\n    this.dx = this.$refs.kefu.offsetLeft;\n    this.dy = this.$refs.kefu.offsetTop;\n  },\n    move() {\n      if (this.flags) {\n        var touch;\n        if (event.touches) {\n          touch = event.touches[0];\n        } else {\n          touch = event;\n        }\n        this.nx = touch.clientX - this.position.x;\n        this.ny = touch.clientY - this.position.y;\n        this.xPum = this.dx + this.nx;\n        this.yPum = this.dy + this.ny;\n        let width = window.innerWidth - this.$refs.kefu.offsetWidth; //屏幕宽度减去自身控件宽度\n        let height = window.innerHeight - this.$refs.kefu.offsetHeight; //屏幕高度减去自身控件高度\n        this.xPum < 0 && (this.xPum = 0);\n        this.yPum < 0 && (this.yPum = 0);\n        this.xPum > width && (this.xPum = width);\n        this.yPum > height && (this.yPum = height);\n        // if (this.xPum >= 0 && this.yPum >= 0 && this.xPum<= width &&this.yPum<= height) {\n        this.$refs.kefu.style.left = this.xPum + "px";\n        this.$refs.kefu.style.top = this.yPum + "px";\n        // }\n        //阻止页面的滑动默认事件\n        document.addEventListener(\n          "touchmove",\n          function () {\n            event.preventDefault();\n          },\n          false\n        );\n      }\n    },\n      //鼠标释放时候的函数\n      end() {\n        this.flags = false;\n      },\n},\n}\n',normalizedContent:'# 可拖拽移动的悬浮图标\n\n\n# 方案一：\n\n\n# html\n\n<div class="viewassetdetail" ref="pagediv" @mousemove="demo_move" @mouseup="demo_up"\n     :class="{ zleveltop: mousedownstate }">\n  <div class="moremodal" ref="actionmgr" :style="position" @mousedown="demo_down">\n    \x3c!--  触发器 --\x3e\n    <div class="imgmore color-font">\n      <span @click="demo_click">\n        <i class="iconfont2 icon-gouwuchekong"></i>\n      </span>\n    </div>\n  </div>\n</div>\n\n\n\n# css\n\n.moremodal {\n  /* 如果碰到滑动问题，1.3 请检查 z-index。z-index需比web大一级*/\n  z-index: 1999;\n  position: absolute;\n  width: 50px;\n  height: 50px;\n  border-radius: 50%;\n  line-height: 40px;\n  text-align: center;\n  color: #fff;\n  // opacity: 0.6;\n}\n.moremodal:hover {\n  opacity: 1;\n}\n.zleveltop {\n  z-index: 9999;\n}\n\n\n\n# javascript\n\nexport default {\n  name: "clone-on-control",\n  display: "clone on control",\n  instruction: "press ctrl to clone element from list 1",\n  order: 4,\n  created() {},\n  watch: {},\n  data() {\n    return {\n      position: {\n        //初始位置\n        top: "1.25rem",\n        right: "0rem",\n      },\n      menuopen: false, //  菜单展开状态\n      mousedownstate: false, //  鼠标点击状态\n      ix: 0,\n      iy: 0,\n      dx: 0,\n      dy: 500, //  初始定位\n      lastmoveindex: 0, //  拖拽计数\n      curmoveindex: 0, //  历史计数\n      activename: "first",\n      activelayoutid: "",\n      marginstyle: " 0 0 0 275px",\n    };\n  },\n  methods: {\n    //  鼠标按下\n    demo_down(event) {\n      //  如果打开了菜单，则不做响应\n      if (this.menuopen) {\n        this.mousedownstate = false;\n        return;\n      }\n      // console.log("demo_down", event);\n      /* 此处判断  pc 或 移动端 得到 event 事件 */\n      var touch;\n      if (event.touches) {\n        touch = event.touches[0];\n      } else {\n        touch = event;\n      }\n      // 鼠标点击 面向页面 的 x坐标 y坐标\n      let { clientx, clienty } = touch;\n      // 鼠标x坐标 - 拖拽按钮x坐标  得到鼠标 距离 拖拽按钮 的间距\n      this.ix = clientx - this.$refs.actionmgr.offsetleft;\n      // 鼠标y坐标 - 拖拽按钮y坐标  得到鼠标 距离 拖拽按钮 的间距\n      this.iy = clienty - this.$refs.actionmgr.offsettop;\n      // 设置当前 状态为 鼠标按下\n      this.mousedownstate = true;\n    },\n    //  鼠标拖拽\n    demo_move(event) {\n      //鼠标按下 切移动中\n      if (this.mousedownstate) {\n        // console.log("demo_move", event);\n        /* 此处判断  pc 或 移动端 得到 event 事件 */\n        var touch;\n        if (event.touches) {\n          touch = event.touches[0];\n        } else {\n          touch = event;\n        }\n        // 鼠标移动时 面向页面 的 x坐标 y坐标\n        let { clientx, clienty } = touch;\n        //当前页面全局容器 dom 元素  获取容器 宽高\n        let { clientheight: pagedivy, clientwidth: pagedivx } =\n            this.$refs.pagediv;\n        /* 鼠标坐标 - 鼠标与拖拽按钮的 间距坐标  得到 拖拽按钮的 左上角 x轴y轴坐标 */\n        let [x, y] = [clientx - this.ix, clienty - this.iy];\n        //拖拽按钮 dom 元素  获取 宽高 style 对象\n        let {\n          clientheight: actionmgry,\n          clientwidth: actionmgrx,\n          style: actionmgrstyle,\n        } = this.$refs.actionmgr;\n        /* 此处判断 拖拽按钮 如果超出 屏幕宽高 或者 小于\n                 设置 屏幕最大 x=全局容器x y=全局容器y 否则 设置 为 x=0 y=0\n              */\n        if (x > pagedivx - actionmgrx) x = pagedivx - actionmgrx;\n        else if (x < 0) x = 0;\n        if (y > pagedivy - actionmgry) y = pagedivy - actionmgry;\n        else if (y < 0) y = 0;\n        this.dx = x;\n        this.dy = y;\n        // 计算后坐标  设置 按钮位置\n        actionmgrstyle.left = `${x}px`;\n        actionmgrstyle.top = `${y}px`;\n        actionmgrstyle.bottom = "auto";\n        actionmgrstyle.right = "auto";\n        // 菜单位置\n        // let { style: menuboxstyle } = this.$refs.menubox;\n        // if (x < 125) {\n        //   menuboxstyle.left = "5px";\n        //   menuboxstyle.right = "";\n        //   this.marginstyle = "0 0 0 5px";\n        // } else if (pagedivx - x < 220) {\n        //   menuboxstyle.right = "5px";\n        //   menuboxstyle.left = "";\n        //   this.marginstyle = "0 0 0 275px";\n        // } else {\n        //   menuboxstyle.left = "";\n        //   menuboxstyle.right = "";\n        //   this.marginstyle = "0 auto";\n        // }\n        //  move index\n        this.lastmoveindex++;\n        //  当按下键滑动时， 阻止屏幕滑动事件\n        event.preventdefault();\n      }\n    },\n    // 鼠标抬起\n    demo_up(event) {\n      // console.log("demo_up", event);\n      //  拖拽按钮 dom 元素  获取 宽高 style 对象\n      let {\n        offsettop: actionmgry,\n        offsetleft: actionmgrx,\n        style: actionmgrstyle,\n      } = this.$refs.actionmgr;\n      //当前页面全局容器 dom 元素  获取容器 宽高\n      actionmgrstyle.top = actionmgry + "px";\n      actionmgrstyle.left = actionmgrx + "px";\n      // 计算后坐标  设置 按钮位置\n      this.mousedownstate = false;\n    },\n    // 单击事件\n    demo_click() {\n      //  mouseup 后会激活click事件\n      //  如果上一次down事件到下一次click事件中经历10次以下move，则视为纯点击事件\n      if (this.lastmoveindex - this.curmoveindex <= 10) {\n        //  点击事件\n        this.menuopen = !this.menuopen;\n        if (this.menuopen) {\n          //  打开菜单\n        }\n      }\n      this.curmoveindex = this.lastmoveindex;\n    },\n  },\n};\n\n\n\n# 方案二：\n\n\n# html\n\n<div class="ys-float-btn" \n     :style="{\'width\': itemwidth+\'px\',\'height\': itemheight+\'px\',\'left\': left+\'px\',\'top\': top+\'px\'}"    \n     ref="div"    \n     @touchstart.prevent="(e) => {dragstart(e)}"     \n     @touchend.prevent="(e) => {dragend(e)}"     \n     @touchmove.prevent="(e) => {dragprogress(e)}"    \n     >    \n  <img src="./../assets/fc-icon.png" />\n</div>\n\n\n\n# javascript\n\nexport default {\n  // 代码直接在 vue 项目里，可自行改为js/jquery 写法\n  data () {\n    return {\n      gapwidth: 10,\n      itemwidth: 20, // 图标的宽度\n      itemheight: 30 // 图标的高度\n    }\n  },\n  created() {      \n    this.clientwidth = document.documentelement.clientwidth;     \n    this.clientheight = document.documentelement.clientheight;      \n    this.left = this.clientwidth - this.itemwidth - this.gapwidth;      \n    this.top = this.clientheight*0.8;   \n  }，\n  methods: {    \n    dragstart(e) {        \n      this.$refs.div.style.transition = \'none\';\n    },\n    dragend(e) {        \n      this.$refs.div.style.transition = \'all 0.3s\';        \n      if (this.left > this.clientwidth/2) {          \n        this.left = this.clientwidth - this.itemwidth - this.gapwidth;\n      } else {          \n        this.left = this.gapwidth;        \n      }      \n    },      \n    dragprogress(e) {        \n      if (e.targettouches.length === 1) {          \n        let touch = event.targettouches[0];          \n        this.left = touch.clientx - this.itemwidth/2;              \n        this.top = touch.clienty - this.itemheight/2;        \n      }      \n    }\n\t},\n}\n\n\n以上代码既可以上下也可以左右移动，如果只想让可上下移动，就去掉 left 相关的设置和计算。\n\n\n# 方案三：\n\n\n# html\n\n<div class="service" @click="tokefu" @mousedown="down" @touchstart="down" @mousemove="move"\n     @touchmove="move" @mouseup="end" @touchend="end" ref="kefu">\n  <img src="../assets/images/icon-service.png" />\n</div>\n\n\n\n# javascript\n\nexport default {\n  data() {\n    return {\n      flags: false, //控制使用\n      position: {\n        x: 0,\n        y: 0,\n      },\n      nx: "",\n      ny: "",\n      dx: "",\n      dy: "",\n      xpum: "",\n      ypum: "",\n    };\n  }\n  methods: {\n  down() {\n    this.flags = true;\n    var touch;\n    if (event.touches) {\n      touch = event.touches[0];\n    } else {\n      touch = event;\n    }\n    this.position.x = touch.clientx;\n    this.position.y = touch.clienty;\n    this.dx = this.$refs.kefu.offsetleft;\n    this.dy = this.$refs.kefu.offsettop;\n  },\n    move() {\n      if (this.flags) {\n        var touch;\n        if (event.touches) {\n          touch = event.touches[0];\n        } else {\n          touch = event;\n        }\n        this.nx = touch.clientx - this.position.x;\n        this.ny = touch.clienty - this.position.y;\n        this.xpum = this.dx + this.nx;\n        this.ypum = this.dy + this.ny;\n        let width = window.innerwidth - this.$refs.kefu.offsetwidth; //屏幕宽度减去自身控件宽度\n        let height = window.innerheight - this.$refs.kefu.offsetheight; //屏幕高度减去自身控件高度\n        this.xpum < 0 && (this.xpum = 0);\n        this.ypum < 0 && (this.ypum = 0);\n        this.xpum > width && (this.xpum = width);\n        this.ypum > height && (this.ypum = height);\n        // if (this.xpum >= 0 && this.ypum >= 0 && this.xpum<= width &&this.ypum<= height) {\n        this.$refs.kefu.style.left = this.xpum + "px";\n        this.$refs.kefu.style.top = this.ypum + "px";\n        // }\n        //阻止页面的滑动默认事件\n        document.addeventlistener(\n          "touchmove",\n          function () {\n            event.preventdefault();\n          },\n          false\n        );\n      }\n    },\n      //鼠标释放时候的函数\n      end() {\n        this.flags = false;\n      },\n},\n}\n',charsets:{cjk:!0}},{title:"同一个浏览器相同路径只允许打开一个窗口",frontmatter:{},regularPath:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E8%B7%B3%E8%BD%AC%E7%9B%B8%E5%85%B3.html",relativePath:"前端问题/跳转相关.md",key:"v-35853b78",path:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E8%B7%B3%E8%BD%AC%E7%9B%B8%E5%85%B3.html",headers:[{level:2,title:"同一个浏览器相同路径只允许打开一个窗口",slug:"同一个浏览器相同路径只允许打开一个窗口",normalizedTitle:"同一个浏览器相同路径只允许打开一个窗口",charIndex:2}],headersStr:"同一个浏览器相同路径只允许打开一个窗口",content:'# 同一个浏览器相同路径只允许打开一个窗口\n\n<!DOCTYPE html>\n<html lang="en">\n\n    <head>\n        <meta charset="UTF-8">\n        <meta http-equiv="X-UA-Compatible" content="IE=edge">\n        <meta name="viewport" content="width=device-width, initial-scale=1.0">\n        <title>Document</title>\n    </head>\n\n    <body>\n        <button onClick="openclk()">打开javascript网站</button>\n        <button onClick="closeclk()">关闭javascript网站</button>\n\n        <script>\n            function openclk() { //用来打开一个新的窗口\n                // 第二个参数传 NewWindow ，就只能打开一个窗口\n                another = open(\'http://www.JavaScript.com/\', \'NewWindow\');\n            }\n            function closeclk() {\n                another.close(); //关闭打开的窗口\n            }    \n        <\/script>\n    </body>\n\n</html>\n',normalizedContent:'# 同一个浏览器相同路径只允许打开一个窗口\n\n<!doctype html>\n<html lang="en">\n\n    <head>\n        <meta charset="utf-8">\n        <meta http-equiv="x-ua-compatible" content="ie=edge">\n        <meta name="viewport" content="width=device-width, initial-scale=1.0">\n        <title>document</title>\n    </head>\n\n    <body>\n        <button onclick="openclk()">打开javascript网站</button>\n        <button onclick="closeclk()">关闭javascript网站</button>\n\n        <script>\n            function openclk() { //用来打开一个新的窗口\n                // 第二个参数传 newwindow ，就只能打开一个窗口\n                another = open(\'http://www.javascript.com/\', \'newwindow\');\n            }\n            function closeclk() {\n                another.close(); //关闭打开的窗口\n            }    \n        <\/script>\n    </body>\n\n</html>\n',charsets:{cjk:!0}},{title:"递归",frontmatter:{},regularPath:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E9%80%92%E5%BD%92.html",relativePath:"前端问题/递归.md",key:"v-2ddae43b",path:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E9%80%92%E5%BD%92.html",headers:[{level:2,title:"递归",slug:"递归",normalizedTitle:"递归",charIndex:2},{level:3,title:"递归事件",slug:"递归事件",normalizedTitle:"递归事件",charIndex:9},{level:3,title:"递归组件",slug:"递归组件",normalizedTitle:"递归组件",charIndex:394}],headersStr:"递归 递归事件 递归组件",content:'# 递归\n\n\n# 递归事件\n\n调用事件\n\n// 对象递归事件\nfindIdByName(tree) {\n    var name = []\n    var clssData = {};\n    function find(obj) {\n        if (obj != null) {\n            if (obj.classId) {\n                name.unshift(obj.name)\n                clssData[obj.classId] = obj.instId || obj.id;\n            }\n            find(obj.parentId);\n        }\n    }\n    find(tree);\n    return { clssData, name };\n},\n\n\n\n# 递归组件\n\n 1. test.vue 创建数据架构\n    \n     data() {\n        return {\n          commentList: [\n            {\n              content: "楼主说的有道理"\n            },\n            {\n              content: "挽尊"\n            },\n            {\n              content: "从前有座山"\n            },\n            {\n              content: "+10086"\n            },\n            // 如果是回复别人, 就会把被回复的评论放在 parent 里面\n            {\n              content: "山上有座庙",\n              parent: {\n                content: "从前有座山"\n              }\n            },\n            {\n              content: "葬爱家族万岁"\n            },\n            {\n              content: "庙里有个和尚在讲故事",\n              parent: {\n                content: "山上有座庙",\n                parent: {\n                  content: "从前有座山"\n                }\n              }\n            }\n          ]\n        };\n      }\n    \n\n 2. 创建mainComment.vue评论组件\n    \n    <template>\n        <div class="box">\n            {{commentData.content}}\n        </div>\n    </template>\n    \n    <script>\n        export default {\n            props: ["commentData"],\n        };\n    <\/script>\n    \n    <style lang="less" scoped>\n        .box {\n            border: 1px solid #e4e4e4;\n            background-color: #eee;\n            margin: 10px;\n            padding: 10px;\n        }\n    </style>\n    \n\n 3. 在test.vue页面引入组件并进行遍历数据渲染\n    \n    <template>\n        <div>\n            <MainComment v-for="(comment, index) in commentList" :key="index" :commentData="comment" />\n        </div>\n    </template>\n    \n    <script>\n        import MainComment from "@/components/test/MainComment";\n        export default {\n            components: {\n                MainComment\n            },\n            ....//数据代码省略\n        }\n    <\/script>\n    \n    \n    这样已经实现最新的第一层评论\n    \n    \n\n 4. 创建parent.vue组件，渲染第一层回复的父评论数据\n    \n    <template>\n        <div>\n            {{parentData.content}}\n            </parent>\n        </div>\n    </template>\n    \n    <script>\n        export default {\n    \n            props: ["parentData"]\n        };\n    <\/script>\n    \n    <style>\n    </style>\n    \n    \n    mainComment.vue主评论组件进行传递数据：\n    \n    <template>\n        <div class="box">\n            {{commentData.content}}\n            //如果当前一级评论里面有parent数据，就渲染parent结构，并把数据传递过去\n            <parentCommit :parentData="commentData.parent" v-if="commentData.parent" />\n        </div>\n    </template>\n    \n    <script>\n        //引入parent组件\n        import parentCommit from "@/components/test/parentComment.vue";\n    \n        export default {\n            props: ["commentData"],\n            components: {\n                parentCommit\n            }\n        };\n    <\/script>\n    \n    <style lang="less" scoped>\n        .box {\n            border: 1px solid #e4e4e4;\n            background-color: #eee;\n            margin: 10px;\n            padding: 10px;\n        }\n    </style>\n    \n    \n    这样已经实现回复的第二层评论：\n    \n    \n\n 5. 递归开始：生成未知层数的评论，parent 组件内部递归\n    \n    1. 递归组件语法, 必须起一个 name 然后就能在自己的 template 当中调用自己\n    \n    2. 自己调用自己的数据传递模式是一样的 也是 props\n    \n    3. v-if="parentData.parent" 就是递归终止处理或计算的出口\n       \n       <template>\n           <div>\n               {{parentData.content}}\n       \n               //组件自己调用自己，有parent就调用渲染并传递数据，没有就不渲染\n       \n               <parent v-if="parentData.parent" :parentData="parentData.parent">{{parentData.conent}}</parent>\n           </div>\n       </template>\n       \n       <script>\n           export default {\n               //递归组件语法，name\n               name: "parent",\n               props: ["parentData"]\n           };\n       <\/script>\n       \n       <style>\n       </style>\n       \n       \n       递归评论已经实现：\n       \n       ',normalizedContent:'# 递归\n\n\n# 递归事件\n\n调用事件\n\n// 对象递归事件\nfindidbyname(tree) {\n    var name = []\n    var clssdata = {};\n    function find(obj) {\n        if (obj != null) {\n            if (obj.classid) {\n                name.unshift(obj.name)\n                clssdata[obj.classid] = obj.instid || obj.id;\n            }\n            find(obj.parentid);\n        }\n    }\n    find(tree);\n    return { clssdata, name };\n},\n\n\n\n# 递归组件\n\n 1. test.vue 创建数据架构\n    \n     data() {\n        return {\n          commentlist: [\n            {\n              content: "楼主说的有道理"\n            },\n            {\n              content: "挽尊"\n            },\n            {\n              content: "从前有座山"\n            },\n            {\n              content: "+10086"\n            },\n            // 如果是回复别人, 就会把被回复的评论放在 parent 里面\n            {\n              content: "山上有座庙",\n              parent: {\n                content: "从前有座山"\n              }\n            },\n            {\n              content: "葬爱家族万岁"\n            },\n            {\n              content: "庙里有个和尚在讲故事",\n              parent: {\n                content: "山上有座庙",\n                parent: {\n                  content: "从前有座山"\n                }\n              }\n            }\n          ]\n        };\n      }\n    \n\n 2. 创建maincomment.vue评论组件\n    \n    <template>\n        <div class="box">\n            {{commentdata.content}}\n        </div>\n    </template>\n    \n    <script>\n        export default {\n            props: ["commentdata"],\n        };\n    <\/script>\n    \n    <style lang="less" scoped>\n        .box {\n            border: 1px solid #e4e4e4;\n            background-color: #eee;\n            margin: 10px;\n            padding: 10px;\n        }\n    </style>\n    \n\n 3. 在test.vue页面引入组件并进行遍历数据渲染\n    \n    <template>\n        <div>\n            <maincomment v-for="(comment, index) in commentlist" :key="index" :commentdata="comment" />\n        </div>\n    </template>\n    \n    <script>\n        import maincomment from "@/components/test/maincomment";\n        export default {\n            components: {\n                maincomment\n            },\n            ....//数据代码省略\n        }\n    <\/script>\n    \n    \n    这样已经实现最新的第一层评论\n    \n    \n\n 4. 创建parent.vue组件，渲染第一层回复的父评论数据\n    \n    <template>\n        <div>\n            {{parentdata.content}}\n            </parent>\n        </div>\n    </template>\n    \n    <script>\n        export default {\n    \n            props: ["parentdata"]\n        };\n    <\/script>\n    \n    <style>\n    </style>\n    \n    \n    maincomment.vue主评论组件进行传递数据：\n    \n    <template>\n        <div class="box">\n            {{commentdata.content}}\n            //如果当前一级评论里面有parent数据，就渲染parent结构，并把数据传递过去\n            <parentcommit :parentdata="commentdata.parent" v-if="commentdata.parent" />\n        </div>\n    </template>\n    \n    <script>\n        //引入parent组件\n        import parentcommit from "@/components/test/parentcomment.vue";\n    \n        export default {\n            props: ["commentdata"],\n            components: {\n                parentcommit\n            }\n        };\n    <\/script>\n    \n    <style lang="less" scoped>\n        .box {\n            border: 1px solid #e4e4e4;\n            background-color: #eee;\n            margin: 10px;\n            padding: 10px;\n        }\n    </style>\n    \n    \n    这样已经实现回复的第二层评论：\n    \n    \n\n 5. 递归开始：生成未知层数的评论，parent 组件内部递归\n    \n    1. 递归组件语法, 必须起一个 name 然后就能在自己的 template 当中调用自己\n    \n    2. 自己调用自己的数据传递模式是一样的 也是 props\n    \n    3. v-if="parentdata.parent" 就是递归终止处理或计算的出口\n       \n       <template>\n           <div>\n               {{parentdata.content}}\n       \n               //组件自己调用自己，有parent就调用渲染并传递数据，没有就不渲染\n       \n               <parent v-if="parentdata.parent" :parentdata="parentdata.parent">{{parentdata.conent}}</parent>\n           </div>\n       </template>\n       \n       <script>\n           export default {\n               //递归组件语法，name\n               name: "parent",\n               props: ["parentdata"]\n           };\n       <\/script>\n       \n       <style>\n       </style>\n       \n       \n       递归评论已经实现：\n       \n       ',charsets:{cjk:!0}},{title:"前端请求接口的几种方式总结",frontmatter:{},regularPath:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AF%E8%AF%B7%E6%B1%82%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93.html",relativePath:"前端问题/前端请求接口的几种方式总结.md",key:"v-4ca00b15",path:"/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/%E5%89%8D%E7%AB%AF%E8%AF%B7%E6%B1%82%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93.html",headers:[{level:2,title:"一、vue-resource",slug:"一、vue-resource",normalizedTitle:"一、vue-resource",charIndex:127},{level:2,title:"二、axios",slug:"二、axios",normalizedTitle:"二、axios",charIndex:540},{level:2,title:"三、ajax",slug:"三、ajax",normalizedTitle:"三、ajax",charIndex:4242},{level:2,title:"四、WebSocket",slug:"四、websocket",normalizedTitle:"四、websocket",charIndex:5393}],headersStr:"一、vue-resource 二、axios 三、ajax 四、WebSocket",content:"# 前端请求接口的几种方式总结\n\n作为一名前端工程师，请求后台接口获取数据是必然的，也是要求前端人员需要掌握的必备技能。但你一段时间只用一种请求方法，突然让你换成其他方式不一定能够立马实现的来，为此总结了一下前端请求API的方法，方便今后查阅。\n\n\n# 一、vue-resource\n\n优点：体积小、支持主流的浏览器、支持Promise API和URI Templates、支持拦截器。\n\n安装\n\n$ yarn add vue-resource\n$ npm install vue-resource\n\n\n使用\n\n/*引入Vue框架*/\nimport Vue from 'vue'\n/*引入资源请求插件*/\nimport VueResource from 'vue-resource'\n\n/*使用VueResource插件*/\nVue.use(VueResource)\n\n\n常用的：\n\nthis.$http.get().then()\nthis.$http.post().then()\nthis.$http.jsonp().then()\n\n\n学习链接：vue-resource（https://www.cnblogs.com/goloving/p/8665421.html）\n\n\n# 二、axios\n\nvue2.0之后，就不再对vue-resource更新，而是推荐使用axios。基于 Promise 的 HTTP 请求客户端，可同时在浏览器和 Node.js 中使用。\n\n优点：\n\n（1）在浏览器中发送 XMLHttpRequests 请求 （2）在 node.js 中发送 http请求 （3）支持 Promise API （4）拦截请求和响应 （5）转换请求和响应数据 （6）取消请求 （7）自动转换为JSON数据 （8）客户端支持保护安全免受 CSRF/XSRF 攻击\n\n直接单独使用：\n\nget方式\n\naxios.get().then().catch()\n\n注：\n\nget方式传参数可以直接跟在url后面，也可以通过param对象传\n\npost方式\n\naxios.post().then().catch()\n\n注：\n\npost方式传参必须用对象传\n\n实际开发时，会将axios封装，便于调用，并且使用拦截器控制请求状态\n\n封装axios请求：\n\n建api文件，在当前目录封装一个request.js文件，配置请求响应的拦截信息\n\n/**\n @file axios请求封装\n**/\nimport axios from 'axios'\nimport store from '../store/common'\nimport router from '../router/common'\nimport { Toast } from 'vant'\n\nconst Axios = axios.create({})\n\n// 响应时间\nAxios.defaults.timeout = 10000\n// `withCredentails`选项表明了是否是跨域请求\nAxios.defaults.withCredentials = true\n// 设置默认请求头\nAxios.defaults.headers = {\n    'X-Requested-With': 'XMLHttpRequest',\n    'Content-Type': 'application/json; charset=UTF-8'\n}\n\n// 添加请求拦截器\nAxios.interceptors.request.use(\n    config => {\n        // loadingInstance = Loading.service({\n        //   fullscreen: true\n        // });\n        // 获取token\n        let token = store.getters.getToken\n        if (token) {\n            // 判断是否存在token，如果存在的话，则每个http header都加上token\n            config.headers.Authorization = token\n        }\n        return config\n    },\n    error => {\n        return Promise.reject(error)\n    }\n)\n\n// 添加返回拦截器\nAxios.interceptors.response.use(\n    response => {\n        if (\n            typeof response != 'undefined' &&\n            (response.data.code == 1001 ||\n             response.data.code == 0 ||\n             response.data.code == 1000 ||\n             response.data.code == 1100 ||\n             response.data.code == 1200)\n        ) {\n            return response.data\n        } else if (response.data.code == 20008) {\n            // 交班后选机器号\n            checkCode('当前无人当班，请选择机器号')\n            router.replace('/center/machine')\n            return response.data\n        } else if (response.data.code == 1006) {\n            // Token过期\n            checkCode('登录过期，请重新登录')\n            return response.data\n        } else if (typeof response != 'undefined' && response.data.msg) {\n            checkCode(response.data.msg)\n            return response.data\n        } else {\n            checkCode('操作失败，请重试')\n        }\n        return ''\n    },\n    error => {\n        if (error && error.response) {\n            switch (error.response.status) {\n                case 400:\n                    error.message = '请求错误'\n                    break\n                    ...\n                    default:\n            }\n        } else {\n            error.message = '无法连接服务器'\n        }\n        // 对返回的错误处理\n        return Promise.reject(error)\n    }\n)\n\n// 请求失败错误信息提示\nfunction checkCode(message) {\n    // 关闭loading\n    // loadingInstance.close();\n    // 弹出错误信息\n    Toast(message)\n}\nexport default Axios\n\n\n再建立一个index.js文件统一写请求接口，如下图：\n\n\n\n全局暴露请求接口api，在vue.config.js文件中，配置chainwebpack，设置api的别名就可以全局使用api的接口了\n\nchainWebpack: config => {\n    config.resolve.alias\n        .set('api', path.resolve('./src/api/index.js'))\n    config.plugin('provide').use(webpack.ProvidePlugin, [\n        {\n            api: 'api'\n        }\n    ])\n}\n\n\n接口请求：直接可以使用await api.getName（index.js下对应的接口名字）\n\nawait api.pageSalesOrderProsDetailData(this.formDate).then(response => {\n    if (response.data) {\n        this.goodsList = this.goodsList.concat(response.data.content)\n        this.totalPages = response.data.totalPages\n        if (response.data.content.length < this.formDate.pageCount) {\n            this.$store.commit('SET_ALL_LOADING', true)\n        }\n    }\n    this.$store.commit('SET_SALES_RANK_MSG', this.goodsList)\n})\n\n\nvue中Axios的封装和API接口的管理（https://juejin.cn/post/6844903652881072141）\n\n\n# 三、ajax\n\n使用Jquery封装的ajax(https://www.w3school.com.cn/jquery/ajax_ajax.asp)\n\n$.ajax({\n    url:\"http://www.microsoft.com\", //请求的url地址\n    dataType:\"json\", //返回格式为json\n    async:true,//请求是否异步，默认为异步，这也是ajax重要特性\n    data:{\"id\":\"value\"}, //参数值\n    type:\"GET\", //请求方式\n    beforeSend:function(){\n        //请求前的处理\n    },\n    success:function(req){\n        //请求成功时处理\n    },\n    complete:function(){\n        //请求完成的处理\n    },\n    error:function(){\n        //请求出错处理\n    }\n});\n\n\n参数解释：\n\n$.ajax({\n    url:\"   \", //请求的地址\n    type:\"   \", //请求方式两种“get”或者“post”，默认为“get”\n    timeout: //设置请求超时时间（毫秒。\n    async: //是否异步，默认设置为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行。\n    cache: //默认为true（当dataType为script时，默认为false），设置为false将不会从浏览器缓存中加载请求信息。\n    data: //要求为Object或String类型的参数，发送到服务器的数据。get请求中将附加在url后\n    dataType: //预期服务器返回的数据类型。可用的类型如下：\n    xml：返回XML文档，可用JQuery处理。\n    html：返回纯文本HTML信息；包含的script标签会在插入DOM时执行。\n    json：返回JSON数据。\n    jsonp：JSONP格式。使用SONP形式调用函数\n    beforeSend: //发送请求前可以修改XMLHttpRequest对象的函数，例如添加自定义HTTP头\n    complete: //请求完成后调用的回调函数（请求成功或失败时均调用）。\n    error: //请求失败时被调用的函数。该函数有3个参数，即XMLHttpRequest对象、错误信息、捕获的错误对象(可选)\n})\n\n\n\n# 四、WebSocket\n\n出现缘由： 前端和后端的交互模式最常见的就是前端发数据请求，从后端拿到数据后展示到页面中。如果前端不做操作，后端不能主动向前端推送数据，这也是http协议的缺陷。因此，一种新的通信协议应运而生—websocket，他最大的特点就是服务端可以主动向客户端推送消息，客户端也可以主动向服务端发送消息，实现了真正的平等。\n\n使用场景： 金融股票数据图、即时订单信息、天气、token是否过期等不请求就返回最新数据的场景使用。\n\n注：vue使用websocket需要注意以下几点：\n\n（1）首先需要判断浏览器是否支持websocket。\n\n\n\n（2）在组件加载的时候连接websocket，在组件销毁的时候断开websocket （3）后端接口需要引入socket模块，否则不能实现连接\n\n举个例子：\n\n<template>\n    <div>\n        <button @click=\"send\">发消息</button>\n    </div>\n</template>\n\n<script>\n    export default {\n        data () {\n            return {\n                path:\"test\",\n                socket:\"\"\n            }\n        },\n        mounted () {\n            // 初始化\n            this.init()\n        },\n        methods: {\n            init: function () {\n                if(typeof(WebSocket) === \"undefined\"){\n                    alert(\"您的浏览器不支持socket\")\n                }else{\n                    // 实例化socket\n                    this.socket = new WebSocket(this.path)\n                    // 监听socket连接\n                    this.socket.onopen = this.open\n                    // 监听socket错误信息\n                    this.socket.onerror = this.error\n                    // 监听socket消息\n                    this.socket.onmessage = this.getMessage\n                }\n            },\n            open: function () {\n                console.log(\"socket连接成功\")\n            },\n            error: function () {\n                console.log(\"连接错误\")\n            },\n            getMessage: function (msg) {\n                console.log(msg.data)\n            },\n            send: function () {\n                this.socket.send(params)\n            },\n            close: function () {\n                console.log(\"socket已经关闭\")\n            }\n        },\n        destroyed () {\n            // 销毁监听\n            this.socket.onclose = this.close\n        }\n    }\n<\/script>\n",normalizedContent:"# 前端请求接口的几种方式总结\n\n作为一名前端工程师，请求后台接口获取数据是必然的，也是要求前端人员需要掌握的必备技能。但你一段时间只用一种请求方法，突然让你换成其他方式不一定能够立马实现的来，为此总结了一下前端请求api的方法，方便今后查阅。\n\n\n# 一、vue-resource\n\n优点：体积小、支持主流的浏览器、支持promise api和uri templates、支持拦截器。\n\n安装\n\n$ yarn add vue-resource\n$ npm install vue-resource\n\n\n使用\n\n/*引入vue框架*/\nimport vue from 'vue'\n/*引入资源请求插件*/\nimport vueresource from 'vue-resource'\n\n/*使用vueresource插件*/\nvue.use(vueresource)\n\n\n常用的：\n\nthis.$http.get().then()\nthis.$http.post().then()\nthis.$http.jsonp().then()\n\n\n学习链接：vue-resource（https://www.cnblogs.com/goloving/p/8665421.html）\n\n\n# 二、axios\n\nvue2.0之后，就不再对vue-resource更新，而是推荐使用axios。基于 promise 的 http 请求客户端，可同时在浏览器和 node.js 中使用。\n\n优点：\n\n（1）在浏览器中发送 xmlhttprequests 请求 （2）在 node.js 中发送 http请求 （3）支持 promise api （4）拦截请求和响应 （5）转换请求和响应数据 （6）取消请求 （7）自动转换为json数据 （8）客户端支持保护安全免受 csrf/xsrf 攻击\n\n直接单独使用：\n\nget方式\n\naxios.get().then().catch()\n\n注：\n\nget方式传参数可以直接跟在url后面，也可以通过param对象传\n\npost方式\n\naxios.post().then().catch()\n\n注：\n\npost方式传参必须用对象传\n\n实际开发时，会将axios封装，便于调用，并且使用拦截器控制请求状态\n\n封装axios请求：\n\n建api文件，在当前目录封装一个request.js文件，配置请求响应的拦截信息\n\n/**\n @file axios请求封装\n**/\nimport axios from 'axios'\nimport store from '../store/common'\nimport router from '../router/common'\nimport { toast } from 'vant'\n\nconst axios = axios.create({})\n\n// 响应时间\naxios.defaults.timeout = 10000\n// `withcredentails`选项表明了是否是跨域请求\naxios.defaults.withcredentials = true\n// 设置默认请求头\naxios.defaults.headers = {\n    'x-requested-with': 'xmlhttprequest',\n    'content-type': 'application/json; charset=utf-8'\n}\n\n// 添加请求拦截器\naxios.interceptors.request.use(\n    config => {\n        // loadinginstance = loading.service({\n        //   fullscreen: true\n        // });\n        // 获取token\n        let token = store.getters.gettoken\n        if (token) {\n            // 判断是否存在token，如果存在的话，则每个http header都加上token\n            config.headers.authorization = token\n        }\n        return config\n    },\n    error => {\n        return promise.reject(error)\n    }\n)\n\n// 添加返回拦截器\naxios.interceptors.response.use(\n    response => {\n        if (\n            typeof response != 'undefined' &&\n            (response.data.code == 1001 ||\n             response.data.code == 0 ||\n             response.data.code == 1000 ||\n             response.data.code == 1100 ||\n             response.data.code == 1200)\n        ) {\n            return response.data\n        } else if (response.data.code == 20008) {\n            // 交班后选机器号\n            checkcode('当前无人当班，请选择机器号')\n            router.replace('/center/machine')\n            return response.data\n        } else if (response.data.code == 1006) {\n            // token过期\n            checkcode('登录过期，请重新登录')\n            return response.data\n        } else if (typeof response != 'undefined' && response.data.msg) {\n            checkcode(response.data.msg)\n            return response.data\n        } else {\n            checkcode('操作失败，请重试')\n        }\n        return ''\n    },\n    error => {\n        if (error && error.response) {\n            switch (error.response.status) {\n                case 400:\n                    error.message = '请求错误'\n                    break\n                    ...\n                    default:\n            }\n        } else {\n            error.message = '无法连接服务器'\n        }\n        // 对返回的错误处理\n        return promise.reject(error)\n    }\n)\n\n// 请求失败错误信息提示\nfunction checkcode(message) {\n    // 关闭loading\n    // loadinginstance.close();\n    // 弹出错误信息\n    toast(message)\n}\nexport default axios\n\n\n再建立一个index.js文件统一写请求接口，如下图：\n\n\n\n全局暴露请求接口api，在vue.config.js文件中，配置chainwebpack，设置api的别名就可以全局使用api的接口了\n\nchainwebpack: config => {\n    config.resolve.alias\n        .set('api', path.resolve('./src/api/index.js'))\n    config.plugin('provide').use(webpack.provideplugin, [\n        {\n            api: 'api'\n        }\n    ])\n}\n\n\n接口请求：直接可以使用await api.getname（index.js下对应的接口名字）\n\nawait api.pagesalesorderprosdetaildata(this.formdate).then(response => {\n    if (response.data) {\n        this.goodslist = this.goodslist.concat(response.data.content)\n        this.totalpages = response.data.totalpages\n        if (response.data.content.length < this.formdate.pagecount) {\n            this.$store.commit('set_all_loading', true)\n        }\n    }\n    this.$store.commit('set_sales_rank_msg', this.goodslist)\n})\n\n\nvue中axios的封装和api接口的管理（https://juejin.cn/post/6844903652881072141）\n\n\n# 三、ajax\n\n使用jquery封装的ajax(https://www.w3school.com.cn/jquery/ajax_ajax.asp)\n\n$.ajax({\n    url:\"http://www.microsoft.com\", //请求的url地址\n    datatype:\"json\", //返回格式为json\n    async:true,//请求是否异步，默认为异步，这也是ajax重要特性\n    data:{\"id\":\"value\"}, //参数值\n    type:\"get\", //请求方式\n    beforesend:function(){\n        //请求前的处理\n    },\n    success:function(req){\n        //请求成功时处理\n    },\n    complete:function(){\n        //请求完成的处理\n    },\n    error:function(){\n        //请求出错处理\n    }\n});\n\n\n参数解释：\n\n$.ajax({\n    url:\"   \", //请求的地址\n    type:\"   \", //请求方式两种“get”或者“post”，默认为“get”\n    timeout: //设置请求超时时间（毫秒。\n    async: //是否异步，默认设置为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行。\n    cache: //默认为true（当datatype为script时，默认为false），设置为false将不会从浏览器缓存中加载请求信息。\n    data: //要求为object或string类型的参数，发送到服务器的数据。get请求中将附加在url后\n    datatype: //预期服务器返回的数据类型。可用的类型如下：\n    xml：返回xml文档，可用jquery处理。\n    html：返回纯文本html信息；包含的script标签会在插入dom时执行。\n    json：返回json数据。\n    jsonp：jsonp格式。使用sonp形式调用函数\n    beforesend: //发送请求前可以修改xmlhttprequest对象的函数，例如添加自定义http头\n    complete: //请求完成后调用的回调函数（请求成功或失败时均调用）。\n    error: //请求失败时被调用的函数。该函数有3个参数，即xmlhttprequest对象、错误信息、捕获的错误对象(可选)\n})\n\n\n\n# 四、websocket\n\n出现缘由： 前端和后端的交互模式最常见的就是前端发数据请求，从后端拿到数据后展示到页面中。如果前端不做操作，后端不能主动向前端推送数据，这也是http协议的缺陷。因此，一种新的通信协议应运而生—websocket，他最大的特点就是服务端可以主动向客户端推送消息，客户端也可以主动向服务端发送消息，实现了真正的平等。\n\n使用场景： 金融股票数据图、即时订单信息、天气、token是否过期等不请求就返回最新数据的场景使用。\n\n注：vue使用websocket需要注意以下几点：\n\n（1）首先需要判断浏览器是否支持websocket。\n\n\n\n（2）在组件加载的时候连接websocket，在组件销毁的时候断开websocket （3）后端接口需要引入socket模块，否则不能实现连接\n\n举个例子：\n\n<template>\n    <div>\n        <button @click=\"send\">发消息</button>\n    </div>\n</template>\n\n<script>\n    export default {\n        data () {\n            return {\n                path:\"test\",\n                socket:\"\"\n            }\n        },\n        mounted () {\n            // 初始化\n            this.init()\n        },\n        methods: {\n            init: function () {\n                if(typeof(websocket) === \"undefined\"){\n                    alert(\"您的浏览器不支持socket\")\n                }else{\n                    // 实例化socket\n                    this.socket = new websocket(this.path)\n                    // 监听socket连接\n                    this.socket.onopen = this.open\n                    // 监听socket错误信息\n                    this.socket.onerror = this.error\n                    // 监听socket消息\n                    this.socket.onmessage = this.getmessage\n                }\n            },\n            open: function () {\n                console.log(\"socket连接成功\")\n            },\n            error: function () {\n                console.log(\"连接错误\")\n            },\n            getmessage: function (msg) {\n                console.log(msg.data)\n            },\n            send: function () {\n                this.socket.send(params)\n            },\n            close: function () {\n                console.log(\"socket已经关闭\")\n            }\n        },\n        destroyed () {\n            // 销毁监听\n            this.socket.onclose = this.close\n        }\n    }\n<\/script>\n",charsets:{cjk:!0}},{frontmatter:{},regularPath:"/%E5%B0%8F%E6%A1%88%E4%BE%8B/",relativePath:"小案例/README.md",key:"v-c8e5c632",path:"/%E5%B0%8F%E6%A1%88%E4%BE%8B/",headersStr:null,content:" 1. 区域随机生成圆\n 2. 随机点餐\n 3. 通用大数据可视化展示平台html模板\n 4. ",normalizedContent:" 1. 区域随机生成圆\n 2. 随机点餐\n 3. 通用大数据可视化展示平台html模板\n 4. ",charsets:{cjk:!0}},{title:"CSS 电子时钟",frontmatter:{},regularPath:"/%E5%B0%8F%E6%A1%88%E4%BE%8B/css%E6%A1%88%E4%BE%8B.html",relativePath:"小案例/css案例.md",key:"v-80b04568",path:"/%E5%B0%8F%E6%A1%88%E4%BE%8B/css%E6%A1%88%E4%BE%8B.html",headers:[{level:2,title:"CSS 电子时钟",slug:"css-电子时钟",normalizedTitle:"css 电子时钟",charIndex:2},{level:3,title:"一、数字的变换",slug:"一、数字的变换",normalizedTitle:"一、数字的变换",charIndex:15},{level:3,title:"二、时、分、秒",slug:"二、时、分、秒",normalizedTitle:"二、时、分、秒",charIndex:1031},{level:3,title:"三、时、分、秒自动补零",slug:"三、时、分、秒自动补零",normalizedTitle:"三、时、分、秒自动补零",charIndex:2511},{level:3,title:"四、时间初始化",slug:"四、时间初始化",normalizedTitle:"四、时间初始化",charIndex:2774},{level:3,title:"五、闪烁的分隔符",slug:"五、闪烁的分隔符",normalizedTitle:"五、闪烁的分隔符",charIndex:3794},{level:3,title:"六、总结一下",slug:"六、总结一下",normalizedTitle:"六、总结一下",charIndex:4021}],headersStr:"CSS 电子时钟 一、数字的变换 二、时、分、秒 三、时、分、秒自动补零 四、时间初始化 五、闪烁的分隔符 六、总结一下",content:"# CSS 电子时钟\n\n\n# 一、数字的变换\n\n先看看数字是如何变换的。\n\n在以前，如果要实现数字的递增变化，可能需要提前准备好这些数字，例如像这样\n\n<span>\n <i>1</i>\n  <i>2</i>\n  ...\n  <i>59</i>\n</span>\n\n\n然后通过改变位移来实现。\n\n但是，现在有更简洁的方式可以实现了，那就是 CSS @property[2]，不了解这个的可以参考这篇文章：CSS @property，让不可能变可能[3]。这是干什么的呢？简单来讲，可以自定义属性，在这个例子中，可以让数字像颜色一样进行过渡和动画，可能不太懂，直接看例子吧\n\n假设 HTML 是这样的\n\n<span style=\"--num: 0\"></span>\n\n\n我们让这个自定义变量在页面中展示出来，单纯的 content无法直接显示自定义变量，需要借助定时器，有兴趣的可以参考这篇文章：小tips: 如何借助content属性显示CSS var变量值[4]\n\nspan::after{\n  counter-reset: num var(--num);\n  content: counter(num);\n}\n\n\n\n\n然后，可以通过:hover改变这个数字\n\nspan:hover::after{\n  --num: 59\n}\n\n\n\n\n很生硬的从 0 变成 59 了，非常符合常规。如果利用 CSS property，情况就不一样了，需要改造的地方很少，先定义一下--h，然后给这个变量一个过渡时间，如下\n\n@property --h { \n  syntax: '<integer>';\n  inherits: false;\n  initial-value: 0;\n}\nspan::after{\n  transition: 1s --num;\n}\n\n\n神奇的一幕发生了\n\n\n\n看着好像不可思议？可以这么理解，通过@property定义后，这个变量本身可以单独设置过渡了，而不再取决于一些仅支持过渡的属性（color、width等）。甚至还能加上动画，需要用到steps方法，设置动画周期为无限，如下\n\n@keyframes num {\n  to {\n    --num: 10\n  }\n}\nspan{\n  animation: num 1s infinite steps(10);\n}\n\n\n时钟的基本运行原理就是这样了，一个无限循环的 CSS 动画！\n\n\n\n\n# 二、时、分、秒\n\n下面来看具体时、分、秒的实现，HTML 如下\n\n<div class=\"time\">\n  <span class=\"hour\"></span>\n  <a class=\"split\">:</a>\n  <span class=\"minitus\"></span>\n  <a class=\"split\">:</a>\n  <span class=\"seconds\"></span>\n</div>\n\n\n给时、分、秒附上初始值\n\n@property --h { \n  syntax: '<integer>';\n  inherits: false;\n  initial-value: 0;\n}\n@property --m { \n  syntax: '<integer>';\n  inherits: false;\n  initial-value: 0;\n}\n@property --s { \n  syntax: '<integer>';\n  inherits: false;\n  initial-value: 0;\n}\n.hour::after{\n  counter-reset: hour var(--h);\n  content: counter(hour);\n}\n.minitus::after{\n  counter-reset: minitus var(--m);\n  content: counter(minitus);\n}\n.seconds::after{\n  counter-reset: seconds var(--s);\n  content: counter(seconds);\n}\n\n\n\n\n这里的时、分、秒并没有联动关系，所以各自都需要单独的动画。下面就需要思考一下🤔，如果用 CSS 动画来实现，每个的动画起始点和时长是多少呢？\n\n没错，就是你想的，时针是0-23，时长24h，分针是0-59，时长60min，秒针是0-59，时长60s，但是 CSS 中的时间单位只支持秒(s)或者毫秒(ms)，所以这里需要转换一下，时长分别是60s*60*24、60s*60、60s，具体实现如下：\n\n@keyframes hour {\n  to {\n    --h: 24\n  }\n}\n@keyframes minitus {\n  to {\n    --m: 60\n  }\n}\n@keyframes seconds {\n  to {\n    --s: 60\n  }\n}\n.hour::after{\n  counter-reset: hour var(--h);\n  content: counter(hour);\n  animation: hour calc(60s * 60 * 24) infinite steps(24);\n}\n.minitus::after{\n  counter-reset: minitus var(--m);\n  content: counter(minitus);\n  animation: minitus calc(60s * 60) infinite steps(60);\n}\n.seconds::after{\n  counter-reset: seconds var(--s);\n  content: counter(seconds);\n  animation: seconds 60s infinite steps(60);\n}\n\n\n这里为了便于观察，将时间调快了10倍（60s => 6s），如下\n\n\n\n\n# 三、时、分、秒自动补零\n\n上面的布局有个问题，1 位数和 2 位数宽度变化导致时钟整体都在“晃动”，所以需要在1位数时补上一个“0”。关于 CSS 补零，之前在文章 CSS 补全字符串？中提到了 3 种方案，由于这里用了计数器，所以直接选择更改计数器样式的方法，通过decimal-leading-zero来实现，具体做法如下\n\n.hour::after{\n  /**/\n  content: counter(hour, decimal-leading-zero);/*添加计数器样式*/\n}\n\n\n这样就和谐多了\n\n\n\n\n# 四、时间初始化\n\n刚才都从00:00:00开始了，所以需要手动指定一下初始时间。假设现在是19:26:30，如何初始化呢？\n\n这里需要用animation-delay来提前运动到未来指定位置，为了方便控制，使用三个变量--dh、--dm、--ds来表示初始时间，注意，由于animation-delay也只支持秒(s)或者毫秒(ms)，所以也同样需要转换，实现如下\n\n:root{\n  --dh: 19;\n  --dm: 26;\n  --ds: 30;\n}\n.hour::after{\n  /**/\n  animation: hour calc(60s * 60 * 24) infinite steps(24);\n  animation-delay: calc( -60s * 60 * var(--dh) );\n}\n.minitus::after{\n  /**/\n  animation: minitus calc(60s * 60) infinite steps(60);\n  animation-delay: calc( -60s * var(--dm) );\n}\n.seconds::after{\n  /**/\n  animation: seconds 60s infinite steps(60);\n  animation-delay: calc( -1s * var(--ds) );\n}\n\n\n\n\n是不是有点奇怪？分钟在秒钟走到 30 的时候才变化，晚了半分钟。原因是这样的，虽然从数字上看，分钟是 26，但是还要考虑到秒钟的运动情况，比如像这种情况，分钟其实已经走了一半，应该是26.5（26 + 30 / 60），所以在计算时还需要加上偏移量。下面我们通过 JS 获取真实的时间，并修复偏移\n\nconst d = new Date()\nconst h = d.getHours();\nconst m = d.getMinutes();\nconst s = d.getSeconds();\ndocument.body.style.setProperty('--ds', s)\ndocument.body.style.setProperty('--dm', m + s/60)\ndocument.body.style.setProperty('--dh', h + m/60 + s/3600)\n\n\n这样就正常了\n\n\n\n\n# 五、闪烁的分隔符\n\n为了时钟看起来更加“动感”，可以给分隔符加上闪烁动画，代码如下\n\n@keyframes shark {\n  0%, 100%{\n    opacity: 1;\n  }\n  50%{\n    opacity: 0;\n  }\n}\n.split{\n  animation: shark 1s step-end infinite;\n}\n\n\n现在看下最终的效果\n\n\n\n完整代码可以访问 CSS time (codepen.io)[5]\n\n\n# 六、总结一下\n\n想不到实现一个时钟效果，用到了那么多 CSS 知识和技巧，简单总结一下吧\n\n 1. CSS 实现本质是无限循环的 CSS 动画\n 2. 灵活运用 CSS calc 计算\n 3. CSS 计数器可以将 CSS 变量通过 content 显示在页面\n 4. 数字的变化现在可以通过 CSS @property 配合动画实现\n 5. 时分秒的区别在于各自的动画时长、动画起始点不同\n 6. CSS 自动补零可以参考之前的文章，这里采用 decimal-leading-zero 实现\n 7. 时间初始化其实就是指定动画 delay 值\n 8. 指定初始值时还需要考虑到各自的偏移量，例如 19:30:30，此时的时针数字其实是 30.5\n 9. 分隔符的闪烁动画\n\n其实整个实现过程就是一个不断思考、学习的过程，比如为了实现数字的变化，就必须去学习 @property 相关，为了实现补零，就需要去了解更深层次的计数器相关，还有用到的各种动画。",normalizedContent:"# css 电子时钟\n\n\n# 一、数字的变换\n\n先看看数字是如何变换的。\n\n在以前，如果要实现数字的递增变化，可能需要提前准备好这些数字，例如像这样\n\n<span>\n <i>1</i>\n  <i>2</i>\n  ...\n  <i>59</i>\n</span>\n\n\n然后通过改变位移来实现。\n\n但是，现在有更简洁的方式可以实现了，那就是 css @property[2]，不了解这个的可以参考这篇文章：css @property，让不可能变可能[3]。这是干什么的呢？简单来讲，可以自定义属性，在这个例子中，可以让数字像颜色一样进行过渡和动画，可能不太懂，直接看例子吧\n\n假设 html 是这样的\n\n<span style=\"--num: 0\"></span>\n\n\n我们让这个自定义变量在页面中展示出来，单纯的 content无法直接显示自定义变量，需要借助定时器，有兴趣的可以参考这篇文章：小tips: 如何借助content属性显示css var变量值[4]\n\nspan::after{\n  counter-reset: num var(--num);\n  content: counter(num);\n}\n\n\n\n\n然后，可以通过:hover改变这个数字\n\nspan:hover::after{\n  --num: 59\n}\n\n\n\n\n很生硬的从 0 变成 59 了，非常符合常规。如果利用 css property，情况就不一样了，需要改造的地方很少，先定义一下--h，然后给这个变量一个过渡时间，如下\n\n@property --h { \n  syntax: '<integer>';\n  inherits: false;\n  initial-value: 0;\n}\nspan::after{\n  transition: 1s --num;\n}\n\n\n神奇的一幕发生了\n\n\n\n看着好像不可思议？可以这么理解，通过@property定义后，这个变量本身可以单独设置过渡了，而不再取决于一些仅支持过渡的属性（color、width等）。甚至还能加上动画，需要用到steps方法，设置动画周期为无限，如下\n\n@keyframes num {\n  to {\n    --num: 10\n  }\n}\nspan{\n  animation: num 1s infinite steps(10);\n}\n\n\n时钟的基本运行原理就是这样了，一个无限循环的 css 动画！\n\n\n\n\n# 二、时、分、秒\n\n下面来看具体时、分、秒的实现，html 如下\n\n<div class=\"time\">\n  <span class=\"hour\"></span>\n  <a class=\"split\">:</a>\n  <span class=\"minitus\"></span>\n  <a class=\"split\">:</a>\n  <span class=\"seconds\"></span>\n</div>\n\n\n给时、分、秒附上初始值\n\n@property --h { \n  syntax: '<integer>';\n  inherits: false;\n  initial-value: 0;\n}\n@property --m { \n  syntax: '<integer>';\n  inherits: false;\n  initial-value: 0;\n}\n@property --s { \n  syntax: '<integer>';\n  inherits: false;\n  initial-value: 0;\n}\n.hour::after{\n  counter-reset: hour var(--h);\n  content: counter(hour);\n}\n.minitus::after{\n  counter-reset: minitus var(--m);\n  content: counter(minitus);\n}\n.seconds::after{\n  counter-reset: seconds var(--s);\n  content: counter(seconds);\n}\n\n\n\n\n这里的时、分、秒并没有联动关系，所以各自都需要单独的动画。下面就需要思考一下🤔，如果用 css 动画来实现，每个的动画起始点和时长是多少呢？\n\n没错，就是你想的，时针是0-23，时长24h，分针是0-59，时长60min，秒针是0-59，时长60s，但是 css 中的时间单位只支持秒(s)或者毫秒(ms)，所以这里需要转换一下，时长分别是60s*60*24、60s*60、60s，具体实现如下：\n\n@keyframes hour {\n  to {\n    --h: 24\n  }\n}\n@keyframes minitus {\n  to {\n    --m: 60\n  }\n}\n@keyframes seconds {\n  to {\n    --s: 60\n  }\n}\n.hour::after{\n  counter-reset: hour var(--h);\n  content: counter(hour);\n  animation: hour calc(60s * 60 * 24) infinite steps(24);\n}\n.minitus::after{\n  counter-reset: minitus var(--m);\n  content: counter(minitus);\n  animation: minitus calc(60s * 60) infinite steps(60);\n}\n.seconds::after{\n  counter-reset: seconds var(--s);\n  content: counter(seconds);\n  animation: seconds 60s infinite steps(60);\n}\n\n\n这里为了便于观察，将时间调快了10倍（60s => 6s），如下\n\n\n\n\n# 三、时、分、秒自动补零\n\n上面的布局有个问题，1 位数和 2 位数宽度变化导致时钟整体都在“晃动”，所以需要在1位数时补上一个“0”。关于 css 补零，之前在文章 css 补全字符串？中提到了 3 种方案，由于这里用了计数器，所以直接选择更改计数器样式的方法，通过decimal-leading-zero来实现，具体做法如下\n\n.hour::after{\n  /**/\n  content: counter(hour, decimal-leading-zero);/*添加计数器样式*/\n}\n\n\n这样就和谐多了\n\n\n\n\n# 四、时间初始化\n\n刚才都从00:00:00开始了，所以需要手动指定一下初始时间。假设现在是19:26:30，如何初始化呢？\n\n这里需要用animation-delay来提前运动到未来指定位置，为了方便控制，使用三个变量--dh、--dm、--ds来表示初始时间，注意，由于animation-delay也只支持秒(s)或者毫秒(ms)，所以也同样需要转换，实现如下\n\n:root{\n  --dh: 19;\n  --dm: 26;\n  --ds: 30;\n}\n.hour::after{\n  /**/\n  animation: hour calc(60s * 60 * 24) infinite steps(24);\n  animation-delay: calc( -60s * 60 * var(--dh) );\n}\n.minitus::after{\n  /**/\n  animation: minitus calc(60s * 60) infinite steps(60);\n  animation-delay: calc( -60s * var(--dm) );\n}\n.seconds::after{\n  /**/\n  animation: seconds 60s infinite steps(60);\n  animation-delay: calc( -1s * var(--ds) );\n}\n\n\n\n\n是不是有点奇怪？分钟在秒钟走到 30 的时候才变化，晚了半分钟。原因是这样的，虽然从数字上看，分钟是 26，但是还要考虑到秒钟的运动情况，比如像这种情况，分钟其实已经走了一半，应该是26.5（26 + 30 / 60），所以在计算时还需要加上偏移量。下面我们通过 js 获取真实的时间，并修复偏移\n\nconst d = new date()\nconst h = d.gethours();\nconst m = d.getminutes();\nconst s = d.getseconds();\ndocument.body.style.setproperty('--ds', s)\ndocument.body.style.setproperty('--dm', m + s/60)\ndocument.body.style.setproperty('--dh', h + m/60 + s/3600)\n\n\n这样就正常了\n\n\n\n\n# 五、闪烁的分隔符\n\n为了时钟看起来更加“动感”，可以给分隔符加上闪烁动画，代码如下\n\n@keyframes shark {\n  0%, 100%{\n    opacity: 1;\n  }\n  50%{\n    opacity: 0;\n  }\n}\n.split{\n  animation: shark 1s step-end infinite;\n}\n\n\n现在看下最终的效果\n\n\n\n完整代码可以访问 css time (codepen.io)[5]\n\n\n# 六、总结一下\n\n想不到实现一个时钟效果，用到了那么多 css 知识和技巧，简单总结一下吧\n\n 1. css 实现本质是无限循环的 css 动画\n 2. 灵活运用 css calc 计算\n 3. css 计数器可以将 css 变量通过 content 显示在页面\n 4. 数字的变化现在可以通过 css @property 配合动画实现\n 5. 时分秒的区别在于各自的动画时长、动画起始点不同\n 6. css 自动补零可以参考之前的文章，这里采用 decimal-leading-zero 实现\n 7. 时间初始化其实就是指定动画 delay 值\n 8. 指定初始值时还需要考虑到各自的偏移量，例如 19:30:30，此时的时针数字其实是 30.5\n 9. 分隔符的闪烁动画\n\n其实整个实现过程就是一个不断思考、学习的过程，比如为了实现数字的变化，就必须去学习 @property 相关，为了实现补零，就需要去了解更深层次的计数器相关，还有用到的各种动画。",charsets:{cjk:!0}},{frontmatter:{},regularPath:"/%E5%B0%8F%E6%A1%88%E4%BE%8B/%E9%80%9A%E7%94%A8%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B1%95%E7%A4%BA%E5%B9%B3%E5%8F%B0html%E6%A8%A1%E6%9D%BF/",relativePath:"小案例/通用大数据可视化展示平台html模板/README.md",key:"v-cb3a39e2",path:"/%E5%B0%8F%E6%A1%88%E4%BE%8B/%E9%80%9A%E7%94%A8%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B1%95%E7%A4%BA%E5%B9%B3%E5%8F%B0html%E6%A8%A1%E6%9D%BF/",headersStr:null,content:"效果：\n\n\n\n代码：\n\n查看当前文件夹",normalizedContent:"效果：\n\n\n\n代码：\n\n查看当前文件夹",charsets:{cjk:!0}},{frontmatter:{},regularPath:"/%E5%B0%8F%E6%A1%88%E4%BE%8B/%E5%8C%BA%E5%9F%9F%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E5%9C%86/",relativePath:"小案例/区域随机生成圆/README.md",key:"v-59b8ee9a",path:"/%E5%B0%8F%E6%A1%88%E4%BE%8B/%E5%8C%BA%E5%9F%9F%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E5%9C%86/",headersStr:null,content:'效果：\n\n\n\n代码：\n\n<!DOCTYPE html>\n<html>\n\n    <body>\n\n        <canvas id="myCanvas" width="1412" height="460" style="border:1px solid #d3d3d3;">\n            Your browser does not support the HTML5 canvas tag.\n        </canvas>\n\n        <script>\n            class Circle {\n                constructor(x, y, r, color) {\n                    this.x = x\n                    this.y = y\n                    this.r = r,\n                        this.c = color ? color : this.getRandomColor()\n                }\n                getRandomColor() {\n                    let r = Math.floor(Math.random() * 100) + 155\n                    let g = Math.floor(Math.random() * 100) + 155\n                    let b = Math.floor(Math.random() * 100) + 155\n                    return `rgb(${r},${g},${b})`\n                }\n            }\n\n            class RandomCircle {\n\n                constructor(obj) {\n                    this.c = document.getElementById(obj.id);\n                    this.ctx = this.c.getContext("2d");\n                    this.dWidth = this.c.width;\n                    this.dHeight = this.c.height\n\n                    this.fix = obj.fix || false;\n                    this.minMargin = obj.minMargin || 10\n                    this.minRadius = obj.minRadius || 30\n                    this.radiuArr = obj.radiuArr || [80, 70, 60, 50, 45, 40, 40, 35, 35, 30]\n                    this.total = obj.total || 10\n                    this.circleArray = []\n                    this.circleNumber = 1\n                }\n\n\n                drawOneCircle(c) {\n                    let ctx = this.ctx;\n                    ctx.beginPath();\n                    ctx.strokeStyle = c.c;\n                    ctx.fillStyle = c.c;\n                    ctx.arc(c.x, c.y, c.r, 0, 2 * Math.PI);\n                    ctx.stroke();\n                    ctx.fill();\n\n                    ctx.fillStyle = \'black\';\n                    ctx.fillText(\'No:\' + this.circleNumber, c.x - 10, c.y - 5);\n                    ctx.fillText(\'R:\' + c.r, c.x - 10, c.y + 5);\n                    this.circleNumber++\n                }\n\n                check(x, y, r) {\n                    return !(x + r > this.dWidth || x - r < 0 || y + r > this.dHeight || y - r < 0)\n                }\n\n                // 获取一个新圆的半径，主要判断半径与最近的一个圆的距离\n                getR(x, y) {\n                    if (this.circleArray.length === 0) return Math.floor(Math.random() * 20 + 80)\n                    let lenArr = this.circleArray.map(c => {\n                        let xSpan = c.x - x\n                        let ySpan = c.y - y\n                        return Math.floor(Math.sqrt(Math.pow(xSpan, 2) + Math.pow(ySpan, 2))) - c.r\n                    })\n                    let minCircleLen = Math.min(...lenArr)\n                    let minC = this.circleArray[lenArr.indexOf(minCircleLen)]\n                    let tempR = this.fix ? this.radiuArr[this.circleArray.length] : minCircleLen - this.minMargin\n                    tempR = tempR < 60 ?  tempR : 60\n                    let bool = this.fix ? (tempR <= minCircleLen - minC.r) : (tempR >= this.minRadius)\n                    return bool ? tempR : false\n                }\n\n                // 生成一个圆，随机生成圆心。\n                // 如果连续生成200次半径都没有合适的话，终止进程\n                createOneCircle() {\n                    let x, y, r;\n                    let createCircleTimes = 0\n                    while (true) {\n                        createCircleTimes++\n                        if (this.circleArray.length === 0) {\n                            x = 706\n                            y = 230\n                        } else {\n                            x = Math.floor(Math.random() * this.dWidth)\n                            y = Math.floor(Math.random() * this.dHeight)\n                        }\n                        let TR = this.getR(x, y)\n                        if (!TR) {\n                            continue;\n                        } else {\n                            r = TR\n                        }\n                        if (this.check(x, y, r) || createCircleTimes > 200) {\n                            break\n                        }\n\n                    }\n                    this.check(x, y, r) && this.circleArray.push(new Circle(x, y, r))\n\n                }\n\n                // 如果生成100次新圆都失败的话，终止方案。\n                // 如果生成100种方案都没有合适可用的话，终止进程。\n                init() {\n                    let n = 0\n                    while (this.circleArray.length < this.total) {\n                        this.circleArray = []\n                        let i = 0;\n                        while (this.circleArray.length < this.total) {\n                            this.createOneCircle()\n                            i++\n                            if (i >= 100) {\n                                break;\n                            }\n                        }\n                        n++\n                        if (n > 100) {\n                            break;\n                        }\n                    }\n                    // 根据半径从大到小画圆。\n                    this.circleArray.sort((a, b) => b.r - a.r).forEach(c => {\n                        this.drawOneCircle(c)\n                    })\n                }\n            }\n\n\n            let p = new RandomCircle({ id: \'myCanvas\', total: 100 })\n            p.init()\n\n            console.log(p.circleArray)\n            console.log(p.circleArray.map(v => {\n                return {\n                    x: v.x - 706,\n                    y: v.y - 230\n                }\n            }))\n\n        <\/script>\n    </body>\n\n</html>\n',normalizedContent:'效果：\n\n\n\n代码：\n\n<!doctype html>\n<html>\n\n    <body>\n\n        <canvas id="mycanvas" width="1412" height="460" style="border:1px solid #d3d3d3;">\n            your browser does not support the html5 canvas tag.\n        </canvas>\n\n        <script>\n            class circle {\n                constructor(x, y, r, color) {\n                    this.x = x\n                    this.y = y\n                    this.r = r,\n                        this.c = color ? color : this.getrandomcolor()\n                }\n                getrandomcolor() {\n                    let r = math.floor(math.random() * 100) + 155\n                    let g = math.floor(math.random() * 100) + 155\n                    let b = math.floor(math.random() * 100) + 155\n                    return `rgb(${r},${g},${b})`\n                }\n            }\n\n            class randomcircle {\n\n                constructor(obj) {\n                    this.c = document.getelementbyid(obj.id);\n                    this.ctx = this.c.getcontext("2d");\n                    this.dwidth = this.c.width;\n                    this.dheight = this.c.height\n\n                    this.fix = obj.fix || false;\n                    this.minmargin = obj.minmargin || 10\n                    this.minradius = obj.minradius || 30\n                    this.radiuarr = obj.radiuarr || [80, 70, 60, 50, 45, 40, 40, 35, 35, 30]\n                    this.total = obj.total || 10\n                    this.circlearray = []\n                    this.circlenumber = 1\n                }\n\n\n                drawonecircle(c) {\n                    let ctx = this.ctx;\n                    ctx.beginpath();\n                    ctx.strokestyle = c.c;\n                    ctx.fillstyle = c.c;\n                    ctx.arc(c.x, c.y, c.r, 0, 2 * math.pi);\n                    ctx.stroke();\n                    ctx.fill();\n\n                    ctx.fillstyle = \'black\';\n                    ctx.filltext(\'no:\' + this.circlenumber, c.x - 10, c.y - 5);\n                    ctx.filltext(\'r:\' + c.r, c.x - 10, c.y + 5);\n                    this.circlenumber++\n                }\n\n                check(x, y, r) {\n                    return !(x + r > this.dwidth || x - r < 0 || y + r > this.dheight || y - r < 0)\n                }\n\n                // 获取一个新圆的半径，主要判断半径与最近的一个圆的距离\n                getr(x, y) {\n                    if (this.circlearray.length === 0) return math.floor(math.random() * 20 + 80)\n                    let lenarr = this.circlearray.map(c => {\n                        let xspan = c.x - x\n                        let yspan = c.y - y\n                        return math.floor(math.sqrt(math.pow(xspan, 2) + math.pow(yspan, 2))) - c.r\n                    })\n                    let mincirclelen = math.min(...lenarr)\n                    let minc = this.circlearray[lenarr.indexof(mincirclelen)]\n                    let tempr = this.fix ? this.radiuarr[this.circlearray.length] : mincirclelen - this.minmargin\n                    tempr = tempr < 60 ?  tempr : 60\n                    let bool = this.fix ? (tempr <= mincirclelen - minc.r) : (tempr >= this.minradius)\n                    return bool ? tempr : false\n                }\n\n                // 生成一个圆，随机生成圆心。\n                // 如果连续生成200次半径都没有合适的话，终止进程\n                createonecircle() {\n                    let x, y, r;\n                    let createcircletimes = 0\n                    while (true) {\n                        createcircletimes++\n                        if (this.circlearray.length === 0) {\n                            x = 706\n                            y = 230\n                        } else {\n                            x = math.floor(math.random() * this.dwidth)\n                            y = math.floor(math.random() * this.dheight)\n                        }\n                        let tr = this.getr(x, y)\n                        if (!tr) {\n                            continue;\n                        } else {\n                            r = tr\n                        }\n                        if (this.check(x, y, r) || createcircletimes > 200) {\n                            break\n                        }\n\n                    }\n                    this.check(x, y, r) && this.circlearray.push(new circle(x, y, r))\n\n                }\n\n                // 如果生成100次新圆都失败的话，终止方案。\n                // 如果生成100种方案都没有合适可用的话，终止进程。\n                init() {\n                    let n = 0\n                    while (this.circlearray.length < this.total) {\n                        this.circlearray = []\n                        let i = 0;\n                        while (this.circlearray.length < this.total) {\n                            this.createonecircle()\n                            i++\n                            if (i >= 100) {\n                                break;\n                            }\n                        }\n                        n++\n                        if (n > 100) {\n                            break;\n                        }\n                    }\n                    // 根据半径从大到小画圆。\n                    this.circlearray.sort((a, b) => b.r - a.r).foreach(c => {\n                        this.drawonecircle(c)\n                    })\n                }\n            }\n\n\n            let p = new randomcircle({ id: \'mycanvas\', total: 100 })\n            p.init()\n\n            console.log(p.circlearray)\n            console.log(p.circlearray.map(v => {\n                return {\n                    x: v.x - 706,\n                    y: v.y - 230\n                }\n            }))\n\n        <\/script>\n    </body>\n\n</html>\n',charsets:{cjk:!0}},{frontmatter:{},regularPath:"/%E5%B0%8F%E6%A1%88%E4%BE%8B/%E9%9A%8F%E6%9C%BA%E7%82%B9%E9%A4%90/",relativePath:"小案例/随机点餐/README.md",key:"v-e498804c",path:"/%E5%B0%8F%E6%A1%88%E4%BE%8B/%E9%9A%8F%E6%9C%BA%E7%82%B9%E9%A4%90/",headersStr:null,content:'效果：\n\n\n\n代码：\n\n<!DOCTYPE html>\n<html lang="en">\n\n    <head>\n        <meta charset="UTF-8">\n        <meta http-equiv="X-UA-Compatible" content="IE=edge">\n        <meta name="viewport" content="width=device-width, initial-scale=1.0">\n        <title>随机点名</title>\n        <style>\n            .main {\n                display: flex;\n                flex-direction: column;\n                align-items: center;\n            }\n\n            .menu {\n                border: 1px solid #ddd;\n                display: flex;\n                flex-direction: column;\n                align-items: center;\n                margin-bottom: 10px;\n                padding: 0 10px;\n            }\n\n            .menu .allName {\n                width: 600px;\n                display: flex;\n                flex-wrap: wrap;\n                padding-bottom: 10px;\n            }\n\n            .menu .allName div {\n                flex: 0 0 25%;\n            }\n\n            .content {\n                width: 300px;\n                height: 450px;\n                /* margin: 0 auto; */\n            }\n\n            .content img {\n                display: block;\n                width: 300px;\n                height: 300px;\n                background: skyblue;\n                margin-bottom: 10px;\n            }\n\n            .content p#name {\n                width: 300px;\n                text-align: center;\n                height: 20px;\n                font-family: Kaiti;\n                font-weight: bold;\n                font-size: 20px;\n            }\n\n            .content input {\n                display: block;\n                width: 80px;\n                margin: 0 auto;\n            }\n        </style>\n    </head>\n\n    <body>\n        <div class="main">\n            <div class="menu">\n                <p>菜单</p>\n                <div id="allName" class="allName">\n                    <div>1111</div>\n                    <div>1111</div>\n                    <div>1111</div>\n                    <div>1111</div>\n                    <div>1111</div>\n                </div>\n            </div>\n            <div class="content">\n                <img src="" alt="" width="300px" height="300px">\n                <p id="name"></p>\n                <input type="button" value="随机" onclick="bianhuan()">\n            </div>\n        </div>\n    </body>\n    <script>\n        // var arr1 = ["何润东", "刘德华", "刘诗诗", "刘涛", "张涵予", "张杰", "张若昀", "张雨绮", "周星驰", "周雨彭", "胡歌", "刘亦菲", "娜扎", "杨幂", "张含韵", "张靓颖", "赵丽颖", "周冬雨", "熊希霖", "范冰冰"];\n        var arr1 = ["炒面", "螺蛳粉", "蒸菜", "香锅", "兰州拉面", "烧腊", "外婆饭"];\n        var allNameP = document.getElementById("allName");\n        // allNameP.innerHTML = arr1.toString();\n        generateMenu()\n        // 生成菜单\n        function generateMenu() {\n            var HTML = \'\'\n            for (let index = 0; index < arr1.length; index++) {\n                const element = arr1[index];\n                HTML += `<div>${index+1}. ${element}</div>`\n            }\n            allNameP.innerHTML = HTML\n        }\n\n        // 数组长度为 arr1.length\n        function bianhuan() {\n            var ran1 = Math.round(Math.random() * 100);  //生成50以内的随机数 \n            ran1 += arr1.length; // 至少循环一轮\n            console.log(ran1);\n            var num = 0;\n            var inte = setInterval(function() {\n                var img1 = document.getElementsByTagName("img")[0];\n                var p1 = document.getElementById("name");\n                var imgName = arr1[num % arr1.length];\n                img1.src = "./imgs/" + imgName + ".jpeg";\n                p1.innerHTML = imgName;\n                if (num == ran1) {\n                    clearInterval(inte);\n                }\n                num++;\n            }, 100);\n        }\n    <\/script>\n\n</html>\n',normalizedContent:'效果：\n\n\n\n代码：\n\n<!doctype html>\n<html lang="en">\n\n    <head>\n        <meta charset="utf-8">\n        <meta http-equiv="x-ua-compatible" content="ie=edge">\n        <meta name="viewport" content="width=device-width, initial-scale=1.0">\n        <title>随机点名</title>\n        <style>\n            .main {\n                display: flex;\n                flex-direction: column;\n                align-items: center;\n            }\n\n            .menu {\n                border: 1px solid #ddd;\n                display: flex;\n                flex-direction: column;\n                align-items: center;\n                margin-bottom: 10px;\n                padding: 0 10px;\n            }\n\n            .menu .allname {\n                width: 600px;\n                display: flex;\n                flex-wrap: wrap;\n                padding-bottom: 10px;\n            }\n\n            .menu .allname div {\n                flex: 0 0 25%;\n            }\n\n            .content {\n                width: 300px;\n                height: 450px;\n                /* margin: 0 auto; */\n            }\n\n            .content img {\n                display: block;\n                width: 300px;\n                height: 300px;\n                background: skyblue;\n                margin-bottom: 10px;\n            }\n\n            .content p#name {\n                width: 300px;\n                text-align: center;\n                height: 20px;\n                font-family: kaiti;\n                font-weight: bold;\n                font-size: 20px;\n            }\n\n            .content input {\n                display: block;\n                width: 80px;\n                margin: 0 auto;\n            }\n        </style>\n    </head>\n\n    <body>\n        <div class="main">\n            <div class="menu">\n                <p>菜单</p>\n                <div id="allname" class="allname">\n                    <div>1111</div>\n                    <div>1111</div>\n                    <div>1111</div>\n                    <div>1111</div>\n                    <div>1111</div>\n                </div>\n            </div>\n            <div class="content">\n                <img src="" alt="" width="300px" height="300px">\n                <p id="name"></p>\n                <input type="button" value="随机" onclick="bianhuan()">\n            </div>\n        </div>\n    </body>\n    <script>\n        // var arr1 = ["何润东", "刘德华", "刘诗诗", "刘涛", "张涵予", "张杰", "张若昀", "张雨绮", "周星驰", "周雨彭", "胡歌", "刘亦菲", "娜扎", "杨幂", "张含韵", "张靓颖", "赵丽颖", "周冬雨", "熊希霖", "范冰冰"];\n        var arr1 = ["炒面", "螺蛳粉", "蒸菜", "香锅", "兰州拉面", "烧腊", "外婆饭"];\n        var allnamep = document.getelementbyid("allname");\n        // allnamep.innerhtml = arr1.tostring();\n        generatemenu()\n        // 生成菜单\n        function generatemenu() {\n            var html = \'\'\n            for (let index = 0; index < arr1.length; index++) {\n                const element = arr1[index];\n                html += `<div>${index+1}. ${element}</div>`\n            }\n            allnamep.innerhtml = html\n        }\n\n        // 数组长度为 arr1.length\n        function bianhuan() {\n            var ran1 = math.round(math.random() * 100);  //生成50以内的随机数 \n            ran1 += arr1.length; // 至少循环一轮\n            console.log(ran1);\n            var num = 0;\n            var inte = setinterval(function() {\n                var img1 = document.getelementsbytagname("img")[0];\n                var p1 = document.getelementbyid("name");\n                var imgname = arr1[num % arr1.length];\n                img1.src = "./imgs/" + imgname + ".jpeg";\n                p1.innerhtml = imgname;\n                if (num == ran1) {\n                    clearinterval(inte);\n                }\n                num++;\n            }, 100);\n        }\n    <\/script>\n\n</html>\n',charsets:{cjk:!0}},{title:"Ant Design of Vue",frontmatter:{},regularPath:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/Ant_Design_Vue.html",relativePath:"插件小技巧/Ant_Design_Vue.md",key:"v-2272963b",path:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/Ant_Design_Vue.html",headersStr:null,content:"# Ant Design of Vue\n\nAnt Design of Vue 官网：https://www.antdv.com/docs/vue/introduce-cn/",normalizedContent:"# ant design of vue\n\nant design of vue 官网：https://www.antdv.com/docs/vue/introduce-cn/",charsets:{cjk:!0}},{frontmatter:{},regularPath:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/api.html",relativePath:"插件小技巧/api.md",key:"v-ac38b92e",path:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/api.html",headersStr:null,content:"https://hellosean1025.github.io/yapi/documents/index.html",normalizedContent:"https://hellosean1025.github.io/yapi/documents/index.html",charsets:{}},{frontmatter:{},regularPath:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/codemirror.html",relativePath:"插件小技巧/codemirror.md",key:"v-62b213c6",path:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/codemirror.html",headersStr:null,content:"<template>\n<div class=\"code-mirror-box\">\n    <textarea ref=\"textareaCoder\" v-model=\"code\"></textarea>\n    </div>\n</template>\n\n<script>\n    // 引入全局实例\n    import _CodeMirror from 'codemirror'\n    // language\n    import 'codemirror/mode/javascript/javascript.js'\n    // 核心样式\n    import 'codemirror/lib/codemirror.css'\n    // 引入主题后还需要在 options 中指定主题才会生效\n    import 'codemirror/theme/monokai.css'\n    // active-line\n    import 'codemirror/addon/selection/active-line.js'\n    // foldGutter\n    import 'codemirror/addon/fold/foldgutter.css'\n    import 'codemirror/addon/fold/brace-fold.js'\n    import 'codemirror/addon/fold/comment-fold.js'\n    import 'codemirror/addon/fold/foldcode.js'\n    import 'codemirror/addon/fold/foldgutter.js'\n    import 'codemirror/addon/fold/indent-fold.js'\n    import 'codemirror/addon/fold/markdown-fold.js'\n    import 'codemirror/addon/fold/xml-fold.js'\n\n    // 尝试获取全局实例\n    const CodeMirror = window.CodeMirror || _CodeMirror\n\n    export default {\n        name: 'code-mirror-box',\n        props: ['conHeight', 'codeValue','editable'],\n        data() {\n            return {\n                // 内部真实的内容\n                code: '',\n                // 编辑器实例\n                coder: null,\n                // 默认配置\n                options: {\n                    mode: 'javascript', // 默认的语法类型\n                    // 缩进格式\n                    tabSize: 2,\n                    // 主题，对应主题库 JS 需要提前引入ambiance(白色)  monokai(黑色)\n                    theme: 'ambiance',\n                    // 显示行号\n                    lineNumbers: true,\n                    line: true,\n                    styleActiveLine: false, // 激活行样式\n                    // 添加折叠\n                    foldGutter: true,\n                    extraKeys: { Ctrl: 'autocomplete' }, //自动提示配置\n                    //设置为只读状态，不可写\n                    readOnly: '',\n                    lineWrapping: true, // 自动换行\n                    gutters: ['CodeMirror-linenumbers', 'CodeMirror-foldgutter'],\n                },\n            }\n        },\n        created() {\n            this.code = this.codeValue\n            this.options.readOnly = this.editable\n        },\n        mounted() {\n            // 初始化\n            this._initialize()\n        },\n        methods: {\n            // 初始化\n            _initialize() {\n                // 初始化编辑器实例，传入需要被实例化的文本域对象和默认配置\n                this.coder = CodeMirror.fromTextArea(\n                    this.$refs.textareaCoder,\n                    this.options\n                )\n                // 监听改变\n                this.coder.on('change', (coder) => {\n                    this.code = coder.getValue()\n                    // this.coder.setSize(600,this.conHeight);//设置编译器大小\n                })\n            },\n            // 赋值操作\n            setValue(val) {\n                this.coder.setValue(val)\n            },\n            // 刷新操作\n            refresh() {\n                let timer = setTimeout(() => {\n                    clearTimeout(timer)\n                    this.$nextTick(() => {\n                        this.coder.refresh()\n                    })\n                }, 100)\n                },\n        },\n        watch: {\n            code: {\n                handler(val) {\n                    this.$emit('getCode', val)\n                },\n            },\n        },\n    }\n<\/script>\n\n<style lang=\"less\" scoped>\n    .code-mirror-box {\n        font-size: 14px;\n    }\n    .CodeMirror {\n        height: 100% !important;\n    }\n    .CodeMirror-scroll {\n        height: 100%;\n    }\n</style>\n",normalizedContent:"<template>\n<div class=\"code-mirror-box\">\n    <textarea ref=\"textareacoder\" v-model=\"code\"></textarea>\n    </div>\n</template>\n\n<script>\n    // 引入全局实例\n    import _codemirror from 'codemirror'\n    // language\n    import 'codemirror/mode/javascript/javascript.js'\n    // 核心样式\n    import 'codemirror/lib/codemirror.css'\n    // 引入主题后还需要在 options 中指定主题才会生效\n    import 'codemirror/theme/monokai.css'\n    // active-line\n    import 'codemirror/addon/selection/active-line.js'\n    // foldgutter\n    import 'codemirror/addon/fold/foldgutter.css'\n    import 'codemirror/addon/fold/brace-fold.js'\n    import 'codemirror/addon/fold/comment-fold.js'\n    import 'codemirror/addon/fold/foldcode.js'\n    import 'codemirror/addon/fold/foldgutter.js'\n    import 'codemirror/addon/fold/indent-fold.js'\n    import 'codemirror/addon/fold/markdown-fold.js'\n    import 'codemirror/addon/fold/xml-fold.js'\n\n    // 尝试获取全局实例\n    const codemirror = window.codemirror || _codemirror\n\n    export default {\n        name: 'code-mirror-box',\n        props: ['conheight', 'codevalue','editable'],\n        data() {\n            return {\n                // 内部真实的内容\n                code: '',\n                // 编辑器实例\n                coder: null,\n                // 默认配置\n                options: {\n                    mode: 'javascript', // 默认的语法类型\n                    // 缩进格式\n                    tabsize: 2,\n                    // 主题，对应主题库 js 需要提前引入ambiance(白色)  monokai(黑色)\n                    theme: 'ambiance',\n                    // 显示行号\n                    linenumbers: true,\n                    line: true,\n                    styleactiveline: false, // 激活行样式\n                    // 添加折叠\n                    foldgutter: true,\n                    extrakeys: { ctrl: 'autocomplete' }, //自动提示配置\n                    //设置为只读状态，不可写\n                    readonly: '',\n                    linewrapping: true, // 自动换行\n                    gutters: ['codemirror-linenumbers', 'codemirror-foldgutter'],\n                },\n            }\n        },\n        created() {\n            this.code = this.codevalue\n            this.options.readonly = this.editable\n        },\n        mounted() {\n            // 初始化\n            this._initialize()\n        },\n        methods: {\n            // 初始化\n            _initialize() {\n                // 初始化编辑器实例，传入需要被实例化的文本域对象和默认配置\n                this.coder = codemirror.fromtextarea(\n                    this.$refs.textareacoder,\n                    this.options\n                )\n                // 监听改变\n                this.coder.on('change', (coder) => {\n                    this.code = coder.getvalue()\n                    // this.coder.setsize(600,this.conheight);//设置编译器大小\n                })\n            },\n            // 赋值操作\n            setvalue(val) {\n                this.coder.setvalue(val)\n            },\n            // 刷新操作\n            refresh() {\n                let timer = settimeout(() => {\n                    cleartimeout(timer)\n                    this.$nexttick(() => {\n                        this.coder.refresh()\n                    })\n                }, 100)\n                },\n        },\n        watch: {\n            code: {\n                handler(val) {\n                    this.$emit('getcode', val)\n                },\n            },\n        },\n    }\n<\/script>\n\n<style lang=\"less\" scoped>\n    .code-mirror-box {\n        font-size: 14px;\n    }\n    .codemirror {\n        height: 100% !important;\n    }\n    .codemirror-scroll {\n        height: 100%;\n    }\n</style>\n",charsets:{cjk:!0}},{frontmatter:{},regularPath:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/",relativePath:"插件小技巧/README.md",key:"v-126e2adc",path:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/",headersStr:null,content:"主要讲解在使用插件中遇到的问题和解决问题的总结。\n\n插件如下：\n\n 1. element\n 2. eChart\n 3. Ant Design of Vue\n 4. wangeditor",normalizedContent:"主要讲解在使用插件中遇到的问题和解决问题的总结。\n\n插件如下：\n\n 1. element\n 2. echart\n 3. ant design of vue\n 4. wangeditor",charsets:{cjk:!0}},{title:"d3.js 实现企业图谱(基于vue)",frontmatter:{},regularPath:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/d3.html",relativePath:"插件小技巧/d3.md",key:"v-db823ad2",path:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/d3.html",headers:[{level:2,title:"d3.js 实现企业图谱(基于vue)",slug:"d3-js-实现企业图谱-基于vue",normalizedTitle:"d3.js 实现企业图谱(基于vue)",charIndex:2},{level:2,title:"D3.js树图tree 组织机构分布图(基于vue)",slug:"d3-js树图tree-组织机构分布图-基于vue",normalizedTitle:"d3.js树图tree 组织机构分布图(基于vue)",charIndex:115},{level:3,title:"实现结果",slug:"实现结果",normalizedTitle:"实现结果",charIndex:146},{level:3,title:"实现代码",slug:"实现代码",normalizedTitle:"实现代码",charIndex:157}],headersStr:"d3.js 实现企业图谱(基于vue) D3.js树图tree 组织机构分布图(基于vue) 实现结果 实现代码",content:"# d3.js 实现企业图谱(基于vue)\n\nhttps://blog.csdn.net/weixin_44406901/article/details/125123880?spm=1001.2014.3001.5506\n\n\n# D3.js树图tree 组织机构分布图(基于vue)\n\n\n# 实现结果\n\n\n\n\n# 实现代码\n\n# html\n\n<template>\n    <div class=\"seeTree-page\">\n        <div id=\"treeRoot\"></div>\n    </div>\n</template>\n\n\n# js\n\n<script>\n    let d3 = require('../static/js/d3.v5.js');\nimport {treeData} from '../constants';//数据源\nexport default {\n    data() {\n        return {\n            container: null,//容器svg>g\n            duration: 750,//动画持续时间\n            scaleRange: [.2, 4],//container缩放范围\n            direction: ['r', 'l'],//分为左右2个方向\n            centralPoint: [0, 0],//画布中心点坐标x,y\n            root: {r: {}, l: {}},//左右2块数据源\n            rootNodeLength: 0,//根节点名称长度\n            rootName: [\"上海天正实业有限\", \"公司\"],//根节点名称\n            textSpace: 15,//多行文字间距\n            themeColor: \"#2196F3\",//主色\n            nodeSize: [30, 100],//节点间距(高/水平)\n            fontSize: 12,//字体大小，也是单字所占宽高\n            rectMinWidth: 50,//节点方框默认最小，\n            textPadding: 5,//文字与方框间距,注：固定值5\n            circleR: 5,//圆圈半径\n        }\n    },\n    computed: {\n        treeMap() {//树布局\n            return d3.tree().nodeSize(this.nodeSize).separation((a, b) => {\n                let result = a.parent === b.parent && !a.children && !b.children ? 1 : 2;\n                if (result > 1) {\n                    let length = 0;\n                    length = a.children ? (length + a.children.length) : length;\n                    length = b.children ? (length + b.children.length) : length;\n                    result = length / 2 + 0.5;\n                }\n                return result;\n            });\n        },\n    },\n    mounted() {\n        this.treeInit();\n    },\n    methods: {\n        //随机数，用于绑定id\n        uuid() {\n            function s4() {\n                return Math.floor((1 + Math.random()) * 0x10000)\n                    .toString(16)\n                    .substring(1)\n            }\n\n            return (\n                s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4()\n            )\n        },\n\n        //初始化\n        treeInit() {\n            const margin = {top: 0, right: 0, bottom: 0, left: 0};\n            const treeWidth = document.body.clientWidth - margin.left - margin.right;//tree容器宽\n            const treeHeight = document.body.clientHeight - margin.top - margin.bottom;//tree容器高\n            const centralY = treeWidth / 2 + margin.left;\n            const centralX = treeHeight / 2 + margin.top;\n            this.centralPoint = [centralX, centralY];//中心点坐标\n            //根节点字符所占宽度\n            this.rootNodeLength = this.rootName[0].length * this.fontSize + 30;\n\n            //svg标签\n            const svg = d3.select('#treeRoot').append('svg')\n            .attr('class', 'tree-svg')\n            .attr('width', treeWidth)\n            .attr('height', treeHeight)\n            .attr('font-size', this.fontSize)\n            .attr('fill', '#555');\n\n            //g标签\n            this.container = svg.append('g')\n                .attr('class', \"container\")\n                .attr('transform', `translate(${margin.left},${margin.top}) scale(1)`);\n            //画出根节点\n            this.drawRoot();\n\n            //指定缩放范围\n            const zoom = d3.zoom().scaleExtent(this.scaleRange).on('zoom', this.zoomFn);\n            //动画持续时间\n            this.container.transition().duration(this.duration).call(zoom.transform, d3.zoomIdentity);\n            svg.call(zoom);\n            //数据处理\n            this.dealData();\n        },\n        //初始化缩放方法\n        zoomFn() {\n            const zoom = d3.event.transform;\n            return this.container.attr('transform', zoom);\n        },\n        //数据处理\n        dealData() {\n            this.direction.forEach(item => {\n                this.root[item] = d3.hierarchy(treeData[item]);\n                this.root[item].x0 = this.centralPoint[0];//根节点x坐标\n                this.root[item].y0 = this.centralPoint[1];//根节点Y坐标\n                this.root[item].descendants().forEach(d => {\n                    d._children = d.children;//添加_children属性，用于实现点击收缩及展开功能\n                    d.id = item + this.uuid();//绑定唯一标识ID\n                });\n                this.update(this.root[item], item);\n            })\n        },\n        //画根节点\n        drawRoot() {\n            const title = this.container.append('g')\n            .attr('id', \"rootTitle\")\n            .attr(\"transform\", `translate(${this.centralPoint[1]},${this.centralPoint[0]})`);\n            title.append('svg:rect')\n                .attr('class', \"rootTitle\")\n                .attr(\"y\", 0)\n                .attr(\"x\", -this.rootNodeLength / 2)\n                .attr(\"width\", this.rootNodeLength)\n                .attr(\"height\", 0)\n                .attr(\"rx\", 5) //圆角\n                .style('fill', this.themeColor);\n            this.rootName.forEach((name, index) => {\n                title.append('text').attr('fill', 'white')\n                    .attr('y', index * this.textSpace - 2)\n                    .attr('text-anchor', 'middle')\n                    .text(name);\n\n                let lineHeight = (index + 2) * this.textSpace;\n                //修改rootTitle rect 的高度\n                d3.select('#rootTitle rect').attr('height', lineHeight).attr('y', -lineHeight / 2);\n            });\n\n\n        },\n        //开始绘图\n        update(source, direction) {\n            const dirRight = direction === 'r' ? 1 : -1;//方向为右/左\n            const className = `${direction}gNode`;\n            const tree = this.treeMap(this.root[direction]);\n            const nodes = tree.descendants();//返回后代节点数组，第一个节点为自身，然后依次为所有子节点的拓扑排序\n            const links = tree.links();//返回当前 node 的 links 数组, 其中每个 link 定义了 source父节点, target 子节点属性。\n            nodes.forEach(d => {\n                //左右2部分，设置以中心点为圆点(默认左上角为远点)\n                d.y = dirRight * (d.y + this.rootNodeLength / 2) + this.centralPoint[1];\n                d.x = d.x + this.centralPoint[0];\n            });\n\n            //根据class名称获取左或者右的g节点，达到分块更新\n            const node = this.container.selectAll(`g.${className}`).data(nodes, d => d.id);\n\n            //新增节点，tree会根据数据内的children扩展相关节点\n            const nodeEnter = node.enter().append(\"g\")\n            .attr('id', d => `g${d.id}`)\n            .attr('class', className)\n            .attr(\"transform\", d => `translate(${source.y0},${source.x0})`)\n            .attr(\"fill-opacity\", 0)\n            .attr(\"stroke-opacity\", 0)\n            .on(\"click\", (d) => {\n                d.depth !== 0 && this.clickNode(d, direction);//根节点不执行点击事件\n            });\n\n            nodeEnter.each(d => {\n                if (d.depth > 0) {//非根节点且无子节点\n                    this.drawText(`g${d.id}`, dirRight);//画文本\n\n                    if (d.data.value) {\n                        this.drawTsText(`g${d.id}`);//画子文本\n                    }\n                    this.drawRect(`g${d.id}`, dirRight);//画方框\n                    // this.drawFilter(`g${d.id}`);//画阴影\n                    // d3.select(`#g${d.id} rect`).attr('stroke-width',15).attr('filter',`url(#fg${d.id})`);//给rect绑定阴影\n                }\n                if (d.depth > 0 && d._children) {//非根节点且有子节点\n                    const width = Math.min(d.data.name.length * 14, this.rectMinWidth);\n                    let right = dirRight > 0;//右为1，左为-1\n                    let xDistance = right ? width : -width;\n                    d3.select(`#g${d.id} rect`)\n                        .attr('width', width)\n                        .attr('x', right ? 0 : -width)\n                        .style('fill', '#ffffff')\n                        .style('stroke', '#ffffff');//修改rect属性\n\n                    d3.select(`#g${d.id} text`)\n                        .attr('text-anchor', right ? 'end' : 'start')\n                        .attr('x', right ? xDistance - this.circleR : xDistance + this.circleR);//修改文本属性\n                    this.drawCircle(`g${d.id}`);//画圆圈\n                    d3.select(`#g${d.id} g`).attr('transform', `translate(${xDistance},0)`);//修改圆圈属性\n                }\n            });\n\n            // 更新节点：节点enter和exit时都会触发tree更新\n            const nodeUpdate = node.merge(nodeEnter).transition().duration(this.duration)\n            .attr(\"transform\", d => `translate(${d.y - dirRight * this.rectMinWidth / 2},${d.x})`)\n            .attr(\"fill-opacity\", 1)\n            .attr(\"stroke-opacity\", 1);\n\n            // 移除节点:tree移除掉数据内不包含的节点(即，children = false)\n            const nodeExit = node.exit().transition().duration(this.duration).remove()\n            .attr(\"transform\", d => `translate(${source.y},${source.x})`)\n            .attr(\"fill-opacity\", 0)\n            .attr(\"stroke-opacity\", 0);\n\n\n            // Update the links 根据 className来实现分块更新\n            const link = this.container.selectAll(`path.${className}`).data(links, d => d.target.id);\n\n            // Enter any new links at the parent's previous position.\n            //insert是在g标签前面插入，防止连接线挡住G节点内容\n            const linkEnter = link.enter().insert(\"path\", 'g')\n            .attr('class', className)\n            .attr(\"d\", d => {\n                const o = {x: source.x0, y: source.y0};\n                return this.diagonal({source: o, target: o});\n            })\n            .attr(\"fill\", 'none')\n            .attr(\"stroke-width\", 1)\n            .attr('stroke', '#dddddd');\n\n            // Transition links to their new position.\n            link.merge(linkEnter).transition().duration(this.duration).attr(\"d\", this.diagonal);\n\n            // Transition exiting nodes to the parent's new position.\n            link.exit().transition().duration(this.duration).remove()\n                .attr(\"d\", d => {\n                const o = {x: source.x, y: source.y};\n                return this.diagonal({source: o, target: o});\n            });\n\n            // Stash the old positions for transition.\n            this.root[direction].eachBefore(d => {\n                d.x0 = d.x;\n                d.y0 = d.y;\n            });\n\n        },\n\n        //画连接线\n        diagonal({source, target}) {\n            let s = source, d = target;\n            return `M ${s.y} ${s.x}\nL ${(s.y + d.y) / 2} ${s.x},\nL ${(s.y + d.y) / 2} ${d.x},\n${d.y} ${d.x}`\n        },\n\n        //画文本\n        drawText(id, dirRight) {\n            dirRight = dirRight > 0;//右为1，左为-1\n            return d3.select(`#${id}`).append(\"text\")\n                .attr('y', this.textPadding)\n                .attr(\"x\", d => dirRight ? this.textPadding : -this.textPadding)\n                .attr('text-anchor', dirRight ? 'start' : 'end')\n                .style('font-size', this.fontSize)\n                .text(d => d.data.name);\n        },\n        //画子文本\n        drawTsText(id) {\n            return d3.select(`#${id} text`).append('tspan')\n                .attr('fill', d => this.getTsTextColor(d.parent.data.name))\n                .text(d => d.data.value)\n        },\n\n        //画方框阴影\n        drawFilter(id) {\n            return d3.select(`#${id}`).insert('defs', 'rect').append('filter')\n                .attr('id', `f${id}`).attr('x', 0).attr('y', 0).append('feGaussianBlur')\n                .attr('in', 'SourceGraphic').attr('stdDeviation', '5');\n        },\n\n        //画方框\n        drawRect(id, dirRight) {\n            let realw = document.getElementById(id).getBBox().width + 10;//获取g实际宽度后，设置rect宽度\n            return d3.select(`#${id}`).insert('rect', 'text')\n                .attr('x', dirRight > 0 ? 0 : -realw)\n                .attr('y', -this.textSpace + this.textPadding)\n                .attr(\"width\", realw)\n                .attr(\"height\", this.textSpace + this.textPadding)\n                .attr(\"rx\", 2) //圆角\n                .style('stroke', d => this.getRectStorke(d.parent.data.name))\n                .style('fill', \"#ffffff\");\n        },\n\n        //画circle\n        drawCircle(id) {\n            let gMark = d3.select(`#${id}`).append('g')\n            .attr('class', 'node-circle')\n            .attr(\"stroke\", \"#ffa500\")\n            .attr('stroke-width', 1);\n\n            gMark.append(\"circle\")\n                .attr('fill', 'none')\n                .attr(\"r\", d => d.depth === 0 ? 0 : this.circleR)//根节点不设置圆圈\n                .attr('fill', '#ffffff');\n            let padding = this.circleR - 2;\n            gMark.append('path').attr('d', `m -${padding} 0 l ${2 * padding} 0`);//横线\n\n            gMark.append('path')//竖线，根据展开/收缩动态控制显示\n                .attr('d', `m 0 -${padding} l 0 ${2 * padding}`)\n                .attr('stroke-width', 0)\n                .attr('class', 'node-circle-vertical');\n            return gMark\n        },\n\n        //点击某个节点\n        clickNode(d, direction) {\n            if (!d._children && !d.children) {//无子节点\n                return;\n            }\n            //根据当前节点是否有children来判断是展开还是收缩，true收缩，false展开\n            //tree会根据节点内是否有children来向下扩展\n            d.children = d.children ? null : d._children;\n            d3.select(`#g${d.id} .node-circle .node-circle-vertical`)\n                .transition().duration(this.duration)\n                .attr('stroke-width', d.children ? 0 : 1);//控制节点伸缩时的标识圆圈\n            this.update(d, direction);\n        },\n\n        //子文本颜色配置\n        getTsTextColor(name) {\n            switch (name) {\n                case '股东':\n                    return 'darkgray';\n                case '供应商':\n                    return '#FF9800';\n                case '合伙人':\n                    return 'green';\n                default:\n                    return 'black';\n            }\n        },\n        //末 节点 边框颜色\n        getRectStorke(name) {\n            switch (name) {\n                case '股东':\n                    return 'green';\n                case '供应商':\n                    return 'skyblue';\n                case '合伙人':\n                    return '#FF9800';\n                default:\n                    return 'gray';\n            }\n        },\n\n\n        //非空或null时返回“”\n        isNull(val) {\n            return val ? val : '';\n        },\n    }\n}\n<\/script>\n\n\n# style\n\n<style lang=\"less\" scoped>\n.seeTree-page {\n    width: 100%;\n    height: 100%;\n    background-color: white;\n}\n</style>\n\n\n# 数据json constants.js\n\nexport const treeData = {\n    r: {\n        name: \"\",\n        children: [\n            {\n                name: \"股东\",\n                children: [\n                    {name: \"何少华\", value: '[董事长,董事]'},\n                    {name: \"何少华\", value: '[副董事长,董事]'},\n                    {name: \"何少华\", value: '[董事,副行长]'},\n                    {name: \"何少华\", value: '[董事]'},\n                    {name: \"何少华\", value: '[董事]'},\n                    {name: \"何少华\", value: '[董事]'},\n                ]\n            }, {\n                name: \"供应商\",\n                children: [\n                    {name: \"福德生命人寿保险股份有限公司-万能H\", value: `[4.33%]`},\n                    {name: \"福德生命人寿保险股份有限公司-万能H\", value: `[4.33%]`},\n                    {name: \"绍兴\"}\n                ]\n            },\n            {\n                name: \"合伙人\",\n                children:\n                [\n                    {name: \"何少华\", value: '[董事长,董事]'},\n                    {name: \"何少华\", value: '[副董事长,董事]'},\n                ]\n            }\n        ]\n    },\n    l: {\n        name: \"\",\n        children: [\n            {\n                name: \"合伙人\",\n                children:\n                [\n                    {name: \"何少华\", value: '[董事]'},\n                    {name: \"何少华\", value: '[董事]'},\n                    {name: \"何少华\", value: '[董事]'},\n                ]\n            },\n            {\n                name: \"合作公司\",\n                children: [\n                    {\n                        name: \"绍兴2\",\n                        value: 100,\n                        children: [{name: \"绍兴2221\"}, {name: \"绍兴2222\"}, {name: \"绍兴2223\"}, {name: \"绍兴2224\"}, {name: \"绍兴2221\"}, {name: \"绍兴2222\"}, {name: \"绍兴2223\"}, {name: \"绍兴2224\"}, {name: \"绍兴2221\"}, {name: \"绍兴2222\"}, {name: \"绍兴2223\"}, {name: \"绍兴2224\"}]\n                    },\n                    {\n                        name: \"宁波2\",\n                        value: 100,\n                        children: [{\n                            name: \"绍兴333\",\n                            children: [{name: \"绍兴3221\"}, {name: \"绍兴3222\"}, {name: \"绍兴3223\"}, {name: \"绍兴3224\"}, {name: \"绍兴3221\"}, {name: \"绍兴3222\"}, {name: \"绍兴3223\"}, {name: \"绍兴3224\"}]\n                        }]\n                    },\n                    {name: \"温州\"},\n                    {name: \"绍兴\"}\n                ]\n            }\n        ]\n    }\n}\n",normalizedContent:"# d3.js 实现企业图谱(基于vue)\n\nhttps://blog.csdn.net/weixin_44406901/article/details/125123880?spm=1001.2014.3001.5506\n\n\n# d3.js树图tree 组织机构分布图(基于vue)\n\n\n# 实现结果\n\n\n\n\n# 实现代码\n\n# html\n\n<template>\n    <div class=\"seetree-page\">\n        <div id=\"treeroot\"></div>\n    </div>\n</template>\n\n\n# js\n\n<script>\n    let d3 = require('../static/js/d3.v5.js');\nimport {treedata} from '../constants';//数据源\nexport default {\n    data() {\n        return {\n            container: null,//容器svg>g\n            duration: 750,//动画持续时间\n            scalerange: [.2, 4],//container缩放范围\n            direction: ['r', 'l'],//分为左右2个方向\n            centralpoint: [0, 0],//画布中心点坐标x,y\n            root: {r: {}, l: {}},//左右2块数据源\n            rootnodelength: 0,//根节点名称长度\n            rootname: [\"上海天正实业有限\", \"公司\"],//根节点名称\n            textspace: 15,//多行文字间距\n            themecolor: \"#2196f3\",//主色\n            nodesize: [30, 100],//节点间距(高/水平)\n            fontsize: 12,//字体大小，也是单字所占宽高\n            rectminwidth: 50,//节点方框默认最小，\n            textpadding: 5,//文字与方框间距,注：固定值5\n            circler: 5,//圆圈半径\n        }\n    },\n    computed: {\n        treemap() {//树布局\n            return d3.tree().nodesize(this.nodesize).separation((a, b) => {\n                let result = a.parent === b.parent && !a.children && !b.children ? 1 : 2;\n                if (result > 1) {\n                    let length = 0;\n                    length = a.children ? (length + a.children.length) : length;\n                    length = b.children ? (length + b.children.length) : length;\n                    result = length / 2 + 0.5;\n                }\n                return result;\n            });\n        },\n    },\n    mounted() {\n        this.treeinit();\n    },\n    methods: {\n        //随机数，用于绑定id\n        uuid() {\n            function s4() {\n                return math.floor((1 + math.random()) * 0x10000)\n                    .tostring(16)\n                    .substring(1)\n            }\n\n            return (\n                s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4()\n            )\n        },\n\n        //初始化\n        treeinit() {\n            const margin = {top: 0, right: 0, bottom: 0, left: 0};\n            const treewidth = document.body.clientwidth - margin.left - margin.right;//tree容器宽\n            const treeheight = document.body.clientheight - margin.top - margin.bottom;//tree容器高\n            const centraly = treewidth / 2 + margin.left;\n            const centralx = treeheight / 2 + margin.top;\n            this.centralpoint = [centralx, centraly];//中心点坐标\n            //根节点字符所占宽度\n            this.rootnodelength = this.rootname[0].length * this.fontsize + 30;\n\n            //svg标签\n            const svg = d3.select('#treeroot').append('svg')\n            .attr('class', 'tree-svg')\n            .attr('width', treewidth)\n            .attr('height', treeheight)\n            .attr('font-size', this.fontsize)\n            .attr('fill', '#555');\n\n            //g标签\n            this.container = svg.append('g')\n                .attr('class', \"container\")\n                .attr('transform', `translate(${margin.left},${margin.top}) scale(1)`);\n            //画出根节点\n            this.drawroot();\n\n            //指定缩放范围\n            const zoom = d3.zoom().scaleextent(this.scalerange).on('zoom', this.zoomfn);\n            //动画持续时间\n            this.container.transition().duration(this.duration).call(zoom.transform, d3.zoomidentity);\n            svg.call(zoom);\n            //数据处理\n            this.dealdata();\n        },\n        //初始化缩放方法\n        zoomfn() {\n            const zoom = d3.event.transform;\n            return this.container.attr('transform', zoom);\n        },\n        //数据处理\n        dealdata() {\n            this.direction.foreach(item => {\n                this.root[item] = d3.hierarchy(treedata[item]);\n                this.root[item].x0 = this.centralpoint[0];//根节点x坐标\n                this.root[item].y0 = this.centralpoint[1];//根节点y坐标\n                this.root[item].descendants().foreach(d => {\n                    d._children = d.children;//添加_children属性，用于实现点击收缩及展开功能\n                    d.id = item + this.uuid();//绑定唯一标识id\n                });\n                this.update(this.root[item], item);\n            })\n        },\n        //画根节点\n        drawroot() {\n            const title = this.container.append('g')\n            .attr('id', \"roottitle\")\n            .attr(\"transform\", `translate(${this.centralpoint[1]},${this.centralpoint[0]})`);\n            title.append('svg:rect')\n                .attr('class', \"roottitle\")\n                .attr(\"y\", 0)\n                .attr(\"x\", -this.rootnodelength / 2)\n                .attr(\"width\", this.rootnodelength)\n                .attr(\"height\", 0)\n                .attr(\"rx\", 5) //圆角\n                .style('fill', this.themecolor);\n            this.rootname.foreach((name, index) => {\n                title.append('text').attr('fill', 'white')\n                    .attr('y', index * this.textspace - 2)\n                    .attr('text-anchor', 'middle')\n                    .text(name);\n\n                let lineheight = (index + 2) * this.textspace;\n                //修改roottitle rect 的高度\n                d3.select('#roottitle rect').attr('height', lineheight).attr('y', -lineheight / 2);\n            });\n\n\n        },\n        //开始绘图\n        update(source, direction) {\n            const dirright = direction === 'r' ? 1 : -1;//方向为右/左\n            const classname = `${direction}gnode`;\n            const tree = this.treemap(this.root[direction]);\n            const nodes = tree.descendants();//返回后代节点数组，第一个节点为自身，然后依次为所有子节点的拓扑排序\n            const links = tree.links();//返回当前 node 的 links 数组, 其中每个 link 定义了 source父节点, target 子节点属性。\n            nodes.foreach(d => {\n                //左右2部分，设置以中心点为圆点(默认左上角为远点)\n                d.y = dirright * (d.y + this.rootnodelength / 2) + this.centralpoint[1];\n                d.x = d.x + this.centralpoint[0];\n            });\n\n            //根据class名称获取左或者右的g节点，达到分块更新\n            const node = this.container.selectall(`g.${classname}`).data(nodes, d => d.id);\n\n            //新增节点，tree会根据数据内的children扩展相关节点\n            const nodeenter = node.enter().append(\"g\")\n            .attr('id', d => `g${d.id}`)\n            .attr('class', classname)\n            .attr(\"transform\", d => `translate(${source.y0},${source.x0})`)\n            .attr(\"fill-opacity\", 0)\n            .attr(\"stroke-opacity\", 0)\n            .on(\"click\", (d) => {\n                d.depth !== 0 && this.clicknode(d, direction);//根节点不执行点击事件\n            });\n\n            nodeenter.each(d => {\n                if (d.depth > 0) {//非根节点且无子节点\n                    this.drawtext(`g${d.id}`, dirright);//画文本\n\n                    if (d.data.value) {\n                        this.drawtstext(`g${d.id}`);//画子文本\n                    }\n                    this.drawrect(`g${d.id}`, dirright);//画方框\n                    // this.drawfilter(`g${d.id}`);//画阴影\n                    // d3.select(`#g${d.id} rect`).attr('stroke-width',15).attr('filter',`url(#fg${d.id})`);//给rect绑定阴影\n                }\n                if (d.depth > 0 && d._children) {//非根节点且有子节点\n                    const width = math.min(d.data.name.length * 14, this.rectminwidth);\n                    let right = dirright > 0;//右为1，左为-1\n                    let xdistance = right ? width : -width;\n                    d3.select(`#g${d.id} rect`)\n                        .attr('width', width)\n                        .attr('x', right ? 0 : -width)\n                        .style('fill', '#ffffff')\n                        .style('stroke', '#ffffff');//修改rect属性\n\n                    d3.select(`#g${d.id} text`)\n                        .attr('text-anchor', right ? 'end' : 'start')\n                        .attr('x', right ? xdistance - this.circler : xdistance + this.circler);//修改文本属性\n                    this.drawcircle(`g${d.id}`);//画圆圈\n                    d3.select(`#g${d.id} g`).attr('transform', `translate(${xdistance},0)`);//修改圆圈属性\n                }\n            });\n\n            // 更新节点：节点enter和exit时都会触发tree更新\n            const nodeupdate = node.merge(nodeenter).transition().duration(this.duration)\n            .attr(\"transform\", d => `translate(${d.y - dirright * this.rectminwidth / 2},${d.x})`)\n            .attr(\"fill-opacity\", 1)\n            .attr(\"stroke-opacity\", 1);\n\n            // 移除节点:tree移除掉数据内不包含的节点(即，children = false)\n            const nodeexit = node.exit().transition().duration(this.duration).remove()\n            .attr(\"transform\", d => `translate(${source.y},${source.x})`)\n            .attr(\"fill-opacity\", 0)\n            .attr(\"stroke-opacity\", 0);\n\n\n            // update the links 根据 classname来实现分块更新\n            const link = this.container.selectall(`path.${classname}`).data(links, d => d.target.id);\n\n            // enter any new links at the parent's previous position.\n            //insert是在g标签前面插入，防止连接线挡住g节点内容\n            const linkenter = link.enter().insert(\"path\", 'g')\n            .attr('class', classname)\n            .attr(\"d\", d => {\n                const o = {x: source.x0, y: source.y0};\n                return this.diagonal({source: o, target: o});\n            })\n            .attr(\"fill\", 'none')\n            .attr(\"stroke-width\", 1)\n            .attr('stroke', '#dddddd');\n\n            // transition links to their new position.\n            link.merge(linkenter).transition().duration(this.duration).attr(\"d\", this.diagonal);\n\n            // transition exiting nodes to the parent's new position.\n            link.exit().transition().duration(this.duration).remove()\n                .attr(\"d\", d => {\n                const o = {x: source.x, y: source.y};\n                return this.diagonal({source: o, target: o});\n            });\n\n            // stash the old positions for transition.\n            this.root[direction].eachbefore(d => {\n                d.x0 = d.x;\n                d.y0 = d.y;\n            });\n\n        },\n\n        //画连接线\n        diagonal({source, target}) {\n            let s = source, d = target;\n            return `m ${s.y} ${s.x}\nl ${(s.y + d.y) / 2} ${s.x},\nl ${(s.y + d.y) / 2} ${d.x},\n${d.y} ${d.x}`\n        },\n\n        //画文本\n        drawtext(id, dirright) {\n            dirright = dirright > 0;//右为1，左为-1\n            return d3.select(`#${id}`).append(\"text\")\n                .attr('y', this.textpadding)\n                .attr(\"x\", d => dirright ? this.textpadding : -this.textpadding)\n                .attr('text-anchor', dirright ? 'start' : 'end')\n                .style('font-size', this.fontsize)\n                .text(d => d.data.name);\n        },\n        //画子文本\n        drawtstext(id) {\n            return d3.select(`#${id} text`).append('tspan')\n                .attr('fill', d => this.gettstextcolor(d.parent.data.name))\n                .text(d => d.data.value)\n        },\n\n        //画方框阴影\n        drawfilter(id) {\n            return d3.select(`#${id}`).insert('defs', 'rect').append('filter')\n                .attr('id', `f${id}`).attr('x', 0).attr('y', 0).append('fegaussianblur')\n                .attr('in', 'sourcegraphic').attr('stddeviation', '5');\n        },\n\n        //画方框\n        drawrect(id, dirright) {\n            let realw = document.getelementbyid(id).getbbox().width + 10;//获取g实际宽度后，设置rect宽度\n            return d3.select(`#${id}`).insert('rect', 'text')\n                .attr('x', dirright > 0 ? 0 : -realw)\n                .attr('y', -this.textspace + this.textpadding)\n                .attr(\"width\", realw)\n                .attr(\"height\", this.textspace + this.textpadding)\n                .attr(\"rx\", 2) //圆角\n                .style('stroke', d => this.getrectstorke(d.parent.data.name))\n                .style('fill', \"#ffffff\");\n        },\n\n        //画circle\n        drawcircle(id) {\n            let gmark = d3.select(`#${id}`).append('g')\n            .attr('class', 'node-circle')\n            .attr(\"stroke\", \"#ffa500\")\n            .attr('stroke-width', 1);\n\n            gmark.append(\"circle\")\n                .attr('fill', 'none')\n                .attr(\"r\", d => d.depth === 0 ? 0 : this.circler)//根节点不设置圆圈\n                .attr('fill', '#ffffff');\n            let padding = this.circler - 2;\n            gmark.append('path').attr('d', `m -${padding} 0 l ${2 * padding} 0`);//横线\n\n            gmark.append('path')//竖线，根据展开/收缩动态控制显示\n                .attr('d', `m 0 -${padding} l 0 ${2 * padding}`)\n                .attr('stroke-width', 0)\n                .attr('class', 'node-circle-vertical');\n            return gmark\n        },\n\n        //点击某个节点\n        clicknode(d, direction) {\n            if (!d._children && !d.children) {//无子节点\n                return;\n            }\n            //根据当前节点是否有children来判断是展开还是收缩，true收缩，false展开\n            //tree会根据节点内是否有children来向下扩展\n            d.children = d.children ? null : d._children;\n            d3.select(`#g${d.id} .node-circle .node-circle-vertical`)\n                .transition().duration(this.duration)\n                .attr('stroke-width', d.children ? 0 : 1);//控制节点伸缩时的标识圆圈\n            this.update(d, direction);\n        },\n\n        //子文本颜色配置\n        gettstextcolor(name) {\n            switch (name) {\n                case '股东':\n                    return 'darkgray';\n                case '供应商':\n                    return '#ff9800';\n                case '合伙人':\n                    return 'green';\n                default:\n                    return 'black';\n            }\n        },\n        //末 节点 边框颜色\n        getrectstorke(name) {\n            switch (name) {\n                case '股东':\n                    return 'green';\n                case '供应商':\n                    return 'skyblue';\n                case '合伙人':\n                    return '#ff9800';\n                default:\n                    return 'gray';\n            }\n        },\n\n\n        //非空或null时返回“”\n        isnull(val) {\n            return val ? val : '';\n        },\n    }\n}\n<\/script>\n\n\n# style\n\n<style lang=\"less\" scoped>\n.seetree-page {\n    width: 100%;\n    height: 100%;\n    background-color: white;\n}\n</style>\n\n\n# 数据json constants.js\n\nexport const treedata = {\n    r: {\n        name: \"\",\n        children: [\n            {\n                name: \"股东\",\n                children: [\n                    {name: \"何少华\", value: '[董事长,董事]'},\n                    {name: \"何少华\", value: '[副董事长,董事]'},\n                    {name: \"何少华\", value: '[董事,副行长]'},\n                    {name: \"何少华\", value: '[董事]'},\n                    {name: \"何少华\", value: '[董事]'},\n                    {name: \"何少华\", value: '[董事]'},\n                ]\n            }, {\n                name: \"供应商\",\n                children: [\n                    {name: \"福德生命人寿保险股份有限公司-万能h\", value: `[4.33%]`},\n                    {name: \"福德生命人寿保险股份有限公司-万能h\", value: `[4.33%]`},\n                    {name: \"绍兴\"}\n                ]\n            },\n            {\n                name: \"合伙人\",\n                children:\n                [\n                    {name: \"何少华\", value: '[董事长,董事]'},\n                    {name: \"何少华\", value: '[副董事长,董事]'},\n                ]\n            }\n        ]\n    },\n    l: {\n        name: \"\",\n        children: [\n            {\n                name: \"合伙人\",\n                children:\n                [\n                    {name: \"何少华\", value: '[董事]'},\n                    {name: \"何少华\", value: '[董事]'},\n                    {name: \"何少华\", value: '[董事]'},\n                ]\n            },\n            {\n                name: \"合作公司\",\n                children: [\n                    {\n                        name: \"绍兴2\",\n                        value: 100,\n                        children: [{name: \"绍兴2221\"}, {name: \"绍兴2222\"}, {name: \"绍兴2223\"}, {name: \"绍兴2224\"}, {name: \"绍兴2221\"}, {name: \"绍兴2222\"}, {name: \"绍兴2223\"}, {name: \"绍兴2224\"}, {name: \"绍兴2221\"}, {name: \"绍兴2222\"}, {name: \"绍兴2223\"}, {name: \"绍兴2224\"}]\n                    },\n                    {\n                        name: \"宁波2\",\n                        value: 100,\n                        children: [{\n                            name: \"绍兴333\",\n                            children: [{name: \"绍兴3221\"}, {name: \"绍兴3222\"}, {name: \"绍兴3223\"}, {name: \"绍兴3224\"}, {name: \"绍兴3221\"}, {name: \"绍兴3222\"}, {name: \"绍兴3223\"}, {name: \"绍兴3224\"}]\n                        }]\n                    },\n                    {name: \"温州\"},\n                    {name: \"绍兴\"}\n                ]\n            }\n        ]\n    }\n}\n",charsets:{cjk:!0}},{title:"G6-项目的影响分析/血缘分析",frontmatter:{},regularPath:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/G6.html",relativePath:"插件小技巧/G6.md",key:"v-5b77c997",path:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/G6.html",headers:[{level:2,title:"metaDmapNew.vue文件[主文件]",slug:"metadmapnew-vue文件-主文件",normalizedTitle:"metadmapnew.vue文件[主文件]",charIndex:22},{level:2,title:"detailDrawer.vue文件",slug:"detaildrawer-vue文件",normalizedTitle:"detaildrawer.vue文件",charIndex:73343},{level:2,title:"tableDetail.vue文件",slug:"tabledetail-vue文件",normalizedTitle:"tabledetail.vue文件",charIndex:75798},{level:2,title:"columnDetail.vue文件",slug:"columndetail-vue文件",normalizedTitle:"columndetail.vue文件",charIndex:78132},{level:2,title:"以资产的数据为例",slug:"以资产的数据为例",normalizedTitle:"以资产的数据为例",charIndex:82949},{level:3,title:"效果图",slug:"效果图",normalizedTitle:"效果图",charIndex:82962},{level:3,title:"表级[dataAssetManaService.getAssetDetail]最全的数据",slug:"表级-dataassetmanaservice-getassetdetail-最全的数据",normalizedTitle:"表级[dataassetmanaservice.getassetdetail]最全的数据",charIndex:82972},{level:3,title:"字段级[dataAssetRegistrationService.getlistItemByPidAndType]",slug:"字段级-dataassetregistrationservice-getlistitembypidandtype",normalizedTitle:"字段级[dataassetregistrationservice.getlistitembypidandtype]",charIndex:85305},{level:3,title:"metaAnalysisService.getAnalyseToAsset获取的数据",slug:"metaanalysisservice-getanalysetoasset获取的数据",normalizedTitle:"metaanalysisservice.getanalysetoasset获取的数据",charIndex:118641}],headersStr:"metaDmapNew.vue文件[主文件] detailDrawer.vue文件 tableDetail.vue文件 columnDetail.vue文件 以资产的数据为例 效果图 表级[dataAssetManaService.getAssetDetail]最全的数据 字段级[dataAssetRegistrationService.getlistItemByPidAndType] metaAnalysisService.getAnalyseToAsset获取的数据",content:'# G6-项目的影响分析/血缘分析\n\n\n# metaDmapNew.vue文件[主文件]\n\n<template>\n<div class="metaDmap" ref="metaDmap" style="background: white">\n  \x3c!-- 按钮组 --\x3e\n  <div class="flexBox line-form">\n    <div class="left" style="min-width:360px;align-items: flex-start;">\n      <el-button-group>\n        <el-button\n                   type="plain"\n                   :class="{ drawerBg: isTable }"\n                   @click="changeType(\'table\')"\n                   >表级</el-button\n          >\n        <el-button\n                   type="plain"\n                   :class="{ drawerBg: !isTable }"\n                   @click="changeType(\'column\')"\n                   >字段级</el-button\n          >\n  </el-button-group>\n      <el-select\n                 v-show="!isTable"\n                 v-model="formInline.name"\n                 placeholder="请选择字段"\n                 size="mini"\n                 style="width: 30%; min-width: 150px;margin-left:15px"\n                 value-key="instId"\n                 @change="changeColumn"\n                 :popper-append-to-body="false"\n                 >\n        \x3c!-- fackClickOutSide 定义fullScreen-select --\x3e\n        <el-option\n                   class="fullScreen-select"\n                   v-for="item in columnList"\n                   :value="item"\n                   :key="item.instId"\n                   :label="item.instCode"\n                   ></el-option>\n  </el-select>\n  </div>\n    <div class="center">\n      <el-button-group style="min-width:240px">\n        <el-button\n                   type="plain"\n                   :class="{ drawerBg: isAll }"\n                   @click="changeGraph(\'03\')"\n                   >全链分析</el-button\n          >\n        <el-button\n                   type="plain"\n                   :class="{ drawerBg: isImpact && !isAll }"\n                   @click="changeGraph(\'01\')"\n                   >影响分析</el-button\n          >\n        <el-button\n                   type="plain"\n                   :class="{ drawerBg: !isImpact && !isAll }"\n                   @click="changeGraph(\'02\')"\n                   >血缘分析</el-button\n          >\n  </el-button-group>\n  </div>\n    <div class="right" style="justify-content: end;">\n      <el-select\n                 v-model="formInline.layer"\n                 placeholder="层级"\n                 size="mini"\n                 style="width: 10%; min-width: 100px;margin-right:20px"\n                 @change="relationsAnalyse"\n                 :popper-append-to-body="false"\n                 >\n        <el-option\n                   class="fullScreen-select"\n                   label="1级"\n                   value="1"\n                   ></el-option>\n        <el-option\n                   class="fullScreen-select"\n                   label="2级"\n                   value="2"\n                   ></el-option>\n        <el-option\n                   class="fullScreen-select"\n                   label="3级"\n                   value="3"\n                   ></el-option>\n        <el-option\n                   class="fullScreen-select"\n                   label="4级"\n                   value="4"\n                   ></el-option>\n        <el-option\n                   class="fullScreen-select"\n                   label="5级"\n                   value="5"\n                   ></el-option>\n        <el-option\n                   class="fullScreen-select"\n                   label="全部"\n                   value="all"\n                   ></el-option>\n  </el-select>\n      <i\n         class="el-icon-zoom-in color-font"\n         @click="scaleMax"\n         :title="$i18ns(\'enlarge\')"\n         ></i>\n      <i\n         class="color-font"\n         style="width:36px;text-align:center;font-size:14px"\n         >{{ parseInt(zoomSize * 100 + 20) + "%" }}</i\n        >\n      <i\n         class="el-icon-zoom-out color-font"\n         @click="scaleMin"\n         :title="$i18ns(\'narrow\')"\n         ></i>\n\n      <i\n         class="el-icon-download color-font"\n         @click="downloadAnalyseFile"\n         :title="$i18ns(\'export\')"\n         ></i>\n\n      <i\n         class="el-icon-picture-outline color-font"\n         @click="downImage"\n         :title="$i18ns(\'ExportImages\')"\n         ></i>\n      <i\n         v-if="fullScreen"\n         class="el-icon-crop color-font"\n         @click="fullScreeHandler"\n         :title="$i18ns(\'Shrink\')"\n         ></i>\n      <i\n         v-else\n         class="el-icon-full-screen color-font"\n         @click="fullScreeHandler"\n         :title="$i18ns(\'FullScreen\')"\n         ></i>\n  </div>\n  </div>\n  \x3c!-- G6图层 --\x3e\n  <div :id="svgId" v-if="showGraph"></div>\n  \x3c!-- 详情弹出框 --\x3e\n  <div class="detail">\n    <transition name="right-slide">\n      <div class="drawerBox" v-if="isShowDrawer">\n        <div class="clickIcon" @click="isShowDrawer = false"></div>\n        <detailDrawer :drawerData="allDetails" />\n  </div>\n  </transition>\n  </div>\n  </div>\n</template>\n\n<script>\n  import detailDrawer from "./component/detailDrawer";\n  import dashboardService from "@/services/dashboardService";\n  import workbenchService from "@/services/workbenchService";\n  import metaAnalysisService from "@/services/metaAnalysis";\n  import dataAssetRegistrationService from "@/services/dataAssetRegistrationService";\n  import dataAssetManaService from "@/services/dataAssetManaService";\n\n  import G6 from "@antv/g6";\n  import { MDS } from "@/services/Constant";\n  import moment from "moment";\n  var tooltipEl = null;\n  export default {\n    name: "G6Demo",\n    props: {\n      tableformData: {\n        type: Object,\n        default: () => {\n          return {};\n        }\n      }\n    },\n    components: { detailDrawer },\n    data() {\n      return {\n        formInline: {\n          name: "",\n          layer: "3"\n        },\n        columnList: [], //字段列表\n        isTable: false, //是否为表\n        isImpact: false, //是否为影响分析\n        isAll: false, //是否为全链路分析\n        isShowDrawer: false, //是否展示弹出框\n        showGraph: false,\n        graph: "",\n        maxWidth: 240, //最大宽度\n        zoomSize: 0.8, //缩放\n        svgId: "",\n        fullScreen: false,\n        timeoutId: null,\n        sessionId: "",\n        allClassList: {\n          // 基础数据\n          baseMetaData: {\n            clssId: "baseMetaData",\n            classificationId: "",\n            categoryTitle: "BasicStandardClassification",\n            TypeTitle: this.$i18ns("business"), // 業務\n            nodeTitle: this.$i18ns("dsmIndex") // 基礎元數據\n          },\n          //指标数据\n          quotaMetaData: {\n            classificationId: "",\n            clssId: "quotaMetaData",\n            categoryTitle: "IndexStandardClassification",\n            TypeTitle: this.$i18ns("business"), // 業務\n            nodeTitle: this.$i18ns("quotaIndex") // 指標元數據\n          },\n          //外部元数据\n          externalMetaData: {\n            classificationId: "",\n            clssId: "externalMetaData",\n            TypeTitle: this.$i18ns("business"), // 業務\n            nodeTitle: this.$i18ns("externalMetadata") // 外部元數據\n          },\n          AssetInfoItem: {\n            classificationId: "DAClassification",\n            clssId: "AssetInfoItem",\n            categoryTitle: "dataCatalogClass",\n            TypeTitle: this.$i18ns("assets"), // 資產\n            nodeTitle: this.$i18ns("DataAssetClassification") // 數據資產分類\n          },\n          DDTable: {\n            clssId: "DDTable",\n            TypeTitle: this.$i18ns("technology"), // 技術\n            nodeTitle: this.$i18ns("technicalMetaData") // 技術元數據\n          },\n          DDColumn: {\n            clssId: "DDColumn",\n            TypeTitle: this.$i18ns("technology"), // 技術\n            nodeTitle: this.$i18ns("technicalMetaData") // 技術元數據\n          },\n          DDNonIffColumn: {\n            clssId: "DDNonIffColumn",\n            TypeTitle: this.$i18ns("technology"), // 技術\n            nodeTitle: this.$i18ns("technicalMetaData") // 技術元數據\n          },\n          DDIffColumn: {\n            clssId: "DDIffColumn",\n            TypeTitle: this.$i18ns("technology"), // 技術\n            nodeTitle: this.$i18ns("technicalMetaData") // 技術元數據\n          },\n          DDFileColumn: {\n            clssId: "DDFileColumn",\n            TypeTitle: this.$i18ns("technology"), // 技術\n            nodeTitle: this.$i18ns("technicalMetaData") // 技術元數據\n          },\n          DDNonIff: {\n            clssId: "DDNonIff",\n            TypeTitle: this.$i18ns("technology"), // 技術\n            nodeTitle: this.$i18ns("technicalMetaData") // 技術元數據\n          },\n          DDIff: {\n            clssId: "DDIff",\n            TypeTitle: this.$i18ns("technology"), // 技術\n            nodeTitle: this.$i18ns("technicalMetaData") // 技術元數據\n          },\n          DDFile: {\n            clssId: "DDFile",\n            TypeTitle: this.$i18ns("technology"), // 技術\n            nodeTitle: this.$i18ns("technicalMetaData") // 技術元數據\n          },\n          DDTable: {\n            clssId: "DDTable",\n            TypeTitle: this.$i18ns("technology"), // 技術\n            nodeTitle: this.$i18ns("technicalMetaData") // 技術元數據\n          },\n          AmCommonCode: {\n            clssId: "AmCommonCode",\n            TypeTitle: this.$i18ns("PublicCode"), // 公共代碼\n            nodeTitle: this.$i18ns("PublicCode") // 公共代碼\n          },\n          EDMDataClassificationLevel1: {\n            clssId: "EDMDataClassificationLevel1",\n            TypeTitle: this.$i18ns("edmDataClassification"), // 模型分類\n            nodeTitle: this.$i18ns("edmDataClassification") // 模型分類\n          },\n          EDMDataClassificationLevel2: {\n            clssId: "EDMDataClassificationLevel2",\n            TypeTitle: this.$i18ns("edmDataClassification"), // 模型分類\n            nodeTitle: this.$i18ns("edmDataClassification") // 模型分類\n          },\n          EDMDataClassificationLevel3: {\n            clssId: "EDMDataClassificationLevel3",\n            TypeTitle: this.$i18ns("edmDataClassification"), // 模型分類\n            nodeTitle: this.$i18ns("edmDataClassification") // 模型分類\n          },\n          EDMDataClassificationLevel4: {\n            clssId: "EDMDataClassificationLevel4",\n            TypeTitle: this.$i18ns("edmDataClassification"), // 模型分類\n            nodeTitle: this.$i18ns("edmDataClassification") // 模型分類\n          },\n          EDMDataClassificationLevel5: {\n            clssId: "EDMDataClassificationLevel5",\n            TypeTitle: this.$i18ns("edmDataClassification"), // 模型分類\n            nodeTitle: this.$i18ns("edmDataClassification") // 模型分類\n          },\n          EDMDataClassificationLevel6: {\n            clssId: "EDMDataClassificationLevel6",\n            TypeTitle: this.$i18ns("edmDataClassification"), // 模型分類\n            nodeTitle: this.$i18ns("edmDataClassification") // 模型分類\n          },\n          DDCommonRealCode: {\n            clssId: "DDCommonRealCode",\n            TypeTitle: this.$i18ns("DDCommonRealCode1"), // 系統落地代碼\n            nodeTitle: this.$i18ns("DDCommonRealCode1") // 系統落地代碼\n          },\n          AmStandardCode: {\n            clssId: "AmStandardCode",\n            TypeTitle: this.$i18ns("Standard"), // 標準\n            nodeTitle: this.$i18ns("StandardCodeSet") // 标准代码集\n          },\n          SdInfoItem: {\n            clssId: "SdInfoItem",\n            TypeTitle: this.$i18ns("SdInfoItem"), // 標準\n            nodeTitle: this.$i18ns("SdInfoItem") // 标准代码集\n          }\n        },\n        isAsset: false, //是否资产类型\n        dataType: "",\n        allDetails: {}\n      };\n    },\n    watch: {\n      tableformData: {\n        deep: true,\n        immediate: true,\n        handler(newval) {\n          this.allDetails = JSON.parse(JSON.stringify(newval));\n          console.log(newval, "watch--allDetails");\n          this.isAsset = false;\n          if (\n            newval.classId !== "DDTable" &&\n            newval.classId !== "DDColumn" &&\n            newval.fromClassId\n          ) {\n            this.allDetails.classId = newval.fromClassId;\n            this.allDetails.instCode = newval.instEnName;\n            this.allDetails.instName = newval.instCnName;\n            this.isAsset = true;\n          }\n          console.log(this.isAsset, "watch");\n          this.svgId = this.generateUUID();\n          this.isTable = false;\n          this.isImpact = false;\n          if (this.allDetails.classId == "DDColumn") {\n            this.nodeParentId = newval.parentId;\n            this.listColumnPage(true);\n          } else {\n            this.isTable = true;\n          }\n          // type 1影响分析  2 血缘\n          if (this.allDetails.type == 1 || this.isAsset) {\n            this.isImpact = true;\n            if (this.allDetails.classId == "DDColumn") {\n              this.changeGraph("01", true);\n            } else {\n              this.changeGraph("01");\n            }\n          } else {\n            if (this.allDetails.classId == "DDColumn") {\n              this.changeGraph("02", true);\n            } else {\n              this.changeGraph("02");\n            }\n          }\n        }\n      }\n    },\n    mounted() {\n      // this.initTree(TREELIST);\n      document.addEventListener("fullscreenchange", v => {\n        // console.log(v, "fullscreenchange");\n        if (this.fullScreen == true) {\n          this.fullScreen = false;\n        } else {\n          this.fullScreen = true;\n        }\n        this.changeSize();\n      });\n    },\n    methods: {\n      // 生成唯一id\n      generateUUID() {\n        // 当前时间转成 36 进制字符串\n        var time = Date.now().toString(36);\n        // 当前随机数转成 36 进制字符串\n        var random = Math.random().toString(36);\n        // 去除随机数的 0. 字符串\n        random = random.substring(2, random.length);\n        // 返回唯一ID\n        return random + time;\n      },\n      // 中英切换\n      en2zh2en() {\n        dmap.en2zh2en("#" + this.svgid);\n      },\n      // 缩小\n      scaleMin() {\n        let zoom = this.graph.getZoom();\n        this.zoomSize = zoom <= 0.3 ? 0.3 : (zoom - 0.1).toFixed(1);\n        this.graph.zoomTo(this.zoomSize);\n      },\n      // 放大\n      scaleMax() {\n        let zoom = this.graph.getZoom();\n        this.zoomSize = zoom >= 1.8 ? 1.8 : (zoom + 0.1).toFixed(1);\n        this.graph.zoomTo(this.zoomSize);\n      },\n      // 下载图片\n      downImage() {\n        // 图片名称，图片类型，图片背景色\n        let name = "分析结果图片导出" + this.allDetails.instName;\n        this.graph.downloadFullImage(name, "", {\n          backgroundColor: "#fff",\n          padding: [10, 10, 10, 10]\n        });\n      },\n      // 导出\n      downloadAnalyseFile() {\n        var prop = {\n          colsIds: this.allDetails.instId,\n          type: this.allDetails.classId,\n          sessionId: this.sessionId,\n          metadataId: this.allDetails.instId,\n          fileType: "01",\n          filterFlag: "0",\n          analyseType: this.isImpact ? "impact" : "blood",\n          analyseBy: "dsm"\n        };\n        if (this.graphType == "03") {\n          prop.sessionId = this.impactSessionId + "," + this.bloodSessionId;\n          prop.analyseType = "ALL_CHAIN";\n        }\n        let objectUrl = `${MDS}/etlAnalyse/downloadAnalyseResult2?colsIds=${prop.colsIds}&type=${prop.type}&sessionId=${prop.sessionId}&metadataId=${prop.metadataId}&fileType=${prop.fileType}&filterFlag=${prop.filterFlag}&analyseType=${prop.analyseType}&analyseBy=${prop.analyseBy}`;\n        this.$axiosDownload(objectUrl, {}, this);\n      },\n      // 全屏\n      fullScreeHandler() {\n        let el = this.$refs.metaDmap;\n        let isFullscreen =\n            document.fullScreen ||\n            document.mozFullScreen ||\n            document.webkitIsFullScreen;\n\n        if (!isFullscreen) {\n          (el.requestFullscreen && el.requestFullscreen()) ||\n            (el.mozRequestFullScreen && el.mozRequestFullScreen()) ||\n            (el.webkitRequestFullscreen && el.webkitRequestFullscreen()) ||\n            (el.msRequestFullscreen && el.msRequestFullscreen());\n        } else {\n          document.exitFullscreen\n            ? document.exitFullscreen()\n          : document.mozCancelFullScreen\n            ? document.mozCancelFullScreen()\n          : document.webkitExitFullscreen\n            ? document.webkitExitFullscreen()\n          : "";\n        }\n      },\n      // 图形切换大小\n      changeSize() {\n        let id = this.fullScreen ? "top-left-icon-layout" : "mainContainer";\n        let width = document.getElementById(id).scrollWidth || 1600;\n        let height = document.getElementById(id).scrollHeight || 900;\n        height = this.fullScreen ? height + 60 : height - 120;\n        console.log(id, width, height, "id,width,heightwidth,height");\n\n        this.graph.changeSize(width, height);\n        this.graph.fitView();\n        this.graph.zoomTo(this.zoomSize);\n        this.graph.fitCenter();\n        this.graph.focusItem(data.id, true);\n        if (this.graphType == "01") {\n          this.graph.translate(-width / 2 + 20, -50);\n        } else if (this.graphType == "02") {\n          this.graph.translate(width / 4, -50);\n        } else {\n          this.graph.translate(-100, -50);\n        }\n      },\n      // 切换级别\n      changeType(type) {\n        // console.log(this.allDetails);\n        // 禁止重复点击\n        if (this.dataType == type) {\n          return;\n        }\n        this.dataType = type;\n        if (type == "table") {\n          this.isTable = true;\n          this.nodeParentId = this.allDetails.parentId;\n          if (this.isAsset) {\n            this.getAssetDetail();\n          } else {\n            this.getMetaBaseInfo();\n          }\n        } else {\n          this.isTable = false;\n          this.nodeParentId = this.allDetails.instId;\n          this.listColumnPage();\n        }\n      },\n\n      // 资产获取当前最全数据\n      async getAssetDetail() {\n        const response = await dataAssetManaService.getAssetDetail(\n          this.nodeParentId\n        );\n        this.allDetails = response.data;\n        this.allDetails.instCode = response.data.instEnName;\n        this.allDetails.instName = response.data.instCnName;\n        this.relationsAnalyse();\n      },\n      // 获取当前最全数据\n      async getMetaBaseInfo() {\n        const response = await workbenchService.getMetaBaseInfo({\n          instId: this.nodeParentId\n        });\n        this.allDetails = response.data;\n        this.relationsAnalyse();\n      },\n      // 查看字段详情\n      async changeColumn(val) {\n        let data = {};\n        if (this.isAsset) {\n          data = {\n            ...val,\n            instCode: val.instEnName,\n            instName: val.instCnName,\n            parentId: this.nodeParentId\n          };\n        } else {\n          const colResponse = await workbenchService.getMetaBaseInfo({\n            instId: val.instId\n          });\n          data = {\n            ...colResponse.data,\n            parentId: this.nodeParentId\n          };\n        }\n\n        this.allDetails = data;\n        this.relationsAnalyse();\n      },\n      // 获取字段列表\n      async listColumnPage(val) {\n        let params = {\n          parentId: this.nodeParentId,\n          name: ""\n        };\n        var response;\n        // console.log(this.isAsset);\n        if (this.isAsset) {\n          params = {\n            instId: this.nodeParentId,\n            tableType: "inst"\n          };\n          response = await dataAssetRegistrationService.getlistItemByPidAndType(\n            params\n          );\n          response.data = response.data.list;\n        } else {\n          response = await dashboardService.listColumnPage(params);\n        }\n\n        this.columnList = response.data;\n        // 不为资产类型，需要调用详情接口\n\n        if (!val) {\n          // 列切换字段时，默认选中第一个字段\n          // console.log(response.data, "response.data")\n          let data = {};\n          if (this.isAsset) {\n            data = {\n              ...response.data[0],\n              instCode: response.data[0].instEnName,\n              instName: response.data[0].instCnName,\n              parentId: this.nodeParentId\n            };\n            // console.log(colResponse, "colResponseanalyseToAsset");\n          } else {\n            let colResponse = await workbenchService.getMetaBaseInfo({\n              instId: response.data[0].instId\n            });\n            data = {\n              ...colResponse.data,\n              parentId: this.nodeParentId\n            };\n          }\n\n          this.allDetails = data;\n          this.$set(this.formInline, "name", data);\n          this.relationsAnalyse();\n        } else {\n          // 字段全部信息\n          let obj = response.data.filter(\n            item => item.instId == this.allDetails.instId\n          );\n          this.$set(this.formInline, "name", obj[0]);\n\n          let data = {};\n          if (this.isAsset) {\n            data = {\n              ...obj[0],\n              instCode: obj[0].instEnName,\n              instName: obj[0].instCnName\n            };\n          } else {\n            let colResponse = await workbenchService.getMetaBaseInfo({\n              instId: response.data[0].instId\n            });\n            data = colResponse.data;\n          }\n          this.allDetails = data;\n          this.relationsAnalyse();\n        }\n      },\n      // 切换分析类型\n      async changeGraph(val, isSearch) {\n        this.graphType = val;\n        if (val == "01") {\n          this.isImpact = true;\n          this.isAll = false;\n        } else if (val == "02") {\n          this.isImpact = false;\n          this.isAll = false;\n        } else {\n          this.isImpact = false;\n          this.isAll = true;\n        }\n        if (!isSearch) {\n          this.relationsAnalyse();\n        }\n      },\n      // 获取图数据\n      async relationsAnalyse() {\n        console.log(this.allDetails);\n        this.showGraph = false;\n        let name =\n            this.allDetails.instName && this.allDetails.instName.trim()\n        ? this.allDetails.instName\n        : this.allDetails.instCode;\n        // let name1 = name.split("<span class=\'hightlightRed\'>").join("");\n        // let name2 = name1.split("</span>").join("");\n        // this.rootName = [name2, ""];\n        let params = {\n          type: this.graphType,\n          originInstId: this.allDetails.instId,\n          instId: this.allDetails.instId,\n          classId: this.allDetails.classId,\n          layer: this.formInline.layer\n        };\n\n        let response = {};\n        if (this.isAsset) {\n          params.classId = this.allDetails.fromClassId;\n          this.allDetails.classId = this.allDetails.fromClassId;\n          response = await metaAnalysisService.getAnalyseToAsset(params);\n        } else {\n          response = await dashboardService.relationsAnalyse(params);\n        }\n        if (response.code == 200) {\n          if (this.graphType == "03") {\n            this.impactSessionId = response.data.impact.sessionId;\n            this.bloodSessionId = response.data.blood.sessionId;\n            response.data.relations = {\n              ...response.data.impact.relations,\n              ...response.data.blood.relations\n            };\n            let arr = [\n              ...response.data.impact.nodes,\n              ...response.data.blood.nodes\n            ];\n            let newArr = [];\n            let obj = {};\n            for (var i = 0; i < arr.length; i++) {\n              if (!obj[arr[i].instId]) {\n                newArr.push(arr[i]);\n                obj[arr[i].instId] = true;\n              }\n            }\n            response.data.nodes = newArr;\n            if (this.isAsset) {\n              response.data.instId = response.data.blood.instId;\n            } else {\n              response.data.instId = this.allDetails.instId;\n            }\n          }\n          console.log(response.data.relations, "response.data.nodes");\n          response.data.nodes.map(item => {\n            if (item.instId == this.allDetails.instId) {\n              this.allDetails = item;\n            }\n          });\n          let jsonData = {\n            id: "root",\n            name: name,\n            ...this.allDetails,\n            children: [],\n            anchorPoints: [\n              [1, 0.5],\n              [0, 0.5]\n            ]\n          }; //重要数组\n          this.sessionId = response.data.sessionId;\n          let _orign_data = {\n            impactArr: [], //影响分析关系数据\n            bloodArr: [], //血缘分析数据\n            others: {}\n          };\n          // 获取所有关系\n          let keys = Object.keys(response.data.relations);\n          keys.map(item => {\n            if (item.indexOf("01") == 0) {\n              //影响分析关联数据\n              _orign_data.impactArr = response.data.relations[item];\n            } else if (item.indexOf("02") == 0) {\n              //血缘分析关联数据\n              _orign_data.bloodArr = response.data.relations[item];\n            } else {\n              _orign_data.others[item] = response.data.relations[item];\n            }\n          });\n          // 组合类型数据\n          _orign_data.others &&\n            Object.keys(_orign_data.others).map((key, index) => {\n            let flagClassId = _orign_data.others[key][0].fromClassId;\n            let toClassId = _orign_data.others[key][0].toClassId;\n            if (\n              (this.allDetails.classId == "DDTable" ||\n               this.allDetails.classId == "DDColumn" ||\n               this.allDetails.classId == "DDIffColumn" ||\n               this.allDetails.classId == "DDFileColumn" ||\n               this.allDetails.classId == "DDNonIffColumn" ||\n               this.allDetails.classId == "AssetInfoItem") &&\n              flagClassId == this.allDetails.classId\n            ) {\n              flagClassId = toClassId;\n            }\n\n            if (flagClassId == "baseMetaData" && toClassId == "AmCommonCode") {\n              flagClassId = toClassId;\n            }\n\n            let node = {\n              id: key,\n              isDisable: true,\n              name: this.allClassList[flagClassId].nodeTitle,\n              nodeType: 0,\n              children: []\n            };\n            if (\n              flagClassId == "DDTable" ||\n              flagClassId == "DDColumn" ||\n              flagClassId == "DDIffColumn" ||\n              flagClassId == "DDFileColumn" ||\n              flagClassId == "DDNonIffColumn"\n            ) {\n              node.state = "left";\n              // 字段展示为技术元数据\n              jsonData.children.push(node);\n            } else {\n              jsonData.children.push(node);\n            }\n\n            // 将所属类型的节点组织加入\n            response.data.relations[key].forEach((thisNode, _index) => {\n              let flagInstId = thisNode.fromInstId;\n\n              if (\n                (this.allDetails.classId == "DDTable" ||\n                 this.allDetails.classId == "DDColumn" ||\n                 this.allDetails.classId == "DDIffColumn" ||\n                 this.allDetails.classId == "DDFileColumn" ||\n                 this.allDetails.classId == "DDNonIffColumn" ||\n                 this.allDetails.classId == "AssetInfoItem") &&\n                thisNode.fromClassId == this.allDetails.classId\n              ) {\n                flagInstId = thisNode.toInstId;\n              }\n              if (\n                thisNode.fromClassId == "baseMetaData" &&\n                thisNode.toClassId == "AmCommonCode"\n              ) {\n                flagInstId = thisNode.toInstId;\n              }\n\n              response.data.nodes.map(item => {\n                if (item.instId == flagInstId) {\n                  item.id = item.instId;\n                  item.name = item.instName.trim()\n                    ? item.instName\n                  : item.instCode;\n                  item.ratio = item.namespaceCode\n                    .split("/")\n                    .slice(1, 4)\n                    .join(">");\n                  let obj = {\n                    nodeType: 1,\n                    ...item,\n                    children: [],\n                    showAnalysis:\n                    item.classId == "DDColumn" ||\n                    item.classId == "DDIffColumn" ||\n                    item.classId == "DDFileColumn" ||\n                    item.classId == "DDNonIffColumn",\n                    data: {\n                      path: item.namespaceCode, //路径\n                      ...this.allClassList[item.classId] //展示字段(标签)\n                    },\n                    noNeedCircle: !(\n                      item.classId == "DDColumn" ||\n                      item.classId == "DDIffColumn" ||\n                      item.classId == "DDFileColumn" ||\n                      item.classId == "DDNonIffColumn"\n                    )\n                  };\n                  node.children.push(obj);\n                }\n              });\n            });\n          });\n          //获取数据\n\n          //字段组合血缘，影响分析\n          if (\n            this.allDetails.classId == "DDTable" ||\n            this.allDetails.classId == "DDColumn" ||\n            this.allDetails.classId == "DDIffColumn" ||\n            this.allDetails.classId == "DDFileColumn" ||\n            this.allDetails.classId == "DDNonIffColumn"\n          ) {\n            // console.log(_orign_data.impactArr, "影响分析");\n            // console.log(_orign_data.bloodArr, "血缘分析");\n            console.log(response.data.instId, "response.data.instId");\n\n            // 影响分析节点\n            let allForm = [];\n            let allForm2 = [];\n\n            // 获取所有血缘关系\n            _orign_data.bloodArr.map(item => {\n              if (allForm.indexOf(item.fromInstId) == -1) {\n                allForm.push(item.fromInstId);\n              }\n            });\n            // 血缘分析节点\n            _orign_data.bloodArr.map(item => {\n              // 找到最接近的根节点\n              if (item.toInstId == response.data.instId) {\n                response.data.nodes.map((node, index) => {\n                  if (node.instId == item.fromInstId) {\n                    let obj = {\n                      ...node,\n                      lineShape: 4,\n                      id: node.instId + this.generateUUID(),\n                      name: node.instName.trim() ? node.instName : node.instCode,\n                      children: [],\n                      state: "left",\n                      anchorPoints: [\n                        [1, 0.5],\n                        [0, 0.5]\n                      ],\n                      expandFlag: item.expandFlag == "Y"\n                    };\n\n                    if (allForm.indexOf(obj.instId) !== -1) {\n                      this.getChildren(\n                        obj,\n                        _orign_data.bloodArr,\n                        response,\n                        allForm,\n                        "02"\n                      );\n                    }\n                    if (obj.children.length == 0) {\n                      obj.noNeedCircle = true;\n                    }\n                    // bloodRootNode.children.push(obj);\n                    jsonData.children.push(obj);\n                  }\n                });\n              }\n            });\n\n            // 获取所有影响关系\n            _orign_data.impactArr.map(item => {\n              if (allForm2.indexOf(item.fromInstId) == -1) {\n                allForm2.push(item.fromInstId);\n              }\n            });\n            //所有formInstIdd\n            _orign_data.impactArr.map(item => {\n              // console.log(item, "itemitemitemitem");\n              // 找到最接近的根节点\n              if (item.fromInstId == response.data.instId) {\n                response.data.nodes.map((node, index) => {\n                  if (node.instId == item.toInstId) {\n                    let obj = {\n                      ...node,\n                      from: "impactAnalysis",\n                      to: item.toInstId,\n                      lineShape: 4,\n                      id: node.instId + this.generateUUID(),\n                      name: node.instName.trim() ? node.instName : node.instCode,\n                      children: [],\n                      ratio: node.namespaceCode\n                      .split("/")\n                      .slice(1, 4)\n                      .join(">"),\n                      nodeType: "out",\n                      noNeedCircle: false,\n                      anchorPoints: [\n                        [1, 0.5],\n                        [0, 0.5]\n                      ],\n                      expandFlag: item.expandFlag == "Y"\n                    };\n\n                    if (allForm2.indexOf(obj.instId) !== -1) {\n                      this.getChildren(\n                        obj,\n                        _orign_data.impactArr,\n                        response,\n                        allForm2,\n                        "01"\n                      );\n                    }\n                    if (obj.children.length == 0) {\n                      obj.noNeedCircle = true;\n                    }\n                    // impactRootNode.children.push(obj);\n                    // console.log(obj, "xxxxxxxxxxxxxxxxxxxx");\n                    jsonData.children.push(obj);\n                  }\n                });\n              }\n            });\n          }\n          let data = jsonData;\n          // console.log(data, "ssssssssssssssss");\n          this.initTree(data);\n        }\n      },\n      // 处理子节点数据\n      getChildren(node, allList, response, allForm, type) {\n        // console.log(node, allForm, "node,  allForm");\n        // 血缘分析 - 找关联关系fromInstId  节点根据toInstId\n        let formFlag = "toInstId";\n        let toFlag = "fromInstId";\n\n        if (type == "01") {\n          formFlag = "fromInstId";\n          toFlag = "toInstId";\n        }\n        allList.map(inner => {\n          if (node.instId == inner[formFlag] && !inner.hasShow) {\n            inner.hasShow = true;\n            // console.log(inner, "关联信息");\n            response.data.nodes.map((innerNode, index) => {\n              if (\n                innerNode.instId == inner[toFlag] &&\n                inner.fromInstId !== inner.toInstId\n              ) {\n                let obj = {\n                  ...innerNode,\n                  from: inner[formFlag],\n                  to: innerNode.instId,\n                  lineShape: 4,\n                  id: innerNode.instId + this.generateUUID(),\n                  name: innerNode.instName.trim()\n                  ? innerNode.instName\n                  : innerNode.instCode,\n                  children: [],\n                  ratio: innerNode.namespaceCode\n                  .split("/")\n                  .slice(1, 4)\n                  .join(">"),\n                  nodeType: node.nodeType,\n                  noNeedCircle: false,\n                  anchorPoints: type == "02" ? [[1, 0.5]] : [[0, 0.5]],\n                  state: type == "02" ? "left" : "",\n                  expandFlag: inner.expandFlag == "Y"\n                };\n\n                // console.log(obj, "objobj");\n                if (allForm.indexOf(innerNode.instId) !== -1) {\n                  obj.anchorPoints = [\n                    [1, 0.5],\n                    [0, 0.5]\n                  ];\n                  this.getChildren(obj, allList, response, allForm, type);\n                }\n                if (obj.children.length == 0) {\n                  obj.noNeedCircle = true;\n                }\n                // console.log(obj, "2222222222222222222");\n                node.children.push(obj);\n              } else {\n                return;\n              }\n            });\n          }\n        });\n      },\n      // 图形第一层名字\n      returnTopName(val) {\n        // console.log(val, "returnTopName");\n        if (val.classId == "DDTable") {\n          return val.schCode;\n        } else {\n          if (val.classId == "DDColumn" && !val.tabCode) {\n            let arr = val.namespaceCode.split("/");\n            val.tabCode = arr[arr.length - 2];\n          }\n          let str = val.schCode + "." + val.tabCode;\n          return str;\n        }\n      },\n      // 画图\n      initTree(data) {\n        this.showGraph = true;\n        const that = this;\n        this.$nextTick(() => {\n          // 文本超出隐藏 (字段, 最大长度, 字体大小)\n          const fittingString = (str, maxWidth, fontSize) => {\n            let maxWidthContent = width > maxWidth ? width : maxWidth;\n            const ellipsis = "...";\n            const ellipsisLength = G6.Util.getTextSize(ellipsis, fontSize)[0];\n            let currentWidth = 0;\n            let res = str;\n            const pattern = new RegExp("[\\u4E00-\\u9FA5]+"); // distinguish the Chinese charactors and letters\n            str.split("").forEach((letter, i) => {\n              if (currentWidth > maxWidth - ellipsisLength) return;\n              if (pattern.test(letter)) {\n                // Chinese charactors\n                currentWidth += fontSize;\n              } else {\n                // get the width of single letter according to the fontSize\n                currentWidth += G6.Util.getLetterWidth(letter, fontSize);\n              }\n              if (currentWidth > maxWidthContent - ellipsisLength) {\n                res = `${str.substr(0, i)}${ellipsis}`;\n              }\n            });\n            return res;\n          };\n          // 获取文本的长度\n          const getTextSize = (val, fontSize) => {\n            let tabCode = that.returnTopName(val);\n            // console.log(tabCode, "tabCode");\n            let width, str1, str2;\n            if (val.classId == "DDTable") {\n              str1 = val.name;\n              str2 = val.schCode;\n            } else {\n              str1 = tabCode;\n              str2 = val.name;\n            }\n            let width1 = G6.Util.getTextSize(str1, fontSize)[0];\n            let width2 = G6.Util.getTextSize(str2, fontSize)[0];\n            // console.log(width1, width2, "====width1,width2");\n            width = width1 > width2 ? width1 : width2;\n            return width > that.maxWidth ? width : that.maxWidth;\n          };\n\n          // 自定义节点\n          G6.registerNode("card-node", {\n            draw(cfg, group) {\n              let boxSize = { height: 80, xNum: 0, yNum: 0 }; //最外层盒子参数 高度，x，y\n              let imgSize = { height: 15 }; //图片高度，横向位置\n              let rect;\n              // 左边血缘分析\n              if (cfg.state === "left") {\n                // 最外层盒子\n                rect = group.addShape("rect", {\n                  attrs: {\n                    x: boxSize.xNum, // x 轴移动距离\n                    y: boxSize.yNum, // y 轴移动距离\n                    width: getTextSize(cfg, 16) + 20, // 宽\n                    height: boxSize.height, // 高\n                    stroke: "#DCDEE0", //描边色 ->border\n                    lineWidth: 1 //border 宽\n                  },\n                  name: "card-node-keyShape",\n                  draggable: true\n                });\n                // top盒子\n                group.addShape("rect", {\n                  attrs: {\n                    x: boxSize.xNum, // x 轴移动距离\n                    y: boxSize.yNum, // y 轴移动距离\n                    width: getTextSize(cfg, 16) + 20, //200,\n                    height: boxSize.height / 2, // 60\n                    fill: "#A6FFC0", //填充颜色\n                    fillOpacity: 0.2 //填充透明度\n                  },\n                  name: "title-box",\n                  draggable: true\n                });\n                // top盒子img  -表类型展示模式图片，字段类型展示表图片\n                group.addShape("text", {\n                  attrs: {\n                    x: boxSize.xNum + 8,\n                    y: boxSize.yNum + 28,\n                    fontFamily: "iconfont2",\n                    text:\n                    that.allDetails.classId == "DDColumn" ? "\\uf87e" : "\\uf6d2",\n                    fontSize: 14,\n                    fill: "#25AEFF",\n                    cursor: "pointer"\n                  },\n                  name: "image-shape-state"\n                });\n\n                // top盒子文字 -表类型展示模式字段，字段类型展示表名\n                group.addShape("text", {\n                  attrs: {\n                    textBaseline: "top",\n                    x: boxSize.xNum + imgSize.height + 15,\n                    y: boxSize.yNum + 15,\n                    lineHeight: 20,\n                    fontSize: 14,\n                    textAlign: "left",\n                    fontWeight: "bold",\n                    text: that.returnTopName(cfg),\n                    fill: "#333"\n                  },\n                  name: "title"\n                });\n                // bottom盒子 图片  -表类型展示表图片，字段类型展示字段图片\n                group.addShape("text", {\n                  attrs: {\n                    x: boxSize.xNum + 32,\n                    y: boxSize.yNum + boxSize.height / 2 + 26,\n                    fontFamily: "iconfont2",\n                    text:\n                    that.allDetails.classId == "DDColumn" ? "\\uf611" : "\\uf87e",\n                    fontSize: 14,\n                    fill: "#25AEFF",\n                    cursor: "pointer"\n                  },\n                  name: "image-shape-state"\n                });\n                // bottom盒子文字  -表展示表名，字段展示字段名\n                group.addShape("text", {\n                  attrs: {\n                    text: fittingString(cfg.name, this.maxWidth, 16),\n                    x: boxSize.xNum + imgSize.height + 40,\n                    y: boxSize.yNum + boxSize.height / 2 + 20,\n                    fontSize: 14,\n                    textAlign: "left",\n                    textBaseline: "middle",\n                    fill: "#333"\n                  },\n                  name: "text-shape"\n                });\n              }\n              // 右边影响分析，根节点\n              if (cfg.state !== "left") {\n                if (cfg.depth === 0) {\n                  // 最外层盒子\n                  rect = group.addShape("rect", {\n                    attrs: {\n                      x: boxSize.xNum, // x 轴移动距离\n                      y: boxSize.yNum, // y 轴移动距离\n                      width: getTextSize(cfg, 16) + 20, // 宽\n                      height: boxSize.height, // 高\n                      stroke: "#DCDEE0", //描边色 ->border\n                      lineWidth: 1 //border 宽\n                    },\n                    name: "card-node-keyShape",\n                    draggable: true\n                  });\n                  // top盒子\n                  group.addShape("rect", {\n                    attrs: {\n                      x: boxSize.xNum, // x 轴移动距离\n                      y: boxSize.yNum, // y 轴移动距离\n                      width: getTextSize(cfg, 16) + 20, //200,\n                      height: boxSize.height / 2, // 60\n                      fill: "#25AEFF", //填充颜色\n                      fillOpacity: 1 //填充透明度\n                    },\n                    name: "title-box",\n                    draggable: true\n                  });\n                  // top盒子img  -表类型展示模式图片，字段类型展示表图片\n                  group.addShape("text", {\n                    attrs: {\n                      x: boxSize.xNum + 8,\n                      y: boxSize.yNum + 28,\n                      fontFamily: "iconfont2",\n                      text:\n                      that.allDetails.classId == "DDColumn"\n                      ? "\\uf87e"\n                      : "\\uf6d2",\n                      fontSize: 14,\n                      fill: "#fff",\n                      cursor: "pointer"\n                    },\n                    name: "image-shape-state"\n                  });\n\n                  // top盒子文字 -表类型展示模式字段，字段类型展示表名\n                  group.addShape("text", {\n                    attrs: {\n                      textBaseline: "top",\n                      x: boxSize.xNum + imgSize.height + 15,\n                      y: boxSize.yNum + 15,\n                      lineHeight: 20,\n                      fontSize: 14,\n                      textAlign: "left",\n                      fontWeight: "bold",\n                      text: that.returnTopName(cfg),\n                      fill: "#fff"\n                    },\n                    name: "title"\n                  });\n                  // bottom盒子 字体图标  -表类型展示表\\uf87e，字段类型展示字段\\uf611\n                  group.addShape("text", {\n                    attrs: {\n                      x: boxSize.xNum + 32,\n                      y: boxSize.yNum + boxSize.height / 2 + 26,\n                      fontFamily: "iconfont2",\n                      text:\n                      that.allDetails.classId == "DDColumn"\n                      ? "\\uf611"\n                      : "\\uf87e",\n                      fontSize: 14,\n                      fill: "#25AEFF",\n                      cursor: "pointer"\n                    },\n                    name: "image-shape-state"\n                  });\n                  // bottom盒子文字  -表展示表名，字段展示字段名\n                  group.addShape("text", {\n                    attrs: {\n                      text: fittingString(cfg.name, this.maxWidth, 16),\n                      x: boxSize.xNum + imgSize.height + 40,\n                      y: boxSize.yNum + boxSize.height / 2 + 20,\n                      fontSize: 14,\n                      textAlign: "left",\n                      textBaseline: "middle",\n                      fill: "#333"\n                    },\n                    name: "text-shape"\n                  });\n                } else {\n                  // 最外层盒子\n                  rect = group.addShape("rect", {\n                    attrs: {\n                      x: boxSize.xNum, // x 轴移动距离\n                      y: boxSize.yNum, // y 轴移动距离\n                      width: getTextSize(cfg, 16) + 20, // 宽\n                      height: boxSize.height, // 高\n                      stroke: "#DCDEE0", //描边色 ->border\n                      lineWidth: 1 //border 宽\n                    },\n                    name: "card-node-keyShape",\n                    draggable: true\n                  });\n                  // top盒子\n                  group.addShape("rect", {\n                    attrs: {\n                      x: boxSize.xNum, // x 轴移动距离\n                      y: boxSize.yNum, // y 轴移动距离\n                      width: getTextSize(cfg, 16) + 20, //200,\n                      height: boxSize.height / 2, // 60\n                      fill: "#25AEFF", //填充颜色\n                      fillOpacity: 0.1 //填充透明度\n                    },\n                    name: "title-box",\n                    draggable: true\n                  });\n                  // top盒子img  -表类型展示模式图片，字段类型展示表图片\n                  group.addShape("text", {\n                    attrs: {\n                      x: boxSize.xNum + 8,\n                      y: boxSize.yNum + 28,\n                      fontFamily: "iconfont2",\n                      text:\n                      that.allDetails.classId == "DDColumn"\n                      ? "\\uf87e"\n                      : "\\uf6d2",\n                      fontSize: 14,\n                      fill: "#25AEFF",\n                      cursor: "pointer"\n                    },\n                    name: "image-shape-state"\n                  });\n\n                  // top盒子文字 -表类型展示模式字段，字段类型展示表名\n                  group.addShape("text", {\n                    attrs: {\n                      textBaseline: "top",\n                      x: boxSize.xNum + imgSize.height + 15,\n                      y: boxSize.yNum + 15,\n                      lineHeight: 20,\n                      fontSize: 14,\n                      textAlign: "left",\n                      fontWeight: "bold",\n                      text: that.returnTopName(cfg),\n                      fill: "#333"\n                    },\n                    name: "title"\n                  });\n                  // bottom盒子 图片  -表类型展示表图片，字段类型展示字段图片\n                  group.addShape("text", {\n                    attrs: {\n                      x: boxSize.xNum + 32,\n                      y: boxSize.yNum + boxSize.height / 2 + 26,\n                      fontFamily: "iconfont2",\n                      text:\n                      that.allDetails.classId == "DDColumn"\n                      ? "\\uf611"\n                      : "\\uf87e",\n                      fontSize: 14,\n                      fill: "#25AEFF",\n                      cursor: "pointer"\n                    },\n                    name: "image-shape-state"\n                  });\n                  // bottom盒子文字  -表展示表名，字段展示字段名\n                  group.addShape("text", {\n                    attrs: {\n                      text: fittingString(cfg.name, this.maxWidth, 16),\n                      x: boxSize.xNum + imgSize.height + 40,\n                      y: boxSize.yNum + boxSize.height / 2 + 20,\n                      fontSize: 14,\n                      textAlign: "left",\n                      textBaseline: "middle",\n                      fill: "#333"\n                    },\n                    name: "text-shape"\n                  });\n                }\n              }\n              // 是否有子节点\n              if (cfg.children && cfg.children.length > 0) {\n                if (cfg.state === "left") {\n                  group.addShape("marker", {\n                    attrs: {\n                      x: -6,\n                      y: boxSize.height / 2,\n                      r: 6,\n                      symbol: cfg.collapsed\n                      ? G6.Marker.expand\n                      : G6.Marker.collapse,\n                      stroke: "#333",\n                      fill: "#fff",\n                      lineWidth: 1,\n                      cursor: "pointer" // 鼠标变手\n                    },\n                    name: "collapse-icon"\n                  });\n                } else {\n                  if (cfg.depth === 0) {\n                    let arr = cfg.children;\n                    // console.log(arr);\n\n                    let isleft = [];\n                    let isRight = [];\n                    isleft =\n                      arr.length > 0 && arr.filter(item => item.state == "left");\n                    isRight = arr.length > 0 && arr.filter(item => !item.state);\n                    // console.log(isleft, "isleft");\n                    // console.log(isRight, "isRight");\n                    if (isleft.length > 0) {\n                      group.addShape("marker", {\n                        attrs: {\n                          x: -6,\n                          y: boxSize.height / 2,\n                          r: 6,\n                          symbol: cfg.collapsed\n                          ? G6.Marker.expand\n                          : G6.Marker.collapse,\n                          stroke: "#666",\n                          fill: "#fff",\n                          lineWidth: 1,\n                          cursor: "pointer" // 鼠标变手\n                        },\n                        name: "collapse-icon"\n                      });\n                    }\n                    if (isRight.length > 0) {\n                      group.addShape("marker", {\n                        attrs: {\n                          x: getTextSize(cfg, 16) + 26, //节点rect的宽度，加marker本身的width\n                          y: boxSize.height / 2,\n                          r: 6,\n                          symbol: cfg.collapsed\n                          ? G6.Marker.expand\n                          : G6.Marker.collapse,\n                          stroke: "#666",\n                          fill: "#fff",\n                          lineWidth: 1,\n                          cursor: "pointer" // 鼠标变手\n                        },\n                        name: "collapse-icon"\n                      });\n                    }\n                  } else {\n                    group.addShape("marker", {\n                      attrs: {\n                        x: getTextSize(cfg, 16) + 26, //节点rect的宽度，加marker本身的width\n                        y: boxSize.height / 2,\n                        r: 6,\n                        symbol: cfg.collapsed\n                        ? G6.Marker.expand\n                        : G6.Marker.collapse,\n                        stroke: "#666",\n                        fill: "#fff",\n                        lineWidth: 1,\n                        cursor: "pointer" // 鼠标变手\n                      },\n                      name: "collapse-icon"\n                    });\n                  }\n                }\n              }\n              // 是否需要动态获取子节点\n              if (cfg.children && cfg.children.length == 0 && cfg.expandFlag) {\n                if (cfg.state === "left") {\n                  group.addShape("marker", {\n                    attrs: {\n                      x: -6,\n                      y: boxSize.height / 2,\n                      r: 6,\n                      symbol: G6.Marker.expand,\n                      stroke: "#333",\n                      fill: "#fff",\n                      lineWidth: 1,\n                      cursor: "pointer" // 鼠标变手\n                    },\n                    name: "collapse-icon"\n                  });\n                } else {\n                  group.addShape("marker", {\n                    attrs: {\n                      x: getTextSize(cfg, 16) + 26, //节点rect的宽度，加marker本身的width\n                      y: boxSize.height / 2,\n                      r: 6,\n                      symbol: G6.Marker.expand,\n                      stroke: "#666",\n                      fill: "#fff",\n                      lineWidth: 1,\n                      cursor: "pointer" // 鼠标变手\n                    },\n                    name: "collapse-icon"\n                  });\n                }\n              }\n              return rect;\n            },\n            setState: (name, value, item) => {\n              // console.log("自定义节点---\x3esetState：", name, value, item);\n              if (name === "collapsed") {\n                // console.log("item-group", item.get("group"));\n                const marker = item\n                .get("group")\n                .findAll(ele => ele.get("name") === "collapse-icon");\n                // console.log("marker---\x3e", marker);\n                marker[0] &&\n                  marker[0].attr(\n                  "symbol",\n                  value ? G6.Marker.collapse : G6.Marker.expand\n                );\n                // 如果是根节点需要处理两个marker\n                if (item._cfg.model.depth === 0) {\n                  //  console.log("marker---\x3e", marker);\n                  marker[1] &&\n                    marker[1].attr(\n                    "symbol",\n                    value ? G6.Marker.collapse : G6.Marker.expand\n                  );\n                }\n              }\n            }\n          });\n          // 自定义边\n          G6.registerEdge("kaimo-line", {\n            /**\n           * 绘制边，包含文本\n           * @param  {Object} cfg 边的配置项\n           * @param  {G.Group} group 图形分组，边中的图形对象的容器\n           * @return {G.Shape} 绘制的图形，通过 node.get(\'keyShape\') 可以获取到\n           */\n            draw(cfg, group) {\n              const startPoint = cfg.startPoint;\n              const endPoint = cfg.endPoint;\n              // console.log(startPoint,endPoint);\n              let shape;\n              if (cfg.targetNode._cfg.model.state === "left") {\n                shape = group.addShape("path", {\n                  //线条\n                  attrs: {\n                    stroke: "#006AD3",\n                    path: [\n                      ["M", startPoint.x - 11, startPoint.y],\n                      [\n                        "L",\n                        endPoint.x / 3 + (2 / 3) * startPoint.x,\n                        startPoint.y\n                      ],\n                      ["L", endPoint.x / 3 + (2 / 3) * startPoint.x, endPoint.y],\n                      ["L", endPoint.x, endPoint.y]\n                    ],\n                    startArrow: {\n                      path: G6.Arrow.triangle(5, 5, 0), // 使用内置箭头路径函数，参数为箭头的 宽度、长度、偏移量（默认为 0，与 d 对应）\n                      d: 0,\n                      fill: "#006AD3",\n                      opacity: 0.5,\n                      lineWidth: 1\n                    }\n                  },\n                  // must be assigned in G6 3.3 and later versions. it can be any value you want\n                  name: "path-shape"\n                });\n              } else {\n                shape = group.addShape("path", {\n                  //线条\n                  attrs: {\n                    stroke: "#006AD3",\n                    path: [\n                      ["M", startPoint.x, startPoint.y],\n                      [\n                        "L",\n                        endPoint.x / 3 + (2 / 3) * startPoint.x,\n                        startPoint.y\n                      ],\n                      ["L", endPoint.x / 3 + (2 / 3) * startPoint.x, endPoint.y],\n                      ["L", endPoint.x, endPoint.y]\n                    ],\n                    endArrow: {\n                      path: G6.Arrow.triangle(5, 5, 0), // 使用内置箭头路径函数，参数为箭头的 宽度、长度、偏移量（默认为 0，与 d 对应）\n                      d: 0,\n                      fill: "#006AD3",\n                      opacity: 0.5,\n                      lineWidth: 1\n                    }\n                  },\n                  // must be assigned in G6 3.3 and later versions. it can be any value you want\n                  name: "path-shape"\n                });\n              }\n              return shape;\n            }\n          });\n          // 自定义事件\n          G6.registerBehavior("kaimo-behavior", {\n            getEvents() {\n              return {\n                "node:click": "onNodeClick"\n              };\n            },\n            // 自定义单击事件\n            onNodeClick: async evt => {\n              // 单击展开/收起\n              const nowNode = evt.item._cfg.model;\n              // console.log("自定义单击事件---\x3e", nowNode);\n              const nodeId = evt.item.get("id");\n              const parentData = that.graph.findDataById(nodeId);\n              if (nowNode.expandFlag && nowNode.children.length == 0) {\n                let params = {\n                  originInstId: this.allDetails.instId,\n                  instId: nowNode.instId,\n                  classId: this.allDetails.classId,\n                  sessionId: this.sessionId,\n                  type: nowNode.state !== "left" ? "01" : "02"\n                };\n                if (this.graphType == "03") {\n                  params.sessionId =\n                    nowNode.state == "left"\n                    ? this.bloodSessionId\n                  : this.impactSessionId;\n                }\n                const response = await dashboardService.expandRelationsAnalyse(\n                  params\n                );\n                let data = [];\n                let allList = [];\n                // 获取所有关系\n                let keys = Object.keys(response.data.relations);\n                nowNode.searchType = nowNode.state !== "left" ? "01" : "02";\n                keys.map(item => {\n                  if (item.indexOf(nowNode.searchType) !== -1) {\n                    //影响分析关联数据\n                    allList = response.data.relations[item];\n                  }\n                });\n\n                // 影响分析节点\n                let allForm = [];\n                // 获取所有关系\n                allList.map(item => {\n                  if (allForm.indexOf(item.fromInstId) == -1) {\n                    allForm.push(item.fromInstId);\n                  }\n                });\n                let formFlag = "toInstId";\n                let toFlag = "fromInstId";\n\n                if (nowNode.searchType == "01") {\n                  formFlag = "fromInstId";\n                  toFlag = "toInstId";\n                }\n                // 节点\n                allList.map(item => {\n                  // 找到最接近的根节点\n                  if (item[formFlag] == response.data.instId) {\n                    response.data.nodes.map((node, index) => {\n                      if (node.instId == item[toFlag]) {\n                        let obj = {\n                          ...node,\n                          from:\n                          nowNode.searchType == "01"\n                          ? "impactAnalysis"\n                          : "bloodAnalysis",\n                          to: node.instId,\n                          lineShape: 4,\n                          id: node.instId + this.generateUUID(),\n                          name: node.instName.trim()\n                          ? node.instName\n                          : node.instCode,\n                          children: [],\n                          noNeedCircle: false,\n                          anchorPoints:\n                          nowNode.searchType == "02" ? [[1, 0.5]] : [[0, 0.5]],\n                          expandFlag: item.expandFlag == "Y",\n                          state: nowNode.searchType == "02" ? "left" : ""\n                        };\n\n                        if (allForm.indexOf(obj.instId) !== -1) {\n                          this.getChildren(\n                            obj,\n                            allList,\n                            response,\n                            allForm,\n                            nowNode.searchType\n                          );\n                        }\n                        data.push(obj);\n                      }\n                    });\n                  }\n                });\n                parentData.anchorPoints = [\n                  [1, 0.5],\n                  [0, 0.5]\n                ];\n                // console.log(data);\n                parentData.children = data;\n                that.graph.updateChildren(parentData.children, nodeId);\n                //移动图，使得 item 对齐到视口中心，该方法可用于做搜索后的缓动动画。\n              } else {\n                evt.item._cfg.model.collapsed = !evt.item._cfg.model.collapsed;\n                // 更改 item 的状态，触发自定义节点：setState\n                that.graph.setItemState(\n                  evt.item,\n                  "collapsed",\n                  !evt.item.getModel().collapsed\n                );\n                that.graph.layout();\n              }\n              //移动图，使得 item 对齐到视口中心，该方法可用于做搜索后的缓动动画。\n              that.graph.fitView();\n              that.graph.zoomTo(that.zoomSize);\n              that.graph.fitCenter();\n              that.graph.focusItem(nodeId, true);\n              if (that.graphType == "01") {\n                that.graph.translate(-100, -50);\n              } else if (this.graphType == "02") {\n                that.graph.translate(-100, -50);\n              } else {\n                that.graph.translate(-100, -50);\n              }\n            }\n          });\n          // 定义画布的宽高\n          const width = document.getElementById(this.svgId).scrollWidth || 1600;\n          let height;\n          if (this.fullScreen) {\n            height = document.getElementById("mainContainer").scrollHeight + 80;\n          } else {\n            height =\n              document.getElementById("mainContainer").scrollHeight - 120 || 700;\n          }\n          // 实例化G6\n          // 因为我们用的是树图，所以这里是G6.TreeGraph(),还有其他，像是普通图的配置G6.Graph(),一般y用的比较多的就像是树图这种，还有组织架构图一类的。\n          that.graph = new G6.TreeGraph({\n            // 图的  DOM 容器，对应上面我们定义的id\n            container: that.svgId,\n            width,\n            height,\n            maxZoom: 1.8,\n            minZoom: 0.3,\n            // 设置画布的交互模式\n            modes: {\n              default: [\n                // 自定义事件\n                "kaimo-behavior",\n                // 拖拽画布\n                "drag-canvas",\n                // 缩放画布\n                "zoom-canvas"\n              ]\n            },\n            // 配置节点的属性\n            defaultNode: {\n              // 节点类型，cicle:圆形，rect:矩形，ellipse:椭圆，diamond:菱形，triangle：三角形，star：五角星，image：图片，modelRect：卡片\n              type: "card-node",\n              // 节点样式\n              style: {\n                // 鼠标经过是的形状，跟css是一样的。\n                cursor: "pointer",\n                // 圆角\n                radius: 4\n              }\n            },\n            // 配置边的属性\n            defaultEdge: {\n              // 指定边的类型，可以是内置边的类型名称，也可以是自定义边的名称。\n              // line:直线，polyline：折线，arc：圆弧线，quadratic：二阶贝塞尔曲线，cubic：三阶贝塞尔曲线，cubic-vertica：垂直方向的三阶贝塞尔曲线，不考虑用户从外部传入的控制点。cubic-horizontal：水平方向的三阶贝塞尔曲线，不考虑用户从外部传入的控制点。loop：自环\n              type: "kaimo-line"\n            },\n            // 布局配置项\n            layout: {\n              // 布局名称,这个可就太多了，这个只是树图结构中的一种。比如还有compactBox：紧凑树布局，dendrogram：生态树布局，indented：缩紧树布局。\n              type: "compactBox", // 脑图树布局\n              direction: "H", // H / V / LR / RL / TB / BT 这些是控制节点分布位置，从左往右、从右往左、从中间往上下延伸、从中间往左右延伸...具体可以看官网\n              // 节点 id 的回调函数\n              getId: function getId(d) {\n                return d.id;\n              },\n              // 下面都是一些控制节点与节点间距离的回调函数，具体可以试着修改一下值。\n              // 节点高度的回调函数\n              getHeight: function getHeight() {\n                return 16;\n              },\n              // 节点宽度的回调函数\n              getWidth: function getWidth(cfg) {\n                return getTextSize(cfg, 16) + 40;\n              },\n              // 节点纵向间距的回调函数\n              getVGap: function getVGap() {\n                return 40;\n              },\n              // 节点横向间距的回调函数\n              getHGap: function getHGap(cfg) {\n                return 40;\n              },\n              // 这个getSide就是控制节点位置的属性了，通过数据结构中定义的值做判断，来控制左右，\n              // 注意的是这个官方写的只能return \'left\'和\'right\'，当我们的树结构是竖着的呢？难道是用top和bottom？这里我也试过了，用top和bottom是不好使的，因为人家官方确确实实的只有left和right，通过尝试，其实left就对应top，right对应bottom，所以要控制节点在上面就写left,在下面就写right。\n              getSide: node => {\n                if (node.data.state === "left") {\n                  return "left";\n                }\n                return "right";\n              }\n            },\n            // 动画属性\n            animate: true\n          });\n          // 默认全部展开\n          G6.Util.traverseTree(data, function(item) {\n            item.collapsed = false;\n          });\n          // console.log(data, "newdata");\n          // 初始化的图数据\n          that.graph.data(data);\n          // 根据提供的数据渲染视图。\n          that.graph.render();\n\n          that.graph.on("wheelzoom", evt => {\n            // 一些操作\n            let zoom = that.graph.getZoom();\n            if (zoom >= 1.8) {\n              zoom = 1.8;\n            } else if (zoom <= 0.3) {\n              zoom = 0.3;\n            }\n            zoom = zoom.toFixed(1);\n            this.zoomSize = zoom;\n          });\n          // 鼠标进入节点\n          that.graph.on("node:mouseenter", event => {\n            // console.log(event);\n            if (!this.timeoutId) {\n              this.timeoutId = window.setTimeout(() => {\n                this.timeoutId = null;\n                var isHave = document.getElementById("graph-tooltip");\n                if (!isHave) {\n                  var container = document.getElementById(this.svgId);\n                  tooltipEl = document.createElement("div");\n                  tooltipEl.setAttribute("id", "graph-tooltip");\n                  container.appendChild(tooltipEl);\n                }\n\n                // tooltipEl.textContent = message;\n                let node = event.item.getModel();\n                if (node.id == "root") {\n                  node = that.allDetails;\n                }\n                console.log(node, "tooltipEl");\n                let formatedNodeName;\n                if (node.classId == "DDColumn") {\n                  if (this.isAsset) {\n                    node.startTime = moment(node.startTime).format(\n                      "YYYY-MM-DD HH:mm:ss"\n                    );\n                  }\n                  formatedNodeName = ` <div class="detailBox">\n            <p style="text-align: left;color: #006ad3;font-weight: bold;padding: 0;"> ${\n                  node.instCode\n                }</p>\n              <div style="display: flex;justify-content: flex-start;flex-wrap: nowrap;margin: 5px 0;">\n              <span style="color: #7d7d7d;white-space: nowrap;">字段中文名：</span>\n              <span style="color: #333333;white-space: nowrap;">${\n                  node.instName\n                }</span>\n  </div>\n             <div style="display: flex;justify-content: flex-start;flex-wrap: nowrap;margin: 5px 0;">\n              <span style="color: #7d7d7d;white-space: nowrap;">所属表：</span>\n              <span style="color: #333333;white-space: nowrap;">${\n                  node.tabCode\n                }</span>\n  </div>\n            <div style="display: flex;justify-content: flex-start;flex-wrap: nowrap;margin: 5px 0;">\n              <span style="color: #7d7d7d;white-space: nowrap;">数据库：</span>\n              <span style="color: #333333;white-space: nowrap;">${\n                  node.dbName ? node.dbName : node.dbCode\n                }</span>\n  </div>\n                        <div style="display: flex;justify-content: flex-start;flex-wrap: nowrap;margin: 5px 0;">\n              <span style="color: #7d7d7d;white-space: nowrap;">所属系统：</span>\n              <span style="color: #333333;white-space: nowrap;">${\n                  node.sysName ? node.sysName : node.sysCode\n                }</span>\n  </div>\n            <div style="display: flex;justify-content: flex-start;flex-wrap: nowrap;margin: 5px 0;">\n              <span style="color: #7d7d7d;white-space: nowrap;">创建时间：</span>\n              <span style="color: #333333;white-space: nowrap;"> ${\n                  node.startTime\n                }</span>\n  </div>\n  </div>`;\n                } else {\n                  if (this.isAsset) {\n                    node.startTime = moment(node.startTime).format(\n                      "YYYY-MM-DD HH:mm:ss"\n                    );\n                  }\n                  formatedNodeName = ` <div class="detailBox">\n            <p style="text-align: left;color: #006ad3;font-weight: bold;padding: 0;"> ${\n                  node.instCode\n                }</p>\n              <div style="display: flex;justify-content: flex-start;flex-wrap: nowrap;margin: 5px 0;">\n              <span style="color: #7d7d7d;white-space: nowrap;">表中文名：</span>\n              <span style="color: #333333;white-space: nowrap;"> ${\n                  node.instName\n                }</span>\n  </div>\n            <div style="display: flex;justify-content: flex-start;flex-wrap: nowrap;margin: 5px 0;">\n              <span style="color: #7d7d7d;white-space: nowrap;">所属系统：</span>\n              <span style="color: #333333;white-space: nowrap;">${\n                  node.sysName ? node.sysName : node.sysCode\n                }</span>\n  </div>\n            <div style="display: flex;justify-content: flex-start;flex-wrap: nowrap;margin: 5px 0;">\n              <span style="color: #7d7d7d;white-space: nowrap;">数据库：</span>\n              <span style="color: #333333;white-space: nowrap;">${\n                  node.dbName ? node.dbName : node.dbCode\n                }</span>\n  </div>\n            <div style="display: flex;justify-content: flex-start;flex-wrap: nowrap;margin: 5px 0;">\n              <span style="color: #7d7d7d;white-space: nowrap;">创建时间：</span>\n              <span style="color: #333333;white-space: nowrap;"> ${\n                  node.startTime\n                }</span>\n  </div>\n  </div>`;\n                }\n                // console.log(\'eeeeeeeeeeee\', e, nodeName, formatedNodeName);\n                tooltipEl.innerHTML = `${formatedNodeName}`;\n                // tooltip是相对于画布canvas element绝对定位，所以position的x，y必须是相对于画布的坐标\n                tooltipEl.style.left = event.canvasX + "px";\n                tooltipEl.style.top = event.canvasY + 40 + "px";\n                tooltipEl.style.display = "block";\n                tooltipEl.style.position = "absolute";\n                tooltipEl.style.border = "1px solid #e2e2e2";\n                tooltipEl.style.borderRadius = "4px";\n                tooltipEl.style.backgroundColor = "rgba(255, 255, 255, 0.9)";\n                tooltipEl.style.boxShadow = "rgb(174, 174, 174) 0px 0px 10px";\n                tooltipEl.style.padding = "10px 8px";\n              }, 500); //停顿两秒\n            }\n          });\n          // 鼠标移出节点\n          that.graph.on("node:mouseleave", event => {\n            if (tooltipEl) {\n              tooltipEl.style.display = "none";\n              window.clearTimeout(this.timeoutId);\n              this.timeoutId = null;\n            }\n          });\n          // 让画布内容适应视口\n          // console.log(this.fullScreen, "this.fullScreen");\n          that.graph.fitView();\n          that.graph.zoomTo(that.zoomSize);\n          that.graph.fitCenter();\n          that.graph.focusItem(data.id, true);\n          if (that.graphType == "01") {\n            that.graph.translate(-width / 2 + 20, -50);\n          } else if (this.graphType == "02") {\n            that.graph.translate(width / 4, -50);\n          } else {\n            that.graph.translate(-100, -50);\n          }\n        });\n      }\n    }\n  };\n<\/script>\n\n<style lang="less" scoped>\n  .metaDmap {\n    position: relative;\n    .flexBox {\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n      padding: 5px 0;\n      border-bottom: 1px solid #c9c9c9;\n      > div {\n        display: flex;\n        align-items: center;\n        i {\n          font-size: 16px;\n          cursor: pointer;\n        }\n        .buttonBox {\n          display: flex;\n          justify-content: flex-start;\n          border: 1px solid #dcdee0;\n          color: #323233;\n          .activeBg {\n            background: #e5f0fa;\n            color: #006ad3;\n            border: 1px solid #006ad3 !important;\n          }\n          .centerSpan {\n            border-left: 1px solid #dcdee0;\n            border-right: 1px solid #dcdee0;\n          }\n          span {\n            padding: 5px 20px;\n            cursor: pointer;\n            white-space: nowrap;\n          }\n        }\n        .el-select {\n          border-radius: 0;\n          height: 30px;\n        }\n      }\n    }\n\n    .detail {\n      position: absolute;\n      right: 0;\n      top: 0;\n      background: #fff;\n      border: 1px solid #ccc;\n      z-index: 2001;\n      .drawerBox {\n        position: relative;\n        .clickIcon {\n          width: 100px;\n          height: 0;\n          border-top: 20px solid blue;\n          border-left: 20px solid transparent;\n          border-right: 20px solid transparent;\n          position: absolute;\n          top: 50%;\n          left: -80px;\n          transform: rotate(90deg);\n        }\n      }\n    }\n\n    .right-slide-enter,\n    .right-slide-leave-active {\n      transform: translateX(130px);\n    }\n\n    .right-slide-leave-active,\n    .right-slide-enter-active {\n      transition: all0.3s;\n    }\n    .nodeBox {\n      position: relative;\n      cursor: pointer;\n      &:hover {\n        .detailBox {\n          z-index: 2002;\n          display: block;\n        }\n      }\n    }\n  }\n</style>\n\n\n\n# detailDrawer.vue文件\n\n<template>\n<div class="detailDrawer">\n  <h3 class="color-font">{{ drawerData.instCode }}</h3>\n  <tableDetail v-if="isTable" :drawerData="drawerData" />\n  <columnDetail :drawerData="allData" v-if="showCol" />\n  </div>\n</template>\n\n<script>\n  import workbenchService from "@/services/workbenchService";\n  import tableDetail from "./inner/tableDetail";\n  import columnDetail from "./inner/columnDetail";\n\n  export default {\n    props: {\n      drawerData: {\n        type: Object,\n        default: () => {\n          return {};\n        }\n      }\n    },\n    components: {\n      tableDetail,\n      columnDetail\n    },\n    watch: {\n      drawerData: {\n        immediate: true,\n        deep: true,\n        handler(newval) {\n          console.log(newval, "newval");\n          this.isTable = false;\n\n          if (newval.classId == "DDTable") {\n            this.isTable = true;\n          } else {\n            this.showCol = false;\n            // 获取该字段所有详情数据\n            this.getMetaBaseInfo();\n          }\n        }\n      }\n    },\n    data() {\n      return {\n        allHtmlData: [],\n        isTable: false, //是否为表类型\n        allData: {},\n        showCol: false\n      };\n    },\n    methods: {\n      async getMetaBaseInfo() {\n        let params = {\n          instId: this.drawerData.instId\n        };\n        const response = await workbenchService.getMetaBaseInfo(params);\n        console.log(response);\n        this.allData = response.data;\n        this.showCol = true;\n      }\n    }\n  };\n<\/script>\n\n<style lang="less" scoped>\n  .detailDrawer {\n    height: calc(100vh - 98px);\n    overflow: auto;\n    h3 {\n      color: #016dbf;\n      text-align: center;\n      border-bottom: 1px solid #efefef;\n      padding: 10px 0;\n      margin: 0;\n      font-weight: bold;\n    }\n    .card {\n      padding: 10px;\n      .titleStyle {\n        color: #333;\n      }\n      p {\n        display: flex;\n        align-items: center;\n        justify-content: space-between;\n      }\n      .tableStyle {\n        border-top: 1px solid #efefef;\n        border-left: 1px solid #efefef;\n        .lineStyle {\n          .bgTd {\n            background: #fafafa;\n          }\n        }\n        .spanItem {\n          display: block;\n          word-break: break-word;\n          padding: 5px 0px 5px 5px;\n          width: 130px;\n          text-align: left;\n          border-right: 1px solid #efefef;\n          border-bottom: 1px solid #efefef;\n        }\n      }\n    }\n  }\n</style>\n\n\n\n# tableDetail.vue文件\n\n<template>\n  <el-tabs tab-position="top" v-model="activeName">\n    \x3c!-- 字段信息 --\x3e\n    <el-tab-pane :label="$i18ns(\'fieldMessage\')" name="fieldInfo">\n      <el-table\n        :data="tableData"\n        tooltip-effect="light"\n        border\n        stripe\n        style="width: 100%"\n        :header-cell-style="{ background: \'inherit!important\' }"\n        align="left"\n      >\n        <el-table-column type="index" width="50" :label="$i18ns(\'序号\')">\n        </el-table-column>\n        <el-table-column\n          prop="instCode"\n          :label="$i18ns(\'fieldEnName\')"\n          show-overflow-tooltip\n        ></el-table-column>\n        <el-table-column\n          prop="instName"\n          :label="$i18ns(\'fieldCnName\')"\n          show-overflow-tooltip\n        ></el-table-column>\n      </el-table>\n      \x3c!-- 分页 --\x3e\n      <my-pagination\n        :pageNum="pageNum"\n        :pageSize="pageSize"\n        :total="total"\n        @handleSizeChange="handleSizeChange"\n        @handleCurrentChange="handleCurrentChange"\n      />\n    </el-tab-pane>\n    \x3c!-- 属性信息 --\x3e\n    <el-tab-pane :label="$i18ns(\'属性信息\')" name="featureInfo">\n      <columnDetail :drawerData="drawerData" />\n    </el-tab-pane>\n  </el-tabs>\n</template>\n\n<script>\nimport dataManaService from "@/services/dataManaService";\nimport columnDetail from "./columnDetail";\n\nexport default {\n  props: {\n    drawerData: {\n      type: Object,\n      default: () => {\n        return {};\n      },\n    },\n  },\n    components: {\n    columnDetail,\n  },\n  data() {\n    return {\n      pageNum: 1,\n      pageSize: 10, //多少条\n      total: 0,\n      tableData: [],\n      activeName: "fieldInfo",\n      allData: {},\n    };\n  },\n  created() {\n    this.listColumnPage();\n  },\n  methods: {\n    // 获取字段列表\n    async listColumnPage() {\n      let params = {\n        parentId: this.drawerData.instId,\n        pageNum: this.pageNum,\n        pageSize: this.pageSize,\n      };\n      const { data, code } = await dataManaService.listColumnPage(params);\n      this.tableData = data.list;\n      this.total = data.total;\n    },\n    //每页多少条\n    handleSizeChange(val) {\n      this.pageNum = 1;\n      this.pageSize = val;\n      this.listColumnPage();\n    },\n    //当前是第几页\n    handleCurrentChange(val) {\n      this.pageNum = val;\n      this.listColumnPage();\n    },\n  },\n};\n<\/script>\n\n<style>\n</style>\n\n\n\n# columnDetail.vue文件\n\n<template>\n<div class="detailDrawer">\n  <div\n       class="card"\n       v-for="item in allHtmlData"\n       :key="item.name"\n       v-show="item.htmlData.length !== 0"\n       >\n    <p>\n      <span class="titleStyle">{{ $i18ns(item.name) }}</span>\n      <i\n         :class="item.show ? \'el-icon-caret-top\' : \'el-icon-caret-bottom\'"\n         @click="item.show = !item.show"\n         ></i>\n  </p>\n\n    <div class="tableStyle" v-if="item.show">\n      <div\n           v-for="innerItem in item.htmlData"\n           :key="innerItem.fetrClss"\n           class="lineStyle"\n           >\n        <template v-if="innerItem.parmCode == \'nameSpaces\'">\n          <span\n                style="display: flex"\n                v-for="(inner, index) in drawerData.nameSpaces"\n                :key="index"\n                >\n            <span class="bgTd spanItem">{{\n              $i18ns("挂载目录") + (index + 1) + ":"\n              }}</span>\n            <span class="conTd spanItem">\n              {{ inner }}\n  </span>\n  </span>\n</template>\n<span v-else style="display: flex">\n  <span class="bgTd spanItem">{{\n    $i18ns(innerItem.name) + ":"\n    }}</span>\n\n  <span\n        class="conTd spanItem"\n        v-if="drawerData.fetrList && drawerData.fetrList.length > 0"\n        >\n    {{\n    drawerData.fetrList[0].hasOwnProperty(innerItem.parmCode)\n    ? drawerData.fetrList[0][innerItem.parmCode]\n    : drawerData[innerItem.parmCode]\n    }}\n  </span>\n  <span class="conTd spanItem" v-else>\n    {{ drawerData[innerItem.parmCode] }}\n  </span>\n</span>\n</div>\n</div>\n</div>\n</div>\n</template>\n\n<script>\n  import dataManaService from "@/services/dataManaService";\n\n  export default {\n    props: ["drawerData"],\n    data() {\n      return {\n        allHtmlData: [],\n      };\n    },\n    created() {\n      this.baseFetrAndClss();\n    },\n    methods: {\n      async baseFetrAndClss() {\n        const queryParams = {\n          clssId: this.drawerData.classId,\n        };\n        const deferData = await dataManaService.baseFetrAndClss(queryParams);\n\n        if (Number(deferData.code) === 200) {\n          var tableData = deferData.data.parentList;\n\n          var basic = [],\n              business = [],\n              technique = [],\n              manage = [];\n          for (let index = 0; index < tableData.length; index++) {\n            if (\n              tableData[index].fetrClss == "basic" &&\n              tableData[index].isShow == "T"\n            ) {\n              // 基础属性\n              basic.push(tableData[index]);\n            } else if (\n              tableData[index].fetrClss == "business" &&\n              tableData[index].isShow == "T"\n            ) {\n              // 业务属性\n              business.push(tableData[index]);\n            } else if (\n              tableData[index].fetrClss == "technique" &&\n              tableData[index].isShow == "T"\n            ) {\n              // 技术属性\n              technique.push(tableData[index]);\n            } else if (\n              tableData[index].fetrClss == "manage" &&\n              tableData[index].isShow == "T"\n            ) {\n              // 管理属性\n              manage.push(tableData[index]);\n            }\n          }\n          basic.unshift({\n            name: "挂载目录",\n            parmCode: "nameSpaces",\n          });\n          this.allHtmlData = [\n            {\n              name: "basicAttributes",\n              htmlData: basic,\n              show: true,\n            },\n            {\n              name: "businessAttributes",\n              htmlData: business,\n              show: true,\n            },\n            {\n              name: "technicalAttributes",\n              htmlData: technique,\n              show: true,\n            },\n            {\n              name: "manageAttributes",\n              htmlData: manage,\n              show: true,\n            },\n          ];\n        }\n      },\n    },\n  };\n<\/script>\n\n<style lang="less" scoped>\n  .detailDrawer {\n    height: calc(100vh - 98px);\n    overflow: auto;\n    h3 {\n      color: #016dbf;\n      text-align: center;\n      border-bottom: 1px solid #efefef;\n      padding: 10px 0;\n      margin: 0;\n      font-weight: bold;\n    }\n    .card {\n      padding: 10px;\n      .titleStyle {\n        color: #333;\n      }\n      p {\n        display: flex;\n        align-items: center;\n        justify-content: space-between;\n      }\n      .tableStyle {\n        border-top: 1px solid #efefef;\n        border-left: 1px solid #efefef;\n        .lineStyle {\n          .bgTd {\n            background: #fafafa;\n          }\n        }\n        .spanItem {\n          display: block;\n          word-break: break-word;\n          padding: 5px 0px 5px 5px;\n          width: 130px;\n          text-align: left;\n          border-right: 1px solid #efefef;\n          border-bottom: 1px solid #efefef;\n        }\n      }\n    }\n  }\n</style>\n\n\n\n# 以资产的数据为例\n\n\n# 效果图\n\n\n\n\n# 表级[dataAssetManaService.getAssetDetail]最全的数据\n\n{\n  "code": 200,\n  "message": "操作成功",\n  "data": {\n    "instId": "00186c9ae3329e2a43e95ba05acfdbb6",\n    "instCode": "AT000005501",\n    "instCnName": "元数据变更登记表",\n    "instEnName": "T_DEV_MD_CHECK",\n    "classId": "SubjectData",\n    "fromClassId": "DDTable",\n    "parentId": "3d86419dec054006b1cb8dd88ae6855a",\n    "namespaceId": "/SubjectData/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/00186c9ae3329e2a43e95ba05acfdbb6",\n    "namespaceCode": "/SubjectData/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/AT000005501",\n    "orgId": "Prod.R&D.Center",\n    "startTime": "2023-07-13T08:26:55.000+0000",\n    "status": "01",\n    "creater": "system",\n    "pageView": 330,\n    "ownerVerCode": "DA_V0.0.2",\n    "verId": "",\n    "verDate": "",\n    "lucenceFlushDate": "",\n    "mdHash": "cb399b0bbe3312871809ddcdf81511f2",\n    "sysCode": "DAP6",\n    "sysName": "",\n    "dbCode": "DAP6",\n    "dbName": "",\n    "schCode": "DAP6",\n    "tabCode": "",\n    "tabName": "",\n    "corpId": "1",\n    "rsvStr1": "",\n    "rsvStr2": "",\n    "rsvStr3": "",\n    "rsvStr4": "",\n    "rsvStr5": "",\n    "rsvStr6": "DAP6",\n    "rsvStr7": "DAP6",\n    "rsvStr8": "DAP6",\n    "rsvStr9": "",\n    "rsvStr10": "23333",\n    "rsvStr11": "",\n    "rsvStr12": "",\n    "rsvStr13": "",\n    "rsvStr14": "",\n    "rsvStr15": "",\n    "rsvStr16": "",\n    "rsvStr17": "",\n    "rsvStr18": "",\n    "rsvStr19": "",\n    "rsvStr20": "",\n    "rsvStr21": "",\n    "rsvStr22": "",\n    "rsvStr23": "",\n    "rsvStr24": "",\n    "rsvStr25": "",\n    "rsvStr26": "",\n    "rsvStr27": "",\n    "rsvStr28": "",\n    "rsvStr29": "",\n    "rsvStr30": "",\n    "rsvStr31": "",\n    "rsvStr32": "",\n    "rsvStr33": "",\n    "rsvStr34": "",\n    "rsvStr35": "",\n    "rsvStr36": "",\n    "rsvStr37": "",\n    "rsvStr38": "",\n    "rsvStr39": "",\n    "rsvStr40": "",\n    "filterList": "",\n    "fetrList": [\n      {\n        "rsvStr7": "DAP6",\n        "instCnName": "元数据变更登记表",\n        "rsvStr8": "DAP6",\n        "instEnName": "T_DEV_MD_CHECK",\n        "instCode": "AT000005501",\n        "rsvStr10": "23333",\n        "orgId": "产品研发部"\n      }\n    ],\n    "nameSpaces": [\n      "/金融市场/运营管理/网点管理"\n    ],\n    "fullPath": "/主题数据/公共汇总层/协议/金融账户",\n    "leaf": false\n  }\n}\n\n\n\n# 字段级[dataAssetRegistrationService.getlistItemByPidAndType]\n\n{\n  "code": 200,\n  "message": "操作成功",\n  "data": {\n    "total": 14,\n    "list": [\n      {\n        "instId": "056fc76a48401e18cd7dc5636cffb2ef",\n        "instCode": "SYS_CODE",\n        "instCnName": "系统编号",\n        "instEnName": "SYS_CODE",\n        "classId": "SubjectDataItem",\n        "fromClassId": "DDColumn",\n        "parentId": "00186c9ae3329e2a43e95ba05acfdbb6",\n        "namespaceId": "/SubjectData/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/00186c9ae3329e2a43e95ba05acfdbb6/056fc76a48401e18cd7dc5636cffb2ef",\n        "namespaceCode": "/SubjectData/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/AT000005501/SYS_CODE",\n        "orgId": "",\n        "startTime": "2023-07-13T08:26:55.000+0000",\n        "creater": "system",\n        "mdHash": "a3d2fbbfe03e6bc9b4e51d0ca119e483",\n        "sysCode": "DAP6",\n        "sysName": "",\n        "dbCode": "",\n        "dbName": "",\n        "schCode": "",\n        "tabCode": "",\n        "tabName": "",\n        "corpId": "",\n        "rsvStr1": "varchar(50)",\n        "rsvStr2": "N",\n        "rsvStr3": "",\n        "rsvStr4": "2",\n        "rsvStr5": "10",\n        "rsvStr6": "2",\n        "rsvStr7": "",\n        "rsvStr8": "",\n        "rsvStr9": "",\n        "rsvStr10": "",\n        "rsvStr11": "",\n        "rsvStr12": "",\n        "rsvStr13": "",\n        "rsvStr14": "",\n        "rsvStr15": "",\n        "rsvStr16": "",\n        "rsvStr17": "",\n        "rsvStr18": "",\n        "rsvStr19": "",\n        "rsvStr20": "",\n        "rsvStr21": "",\n        "rsvStr22": "",\n        "rsvStr23": "",\n        "rsvStr24": "",\n        "rsvStr25": "",\n        "rsvStr26": "",\n        "rsvStr27": "",\n        "rsvStr28": "",\n        "rsvStr29": "",\n        "rsvStr30": "",\n        "rsvStr31": "",\n        "rsvStr32": "",\n        "rsvStr33": "",\n        "rsvStr34": "",\n        "rsvStr35": "",\n        "rsvStr36": "",\n        "rsvStr37": "",\n        "rsvStr38": "",\n        "rsvStr39": "",\n        "rsvStr40": "",\n        "pageSize": "",\n        "pageNum": "",\n        "apprStatus": "",\n        "alterType": "",\n        "fetrList": [\n          {\n            "rsvStr6": "C2",\n            "rsvStr4": "2",\n            "rsvStr5": "配偶及子女情况",\n            "instCnName": "系统编号",\n            "instEnName": "SYS_CODE",\n            "rsvStr2": "否",\n            "rsvStr1": "varchar(50)"\n          }\n        ]\n      },\n      {\n        "instId": "11f9cec7cd06e168b811ba605b6acb8a",\n        "instCode": "SYS_NAME",\n        "instCnName": "系统名称",\n        "instEnName": "SYS_NAME",\n        "classId": "SubjectDataItem",\n        "fromClassId": "DDColumn",\n        "parentId": "00186c9ae3329e2a43e95ba05acfdbb6",\n        "namespaceId": "/SubjectData/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/00186c9ae3329e2a43e95ba05acfdbb6/11f9cec7cd06e168b811ba605b6acb8a",\n        "namespaceCode": "/SubjectData/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/AT000005501/SYS_NAME",\n        "orgId": "",\n        "startTime": "2023-07-13T08:26:55.000+0000",\n        "creater": "system",\n        "mdHash": "5fd0ba46e4f2c02cfd0dbf9f1aa12351",\n        "sysCode": "DAP6",\n        "sysName": "",\n        "dbCode": "",\n        "dbName": "",\n        "schCode": "",\n        "tabCode": "",\n        "tabName": "",\n        "corpId": "",\n        "rsvStr1": "varchar(255)",\n        "rsvStr2": "N",\n        "rsvStr3": "",\n        "rsvStr4": "2",\n        "rsvStr5": "14",\n        "rsvStr6": "3",\n        "rsvStr7": "",\n        "rsvStr8": "",\n        "rsvStr9": "",\n        "rsvStr10": "",\n        "rsvStr11": "",\n        "rsvStr12": "",\n        "rsvStr13": "",\n        "rsvStr14": "",\n        "rsvStr15": "",\n        "rsvStr16": "",\n        "rsvStr17": "",\n        "rsvStr18": "",\n        "rsvStr19": "",\n        "rsvStr20": "",\n        "rsvStr21": "",\n        "rsvStr22": "",\n        "rsvStr23": "",\n        "rsvStr24": "",\n        "rsvStr25": "",\n        "rsvStr26": "",\n        "rsvStr27": "",\n        "rsvStr28": "",\n        "rsvStr29": "",\n        "rsvStr30": "",\n        "rsvStr31": "",\n        "rsvStr32": "",\n        "rsvStr33": "",\n        "rsvStr34": "",\n        "rsvStr35": "",\n        "rsvStr36": "",\n        "rsvStr37": "",\n        "rsvStr38": "",\n        "rsvStr39": "",\n        "rsvStr40": "",\n        "pageSize": "",\n        "pageNum": "",\n        "apprStatus": "",\n        "alterType": "",\n        "fetrList": [\n          {\n            "rsvStr6": "C3",\n            "rsvStr4": "2",\n            "rsvStr5": "企业（个人）信用等级",\n            "instCnName": "系统名称",\n            "instEnName": "SYS_NAME",\n            "rsvStr2": "否",\n            "rsvStr1": "varchar(255)"\n          }\n        ]\n      },\n      {\n        "instId": "191115812190db6112c231c31aa356a2",\n        "instCode": "VER_NO",\n        "instCnName": "版本号",\n        "instEnName": "VER_NO",\n        "classId": "SubjectDataItem",\n        "fromClassId": "DDColumn",\n        "parentId": "00186c9ae3329e2a43e95ba05acfdbb6",\n        "namespaceId": "/SubjectData/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/00186c9ae3329e2a43e95ba05acfdbb6/191115812190db6112c231c31aa356a2",\n        "namespaceCode": "/SubjectData/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/AT000005501/VER_NO",\n        "orgId": "",\n        "startTime": "2023-07-13T08:26:55.000+0000",\n        "creater": "system",\n        "mdHash": "143aa441acc79edd8060c92df05b9182",\n        "sysCode": "DAP6",\n        "sysName": "",\n        "dbCode": "",\n        "dbName": "",\n        "schCode": "",\n        "tabCode": "",\n        "tabName": "",\n        "corpId": "",\n        "rsvStr1": "varchar(50)",\n        "rsvStr2": "N",\n        "rsvStr3": "",\n        "rsvStr4": "3",\n        "rsvStr5": "",\n        "rsvStr6": "3",\n        "rsvStr7": "",\n        "rsvStr8": "",\n        "rsvStr9": "",\n        "rsvStr10": "",\n        "rsvStr11": "",\n        "rsvStr12": "",\n        "rsvStr13": "",\n        "rsvStr14": "",\n        "rsvStr15": "",\n        "rsvStr16": "",\n        "rsvStr17": "",\n        "rsvStr18": "",\n        "rsvStr19": "",\n        "rsvStr20": "",\n        "rsvStr21": "",\n        "rsvStr22": "",\n        "rsvStr23": "",\n        "rsvStr24": "",\n        "rsvStr25": "",\n        "rsvStr26": "",\n        "rsvStr27": "",\n        "rsvStr28": "",\n        "rsvStr29": "",\n        "rsvStr30": "",\n        "rsvStr31": "",\n        "rsvStr32": "",\n        "rsvStr33": "",\n        "rsvStr34": "",\n        "rsvStr35": "",\n        "rsvStr36": "",\n        "rsvStr37": "",\n        "rsvStr38": "",\n        "rsvStr39": "",\n        "rsvStr40": "",\n        "pageSize": "",\n        "pageNum": "",\n        "apprStatus": "",\n        "alterType": "",\n        "fetrList": [\n          {\n            "rsvStr6": "C3",\n            "rsvStr4": "3",\n            "instCnName": "版本号",\n            "instEnName": "VER_NO",\n            "rsvStr2": "否",\n            "rsvStr1": "varchar(50)"\n          }\n        ]\n      },\n      {\n        "instId": "4303589b5131d6450b44024891639d3b",\n        "instCode": "CHECK_ID",\n        "instCnName": "登记编号",\n        "instEnName": "CHECK_ID",\n        "classId": "SubjectDataItem",\n        "fromClassId": "DDColumn",\n        "parentId": "00186c9ae3329e2a43e95ba05acfdbb6",\n        "namespaceId": "/SubjectData/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/00186c9ae3329e2a43e95ba05acfdbb6/4303589b5131d6450b44024891639d3b",\n        "namespaceCode": "/SubjectData/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/AT000005501/CHECK_ID",\n        "orgId": "",\n        "startTime": "2023-07-13T08:26:55.000+0000",\n        "creater": "system",\n        "mdHash": "9c43195ed115dfda9cd464d43c5d256a",\n        "sysCode": "DAP6",\n        "sysName": "",\n        "dbCode": "",\n        "dbName": "",\n        "schCode": "",\n        "tabCode": "",\n        "tabName": "",\n        "corpId": "",\n        "rsvStr1": "varchar(50)",\n        "rsvStr2": "Y",\n        "rsvStr3": "",\n        "rsvStr4": "3",\n        "rsvStr5": "",\n        "rsvStr6": "3",\n        "rsvStr7": "",\n        "rsvStr8": "",\n        "rsvStr9": "",\n        "rsvStr10": "",\n        "rsvStr11": "",\n        "rsvStr12": "",\n        "rsvStr13": "",\n        "rsvStr14": "",\n        "rsvStr15": "",\n        "rsvStr16": "",\n        "rsvStr17": "",\n        "rsvStr18": "",\n        "rsvStr19": "",\n        "rsvStr20": "",\n        "rsvStr21": "",\n        "rsvStr22": "",\n        "rsvStr23": "",\n        "rsvStr24": "",\n        "rsvStr25": "",\n        "rsvStr26": "",\n        "rsvStr27": "",\n        "rsvStr28": "",\n        "rsvStr29": "",\n        "rsvStr30": "",\n        "rsvStr31": "",\n        "rsvStr32": "",\n        "rsvStr33": "",\n        "rsvStr34": "",\n        "rsvStr35": "",\n        "rsvStr36": "",\n        "rsvStr37": "",\n        "rsvStr38": "",\n        "rsvStr39": "",\n        "rsvStr40": "",\n        "pageSize": "",\n        "pageNum": "",\n        "apprStatus": "",\n        "alterType": "",\n        "fetrList": [\n          {\n            "rsvStr6": "C3",\n            "rsvStr4": "3",\n            "instCnName": "登记编号",\n            "instEnName": "CHECK_ID",\n            "rsvStr2": "是",\n            "rsvStr1": "varchar(50)"\n          }\n        ]\n      },\n      {\n        "instId": "51bd518bc8686605daa461ca2016b2c0",\n        "instCode": "REG_USER",\n        "instCnName": "变更人",\n        "instEnName": "REG_USER",\n        "classId": "SubjectDataItem",\n        "fromClassId": "DDColumn",\n        "parentId": "00186c9ae3329e2a43e95ba05acfdbb6",\n        "namespaceId": "/SubjectData/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/00186c9ae3329e2a43e95ba05acfdbb6/51bd518bc8686605daa461ca2016b2c0",\n        "namespaceCode": "/SubjectData/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/AT000005501/REG_USER",\n        "orgId": "",\n        "startTime": "2023-07-13T08:26:55.000+0000",\n        "creater": "system",\n        "mdHash": "26a4c88cb4c9fd7bb57852218f39ce4f",\n        "sysCode": "DAP6",\n        "sysName": "",\n        "dbCode": "",\n        "dbName": "",\n        "schCode": "",\n        "tabCode": "",\n        "tabName": "",\n        "corpId": "",\n        "rsvStr1": "varchar(50)",\n        "rsvStr2": "N",\n        "rsvStr3": "",\n        "rsvStr4": "3",\n        "rsvStr5": "",\n        "rsvStr6": "3",\n        "rsvStr7": "",\n        "rsvStr8": "",\n        "rsvStr9": "",\n        "rsvStr10": "",\n        "rsvStr11": "",\n        "rsvStr12": "",\n        "rsvStr13": "",\n        "rsvStr14": "",\n        "rsvStr15": "",\n        "rsvStr16": "",\n        "rsvStr17": "",\n        "rsvStr18": "",\n        "rsvStr19": "",\n        "rsvStr20": "",\n        "rsvStr21": "",\n        "rsvStr22": "",\n        "rsvStr23": "",\n        "rsvStr24": "",\n        "rsvStr25": "",\n        "rsvStr26": "",\n        "rsvStr27": "",\n        "rsvStr28": "",\n        "rsvStr29": "",\n        "rsvStr30": "",\n        "rsvStr31": "",\n        "rsvStr32": "",\n        "rsvStr33": "",\n        "rsvStr34": "",\n        "rsvStr35": "",\n        "rsvStr36": "",\n        "rsvStr37": "",\n        "rsvStr38": "",\n        "rsvStr39": "",\n        "rsvStr40": "",\n        "pageSize": "",\n        "pageNum": "",\n        "apprStatus": "",\n        "alterType": "",\n        "fetrList": [\n          {\n            "rsvStr6": "C3",\n            "rsvStr4": "3",\n            "instCnName": "变更人",\n            "instEnName": "REG_USER",\n            "rsvStr2": "否",\n            "rsvStr1": "varchar(50)"\n          }\n        ]\n      },\n      {\n        "instId": "7b19ddcb782d0638145fadea79b562f2",\n        "instCode": "DES_EMAIL",\n        "instCnName": "邮件通知已卸数表 0:未发送 1:已发送成功过  发送失败原因",\n        "instEnName": "DES_EMAIL",\n        "classId": "SubjectDataItem",\n        "fromClassId": "DDColumn",\n        "parentId": "00186c9ae3329e2a43e95ba05acfdbb6",\n        "namespaceId": "/SubjectData/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/00186c9ae3329e2a43e95ba05acfdbb6/7b19ddcb782d0638145fadea79b562f2",\n        "namespaceCode": "/SubjectData/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/AT000005501/DES_EMAIL",\n        "orgId": "",\n        "startTime": "2023-07-13T08:26:55.000+0000",\n        "creater": "system",\n        "mdHash": "2c770ac1adb3a6c1def49583e6d5fcfd",\n        "sysCode": "DAP6",\n        "sysName": "",\n        "dbCode": "",\n        "dbName": "",\n        "schCode": "",\n        "tabCode": "",\n        "tabName": "",\n        "corpId": "",\n        "rsvStr1": "varchar(255)",\n        "rsvStr2": "N",\n        "rsvStr3": "",\n        "rsvStr4": "2",\n        "rsvStr5": "11",\n        "rsvStr6": "3",\n        "rsvStr7": "",\n        "rsvStr8": "",\n        "rsvStr9": "",\n        "rsvStr10": "",\n        "rsvStr11": "",\n        "rsvStr12": "",\n        "rsvStr13": "",\n        "rsvStr14": "",\n        "rsvStr15": "",\n        "rsvStr16": "",\n        "rsvStr17": "",\n        "rsvStr18": "",\n        "rsvStr19": "",\n        "rsvStr20": "",\n        "rsvStr21": "",\n        "rsvStr22": "",\n        "rsvStr23": "",\n        "rsvStr24": "",\n        "rsvStr25": "",\n        "rsvStr26": "",\n        "rsvStr27": "",\n        "rsvStr28": "",\n        "rsvStr29": "",\n        "rsvStr30": "",\n        "rsvStr31": "",\n        "rsvStr32": "",\n        "rsvStr33": "",\n        "rsvStr34": "",\n        "rsvStr35": "",\n        "rsvStr36": "",\n        "rsvStr37": "",\n        "rsvStr38": "",\n        "rsvStr39": "",\n        "rsvStr40": "",\n        "pageSize": "",\n        "pageNum": "",\n        "apprStatus": "",\n        "alterType": "",\n        "fetrList": [\n          {\n            "rsvStr6": "C3",\n            "rsvStr4": "2",\n            "rsvStr5": "系统密钥",\n            "instCnName": "邮件通知已卸数表 0:未发送 1:已发送成功过  发送失败原因",\n            "instEnName": "DES_EMAIL",\n            "rsvStr2": "否",\n            "rsvStr1": "varchar(255)"\n          }\n        ]\n      },\n      {\n        "instId": "9182ba444eaa052a68289f3d534a4a1e",\n        "instCode": "REG_DATE",\n        "instCnName": "变更时间",\n        "instEnName": "REG_DATE",\n        "classId": "SubjectDataItem",\n        "fromClassId": "DDColumn",\n        "parentId": "00186c9ae3329e2a43e95ba05acfdbb6",\n        "namespaceId": "/SubjectData/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/00186c9ae3329e2a43e95ba05acfdbb6/9182ba444eaa052a68289f3d534a4a1e",\n        "namespaceCode": "/SubjectData/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/AT000005501/REG_DATE",\n        "orgId": "",\n        "startTime": "2023-07-13T08:26:55.000+0000",\n        "creater": "system",\n        "mdHash": "b9924e95fde0397138391a8282bd3e8c",\n        "sysCode": "DAP6",\n        "sysName": "",\n        "dbCode": "",\n        "dbName": "",\n        "schCode": "",\n        "tabCode": "",\n        "tabName": "",\n        "corpId": "",\n        "rsvStr1": "varchar(50)",\n        "rsvStr2": "N",\n        "rsvStr3": "",\n        "rsvStr4": "3",\n        "rsvStr5": "",\n        "rsvStr6": "3",\n        "rsvStr7": "",\n        "rsvStr8": "",\n        "rsvStr9": "",\n        "rsvStr10": "",\n        "rsvStr11": "",\n        "rsvStr12": "",\n        "rsvStr13": "",\n        "rsvStr14": "",\n        "rsvStr15": "",\n        "rsvStr16": "",\n        "rsvStr17": "",\n        "rsvStr18": "",\n        "rsvStr19": "",\n        "rsvStr20": "",\n        "rsvStr21": "",\n        "rsvStr22": "",\n        "rsvStr23": "",\n        "rsvStr24": "",\n        "rsvStr25": "",\n        "rsvStr26": "",\n        "rsvStr27": "",\n        "rsvStr28": "",\n        "rsvStr29": "",\n        "rsvStr30": "",\n        "rsvStr31": "",\n        "rsvStr32": "",\n        "rsvStr33": "",\n        "rsvStr34": "",\n        "rsvStr35": "",\n        "rsvStr36": "",\n        "rsvStr37": "",\n        "rsvStr38": "",\n        "rsvStr39": "",\n        "rsvStr40": "",\n        "pageSize": "",\n        "pageNum": "",\n        "apprStatus": "",\n        "alterType": "",\n        "fetrList": [\n          {\n            "rsvStr6": "C3",\n            "rsvStr4": "3",\n            "instCnName": "变更时间",\n            "instEnName": "REG_DATE",\n            "rsvStr2": "否",\n            "rsvStr1": "varchar(50)"\n          }\n        ]\n      },\n      {\n        "instId": "92c124123b7f9cc3f31b36271f6e0455",\n        "instCode": "STATUS",\n        "instCnName": "状态",\n        "instEnName": "STATUS",\n        "classId": "SubjectDataItem",\n        "fromClassId": "DDColumn",\n        "parentId": "00186c9ae3329e2a43e95ba05acfdbb6",\n        "namespaceId": "/SubjectData/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/00186c9ae3329e2a43e95ba05acfdbb6/92c124123b7f9cc3f31b36271f6e0455",\n        "namespaceCode": "/SubjectData/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/AT000005501/STATUS",\n        "orgId": "",\n        "startTime": "2023-07-13T08:26:55.000+0000",\n        "creater": "system",\n        "mdHash": "b1e7adfbbedc301c7b3dd58e9cbbba8c",\n        "sysCode": "DAP6",\n        "sysName": "",\n        "dbCode": "",\n        "dbName": "",\n        "schCode": "",\n        "tabCode": "",\n        "tabName": "",\n        "corpId": "",\n        "rsvStr1": "varchar(32)",\n        "rsvStr2": "N",\n        "rsvStr3": "",\n        "rsvStr4": "2",\n        "rsvStr5": "",\n        "rsvStr6": "1",\n        "rsvStr7": "",\n        "rsvStr8": "",\n        "rsvStr9": "",\n        "rsvStr10": "",\n        "rsvStr11": "",\n        "rsvStr12": "",\n        "rsvStr13": "",\n        "rsvStr14": "",\n        "rsvStr15": "",\n        "rsvStr16": "",\n        "rsvStr17": "",\n        "rsvStr18": "",\n        "rsvStr19": "",\n        "rsvStr20": "",\n        "rsvStr21": "",\n        "rsvStr22": "",\n        "rsvStr23": "",\n        "rsvStr24": "",\n        "rsvStr25": "",\n        "rsvStr26": "",\n        "rsvStr27": "",\n        "rsvStr28": "",\n        "rsvStr29": "",\n        "rsvStr30": "",\n        "rsvStr31": "",\n        "rsvStr32": "",\n        "rsvStr33": "",\n        "rsvStr34": "",\n        "rsvStr35": "",\n        "rsvStr36": "",\n        "rsvStr37": "",\n        "rsvStr38": "",\n        "rsvStr39": "",\n        "rsvStr40": "",\n        "pageSize": "",\n        "pageNum": "",\n        "apprStatus": "",\n        "alterType": "",\n        "fetrList": [\n          {\n            "rsvStr6": "C1",\n            "rsvStr4": "2",\n            "instCnName": "状态",\n            "instEnName": "STATUS",\n            "rsvStr2": "否",\n            "rsvStr1": "varchar(32)"\n          }\n        ]\n      },\n      {\n        "instId": "a221079cfc18d09fba02e3c0d207107b",\n        "instCode": "REG_INFO",\n        "instCnName": "变更内容",\n        "instEnName": "REG_INFO",\n        "classId": "SubjectDataItem",\n        "fromClassId": "DDColumn",\n        "parentId": "00186c9ae3329e2a43e95ba05acfdbb6",\n        "namespaceId": "/SubjectData/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/00186c9ae3329e2a43e95ba05acfdbb6/a221079cfc18d09fba02e3c0d207107b",\n        "namespaceCode": "/SubjectData/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/AT000005501/REG_INFO",\n        "orgId": "",\n        "startTime": "2023-07-13T08:26:55.000+0000",\n        "creater": "system",\n        "mdHash": "793418f290dda0d2fad48df1bdd9465e",\n        "sysCode": "DAP6",\n        "sysName": "",\n        "dbCode": "",\n        "dbName": "",\n        "schCode": "",\n        "tabCode": "",\n        "tabName": "",\n        "corpId": "",\n        "rsvStr1": "varchar(500)",\n        "rsvStr2": "N",\n        "rsvStr3": "",\n        "rsvStr4": "2",\n        "rsvStr5": "",\n        "rsvStr6": "1",\n        "rsvStr7": "",\n        "rsvStr8": "",\n        "rsvStr9": "",\n        "rsvStr10": "",\n        "rsvStr11": "",\n        "rsvStr12": "",\n        "rsvStr13": "",\n        "rsvStr14": "",\n        "rsvStr15": "",\n        "rsvStr16": "",\n        "rsvStr17": "",\n        "rsvStr18": "",\n        "rsvStr19": "",\n        "rsvStr20": "",\n        "rsvStr21": "",\n        "rsvStr22": "",\n        "rsvStr23": "",\n        "rsvStr24": "",\n        "rsvStr25": "",\n        "rsvStr26": "",\n        "rsvStr27": "",\n        "rsvStr28": "",\n        "rsvStr29": "",\n        "rsvStr30": "",\n        "rsvStr31": "",\n        "rsvStr32": "",\n        "rsvStr33": "",\n        "rsvStr34": "",\n        "rsvStr35": "",\n        "rsvStr36": "",\n        "rsvStr37": "",\n        "rsvStr38": "",\n        "rsvStr39": "",\n        "rsvStr40": "",\n        "pageSize": "",\n        "pageNum": "",\n        "apprStatus": "",\n        "alterType": "",\n        "fetrList": [\n          {\n            "rsvStr6": "C1",\n            "rsvStr4": "2",\n            "instCnName": "变更内容",\n            "instEnName": "REG_INFO",\n            "rsvStr2": "否",\n            "rsvStr1": "varchar(500)"\n          }\n        ]\n      },\n      {\n        "instId": "b0aba53993d4b6aad99e4e3fcb4778ed",\n        "instCode": "COMPARE_STATUS",\n        "instCnName": "对比结果  0：未对比  1：已对比无差异  2：对比有差异，3对比失败",\n        "instEnName": "COMPARE_STATUS",\n        "classId": "SubjectDataItem",\n        "fromClassId": "DDColumn",\n        "parentId": "00186c9ae3329e2a43e95ba05acfdbb6",\n        "namespaceId": "/SubjectData/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/00186c9ae3329e2a43e95ba05acfdbb6/b0aba53993d4b6aad99e4e3fcb4778ed",\n        "namespaceCode": "/SubjectData/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/AT000005501/COMPARE_STATUS",\n        "orgId": "",\n        "startTime": "2023-07-13T08:26:55.000+0000",\n        "creater": "system",\n        "mdHash": "9d3c6e98f66a5b11ecba564b5e85b06e",\n        "sysCode": "DAP6",\n        "sysName": "",\n        "dbCode": "",\n        "dbName": "",\n        "schCode": "",\n        "tabCode": "",\n        "tabName": "",\n        "corpId": "",\n        "rsvStr1": "varchar(255)",\n        "rsvStr2": "N",\n        "rsvStr3": "",\n        "rsvStr4": "3",\n        "rsvStr5": "",\n        "rsvStr6": "3",\n        "rsvStr7": "",\n        "rsvStr8": "",\n        "rsvStr9": "",\n        "rsvStr10": "",\n        "rsvStr11": "",\n        "rsvStr12": "",\n        "rsvStr13": "",\n        "rsvStr14": "",\n        "rsvStr15": "",\n        "rsvStr16": "",\n        "rsvStr17": "",\n        "rsvStr18": "",\n        "rsvStr19": "",\n        "rsvStr20": "",\n        "rsvStr21": "",\n        "rsvStr22": "",\n        "rsvStr23": "",\n        "rsvStr24": "",\n        "rsvStr25": "",\n        "rsvStr26": "",\n        "rsvStr27": "",\n        "rsvStr28": "",\n        "rsvStr29": "",\n        "rsvStr30": "",\n        "rsvStr31": "",\n        "rsvStr32": "",\n        "rsvStr33": "",\n        "rsvStr34": "",\n        "rsvStr35": "",\n        "rsvStr36": "",\n        "rsvStr37": "",\n        "rsvStr38": "",\n        "rsvStr39": "",\n        "rsvStr40": "",\n        "pageSize": "",\n        "pageNum": "",\n        "apprStatus": "",\n        "alterType": "",\n        "fetrList": [\n          {\n            "rsvStr6": "C3",\n            "rsvStr4": "3",\n            "instCnName": "对比结果  0：未对比  1：已对比无差异  2：对比有差异，3对比失败",\n            "instEnName": "COMPARE_STATUS",\n            "rsvStr2": "否",\n            "rsvStr1": "varchar(255)"\n          }\n        ]\n      },\n      {\n        "instId": "c18017de0ad6d9a707a6c80cc77080c5",\n        "instCode": "SYN_STATUS",\n        "instCnName": "同步结果  0：未同步  1、同步成功 同步失败原因",\n        "instEnName": "SYN_STATUS",\n        "classId": "SubjectDataItem",\n        "fromClassId": "DDColumn",\n        "parentId": "00186c9ae3329e2a43e95ba05acfdbb6",\n        "namespaceId": "/SubjectData/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/00186c9ae3329e2a43e95ba05acfdbb6/c18017de0ad6d9a707a6c80cc77080c5",\n        "namespaceCode": "/SubjectData/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/AT000005501/SYN_STATUS",\n        "orgId": "",\n        "startTime": "2023-07-13T08:26:55.000+0000",\n        "creater": "system",\n        "mdHash": "13d886db37a34402e350351f40d84c15",\n        "sysCode": "DAP6",\n        "sysName": "",\n        "dbCode": "",\n        "dbName": "",\n        "schCode": "",\n        "tabCode": "",\n        "tabName": "",\n        "corpId": "",\n        "rsvStr1": "varchar(255)",\n        "rsvStr2": "N",\n        "rsvStr3": "",\n        "rsvStr4": "3",\n        "rsvStr5": "",\n        "rsvStr6": "3",\n        "rsvStr7": "",\n        "rsvStr8": "",\n        "rsvStr9": "",\n        "rsvStr10": "",\n        "rsvStr11": "",\n        "rsvStr12": "",\n        "rsvStr13": "",\n        "rsvStr14": "",\n        "rsvStr15": "",\n        "rsvStr16": "",\n        "rsvStr17": "",\n        "rsvStr18": "",\n        "rsvStr19": "",\n        "rsvStr20": "",\n        "rsvStr21": "",\n        "rsvStr22": "",\n        "rsvStr23": "",\n        "rsvStr24": "",\n        "rsvStr25": "",\n        "rsvStr26": "",\n        "rsvStr27": "",\n        "rsvStr28": "",\n        "rsvStr29": "",\n        "rsvStr30": "",\n        "rsvStr31": "",\n        "rsvStr32": "",\n        "rsvStr33": "",\n        "rsvStr34": "",\n        "rsvStr35": "",\n        "rsvStr36": "",\n        "rsvStr37": "",\n        "rsvStr38": "",\n        "rsvStr39": "",\n        "rsvStr40": "",\n        "pageSize": "",\n        "pageNum": "",\n        "apprStatus": "",\n        "alterType": "",\n        "fetrList": [\n          {\n            "rsvStr6": "C3",\n            "rsvStr4": "3",\n            "instCnName": "同步结果  0：未同步  1、同步成功 同步失败原因",\n            "instEnName": "SYN_STATUS",\n            "rsvStr2": "否",\n            "rsvStr1": "varchar(255)"\n          }\n        ]\n      },\n      {\n        "instId": "c89685e9ff561879bcdf489a06959c29",\n        "instCode": "TC_DATE",\n        "instCnName": "投产日期",\n        "instEnName": "TC_DATE",\n        "classId": "SubjectDataItem",\n        "fromClassId": "DDColumn",\n        "parentId": "00186c9ae3329e2a43e95ba05acfdbb6",\n        "namespaceId": "/SubjectData/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/00186c9ae3329e2a43e95ba05acfdbb6/c89685e9ff561879bcdf489a06959c29",\n        "namespaceCode": "/SubjectData/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/AT000005501/TC_DATE",\n        "orgId": "",\n        "startTime": "2023-07-13T08:26:55.000+0000",\n        "creater": "system",\n        "mdHash": "e57e7a296a166136dc117528bdae2e6a",\n        "sysCode": "DAP6",\n        "sysName": "",\n        "dbCode": "",\n        "dbName": "",\n        "schCode": "",\n        "tabCode": "",\n        "tabName": "",\n        "corpId": "",\n        "rsvStr1": "varchar(32)",\n        "rsvStr2": "N",\n        "rsvStr3": "",\n        "rsvStr4": "2",\n        "rsvStr5": "",\n        "rsvStr6": "1",\n        "rsvStr7": "",\n        "rsvStr8": "",\n        "rsvStr9": "",\n        "rsvStr10": "",\n        "rsvStr11": "",\n        "rsvStr12": "",\n        "rsvStr13": "",\n        "rsvStr14": "",\n        "rsvStr15": "",\n        "rsvStr16": "",\n        "rsvStr17": "",\n        "rsvStr18": "",\n        "rsvStr19": "",\n        "rsvStr20": "",\n        "rsvStr21": "",\n        "rsvStr22": "",\n        "rsvStr23": "",\n        "rsvStr24": "",\n        "rsvStr25": "",\n        "rsvStr26": "",\n        "rsvStr27": "",\n        "rsvStr28": "",\n        "rsvStr29": "",\n        "rsvStr30": "",\n        "rsvStr31": "",\n        "rsvStr32": "",\n        "rsvStr33": "",\n        "rsvStr34": "",\n        "rsvStr35": "",\n        "rsvStr36": "",\n        "rsvStr37": "",\n        "rsvStr38": "",\n        "rsvStr39": "",\n        "rsvStr40": "",\n        "pageSize": "",\n        "pageNum": "",\n        "apprStatus": "",\n        "alterType": "",\n        "fetrList": [\n          {\n            "rsvStr6": "C1",\n            "rsvStr4": "2",\n            "instCnName": "投产日期",\n            "instEnName": "TC_DATE",\n            "rsvStr2": "否",\n            "rsvStr1": "varchar(32)"\n          }\n        ]\n      },\n      {\n        "instId": "d0e06a6d72929d0a46432e3fb298b5d2",\n        "instCode": "FORM_ID",\n        "instCnName": "流程编号",\n        "instEnName": "FORM_ID",\n        "classId": "SubjectDataItem",\n        "fromClassId": "DDColumn",\n        "parentId": "00186c9ae3329e2a43e95ba05acfdbb6",\n        "namespaceId": "/SubjectData/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/00186c9ae3329e2a43e95ba05acfdbb6/d0e06a6d72929d0a46432e3fb298b5d2",\n        "namespaceCode": "/SubjectData/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/AT000005501/FORM_ID",\n        "orgId": "",\n        "startTime": "2023-07-13T08:26:55.000+0000",\n        "creater": "system",\n        "mdHash": "6d6cad8476be2f1e47a3a5fc00471c86",\n        "sysCode": "DAP6",\n        "sysName": "",\n        "dbCode": "",\n        "dbName": "",\n        "schCode": "",\n        "tabCode": "",\n        "tabName": "",\n        "corpId": "",\n        "rsvStr1": "varchar(50)",\n        "rsvStr2": "N",\n        "rsvStr3": "",\n        "rsvStr4": "3",\n        "rsvStr5": "",\n        "rsvStr6": "3",\n        "rsvStr7": "",\n        "rsvStr8": "",\n        "rsvStr9": "",\n        "rsvStr10": "",\n        "rsvStr11": "",\n        "rsvStr12": "",\n        "rsvStr13": "",\n        "rsvStr14": "",\n        "rsvStr15": "",\n        "rsvStr16": "",\n        "rsvStr17": "",\n        "rsvStr18": "",\n        "rsvStr19": "",\n        "rsvStr20": "",\n        "rsvStr21": "",\n        "rsvStr22": "",\n        "rsvStr23": "",\n        "rsvStr24": "",\n        "rsvStr25": "",\n        "rsvStr26": "",\n        "rsvStr27": "",\n        "rsvStr28": "",\n        "rsvStr29": "",\n        "rsvStr30": "",\n        "rsvStr31": "",\n        "rsvStr32": "",\n        "rsvStr33": "",\n        "rsvStr34": "",\n        "rsvStr35": "",\n        "rsvStr36": "",\n        "rsvStr37": "",\n        "rsvStr38": "",\n        "rsvStr39": "",\n        "rsvStr40": "",\n        "pageSize": "",\n        "pageNum": "",\n        "apprStatus": "",\n        "alterType": "",\n        "fetrList": [\n          {\n            "rsvStr6": "C3",\n            "rsvStr4": "3",\n            "instCnName": "流程编号",\n            "instEnName": "FORM_ID",\n            "rsvStr2": "否",\n            "rsvStr1": "varchar(50)"\n          }\n        ]\n      },\n      {\n        "instId": "dd1c584f6743d3f4c8a36a837db59a8e",\n        "instCode": "REMIND_EMAIL",\n        "instCnName": "投产当天通知 0：未发送 1:已发送成功 发送失败原因",\n        "instEnName": "REMIND_EMAIL",\n        "classId": "SubjectDataItem",\n        "fromClassId": "DDColumn",\n        "parentId": "00186c9ae3329e2a43e95ba05acfdbb6",\n        "namespaceId": "/SubjectData/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/00186c9ae3329e2a43e95ba05acfdbb6/dd1c584f6743d3f4c8a36a837db59a8e",\n        "namespaceCode": "/SubjectData/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/AT000005501/REMIND_EMAIL",\n        "orgId": "",\n        "startTime": "2023-07-13T08:26:55.000+0000",\n        "creater": "system",\n        "mdHash": "babab10a89cfc60afed0c82d6213c9b9",\n        "sysCode": "DAP6",\n        "sysName": "",\n        "dbCode": "",\n        "dbName": "",\n        "schCode": "",\n        "tabCode": "",\n        "tabName": "",\n        "corpId": "",\n        "rsvStr1": "varchar(255)",\n        "rsvStr2": "N",\n        "rsvStr3": "",\n        "rsvStr4": "3",\n        "rsvStr5": "",\n        "rsvStr6": "3",\n        "rsvStr7": "",\n        "rsvStr8": "",\n        "rsvStr9": "",\n        "rsvStr10": "",\n        "rsvStr11": "",\n        "rsvStr12": "",\n        "rsvStr13": "",\n        "rsvStr14": "",\n        "rsvStr15": "",\n        "rsvStr16": "",\n        "rsvStr17": "",\n        "rsvStr18": "",\n        "rsvStr19": "",\n        "rsvStr20": "",\n        "rsvStr21": "",\n        "rsvStr22": "",\n        "rsvStr23": "",\n        "rsvStr24": "",\n        "rsvStr25": "",\n        "rsvStr26": "",\n        "rsvStr27": "",\n        "rsvStr28": "",\n        "rsvStr29": "",\n        "rsvStr30": "",\n        "rsvStr31": "",\n        "rsvStr32": "",\n        "rsvStr33": "",\n        "rsvStr34": "",\n        "rsvStr35": "",\n        "rsvStr36": "",\n        "rsvStr37": "",\n        "rsvStr38": "",\n        "rsvStr39": "",\n        "rsvStr40": "",\n        "pageSize": "",\n        "pageNum": "",\n        "apprStatus": "",\n        "alterType": "",\n        "fetrList": [\n          {\n            "rsvStr6": "C3",\n            "rsvStr4": "3",\n            "instCnName": "投产当天通知 0：未发送 1:已发送成功 发送失败原因",\n            "instEnName": "REMIND_EMAIL",\n            "rsvStr2": "否",\n            "rsvStr1": "varchar(255)"\n          }\n        ]\n      }\n    ],\n    "pageNum": 1,\n    "pageSize": 14,\n    "size": 14,\n    "startRow": 0,\n    "endRow": 13,\n    "pages": 1,\n    "prePage": 0,\n    "nextPage": 0,\n    "isFirstPage": true,\n    "isLastPage": true,\n    "hasPreviousPage": false,\n    "hasNextPage": false,\n    "navigatePages": 8,\n    "navigatepageNums": [\n      1\n    ],\n    "navigateFirstPage": 1,\n    "navigateLastPage": 1,\n    "firstPage": 1,\n    "lastPage": 1\n  }\n}\n\n\n\n# metaAnalysisService.getAnalyseToAsset获取的数据\n\n{\n  "code": 200,\n  "message": "操作成功",\n  "data": {\n    "blood": {\n      "blood": "",\n      "impact": "",\n      "sessionId": "6a12a8134dd54d2682f629556a8a188e",\n      "layer": "3",\n      "type": "02",\n      "originInstId": "4ae1ce8f388d5b4b02db92dba007ea36",\n      "instId": "4ae1ce8f388d5b4b02db92dba007ea36",\n      "classId": "DDTable",\n      "relations": {},\n      "nodes": [\n        {\n          "instId": "4ae1ce8f388d5b4b02db92dba007ea36",\n          "instCode": "T_DEV_MD_CHECK",\n          "instName": "元数据变更登记表",\n          "classId": "DDTable",\n          "parentId": "a684856d6e40965138cf24c59672e2d0",\n          "namespaceId": "/DataDict_PDE/PDE_dd7833fb44274e0c9f49d89c1aff151f/bcce37af9d2b493517594f972c536f02/a684856d6e40965138cf24c59672e2d0/4ae1ce8f388d5b4b02db92dba007ea36",\n          "namespaceCode": "/DataDict_PDE/DAP6/DAP6/DAP6/T_DEV_MD_CHECK",\n          "verId": "6632c106daab47b9a21e54e6b0ce392f",\n          "startTime": "2023-07-10 14:51:18",\n          "isroot": "",\n          "appType": "MD",\n          "status": "",\n          "pageView": 0,\n          "creater": "",\n          "corpId": "default",\n          "rsvStr1": "",\n          "rsvStr2": "",\n          "rsvStr3": "0",\n          "rsvStr4": "",\n          "rsvStr5": "",\n          "rsvStr6": "16384",\n          "rsvStr7": "2022-06-15 10:38:28",\n          "rsvStr8": "",\n          "rsvStr9": "T",\n          "rsvStr10": "",\n          "rsvStr11": "",\n          "rsvStr12": "",\n          "rsvStr13": "",\n          "rsvStr14": "",\n          "rsvStr15": "",\n          "rsvStr16": "",\n          "rsvStr17": "",\n          "rsvStr18": "",\n          "rsvStr19": "",\n          "rsvStr20": "",\n          "rsvStr21": "",\n          "rsvStr22": "",\n          "rsvStr23": "",\n          "rsvStr24": "",\n          "rsvStr25": "",\n          "rsvStr26": "",\n          "rsvStr27": "",\n          "rsvStr28": "",\n          "rsvStr29": "",\n          "rsvStr30": "",\n          "rsvStr31": "",\n          "rsvStr32": "",\n          "rsvStr33": "",\n          "rsvStr34": "",\n          "rsvStr35": "",\n          "rsvStr36": "",\n          "rsvStr37": "",\n          "rsvStr38": "",\n          "rsvStr39": "",\n          "rsvStr40": "",\n          "versionDate": "2023-07-10 14:51:18",\n          "lucnecFalgdate": "",\n          "mdHash": "",\n          "sysCode": "DAP6",\n          "sysName": "DAP6数据库",\n          "dbCode": "DAP6",\n          "dbName": "DAP6",\n          "schCode": "DAP6",\n          "schName": "DAP6",\n          "tabCode": "",\n          "tabName": "",\n          "sysInstId": "",\n          "sysInstName": "",\n          "sysClassId": "",\n          "sysParentId": "",\n          "dbInstId": "",\n          "dbInstName": "",\n          "dbClassId": "",\n          "dbParentId": "",\n          "theme": "",\n          "collflag": "",\n          "colluserid": "",\n          "parent": "",\n          "optionType": "",\n          "corpValue": ""\n        }\n      ]\n    },\n    "impact": {\n      "blood": "",\n      "impact": "",\n      "sessionId": "d3292d53d9c347e184917b7d7a21879c",\n      "layer": "3",\n      "type": "01",\n      "originInstId": "4ae1ce8f388d5b4b02db92dba007ea36",\n      "instId": "4ae1ce8f388d5b4b02db92dba007ea36",\n      "classId": "DDTable",\n      "relations": {},\n      "nodes": [\n        {\n          "instId": "4ae1ce8f388d5b4b02db92dba007ea36",\n          "instCode": "T_DEV_MD_CHECK",\n          "instName": "元数据变更登记表",\n          "classId": "DDTable",\n          "parentId": "a684856d6e40965138cf24c59672e2d0",\n          "namespaceId": "/DataDict_PDE/PDE_dd7833fb44274e0c9f49d89c1aff151f/bcce37af9d2b493517594f972c536f02/a684856d6e40965138cf24c59672e2d0/4ae1ce8f388d5b4b02db92dba007ea36",\n          "namespaceCode": "/DataDict_PDE/DAP6/DAP6/DAP6/T_DEV_MD_CHECK",\n          "verId": "6632c106daab47b9a21e54e6b0ce392f",\n          "startTime": "2023-07-10 14:51:18",\n          "isroot": "",\n          "appType": "MD",\n          "status": "",\n          "pageView": 0,\n          "creater": "",\n          "corpId": "default",\n          "rsvStr1": "",\n          "rsvStr2": "",\n          "rsvStr3": "0",\n          "rsvStr4": "",\n          "rsvStr5": "",\n          "rsvStr6": "16384",\n          "rsvStr7": "2022-06-15 10:38:28",\n          "rsvStr8": "",\n          "rsvStr9": "T",\n          "rsvStr10": "",\n          "rsvStr11": "",\n          "rsvStr12": "",\n          "rsvStr13": "",\n          "rsvStr14": "",\n          "rsvStr15": "",\n          "rsvStr16": "",\n          "rsvStr17": "",\n          "rsvStr18": "",\n          "rsvStr19": "",\n          "rsvStr20": "",\n          "rsvStr21": "",\n          "rsvStr22": "",\n          "rsvStr23": "",\n          "rsvStr24": "",\n          "rsvStr25": "",\n          "rsvStr26": "",\n          "rsvStr27": "",\n          "rsvStr28": "",\n          "rsvStr29": "",\n          "rsvStr30": "",\n          "rsvStr31": "",\n          "rsvStr32": "",\n          "rsvStr33": "",\n          "rsvStr34": "",\n          "rsvStr35": "",\n          "rsvStr36": "",\n          "rsvStr37": "",\n          "rsvStr38": "",\n          "rsvStr39": "",\n          "rsvStr40": "",\n          "versionDate": "2023-07-10 14:51:18",\n          "lucnecFalgdate": "",\n          "mdHash": "",\n          "sysCode": "DAP6",\n          "sysName": "DAP6数据库",\n          "dbCode": "DAP6",\n          "dbName": "DAP6",\n          "schCode": "DAP6",\n          "schName": "DAP6",\n          "tabCode": "",\n          "tabName": "",\n          "sysInstId": "",\n          "sysInstName": "",\n          "sysClassId": "",\n          "sysParentId": "",\n          "dbInstId": "",\n          "dbInstName": "",\n          "dbClassId": "",\n          "dbParentId": "",\n          "theme": "",\n          "collflag": "",\n          "colluserid": "",\n          "parent": "",\n          "optionType": "",\n          "corpValue": ""\n        }\n      ]\n    },\n    "sessionId": "",\n    "layer": "3",\n    "type": "",\n    "originInstId": "",\n    "instId": "",\n    "classId": "",\n    "relations": {},\n    "nodes": []\n  }\n}\n',normalizedContent:'# g6-项目的影响分析/血缘分析\n\n\n# metadmapnew.vue文件[主文件]\n\n<template>\n<div class="metadmap" ref="metadmap" style="background: white">\n  \x3c!-- 按钮组 --\x3e\n  <div class="flexbox line-form">\n    <div class="left" style="min-width:360px;align-items: flex-start;">\n      <el-button-group>\n        <el-button\n                   type="plain"\n                   :class="{ drawerbg: istable }"\n                   @click="changetype(\'table\')"\n                   >表级</el-button\n          >\n        <el-button\n                   type="plain"\n                   :class="{ drawerbg: !istable }"\n                   @click="changetype(\'column\')"\n                   >字段级</el-button\n          >\n  </el-button-group>\n      <el-select\n                 v-show="!istable"\n                 v-model="forminline.name"\n                 placeholder="请选择字段"\n                 size="mini"\n                 style="width: 30%; min-width: 150px;margin-left:15px"\n                 value-key="instid"\n                 @change="changecolumn"\n                 :popper-append-to-body="false"\n                 >\n        \x3c!-- fackclickoutside 定义fullscreen-select --\x3e\n        <el-option\n                   class="fullscreen-select"\n                   v-for="item in columnlist"\n                   :value="item"\n                   :key="item.instid"\n                   :label="item.instcode"\n                   ></el-option>\n  </el-select>\n  </div>\n    <div class="center">\n      <el-button-group style="min-width:240px">\n        <el-button\n                   type="plain"\n                   :class="{ drawerbg: isall }"\n                   @click="changegraph(\'03\')"\n                   >全链分析</el-button\n          >\n        <el-button\n                   type="plain"\n                   :class="{ drawerbg: isimpact && !isall }"\n                   @click="changegraph(\'01\')"\n                   >影响分析</el-button\n          >\n        <el-button\n                   type="plain"\n                   :class="{ drawerbg: !isimpact && !isall }"\n                   @click="changegraph(\'02\')"\n                   >血缘分析</el-button\n          >\n  </el-button-group>\n  </div>\n    <div class="right" style="justify-content: end;">\n      <el-select\n                 v-model="forminline.layer"\n                 placeholder="层级"\n                 size="mini"\n                 style="width: 10%; min-width: 100px;margin-right:20px"\n                 @change="relationsanalyse"\n                 :popper-append-to-body="false"\n                 >\n        <el-option\n                   class="fullscreen-select"\n                   label="1级"\n                   value="1"\n                   ></el-option>\n        <el-option\n                   class="fullscreen-select"\n                   label="2级"\n                   value="2"\n                   ></el-option>\n        <el-option\n                   class="fullscreen-select"\n                   label="3级"\n                   value="3"\n                   ></el-option>\n        <el-option\n                   class="fullscreen-select"\n                   label="4级"\n                   value="4"\n                   ></el-option>\n        <el-option\n                   class="fullscreen-select"\n                   label="5级"\n                   value="5"\n                   ></el-option>\n        <el-option\n                   class="fullscreen-select"\n                   label="全部"\n                   value="all"\n                   ></el-option>\n  </el-select>\n      <i\n         class="el-icon-zoom-in color-font"\n         @click="scalemax"\n         :title="$i18ns(\'enlarge\')"\n         ></i>\n      <i\n         class="color-font"\n         style="width:36px;text-align:center;font-size:14px"\n         >{{ parseint(zoomsize * 100 + 20) + "%" }}</i\n        >\n      <i\n         class="el-icon-zoom-out color-font"\n         @click="scalemin"\n         :title="$i18ns(\'narrow\')"\n         ></i>\n\n      <i\n         class="el-icon-download color-font"\n         @click="downloadanalysefile"\n         :title="$i18ns(\'export\')"\n         ></i>\n\n      <i\n         class="el-icon-picture-outline color-font"\n         @click="downimage"\n         :title="$i18ns(\'exportimages\')"\n         ></i>\n      <i\n         v-if="fullscreen"\n         class="el-icon-crop color-font"\n         @click="fullscreehandler"\n         :title="$i18ns(\'shrink\')"\n         ></i>\n      <i\n         v-else\n         class="el-icon-full-screen color-font"\n         @click="fullscreehandler"\n         :title="$i18ns(\'fullscreen\')"\n         ></i>\n  </div>\n  </div>\n  \x3c!-- g6图层 --\x3e\n  <div :id="svgid" v-if="showgraph"></div>\n  \x3c!-- 详情弹出框 --\x3e\n  <div class="detail">\n    <transition name="right-slide">\n      <div class="drawerbox" v-if="isshowdrawer">\n        <div class="clickicon" @click="isshowdrawer = false"></div>\n        <detaildrawer :drawerdata="alldetails" />\n  </div>\n  </transition>\n  </div>\n  </div>\n</template>\n\n<script>\n  import detaildrawer from "./component/detaildrawer";\n  import dashboardservice from "@/services/dashboardservice";\n  import workbenchservice from "@/services/workbenchservice";\n  import metaanalysisservice from "@/services/metaanalysis";\n  import dataassetregistrationservice from "@/services/dataassetregistrationservice";\n  import dataassetmanaservice from "@/services/dataassetmanaservice";\n\n  import g6 from "@antv/g6";\n  import { mds } from "@/services/constant";\n  import moment from "moment";\n  var tooltipel = null;\n  export default {\n    name: "g6demo",\n    props: {\n      tableformdata: {\n        type: object,\n        default: () => {\n          return {};\n        }\n      }\n    },\n    components: { detaildrawer },\n    data() {\n      return {\n        forminline: {\n          name: "",\n          layer: "3"\n        },\n        columnlist: [], //字段列表\n        istable: false, //是否为表\n        isimpact: false, //是否为影响分析\n        isall: false, //是否为全链路分析\n        isshowdrawer: false, //是否展示弹出框\n        showgraph: false,\n        graph: "",\n        maxwidth: 240, //最大宽度\n        zoomsize: 0.8, //缩放\n        svgid: "",\n        fullscreen: false,\n        timeoutid: null,\n        sessionid: "",\n        allclasslist: {\n          // 基础数据\n          basemetadata: {\n            clssid: "basemetadata",\n            classificationid: "",\n            categorytitle: "basicstandardclassification",\n            typetitle: this.$i18ns("business"), // 業務\n            nodetitle: this.$i18ns("dsmindex") // 基礎元數據\n          },\n          //指标数据\n          quotametadata: {\n            classificationid: "",\n            clssid: "quotametadata",\n            categorytitle: "indexstandardclassification",\n            typetitle: this.$i18ns("business"), // 業務\n            nodetitle: this.$i18ns("quotaindex") // 指標元數據\n          },\n          //外部元数据\n          externalmetadata: {\n            classificationid: "",\n            clssid: "externalmetadata",\n            typetitle: this.$i18ns("business"), // 業務\n            nodetitle: this.$i18ns("externalmetadata") // 外部元數據\n          },\n          assetinfoitem: {\n            classificationid: "daclassification",\n            clssid: "assetinfoitem",\n            categorytitle: "datacatalogclass",\n            typetitle: this.$i18ns("assets"), // 資產\n            nodetitle: this.$i18ns("dataassetclassification") // 數據資產分類\n          },\n          ddtable: {\n            clssid: "ddtable",\n            typetitle: this.$i18ns("technology"), // 技術\n            nodetitle: this.$i18ns("technicalmetadata") // 技術元數據\n          },\n          ddcolumn: {\n            clssid: "ddcolumn",\n            typetitle: this.$i18ns("technology"), // 技術\n            nodetitle: this.$i18ns("technicalmetadata") // 技術元數據\n          },\n          ddnoniffcolumn: {\n            clssid: "ddnoniffcolumn",\n            typetitle: this.$i18ns("technology"), // 技術\n            nodetitle: this.$i18ns("technicalmetadata") // 技術元數據\n          },\n          ddiffcolumn: {\n            clssid: "ddiffcolumn",\n            typetitle: this.$i18ns("technology"), // 技術\n            nodetitle: this.$i18ns("technicalmetadata") // 技術元數據\n          },\n          ddfilecolumn: {\n            clssid: "ddfilecolumn",\n            typetitle: this.$i18ns("technology"), // 技術\n            nodetitle: this.$i18ns("technicalmetadata") // 技術元數據\n          },\n          ddnoniff: {\n            clssid: "ddnoniff",\n            typetitle: this.$i18ns("technology"), // 技術\n            nodetitle: this.$i18ns("technicalmetadata") // 技術元數據\n          },\n          ddiff: {\n            clssid: "ddiff",\n            typetitle: this.$i18ns("technology"), // 技術\n            nodetitle: this.$i18ns("technicalmetadata") // 技術元數據\n          },\n          ddfile: {\n            clssid: "ddfile",\n            typetitle: this.$i18ns("technology"), // 技術\n            nodetitle: this.$i18ns("technicalmetadata") // 技術元數據\n          },\n          ddtable: {\n            clssid: "ddtable",\n            typetitle: this.$i18ns("technology"), // 技術\n            nodetitle: this.$i18ns("technicalmetadata") // 技術元數據\n          },\n          amcommoncode: {\n            clssid: "amcommoncode",\n            typetitle: this.$i18ns("publiccode"), // 公共代碼\n            nodetitle: this.$i18ns("publiccode") // 公共代碼\n          },\n          edmdataclassificationlevel1: {\n            clssid: "edmdataclassificationlevel1",\n            typetitle: this.$i18ns("edmdataclassification"), // 模型分類\n            nodetitle: this.$i18ns("edmdataclassification") // 模型分類\n          },\n          edmdataclassificationlevel2: {\n            clssid: "edmdataclassificationlevel2",\n            typetitle: this.$i18ns("edmdataclassification"), // 模型分類\n            nodetitle: this.$i18ns("edmdataclassification") // 模型分類\n          },\n          edmdataclassificationlevel3: {\n            clssid: "edmdataclassificationlevel3",\n            typetitle: this.$i18ns("edmdataclassification"), // 模型分類\n            nodetitle: this.$i18ns("edmdataclassification") // 模型分類\n          },\n          edmdataclassificationlevel4: {\n            clssid: "edmdataclassificationlevel4",\n            typetitle: this.$i18ns("edmdataclassification"), // 模型分類\n            nodetitle: this.$i18ns("edmdataclassification") // 模型分類\n          },\n          edmdataclassificationlevel5: {\n            clssid: "edmdataclassificationlevel5",\n            typetitle: this.$i18ns("edmdataclassification"), // 模型分類\n            nodetitle: this.$i18ns("edmdataclassification") // 模型分類\n          },\n          edmdataclassificationlevel6: {\n            clssid: "edmdataclassificationlevel6",\n            typetitle: this.$i18ns("edmdataclassification"), // 模型分類\n            nodetitle: this.$i18ns("edmdataclassification") // 模型分類\n          },\n          ddcommonrealcode: {\n            clssid: "ddcommonrealcode",\n            typetitle: this.$i18ns("ddcommonrealcode1"), // 系統落地代碼\n            nodetitle: this.$i18ns("ddcommonrealcode1") // 系統落地代碼\n          },\n          amstandardcode: {\n            clssid: "amstandardcode",\n            typetitle: this.$i18ns("standard"), // 標準\n            nodetitle: this.$i18ns("standardcodeset") // 标准代码集\n          },\n          sdinfoitem: {\n            clssid: "sdinfoitem",\n            typetitle: this.$i18ns("sdinfoitem"), // 標準\n            nodetitle: this.$i18ns("sdinfoitem") // 标准代码集\n          }\n        },\n        isasset: false, //是否资产类型\n        datatype: "",\n        alldetails: {}\n      };\n    },\n    watch: {\n      tableformdata: {\n        deep: true,\n        immediate: true,\n        handler(newval) {\n          this.alldetails = json.parse(json.stringify(newval));\n          console.log(newval, "watch--alldetails");\n          this.isasset = false;\n          if (\n            newval.classid !== "ddtable" &&\n            newval.classid !== "ddcolumn" &&\n            newval.fromclassid\n          ) {\n            this.alldetails.classid = newval.fromclassid;\n            this.alldetails.instcode = newval.instenname;\n            this.alldetails.instname = newval.instcnname;\n            this.isasset = true;\n          }\n          console.log(this.isasset, "watch");\n          this.svgid = this.generateuuid();\n          this.istable = false;\n          this.isimpact = false;\n          if (this.alldetails.classid == "ddcolumn") {\n            this.nodeparentid = newval.parentid;\n            this.listcolumnpage(true);\n          } else {\n            this.istable = true;\n          }\n          // type 1影响分析  2 血缘\n          if (this.alldetails.type == 1 || this.isasset) {\n            this.isimpact = true;\n            if (this.alldetails.classid == "ddcolumn") {\n              this.changegraph("01", true);\n            } else {\n              this.changegraph("01");\n            }\n          } else {\n            if (this.alldetails.classid == "ddcolumn") {\n              this.changegraph("02", true);\n            } else {\n              this.changegraph("02");\n            }\n          }\n        }\n      }\n    },\n    mounted() {\n      // this.inittree(treelist);\n      document.addeventlistener("fullscreenchange", v => {\n        // console.log(v, "fullscreenchange");\n        if (this.fullscreen == true) {\n          this.fullscreen = false;\n        } else {\n          this.fullscreen = true;\n        }\n        this.changesize();\n      });\n    },\n    methods: {\n      // 生成唯一id\n      generateuuid() {\n        // 当前时间转成 36 进制字符串\n        var time = date.now().tostring(36);\n        // 当前随机数转成 36 进制字符串\n        var random = math.random().tostring(36);\n        // 去除随机数的 0. 字符串\n        random = random.substring(2, random.length);\n        // 返回唯一id\n        return random + time;\n      },\n      // 中英切换\n      en2zh2en() {\n        dmap.en2zh2en("#" + this.svgid);\n      },\n      // 缩小\n      scalemin() {\n        let zoom = this.graph.getzoom();\n        this.zoomsize = zoom <= 0.3 ? 0.3 : (zoom - 0.1).tofixed(1);\n        this.graph.zoomto(this.zoomsize);\n      },\n      // 放大\n      scalemax() {\n        let zoom = this.graph.getzoom();\n        this.zoomsize = zoom >= 1.8 ? 1.8 : (zoom + 0.1).tofixed(1);\n        this.graph.zoomto(this.zoomsize);\n      },\n      // 下载图片\n      downimage() {\n        // 图片名称，图片类型，图片背景色\n        let name = "分析结果图片导出" + this.alldetails.instname;\n        this.graph.downloadfullimage(name, "", {\n          backgroundcolor: "#fff",\n          padding: [10, 10, 10, 10]\n        });\n      },\n      // 导出\n      downloadanalysefile() {\n        var prop = {\n          colsids: this.alldetails.instid,\n          type: this.alldetails.classid,\n          sessionid: this.sessionid,\n          metadataid: this.alldetails.instid,\n          filetype: "01",\n          filterflag: "0",\n          analysetype: this.isimpact ? "impact" : "blood",\n          analyseby: "dsm"\n        };\n        if (this.graphtype == "03") {\n          prop.sessionid = this.impactsessionid + "," + this.bloodsessionid;\n          prop.analysetype = "all_chain";\n        }\n        let objecturl = `${mds}/etlanalyse/downloadanalyseresult2?colsids=${prop.colsids}&type=${prop.type}&sessionid=${prop.sessionid}&metadataid=${prop.metadataid}&filetype=${prop.filetype}&filterflag=${prop.filterflag}&analysetype=${prop.analysetype}&analyseby=${prop.analyseby}`;\n        this.$axiosdownload(objecturl, {}, this);\n      },\n      // 全屏\n      fullscreehandler() {\n        let el = this.$refs.metadmap;\n        let isfullscreen =\n            document.fullscreen ||\n            document.mozfullscreen ||\n            document.webkitisfullscreen;\n\n        if (!isfullscreen) {\n          (el.requestfullscreen && el.requestfullscreen()) ||\n            (el.mozrequestfullscreen && el.mozrequestfullscreen()) ||\n            (el.webkitrequestfullscreen && el.webkitrequestfullscreen()) ||\n            (el.msrequestfullscreen && el.msrequestfullscreen());\n        } else {\n          document.exitfullscreen\n            ? document.exitfullscreen()\n          : document.mozcancelfullscreen\n            ? document.mozcancelfullscreen()\n          : document.webkitexitfullscreen\n            ? document.webkitexitfullscreen()\n          : "";\n        }\n      },\n      // 图形切换大小\n      changesize() {\n        let id = this.fullscreen ? "top-left-icon-layout" : "maincontainer";\n        let width = document.getelementbyid(id).scrollwidth || 1600;\n        let height = document.getelementbyid(id).scrollheight || 900;\n        height = this.fullscreen ? height + 60 : height - 120;\n        console.log(id, width, height, "id,width,heightwidth,height");\n\n        this.graph.changesize(width, height);\n        this.graph.fitview();\n        this.graph.zoomto(this.zoomsize);\n        this.graph.fitcenter();\n        this.graph.focusitem(data.id, true);\n        if (this.graphtype == "01") {\n          this.graph.translate(-width / 2 + 20, -50);\n        } else if (this.graphtype == "02") {\n          this.graph.translate(width / 4, -50);\n        } else {\n          this.graph.translate(-100, -50);\n        }\n      },\n      // 切换级别\n      changetype(type) {\n        // console.log(this.alldetails);\n        // 禁止重复点击\n        if (this.datatype == type) {\n          return;\n        }\n        this.datatype = type;\n        if (type == "table") {\n          this.istable = true;\n          this.nodeparentid = this.alldetails.parentid;\n          if (this.isasset) {\n            this.getassetdetail();\n          } else {\n            this.getmetabaseinfo();\n          }\n        } else {\n          this.istable = false;\n          this.nodeparentid = this.alldetails.instid;\n          this.listcolumnpage();\n        }\n      },\n\n      // 资产获取当前最全数据\n      async getassetdetail() {\n        const response = await dataassetmanaservice.getassetdetail(\n          this.nodeparentid\n        );\n        this.alldetails = response.data;\n        this.alldetails.instcode = response.data.instenname;\n        this.alldetails.instname = response.data.instcnname;\n        this.relationsanalyse();\n      },\n      // 获取当前最全数据\n      async getmetabaseinfo() {\n        const response = await workbenchservice.getmetabaseinfo({\n          instid: this.nodeparentid\n        });\n        this.alldetails = response.data;\n        this.relationsanalyse();\n      },\n      // 查看字段详情\n      async changecolumn(val) {\n        let data = {};\n        if (this.isasset) {\n          data = {\n            ...val,\n            instcode: val.instenname,\n            instname: val.instcnname,\n            parentid: this.nodeparentid\n          };\n        } else {\n          const colresponse = await workbenchservice.getmetabaseinfo({\n            instid: val.instid\n          });\n          data = {\n            ...colresponse.data,\n            parentid: this.nodeparentid\n          };\n        }\n\n        this.alldetails = data;\n        this.relationsanalyse();\n      },\n      // 获取字段列表\n      async listcolumnpage(val) {\n        let params = {\n          parentid: this.nodeparentid,\n          name: ""\n        };\n        var response;\n        // console.log(this.isasset);\n        if (this.isasset) {\n          params = {\n            instid: this.nodeparentid,\n            tabletype: "inst"\n          };\n          response = await dataassetregistrationservice.getlistitembypidandtype(\n            params\n          );\n          response.data = response.data.list;\n        } else {\n          response = await dashboardservice.listcolumnpage(params);\n        }\n\n        this.columnlist = response.data;\n        // 不为资产类型，需要调用详情接口\n\n        if (!val) {\n          // 列切换字段时，默认选中第一个字段\n          // console.log(response.data, "response.data")\n          let data = {};\n          if (this.isasset) {\n            data = {\n              ...response.data[0],\n              instcode: response.data[0].instenname,\n              instname: response.data[0].instcnname,\n              parentid: this.nodeparentid\n            };\n            // console.log(colresponse, "colresponseanalysetoasset");\n          } else {\n            let colresponse = await workbenchservice.getmetabaseinfo({\n              instid: response.data[0].instid\n            });\n            data = {\n              ...colresponse.data,\n              parentid: this.nodeparentid\n            };\n          }\n\n          this.alldetails = data;\n          this.$set(this.forminline, "name", data);\n          this.relationsanalyse();\n        } else {\n          // 字段全部信息\n          let obj = response.data.filter(\n            item => item.instid == this.alldetails.instid\n          );\n          this.$set(this.forminline, "name", obj[0]);\n\n          let data = {};\n          if (this.isasset) {\n            data = {\n              ...obj[0],\n              instcode: obj[0].instenname,\n              instname: obj[0].instcnname\n            };\n          } else {\n            let colresponse = await workbenchservice.getmetabaseinfo({\n              instid: response.data[0].instid\n            });\n            data = colresponse.data;\n          }\n          this.alldetails = data;\n          this.relationsanalyse();\n        }\n      },\n      // 切换分析类型\n      async changegraph(val, issearch) {\n        this.graphtype = val;\n        if (val == "01") {\n          this.isimpact = true;\n          this.isall = false;\n        } else if (val == "02") {\n          this.isimpact = false;\n          this.isall = false;\n        } else {\n          this.isimpact = false;\n          this.isall = true;\n        }\n        if (!issearch) {\n          this.relationsanalyse();\n        }\n      },\n      // 获取图数据\n      async relationsanalyse() {\n        console.log(this.alldetails);\n        this.showgraph = false;\n        let name =\n            this.alldetails.instname && this.alldetails.instname.trim()\n        ? this.alldetails.instname\n        : this.alldetails.instcode;\n        // let name1 = name.split("<span class=\'hightlightred\'>").join("");\n        // let name2 = name1.split("</span>").join("");\n        // this.rootname = [name2, ""];\n        let params = {\n          type: this.graphtype,\n          origininstid: this.alldetails.instid,\n          instid: this.alldetails.instid,\n          classid: this.alldetails.classid,\n          layer: this.forminline.layer\n        };\n\n        let response = {};\n        if (this.isasset) {\n          params.classid = this.alldetails.fromclassid;\n          this.alldetails.classid = this.alldetails.fromclassid;\n          response = await metaanalysisservice.getanalysetoasset(params);\n        } else {\n          response = await dashboardservice.relationsanalyse(params);\n        }\n        if (response.code == 200) {\n          if (this.graphtype == "03") {\n            this.impactsessionid = response.data.impact.sessionid;\n            this.bloodsessionid = response.data.blood.sessionid;\n            response.data.relations = {\n              ...response.data.impact.relations,\n              ...response.data.blood.relations\n            };\n            let arr = [\n              ...response.data.impact.nodes,\n              ...response.data.blood.nodes\n            ];\n            let newarr = [];\n            let obj = {};\n            for (var i = 0; i < arr.length; i++) {\n              if (!obj[arr[i].instid]) {\n                newarr.push(arr[i]);\n                obj[arr[i].instid] = true;\n              }\n            }\n            response.data.nodes = newarr;\n            if (this.isasset) {\n              response.data.instid = response.data.blood.instid;\n            } else {\n              response.data.instid = this.alldetails.instid;\n            }\n          }\n          console.log(response.data.relations, "response.data.nodes");\n          response.data.nodes.map(item => {\n            if (item.instid == this.alldetails.instid) {\n              this.alldetails = item;\n            }\n          });\n          let jsondata = {\n            id: "root",\n            name: name,\n            ...this.alldetails,\n            children: [],\n            anchorpoints: [\n              [1, 0.5],\n              [0, 0.5]\n            ]\n          }; //重要数组\n          this.sessionid = response.data.sessionid;\n          let _orign_data = {\n            impactarr: [], //影响分析关系数据\n            bloodarr: [], //血缘分析数据\n            others: {}\n          };\n          // 获取所有关系\n          let keys = object.keys(response.data.relations);\n          keys.map(item => {\n            if (item.indexof("01") == 0) {\n              //影响分析关联数据\n              _orign_data.impactarr = response.data.relations[item];\n            } else if (item.indexof("02") == 0) {\n              //血缘分析关联数据\n              _orign_data.bloodarr = response.data.relations[item];\n            } else {\n              _orign_data.others[item] = response.data.relations[item];\n            }\n          });\n          // 组合类型数据\n          _orign_data.others &&\n            object.keys(_orign_data.others).map((key, index) => {\n            let flagclassid = _orign_data.others[key][0].fromclassid;\n            let toclassid = _orign_data.others[key][0].toclassid;\n            if (\n              (this.alldetails.classid == "ddtable" ||\n               this.alldetails.classid == "ddcolumn" ||\n               this.alldetails.classid == "ddiffcolumn" ||\n               this.alldetails.classid == "ddfilecolumn" ||\n               this.alldetails.classid == "ddnoniffcolumn" ||\n               this.alldetails.classid == "assetinfoitem") &&\n              flagclassid == this.alldetails.classid\n            ) {\n              flagclassid = toclassid;\n            }\n\n            if (flagclassid == "basemetadata" && toclassid == "amcommoncode") {\n              flagclassid = toclassid;\n            }\n\n            let node = {\n              id: key,\n              isdisable: true,\n              name: this.allclasslist[flagclassid].nodetitle,\n              nodetype: 0,\n              children: []\n            };\n            if (\n              flagclassid == "ddtable" ||\n              flagclassid == "ddcolumn" ||\n              flagclassid == "ddiffcolumn" ||\n              flagclassid == "ddfilecolumn" ||\n              flagclassid == "ddnoniffcolumn"\n            ) {\n              node.state = "left";\n              // 字段展示为技术元数据\n              jsondata.children.push(node);\n            } else {\n              jsondata.children.push(node);\n            }\n\n            // 将所属类型的节点组织加入\n            response.data.relations[key].foreach((thisnode, _index) => {\n              let flaginstid = thisnode.frominstid;\n\n              if (\n                (this.alldetails.classid == "ddtable" ||\n                 this.alldetails.classid == "ddcolumn" ||\n                 this.alldetails.classid == "ddiffcolumn" ||\n                 this.alldetails.classid == "ddfilecolumn" ||\n                 this.alldetails.classid == "ddnoniffcolumn" ||\n                 this.alldetails.classid == "assetinfoitem") &&\n                thisnode.fromclassid == this.alldetails.classid\n              ) {\n                flaginstid = thisnode.toinstid;\n              }\n              if (\n                thisnode.fromclassid == "basemetadata" &&\n                thisnode.toclassid == "amcommoncode"\n              ) {\n                flaginstid = thisnode.toinstid;\n              }\n\n              response.data.nodes.map(item => {\n                if (item.instid == flaginstid) {\n                  item.id = item.instid;\n                  item.name = item.instname.trim()\n                    ? item.instname\n                  : item.instcode;\n                  item.ratio = item.namespacecode\n                    .split("/")\n                    .slice(1, 4)\n                    .join(">");\n                  let obj = {\n                    nodetype: 1,\n                    ...item,\n                    children: [],\n                    showanalysis:\n                    item.classid == "ddcolumn" ||\n                    item.classid == "ddiffcolumn" ||\n                    item.classid == "ddfilecolumn" ||\n                    item.classid == "ddnoniffcolumn",\n                    data: {\n                      path: item.namespacecode, //路径\n                      ...this.allclasslist[item.classid] //展示字段(标签)\n                    },\n                    noneedcircle: !(\n                      item.classid == "ddcolumn" ||\n                      item.classid == "ddiffcolumn" ||\n                      item.classid == "ddfilecolumn" ||\n                      item.classid == "ddnoniffcolumn"\n                    )\n                  };\n                  node.children.push(obj);\n                }\n              });\n            });\n          });\n          //获取数据\n\n          //字段组合血缘，影响分析\n          if (\n            this.alldetails.classid == "ddtable" ||\n            this.alldetails.classid == "ddcolumn" ||\n            this.alldetails.classid == "ddiffcolumn" ||\n            this.alldetails.classid == "ddfilecolumn" ||\n            this.alldetails.classid == "ddnoniffcolumn"\n          ) {\n            // console.log(_orign_data.impactarr, "影响分析");\n            // console.log(_orign_data.bloodarr, "血缘分析");\n            console.log(response.data.instid, "response.data.instid");\n\n            // 影响分析节点\n            let allform = [];\n            let allform2 = [];\n\n            // 获取所有血缘关系\n            _orign_data.bloodarr.map(item => {\n              if (allform.indexof(item.frominstid) == -1) {\n                allform.push(item.frominstid);\n              }\n            });\n            // 血缘分析节点\n            _orign_data.bloodarr.map(item => {\n              // 找到最接近的根节点\n              if (item.toinstid == response.data.instid) {\n                response.data.nodes.map((node, index) => {\n                  if (node.instid == item.frominstid) {\n                    let obj = {\n                      ...node,\n                      lineshape: 4,\n                      id: node.instid + this.generateuuid(),\n                      name: node.instname.trim() ? node.instname : node.instcode,\n                      children: [],\n                      state: "left",\n                      anchorpoints: [\n                        [1, 0.5],\n                        [0, 0.5]\n                      ],\n                      expandflag: item.expandflag == "y"\n                    };\n\n                    if (allform.indexof(obj.instid) !== -1) {\n                      this.getchildren(\n                        obj,\n                        _orign_data.bloodarr,\n                        response,\n                        allform,\n                        "02"\n                      );\n                    }\n                    if (obj.children.length == 0) {\n                      obj.noneedcircle = true;\n                    }\n                    // bloodrootnode.children.push(obj);\n                    jsondata.children.push(obj);\n                  }\n                });\n              }\n            });\n\n            // 获取所有影响关系\n            _orign_data.impactarr.map(item => {\n              if (allform2.indexof(item.frominstid) == -1) {\n                allform2.push(item.frominstid);\n              }\n            });\n            //所有forminstidd\n            _orign_data.impactarr.map(item => {\n              // console.log(item, "itemitemitemitem");\n              // 找到最接近的根节点\n              if (item.frominstid == response.data.instid) {\n                response.data.nodes.map((node, index) => {\n                  if (node.instid == item.toinstid) {\n                    let obj = {\n                      ...node,\n                      from: "impactanalysis",\n                      to: item.toinstid,\n                      lineshape: 4,\n                      id: node.instid + this.generateuuid(),\n                      name: node.instname.trim() ? node.instname : node.instcode,\n                      children: [],\n                      ratio: node.namespacecode\n                      .split("/")\n                      .slice(1, 4)\n                      .join(">"),\n                      nodetype: "out",\n                      noneedcircle: false,\n                      anchorpoints: [\n                        [1, 0.5],\n                        [0, 0.5]\n                      ],\n                      expandflag: item.expandflag == "y"\n                    };\n\n                    if (allform2.indexof(obj.instid) !== -1) {\n                      this.getchildren(\n                        obj,\n                        _orign_data.impactarr,\n                        response,\n                        allform2,\n                        "01"\n                      );\n                    }\n                    if (obj.children.length == 0) {\n                      obj.noneedcircle = true;\n                    }\n                    // impactrootnode.children.push(obj);\n                    // console.log(obj, "xxxxxxxxxxxxxxxxxxxx");\n                    jsondata.children.push(obj);\n                  }\n                });\n              }\n            });\n          }\n          let data = jsondata;\n          // console.log(data, "ssssssssssssssss");\n          this.inittree(data);\n        }\n      },\n      // 处理子节点数据\n      getchildren(node, alllist, response, allform, type) {\n        // console.log(node, allform, "node,  allform");\n        // 血缘分析 - 找关联关系frominstid  节点根据toinstid\n        let formflag = "toinstid";\n        let toflag = "frominstid";\n\n        if (type == "01") {\n          formflag = "frominstid";\n          toflag = "toinstid";\n        }\n        alllist.map(inner => {\n          if (node.instid == inner[formflag] && !inner.hasshow) {\n            inner.hasshow = true;\n            // console.log(inner, "关联信息");\n            response.data.nodes.map((innernode, index) => {\n              if (\n                innernode.instid == inner[toflag] &&\n                inner.frominstid !== inner.toinstid\n              ) {\n                let obj = {\n                  ...innernode,\n                  from: inner[formflag],\n                  to: innernode.instid,\n                  lineshape: 4,\n                  id: innernode.instid + this.generateuuid(),\n                  name: innernode.instname.trim()\n                  ? innernode.instname\n                  : innernode.instcode,\n                  children: [],\n                  ratio: innernode.namespacecode\n                  .split("/")\n                  .slice(1, 4)\n                  .join(">"),\n                  nodetype: node.nodetype,\n                  noneedcircle: false,\n                  anchorpoints: type == "02" ? [[1, 0.5]] : [[0, 0.5]],\n                  state: type == "02" ? "left" : "",\n                  expandflag: inner.expandflag == "y"\n                };\n\n                // console.log(obj, "objobj");\n                if (allform.indexof(innernode.instid) !== -1) {\n                  obj.anchorpoints = [\n                    [1, 0.5],\n                    [0, 0.5]\n                  ];\n                  this.getchildren(obj, alllist, response, allform, type);\n                }\n                if (obj.children.length == 0) {\n                  obj.noneedcircle = true;\n                }\n                // console.log(obj, "2222222222222222222");\n                node.children.push(obj);\n              } else {\n                return;\n              }\n            });\n          }\n        });\n      },\n      // 图形第一层名字\n      returntopname(val) {\n        // console.log(val, "returntopname");\n        if (val.classid == "ddtable") {\n          return val.schcode;\n        } else {\n          if (val.classid == "ddcolumn" && !val.tabcode) {\n            let arr = val.namespacecode.split("/");\n            val.tabcode = arr[arr.length - 2];\n          }\n          let str = val.schcode + "." + val.tabcode;\n          return str;\n        }\n      },\n      // 画图\n      inittree(data) {\n        this.showgraph = true;\n        const that = this;\n        this.$nexttick(() => {\n          // 文本超出隐藏 (字段, 最大长度, 字体大小)\n          const fittingstring = (str, maxwidth, fontsize) => {\n            let maxwidthcontent = width > maxwidth ? width : maxwidth;\n            const ellipsis = "...";\n            const ellipsislength = g6.util.gettextsize(ellipsis, fontsize)[0];\n            let currentwidth = 0;\n            let res = str;\n            const pattern = new regexp("[\\u4e00-\\u9fa5]+"); // distinguish the chinese charactors and letters\n            str.split("").foreach((letter, i) => {\n              if (currentwidth > maxwidth - ellipsislength) return;\n              if (pattern.test(letter)) {\n                // chinese charactors\n                currentwidth += fontsize;\n              } else {\n                // get the width of single letter according to the fontsize\n                currentwidth += g6.util.getletterwidth(letter, fontsize);\n              }\n              if (currentwidth > maxwidthcontent - ellipsislength) {\n                res = `${str.substr(0, i)}${ellipsis}`;\n              }\n            });\n            return res;\n          };\n          // 获取文本的长度\n          const gettextsize = (val, fontsize) => {\n            let tabcode = that.returntopname(val);\n            // console.log(tabcode, "tabcode");\n            let width, str1, str2;\n            if (val.classid == "ddtable") {\n              str1 = val.name;\n              str2 = val.schcode;\n            } else {\n              str1 = tabcode;\n              str2 = val.name;\n            }\n            let width1 = g6.util.gettextsize(str1, fontsize)[0];\n            let width2 = g6.util.gettextsize(str2, fontsize)[0];\n            // console.log(width1, width2, "====width1,width2");\n            width = width1 > width2 ? width1 : width2;\n            return width > that.maxwidth ? width : that.maxwidth;\n          };\n\n          // 自定义节点\n          g6.registernode("card-node", {\n            draw(cfg, group) {\n              let boxsize = { height: 80, xnum: 0, ynum: 0 }; //最外层盒子参数 高度，x，y\n              let imgsize = { height: 15 }; //图片高度，横向位置\n              let rect;\n              // 左边血缘分析\n              if (cfg.state === "left") {\n                // 最外层盒子\n                rect = group.addshape("rect", {\n                  attrs: {\n                    x: boxsize.xnum, // x 轴移动距离\n                    y: boxsize.ynum, // y 轴移动距离\n                    width: gettextsize(cfg, 16) + 20, // 宽\n                    height: boxsize.height, // 高\n                    stroke: "#dcdee0", //描边色 ->border\n                    linewidth: 1 //border 宽\n                  },\n                  name: "card-node-keyshape",\n                  draggable: true\n                });\n                // top盒子\n                group.addshape("rect", {\n                  attrs: {\n                    x: boxsize.xnum, // x 轴移动距离\n                    y: boxsize.ynum, // y 轴移动距离\n                    width: gettextsize(cfg, 16) + 20, //200,\n                    height: boxsize.height / 2, // 60\n                    fill: "#a6ffc0", //填充颜色\n                    fillopacity: 0.2 //填充透明度\n                  },\n                  name: "title-box",\n                  draggable: true\n                });\n                // top盒子img  -表类型展示模式图片，字段类型展示表图片\n                group.addshape("text", {\n                  attrs: {\n                    x: boxsize.xnum + 8,\n                    y: boxsize.ynum + 28,\n                    fontfamily: "iconfont2",\n                    text:\n                    that.alldetails.classid == "ddcolumn" ? "\\uf87e" : "\\uf6d2",\n                    fontsize: 14,\n                    fill: "#25aeff",\n                    cursor: "pointer"\n                  },\n                  name: "image-shape-state"\n                });\n\n                // top盒子文字 -表类型展示模式字段，字段类型展示表名\n                group.addshape("text", {\n                  attrs: {\n                    textbaseline: "top",\n                    x: boxsize.xnum + imgsize.height + 15,\n                    y: boxsize.ynum + 15,\n                    lineheight: 20,\n                    fontsize: 14,\n                    textalign: "left",\n                    fontweight: "bold",\n                    text: that.returntopname(cfg),\n                    fill: "#333"\n                  },\n                  name: "title"\n                });\n                // bottom盒子 图片  -表类型展示表图片，字段类型展示字段图片\n                group.addshape("text", {\n                  attrs: {\n                    x: boxsize.xnum + 32,\n                    y: boxsize.ynum + boxsize.height / 2 + 26,\n                    fontfamily: "iconfont2",\n                    text:\n                    that.alldetails.classid == "ddcolumn" ? "\\uf611" : "\\uf87e",\n                    fontsize: 14,\n                    fill: "#25aeff",\n                    cursor: "pointer"\n                  },\n                  name: "image-shape-state"\n                });\n                // bottom盒子文字  -表展示表名，字段展示字段名\n                group.addshape("text", {\n                  attrs: {\n                    text: fittingstring(cfg.name, this.maxwidth, 16),\n                    x: boxsize.xnum + imgsize.height + 40,\n                    y: boxsize.ynum + boxsize.height / 2 + 20,\n                    fontsize: 14,\n                    textalign: "left",\n                    textbaseline: "middle",\n                    fill: "#333"\n                  },\n                  name: "text-shape"\n                });\n              }\n              // 右边影响分析，根节点\n              if (cfg.state !== "left") {\n                if (cfg.depth === 0) {\n                  // 最外层盒子\n                  rect = group.addshape("rect", {\n                    attrs: {\n                      x: boxsize.xnum, // x 轴移动距离\n                      y: boxsize.ynum, // y 轴移动距离\n                      width: gettextsize(cfg, 16) + 20, // 宽\n                      height: boxsize.height, // 高\n                      stroke: "#dcdee0", //描边色 ->border\n                      linewidth: 1 //border 宽\n                    },\n                    name: "card-node-keyshape",\n                    draggable: true\n                  });\n                  // top盒子\n                  group.addshape("rect", {\n                    attrs: {\n                      x: boxsize.xnum, // x 轴移动距离\n                      y: boxsize.ynum, // y 轴移动距离\n                      width: gettextsize(cfg, 16) + 20, //200,\n                      height: boxsize.height / 2, // 60\n                      fill: "#25aeff", //填充颜色\n                      fillopacity: 1 //填充透明度\n                    },\n                    name: "title-box",\n                    draggable: true\n                  });\n                  // top盒子img  -表类型展示模式图片，字段类型展示表图片\n                  group.addshape("text", {\n                    attrs: {\n                      x: boxsize.xnum + 8,\n                      y: boxsize.ynum + 28,\n                      fontfamily: "iconfont2",\n                      text:\n                      that.alldetails.classid == "ddcolumn"\n                      ? "\\uf87e"\n                      : "\\uf6d2",\n                      fontsize: 14,\n                      fill: "#fff",\n                      cursor: "pointer"\n                    },\n                    name: "image-shape-state"\n                  });\n\n                  // top盒子文字 -表类型展示模式字段，字段类型展示表名\n                  group.addshape("text", {\n                    attrs: {\n                      textbaseline: "top",\n                      x: boxsize.xnum + imgsize.height + 15,\n                      y: boxsize.ynum + 15,\n                      lineheight: 20,\n                      fontsize: 14,\n                      textalign: "left",\n                      fontweight: "bold",\n                      text: that.returntopname(cfg),\n                      fill: "#fff"\n                    },\n                    name: "title"\n                  });\n                  // bottom盒子 字体图标  -表类型展示表\\uf87e，字段类型展示字段\\uf611\n                  group.addshape("text", {\n                    attrs: {\n                      x: boxsize.xnum + 32,\n                      y: boxsize.ynum + boxsize.height / 2 + 26,\n                      fontfamily: "iconfont2",\n                      text:\n                      that.alldetails.classid == "ddcolumn"\n                      ? "\\uf611"\n                      : "\\uf87e",\n                      fontsize: 14,\n                      fill: "#25aeff",\n                      cursor: "pointer"\n                    },\n                    name: "image-shape-state"\n                  });\n                  // bottom盒子文字  -表展示表名，字段展示字段名\n                  group.addshape("text", {\n                    attrs: {\n                      text: fittingstring(cfg.name, this.maxwidth, 16),\n                      x: boxsize.xnum + imgsize.height + 40,\n                      y: boxsize.ynum + boxsize.height / 2 + 20,\n                      fontsize: 14,\n                      textalign: "left",\n                      textbaseline: "middle",\n                      fill: "#333"\n                    },\n                    name: "text-shape"\n                  });\n                } else {\n                  // 最外层盒子\n                  rect = group.addshape("rect", {\n                    attrs: {\n                      x: boxsize.xnum, // x 轴移动距离\n                      y: boxsize.ynum, // y 轴移动距离\n                      width: gettextsize(cfg, 16) + 20, // 宽\n                      height: boxsize.height, // 高\n                      stroke: "#dcdee0", //描边色 ->border\n                      linewidth: 1 //border 宽\n                    },\n                    name: "card-node-keyshape",\n                    draggable: true\n                  });\n                  // top盒子\n                  group.addshape("rect", {\n                    attrs: {\n                      x: boxsize.xnum, // x 轴移动距离\n                      y: boxsize.ynum, // y 轴移动距离\n                      width: gettextsize(cfg, 16) + 20, //200,\n                      height: boxsize.height / 2, // 60\n                      fill: "#25aeff", //填充颜色\n                      fillopacity: 0.1 //填充透明度\n                    },\n                    name: "title-box",\n                    draggable: true\n                  });\n                  // top盒子img  -表类型展示模式图片，字段类型展示表图片\n                  group.addshape("text", {\n                    attrs: {\n                      x: boxsize.xnum + 8,\n                      y: boxsize.ynum + 28,\n                      fontfamily: "iconfont2",\n                      text:\n                      that.alldetails.classid == "ddcolumn"\n                      ? "\\uf87e"\n                      : "\\uf6d2",\n                      fontsize: 14,\n                      fill: "#25aeff",\n                      cursor: "pointer"\n                    },\n                    name: "image-shape-state"\n                  });\n\n                  // top盒子文字 -表类型展示模式字段，字段类型展示表名\n                  group.addshape("text", {\n                    attrs: {\n                      textbaseline: "top",\n                      x: boxsize.xnum + imgsize.height + 15,\n                      y: boxsize.ynum + 15,\n                      lineheight: 20,\n                      fontsize: 14,\n                      textalign: "left",\n                      fontweight: "bold",\n                      text: that.returntopname(cfg),\n                      fill: "#333"\n                    },\n                    name: "title"\n                  });\n                  // bottom盒子 图片  -表类型展示表图片，字段类型展示字段图片\n                  group.addshape("text", {\n                    attrs: {\n                      x: boxsize.xnum + 32,\n                      y: boxsize.ynum + boxsize.height / 2 + 26,\n                      fontfamily: "iconfont2",\n                      text:\n                      that.alldetails.classid == "ddcolumn"\n                      ? "\\uf611"\n                      : "\\uf87e",\n                      fontsize: 14,\n                      fill: "#25aeff",\n                      cursor: "pointer"\n                    },\n                    name: "image-shape-state"\n                  });\n                  // bottom盒子文字  -表展示表名，字段展示字段名\n                  group.addshape("text", {\n                    attrs: {\n                      text: fittingstring(cfg.name, this.maxwidth, 16),\n                      x: boxsize.xnum + imgsize.height + 40,\n                      y: boxsize.ynum + boxsize.height / 2 + 20,\n                      fontsize: 14,\n                      textalign: "left",\n                      textbaseline: "middle",\n                      fill: "#333"\n                    },\n                    name: "text-shape"\n                  });\n                }\n              }\n              // 是否有子节点\n              if (cfg.children && cfg.children.length > 0) {\n                if (cfg.state === "left") {\n                  group.addshape("marker", {\n                    attrs: {\n                      x: -6,\n                      y: boxsize.height / 2,\n                      r: 6,\n                      symbol: cfg.collapsed\n                      ? g6.marker.expand\n                      : g6.marker.collapse,\n                      stroke: "#333",\n                      fill: "#fff",\n                      linewidth: 1,\n                      cursor: "pointer" // 鼠标变手\n                    },\n                    name: "collapse-icon"\n                  });\n                } else {\n                  if (cfg.depth === 0) {\n                    let arr = cfg.children;\n                    // console.log(arr);\n\n                    let isleft = [];\n                    let isright = [];\n                    isleft =\n                      arr.length > 0 && arr.filter(item => item.state == "left");\n                    isright = arr.length > 0 && arr.filter(item => !item.state);\n                    // console.log(isleft, "isleft");\n                    // console.log(isright, "isright");\n                    if (isleft.length > 0) {\n                      group.addshape("marker", {\n                        attrs: {\n                          x: -6,\n                          y: boxsize.height / 2,\n                          r: 6,\n                          symbol: cfg.collapsed\n                          ? g6.marker.expand\n                          : g6.marker.collapse,\n                          stroke: "#666",\n                          fill: "#fff",\n                          linewidth: 1,\n                          cursor: "pointer" // 鼠标变手\n                        },\n                        name: "collapse-icon"\n                      });\n                    }\n                    if (isright.length > 0) {\n                      group.addshape("marker", {\n                        attrs: {\n                          x: gettextsize(cfg, 16) + 26, //节点rect的宽度，加marker本身的width\n                          y: boxsize.height / 2,\n                          r: 6,\n                          symbol: cfg.collapsed\n                          ? g6.marker.expand\n                          : g6.marker.collapse,\n                          stroke: "#666",\n                          fill: "#fff",\n                          linewidth: 1,\n                          cursor: "pointer" // 鼠标变手\n                        },\n                        name: "collapse-icon"\n                      });\n                    }\n                  } else {\n                    group.addshape("marker", {\n                      attrs: {\n                        x: gettextsize(cfg, 16) + 26, //节点rect的宽度，加marker本身的width\n                        y: boxsize.height / 2,\n                        r: 6,\n                        symbol: cfg.collapsed\n                        ? g6.marker.expand\n                        : g6.marker.collapse,\n                        stroke: "#666",\n                        fill: "#fff",\n                        linewidth: 1,\n                        cursor: "pointer" // 鼠标变手\n                      },\n                      name: "collapse-icon"\n                    });\n                  }\n                }\n              }\n              // 是否需要动态获取子节点\n              if (cfg.children && cfg.children.length == 0 && cfg.expandflag) {\n                if (cfg.state === "left") {\n                  group.addshape("marker", {\n                    attrs: {\n                      x: -6,\n                      y: boxsize.height / 2,\n                      r: 6,\n                      symbol: g6.marker.expand,\n                      stroke: "#333",\n                      fill: "#fff",\n                      linewidth: 1,\n                      cursor: "pointer" // 鼠标变手\n                    },\n                    name: "collapse-icon"\n                  });\n                } else {\n                  group.addshape("marker", {\n                    attrs: {\n                      x: gettextsize(cfg, 16) + 26, //节点rect的宽度，加marker本身的width\n                      y: boxsize.height / 2,\n                      r: 6,\n                      symbol: g6.marker.expand,\n                      stroke: "#666",\n                      fill: "#fff",\n                      linewidth: 1,\n                      cursor: "pointer" // 鼠标变手\n                    },\n                    name: "collapse-icon"\n                  });\n                }\n              }\n              return rect;\n            },\n            setstate: (name, value, item) => {\n              // console.log("自定义节点---\x3esetstate：", name, value, item);\n              if (name === "collapsed") {\n                // console.log("item-group", item.get("group"));\n                const marker = item\n                .get("group")\n                .findall(ele => ele.get("name") === "collapse-icon");\n                // console.log("marker---\x3e", marker);\n                marker[0] &&\n                  marker[0].attr(\n                  "symbol",\n                  value ? g6.marker.collapse : g6.marker.expand\n                );\n                // 如果是根节点需要处理两个marker\n                if (item._cfg.model.depth === 0) {\n                  //  console.log("marker---\x3e", marker);\n                  marker[1] &&\n                    marker[1].attr(\n                    "symbol",\n                    value ? g6.marker.collapse : g6.marker.expand\n                  );\n                }\n              }\n            }\n          });\n          // 自定义边\n          g6.registeredge("kaimo-line", {\n            /**\n           * 绘制边，包含文本\n           * @param  {object} cfg 边的配置项\n           * @param  {g.group} group 图形分组，边中的图形对象的容器\n           * @return {g.shape} 绘制的图形，通过 node.get(\'keyshape\') 可以获取到\n           */\n            draw(cfg, group) {\n              const startpoint = cfg.startpoint;\n              const endpoint = cfg.endpoint;\n              // console.log(startpoint,endpoint);\n              let shape;\n              if (cfg.targetnode._cfg.model.state === "left") {\n                shape = group.addshape("path", {\n                  //线条\n                  attrs: {\n                    stroke: "#006ad3",\n                    path: [\n                      ["m", startpoint.x - 11, startpoint.y],\n                      [\n                        "l",\n                        endpoint.x / 3 + (2 / 3) * startpoint.x,\n                        startpoint.y\n                      ],\n                      ["l", endpoint.x / 3 + (2 / 3) * startpoint.x, endpoint.y],\n                      ["l", endpoint.x, endpoint.y]\n                    ],\n                    startarrow: {\n                      path: g6.arrow.triangle(5, 5, 0), // 使用内置箭头路径函数，参数为箭头的 宽度、长度、偏移量（默认为 0，与 d 对应）\n                      d: 0,\n                      fill: "#006ad3",\n                      opacity: 0.5,\n                      linewidth: 1\n                    }\n                  },\n                  // must be assigned in g6 3.3 and later versions. it can be any value you want\n                  name: "path-shape"\n                });\n              } else {\n                shape = group.addshape("path", {\n                  //线条\n                  attrs: {\n                    stroke: "#006ad3",\n                    path: [\n                      ["m", startpoint.x, startpoint.y],\n                      [\n                        "l",\n                        endpoint.x / 3 + (2 / 3) * startpoint.x,\n                        startpoint.y\n                      ],\n                      ["l", endpoint.x / 3 + (2 / 3) * startpoint.x, endpoint.y],\n                      ["l", endpoint.x, endpoint.y]\n                    ],\n                    endarrow: {\n                      path: g6.arrow.triangle(5, 5, 0), // 使用内置箭头路径函数，参数为箭头的 宽度、长度、偏移量（默认为 0，与 d 对应）\n                      d: 0,\n                      fill: "#006ad3",\n                      opacity: 0.5,\n                      linewidth: 1\n                    }\n                  },\n                  // must be assigned in g6 3.3 and later versions. it can be any value you want\n                  name: "path-shape"\n                });\n              }\n              return shape;\n            }\n          });\n          // 自定义事件\n          g6.registerbehavior("kaimo-behavior", {\n            getevents() {\n              return {\n                "node:click": "onnodeclick"\n              };\n            },\n            // 自定义单击事件\n            onnodeclick: async evt => {\n              // 单击展开/收起\n              const nownode = evt.item._cfg.model;\n              // console.log("自定义单击事件---\x3e", nownode);\n              const nodeid = evt.item.get("id");\n              const parentdata = that.graph.finddatabyid(nodeid);\n              if (nownode.expandflag && nownode.children.length == 0) {\n                let params = {\n                  origininstid: this.alldetails.instid,\n                  instid: nownode.instid,\n                  classid: this.alldetails.classid,\n                  sessionid: this.sessionid,\n                  type: nownode.state !== "left" ? "01" : "02"\n                };\n                if (this.graphtype == "03") {\n                  params.sessionid =\n                    nownode.state == "left"\n                    ? this.bloodsessionid\n                  : this.impactsessionid;\n                }\n                const response = await dashboardservice.expandrelationsanalyse(\n                  params\n                );\n                let data = [];\n                let alllist = [];\n                // 获取所有关系\n                let keys = object.keys(response.data.relations);\n                nownode.searchtype = nownode.state !== "left" ? "01" : "02";\n                keys.map(item => {\n                  if (item.indexof(nownode.searchtype) !== -1) {\n                    //影响分析关联数据\n                    alllist = response.data.relations[item];\n                  }\n                });\n\n                // 影响分析节点\n                let allform = [];\n                // 获取所有关系\n                alllist.map(item => {\n                  if (allform.indexof(item.frominstid) == -1) {\n                    allform.push(item.frominstid);\n                  }\n                });\n                let formflag = "toinstid";\n                let toflag = "frominstid";\n\n                if (nownode.searchtype == "01") {\n                  formflag = "frominstid";\n                  toflag = "toinstid";\n                }\n                // 节点\n                alllist.map(item => {\n                  // 找到最接近的根节点\n                  if (item[formflag] == response.data.instid) {\n                    response.data.nodes.map((node, index) => {\n                      if (node.instid == item[toflag]) {\n                        let obj = {\n                          ...node,\n                          from:\n                          nownode.searchtype == "01"\n                          ? "impactanalysis"\n                          : "bloodanalysis",\n                          to: node.instid,\n                          lineshape: 4,\n                          id: node.instid + this.generateuuid(),\n                          name: node.instname.trim()\n                          ? node.instname\n                          : node.instcode,\n                          children: [],\n                          noneedcircle: false,\n                          anchorpoints:\n                          nownode.searchtype == "02" ? [[1, 0.5]] : [[0, 0.5]],\n                          expandflag: item.expandflag == "y",\n                          state: nownode.searchtype == "02" ? "left" : ""\n                        };\n\n                        if (allform.indexof(obj.instid) !== -1) {\n                          this.getchildren(\n                            obj,\n                            alllist,\n                            response,\n                            allform,\n                            nownode.searchtype\n                          );\n                        }\n                        data.push(obj);\n                      }\n                    });\n                  }\n                });\n                parentdata.anchorpoints = [\n                  [1, 0.5],\n                  [0, 0.5]\n                ];\n                // console.log(data);\n                parentdata.children = data;\n                that.graph.updatechildren(parentdata.children, nodeid);\n                //移动图，使得 item 对齐到视口中心，该方法可用于做搜索后的缓动动画。\n              } else {\n                evt.item._cfg.model.collapsed = !evt.item._cfg.model.collapsed;\n                // 更改 item 的状态，触发自定义节点：setstate\n                that.graph.setitemstate(\n                  evt.item,\n                  "collapsed",\n                  !evt.item.getmodel().collapsed\n                );\n                that.graph.layout();\n              }\n              //移动图，使得 item 对齐到视口中心，该方法可用于做搜索后的缓动动画。\n              that.graph.fitview();\n              that.graph.zoomto(that.zoomsize);\n              that.graph.fitcenter();\n              that.graph.focusitem(nodeid, true);\n              if (that.graphtype == "01") {\n                that.graph.translate(-100, -50);\n              } else if (this.graphtype == "02") {\n                that.graph.translate(-100, -50);\n              } else {\n                that.graph.translate(-100, -50);\n              }\n            }\n          });\n          // 定义画布的宽高\n          const width = document.getelementbyid(this.svgid).scrollwidth || 1600;\n          let height;\n          if (this.fullscreen) {\n            height = document.getelementbyid("maincontainer").scrollheight + 80;\n          } else {\n            height =\n              document.getelementbyid("maincontainer").scrollheight - 120 || 700;\n          }\n          // 实例化g6\n          // 因为我们用的是树图，所以这里是g6.treegraph(),还有其他，像是普通图的配置g6.graph(),一般y用的比较多的就像是树图这种，还有组织架构图一类的。\n          that.graph = new g6.treegraph({\n            // 图的  dom 容器，对应上面我们定义的id\n            container: that.svgid,\n            width,\n            height,\n            maxzoom: 1.8,\n            minzoom: 0.3,\n            // 设置画布的交互模式\n            modes: {\n              default: [\n                // 自定义事件\n                "kaimo-behavior",\n                // 拖拽画布\n                "drag-canvas",\n                // 缩放画布\n                "zoom-canvas"\n              ]\n            },\n            // 配置节点的属性\n            defaultnode: {\n              // 节点类型，cicle:圆形，rect:矩形，ellipse:椭圆，diamond:菱形，triangle：三角形，star：五角星，image：图片，modelrect：卡片\n              type: "card-node",\n              // 节点样式\n              style: {\n                // 鼠标经过是的形状，跟css是一样的。\n                cursor: "pointer",\n                // 圆角\n                radius: 4\n              }\n            },\n            // 配置边的属性\n            defaultedge: {\n              // 指定边的类型，可以是内置边的类型名称，也可以是自定义边的名称。\n              // line:直线，polyline：折线，arc：圆弧线，quadratic：二阶贝塞尔曲线，cubic：三阶贝塞尔曲线，cubic-vertica：垂直方向的三阶贝塞尔曲线，不考虑用户从外部传入的控制点。cubic-horizontal：水平方向的三阶贝塞尔曲线，不考虑用户从外部传入的控制点。loop：自环\n              type: "kaimo-line"\n            },\n            // 布局配置项\n            layout: {\n              // 布局名称,这个可就太多了，这个只是树图结构中的一种。比如还有compactbox：紧凑树布局，dendrogram：生态树布局，indented：缩紧树布局。\n              type: "compactbox", // 脑图树布局\n              direction: "h", // h / v / lr / rl / tb / bt 这些是控制节点分布位置，从左往右、从右往左、从中间往上下延伸、从中间往左右延伸...具体可以看官网\n              // 节点 id 的回调函数\n              getid: function getid(d) {\n                return d.id;\n              },\n              // 下面都是一些控制节点与节点间距离的回调函数，具体可以试着修改一下值。\n              // 节点高度的回调函数\n              getheight: function getheight() {\n                return 16;\n              },\n              // 节点宽度的回调函数\n              getwidth: function getwidth(cfg) {\n                return gettextsize(cfg, 16) + 40;\n              },\n              // 节点纵向间距的回调函数\n              getvgap: function getvgap() {\n                return 40;\n              },\n              // 节点横向间距的回调函数\n              gethgap: function gethgap(cfg) {\n                return 40;\n              },\n              // 这个getside就是控制节点位置的属性了，通过数据结构中定义的值做判断，来控制左右，\n              // 注意的是这个官方写的只能return \'left\'和\'right\'，当我们的树结构是竖着的呢？难道是用top和bottom？这里我也试过了，用top和bottom是不好使的，因为人家官方确确实实的只有left和right，通过尝试，其实left就对应top，right对应bottom，所以要控制节点在上面就写left,在下面就写right。\n              getside: node => {\n                if (node.data.state === "left") {\n                  return "left";\n                }\n                return "right";\n              }\n            },\n            // 动画属性\n            animate: true\n          });\n          // 默认全部展开\n          g6.util.traversetree(data, function(item) {\n            item.collapsed = false;\n          });\n          // console.log(data, "newdata");\n          // 初始化的图数据\n          that.graph.data(data);\n          // 根据提供的数据渲染视图。\n          that.graph.render();\n\n          that.graph.on("wheelzoom", evt => {\n            // 一些操作\n            let zoom = that.graph.getzoom();\n            if (zoom >= 1.8) {\n              zoom = 1.8;\n            } else if (zoom <= 0.3) {\n              zoom = 0.3;\n            }\n            zoom = zoom.tofixed(1);\n            this.zoomsize = zoom;\n          });\n          // 鼠标进入节点\n          that.graph.on("node:mouseenter", event => {\n            // console.log(event);\n            if (!this.timeoutid) {\n              this.timeoutid = window.settimeout(() => {\n                this.timeoutid = null;\n                var ishave = document.getelementbyid("graph-tooltip");\n                if (!ishave) {\n                  var container = document.getelementbyid(this.svgid);\n                  tooltipel = document.createelement("div");\n                  tooltipel.setattribute("id", "graph-tooltip");\n                  container.appendchild(tooltipel);\n                }\n\n                // tooltipel.textcontent = message;\n                let node = event.item.getmodel();\n                if (node.id == "root") {\n                  node = that.alldetails;\n                }\n                console.log(node, "tooltipel");\n                let formatednodename;\n                if (node.classid == "ddcolumn") {\n                  if (this.isasset) {\n                    node.starttime = moment(node.starttime).format(\n                      "yyyy-mm-dd hh:mm:ss"\n                    );\n                  }\n                  formatednodename = ` <div class="detailbox">\n            <p style="text-align: left;color: #006ad3;font-weight: bold;padding: 0;"> ${\n                  node.instcode\n                }</p>\n              <div style="display: flex;justify-content: flex-start;flex-wrap: nowrap;margin: 5px 0;">\n              <span style="color: #7d7d7d;white-space: nowrap;">字段中文名：</span>\n              <span style="color: #333333;white-space: nowrap;">${\n                  node.instname\n                }</span>\n  </div>\n             <div style="display: flex;justify-content: flex-start;flex-wrap: nowrap;margin: 5px 0;">\n              <span style="color: #7d7d7d;white-space: nowrap;">所属表：</span>\n              <span style="color: #333333;white-space: nowrap;">${\n                  node.tabcode\n                }</span>\n  </div>\n            <div style="display: flex;justify-content: flex-start;flex-wrap: nowrap;margin: 5px 0;">\n              <span style="color: #7d7d7d;white-space: nowrap;">数据库：</span>\n              <span style="color: #333333;white-space: nowrap;">${\n                  node.dbname ? node.dbname : node.dbcode\n                }</span>\n  </div>\n                        <div style="display: flex;justify-content: flex-start;flex-wrap: nowrap;margin: 5px 0;">\n              <span style="color: #7d7d7d;white-space: nowrap;">所属系统：</span>\n              <span style="color: #333333;white-space: nowrap;">${\n                  node.sysname ? node.sysname : node.syscode\n                }</span>\n  </div>\n            <div style="display: flex;justify-content: flex-start;flex-wrap: nowrap;margin: 5px 0;">\n              <span style="color: #7d7d7d;white-space: nowrap;">创建时间：</span>\n              <span style="color: #333333;white-space: nowrap;"> ${\n                  node.starttime\n                }</span>\n  </div>\n  </div>`;\n                } else {\n                  if (this.isasset) {\n                    node.starttime = moment(node.starttime).format(\n                      "yyyy-mm-dd hh:mm:ss"\n                    );\n                  }\n                  formatednodename = ` <div class="detailbox">\n            <p style="text-align: left;color: #006ad3;font-weight: bold;padding: 0;"> ${\n                  node.instcode\n                }</p>\n              <div style="display: flex;justify-content: flex-start;flex-wrap: nowrap;margin: 5px 0;">\n              <span style="color: #7d7d7d;white-space: nowrap;">表中文名：</span>\n              <span style="color: #333333;white-space: nowrap;"> ${\n                  node.instname\n                }</span>\n  </div>\n            <div style="display: flex;justify-content: flex-start;flex-wrap: nowrap;margin: 5px 0;">\n              <span style="color: #7d7d7d;white-space: nowrap;">所属系统：</span>\n              <span style="color: #333333;white-space: nowrap;">${\n                  node.sysname ? node.sysname : node.syscode\n                }</span>\n  </div>\n            <div style="display: flex;justify-content: flex-start;flex-wrap: nowrap;margin: 5px 0;">\n              <span style="color: #7d7d7d;white-space: nowrap;">数据库：</span>\n              <span style="color: #333333;white-space: nowrap;">${\n                  node.dbname ? node.dbname : node.dbcode\n                }</span>\n  </div>\n            <div style="display: flex;justify-content: flex-start;flex-wrap: nowrap;margin: 5px 0;">\n              <span style="color: #7d7d7d;white-space: nowrap;">创建时间：</span>\n              <span style="color: #333333;white-space: nowrap;"> ${\n                  node.starttime\n                }</span>\n  </div>\n  </div>`;\n                }\n                // console.log(\'eeeeeeeeeeee\', e, nodename, formatednodename);\n                tooltipel.innerhtml = `${formatednodename}`;\n                // tooltip是相对于画布canvas element绝对定位，所以position的x，y必须是相对于画布的坐标\n                tooltipel.style.left = event.canvasx + "px";\n                tooltipel.style.top = event.canvasy + 40 + "px";\n                tooltipel.style.display = "block";\n                tooltipel.style.position = "absolute";\n                tooltipel.style.border = "1px solid #e2e2e2";\n                tooltipel.style.borderradius = "4px";\n                tooltipel.style.backgroundcolor = "rgba(255, 255, 255, 0.9)";\n                tooltipel.style.boxshadow = "rgb(174, 174, 174) 0px 0px 10px";\n                tooltipel.style.padding = "10px 8px";\n              }, 500); //停顿两秒\n            }\n          });\n          // 鼠标移出节点\n          that.graph.on("node:mouseleave", event => {\n            if (tooltipel) {\n              tooltipel.style.display = "none";\n              window.cleartimeout(this.timeoutid);\n              this.timeoutid = null;\n            }\n          });\n          // 让画布内容适应视口\n          // console.log(this.fullscreen, "this.fullscreen");\n          that.graph.fitview();\n          that.graph.zoomto(that.zoomsize);\n          that.graph.fitcenter();\n          that.graph.focusitem(data.id, true);\n          if (that.graphtype == "01") {\n            that.graph.translate(-width / 2 + 20, -50);\n          } else if (this.graphtype == "02") {\n            that.graph.translate(width / 4, -50);\n          } else {\n            that.graph.translate(-100, -50);\n          }\n        });\n      }\n    }\n  };\n<\/script>\n\n<style lang="less" scoped>\n  .metadmap {\n    position: relative;\n    .flexbox {\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n      padding: 5px 0;\n      border-bottom: 1px solid #c9c9c9;\n      > div {\n        display: flex;\n        align-items: center;\n        i {\n          font-size: 16px;\n          cursor: pointer;\n        }\n        .buttonbox {\n          display: flex;\n          justify-content: flex-start;\n          border: 1px solid #dcdee0;\n          color: #323233;\n          .activebg {\n            background: #e5f0fa;\n            color: #006ad3;\n            border: 1px solid #006ad3 !important;\n          }\n          .centerspan {\n            border-left: 1px solid #dcdee0;\n            border-right: 1px solid #dcdee0;\n          }\n          span {\n            padding: 5px 20px;\n            cursor: pointer;\n            white-space: nowrap;\n          }\n        }\n        .el-select {\n          border-radius: 0;\n          height: 30px;\n        }\n      }\n    }\n\n    .detail {\n      position: absolute;\n      right: 0;\n      top: 0;\n      background: #fff;\n      border: 1px solid #ccc;\n      z-index: 2001;\n      .drawerbox {\n        position: relative;\n        .clickicon {\n          width: 100px;\n          height: 0;\n          border-top: 20px solid blue;\n          border-left: 20px solid transparent;\n          border-right: 20px solid transparent;\n          position: absolute;\n          top: 50%;\n          left: -80px;\n          transform: rotate(90deg);\n        }\n      }\n    }\n\n    .right-slide-enter,\n    .right-slide-leave-active {\n      transform: translatex(130px);\n    }\n\n    .right-slide-leave-active,\n    .right-slide-enter-active {\n      transition: all0.3s;\n    }\n    .nodebox {\n      position: relative;\n      cursor: pointer;\n      &:hover {\n        .detailbox {\n          z-index: 2002;\n          display: block;\n        }\n      }\n    }\n  }\n</style>\n\n\n\n# detaildrawer.vue文件\n\n<template>\n<div class="detaildrawer">\n  <h3 class="color-font">{{ drawerdata.instcode }}</h3>\n  <tabledetail v-if="istable" :drawerdata="drawerdata" />\n  <columndetail :drawerdata="alldata" v-if="showcol" />\n  </div>\n</template>\n\n<script>\n  import workbenchservice from "@/services/workbenchservice";\n  import tabledetail from "./inner/tabledetail";\n  import columndetail from "./inner/columndetail";\n\n  export default {\n    props: {\n      drawerdata: {\n        type: object,\n        default: () => {\n          return {};\n        }\n      }\n    },\n    components: {\n      tabledetail,\n      columndetail\n    },\n    watch: {\n      drawerdata: {\n        immediate: true,\n        deep: true,\n        handler(newval) {\n          console.log(newval, "newval");\n          this.istable = false;\n\n          if (newval.classid == "ddtable") {\n            this.istable = true;\n          } else {\n            this.showcol = false;\n            // 获取该字段所有详情数据\n            this.getmetabaseinfo();\n          }\n        }\n      }\n    },\n    data() {\n      return {\n        allhtmldata: [],\n        istable: false, //是否为表类型\n        alldata: {},\n        showcol: false\n      };\n    },\n    methods: {\n      async getmetabaseinfo() {\n        let params = {\n          instid: this.drawerdata.instid\n        };\n        const response = await workbenchservice.getmetabaseinfo(params);\n        console.log(response);\n        this.alldata = response.data;\n        this.showcol = true;\n      }\n    }\n  };\n<\/script>\n\n<style lang="less" scoped>\n  .detaildrawer {\n    height: calc(100vh - 98px);\n    overflow: auto;\n    h3 {\n      color: #016dbf;\n      text-align: center;\n      border-bottom: 1px solid #efefef;\n      padding: 10px 0;\n      margin: 0;\n      font-weight: bold;\n    }\n    .card {\n      padding: 10px;\n      .titlestyle {\n        color: #333;\n      }\n      p {\n        display: flex;\n        align-items: center;\n        justify-content: space-between;\n      }\n      .tablestyle {\n        border-top: 1px solid #efefef;\n        border-left: 1px solid #efefef;\n        .linestyle {\n          .bgtd {\n            background: #fafafa;\n          }\n        }\n        .spanitem {\n          display: block;\n          word-break: break-word;\n          padding: 5px 0px 5px 5px;\n          width: 130px;\n          text-align: left;\n          border-right: 1px solid #efefef;\n          border-bottom: 1px solid #efefef;\n        }\n      }\n    }\n  }\n</style>\n\n\n\n# tabledetail.vue文件\n\n<template>\n  <el-tabs tab-position="top" v-model="activename">\n    \x3c!-- 字段信息 --\x3e\n    <el-tab-pane :label="$i18ns(\'fieldmessage\')" name="fieldinfo">\n      <el-table\n        :data="tabledata"\n        tooltip-effect="light"\n        border\n        stripe\n        style="width: 100%"\n        :header-cell-style="{ background: \'inherit!important\' }"\n        align="left"\n      >\n        <el-table-column type="index" width="50" :label="$i18ns(\'序号\')">\n        </el-table-column>\n        <el-table-column\n          prop="instcode"\n          :label="$i18ns(\'fieldenname\')"\n          show-overflow-tooltip\n        ></el-table-column>\n        <el-table-column\n          prop="instname"\n          :label="$i18ns(\'fieldcnname\')"\n          show-overflow-tooltip\n        ></el-table-column>\n      </el-table>\n      \x3c!-- 分页 --\x3e\n      <my-pagination\n        :pagenum="pagenum"\n        :pagesize="pagesize"\n        :total="total"\n        @handlesizechange="handlesizechange"\n        @handlecurrentchange="handlecurrentchange"\n      />\n    </el-tab-pane>\n    \x3c!-- 属性信息 --\x3e\n    <el-tab-pane :label="$i18ns(\'属性信息\')" name="featureinfo">\n      <columndetail :drawerdata="drawerdata" />\n    </el-tab-pane>\n  </el-tabs>\n</template>\n\n<script>\nimport datamanaservice from "@/services/datamanaservice";\nimport columndetail from "./columndetail";\n\nexport default {\n  props: {\n    drawerdata: {\n      type: object,\n      default: () => {\n        return {};\n      },\n    },\n  },\n    components: {\n    columndetail,\n  },\n  data() {\n    return {\n      pagenum: 1,\n      pagesize: 10, //多少条\n      total: 0,\n      tabledata: [],\n      activename: "fieldinfo",\n      alldata: {},\n    };\n  },\n  created() {\n    this.listcolumnpage();\n  },\n  methods: {\n    // 获取字段列表\n    async listcolumnpage() {\n      let params = {\n        parentid: this.drawerdata.instid,\n        pagenum: this.pagenum,\n        pagesize: this.pagesize,\n      };\n      const { data, code } = await datamanaservice.listcolumnpage(params);\n      this.tabledata = data.list;\n      this.total = data.total;\n    },\n    //每页多少条\n    handlesizechange(val) {\n      this.pagenum = 1;\n      this.pagesize = val;\n      this.listcolumnpage();\n    },\n    //当前是第几页\n    handlecurrentchange(val) {\n      this.pagenum = val;\n      this.listcolumnpage();\n    },\n  },\n};\n<\/script>\n\n<style>\n</style>\n\n\n\n# columndetail.vue文件\n\n<template>\n<div class="detaildrawer">\n  <div\n       class="card"\n       v-for="item in allhtmldata"\n       :key="item.name"\n       v-show="item.htmldata.length !== 0"\n       >\n    <p>\n      <span class="titlestyle">{{ $i18ns(item.name) }}</span>\n      <i\n         :class="item.show ? \'el-icon-caret-top\' : \'el-icon-caret-bottom\'"\n         @click="item.show = !item.show"\n         ></i>\n  </p>\n\n    <div class="tablestyle" v-if="item.show">\n      <div\n           v-for="inneritem in item.htmldata"\n           :key="inneritem.fetrclss"\n           class="linestyle"\n           >\n        <template v-if="inneritem.parmcode == \'namespaces\'">\n          <span\n                style="display: flex"\n                v-for="(inner, index) in drawerdata.namespaces"\n                :key="index"\n                >\n            <span class="bgtd spanitem">{{\n              $i18ns("挂载目录") + (index + 1) + ":"\n              }}</span>\n            <span class="contd spanitem">\n              {{ inner }}\n  </span>\n  </span>\n</template>\n<span v-else style="display: flex">\n  <span class="bgtd spanitem">{{\n    $i18ns(inneritem.name) + ":"\n    }}</span>\n\n  <span\n        class="contd spanitem"\n        v-if="drawerdata.fetrlist && drawerdata.fetrlist.length > 0"\n        >\n    {{\n    drawerdata.fetrlist[0].hasownproperty(inneritem.parmcode)\n    ? drawerdata.fetrlist[0][inneritem.parmcode]\n    : drawerdata[inneritem.parmcode]\n    }}\n  </span>\n  <span class="contd spanitem" v-else>\n    {{ drawerdata[inneritem.parmcode] }}\n  </span>\n</span>\n</div>\n</div>\n</div>\n</div>\n</template>\n\n<script>\n  import datamanaservice from "@/services/datamanaservice";\n\n  export default {\n    props: ["drawerdata"],\n    data() {\n      return {\n        allhtmldata: [],\n      };\n    },\n    created() {\n      this.basefetrandclss();\n    },\n    methods: {\n      async basefetrandclss() {\n        const queryparams = {\n          clssid: this.drawerdata.classid,\n        };\n        const deferdata = await datamanaservice.basefetrandclss(queryparams);\n\n        if (number(deferdata.code) === 200) {\n          var tabledata = deferdata.data.parentlist;\n\n          var basic = [],\n              business = [],\n              technique = [],\n              manage = [];\n          for (let index = 0; index < tabledata.length; index++) {\n            if (\n              tabledata[index].fetrclss == "basic" &&\n              tabledata[index].isshow == "t"\n            ) {\n              // 基础属性\n              basic.push(tabledata[index]);\n            } else if (\n              tabledata[index].fetrclss == "business" &&\n              tabledata[index].isshow == "t"\n            ) {\n              // 业务属性\n              business.push(tabledata[index]);\n            } else if (\n              tabledata[index].fetrclss == "technique" &&\n              tabledata[index].isshow == "t"\n            ) {\n              // 技术属性\n              technique.push(tabledata[index]);\n            } else if (\n              tabledata[index].fetrclss == "manage" &&\n              tabledata[index].isshow == "t"\n            ) {\n              // 管理属性\n              manage.push(tabledata[index]);\n            }\n          }\n          basic.unshift({\n            name: "挂载目录",\n            parmcode: "namespaces",\n          });\n          this.allhtmldata = [\n            {\n              name: "basicattributes",\n              htmldata: basic,\n              show: true,\n            },\n            {\n              name: "businessattributes",\n              htmldata: business,\n              show: true,\n            },\n            {\n              name: "technicalattributes",\n              htmldata: technique,\n              show: true,\n            },\n            {\n              name: "manageattributes",\n              htmldata: manage,\n              show: true,\n            },\n          ];\n        }\n      },\n    },\n  };\n<\/script>\n\n<style lang="less" scoped>\n  .detaildrawer {\n    height: calc(100vh - 98px);\n    overflow: auto;\n    h3 {\n      color: #016dbf;\n      text-align: center;\n      border-bottom: 1px solid #efefef;\n      padding: 10px 0;\n      margin: 0;\n      font-weight: bold;\n    }\n    .card {\n      padding: 10px;\n      .titlestyle {\n        color: #333;\n      }\n      p {\n        display: flex;\n        align-items: center;\n        justify-content: space-between;\n      }\n      .tablestyle {\n        border-top: 1px solid #efefef;\n        border-left: 1px solid #efefef;\n        .linestyle {\n          .bgtd {\n            background: #fafafa;\n          }\n        }\n        .spanitem {\n          display: block;\n          word-break: break-word;\n          padding: 5px 0px 5px 5px;\n          width: 130px;\n          text-align: left;\n          border-right: 1px solid #efefef;\n          border-bottom: 1px solid #efefef;\n        }\n      }\n    }\n  }\n</style>\n\n\n\n# 以资产的数据为例\n\n\n# 效果图\n\n\n\n\n# 表级[dataassetmanaservice.getassetdetail]最全的数据\n\n{\n  "code": 200,\n  "message": "操作成功",\n  "data": {\n    "instid": "00186c9ae3329e2a43e95ba05acfdbb6",\n    "instcode": "at000005501",\n    "instcnname": "元数据变更登记表",\n    "instenname": "t_dev_md_check",\n    "classid": "subjectdata",\n    "fromclassid": "ddtable",\n    "parentid": "3d86419dec054006b1cb8dd88ae6855a",\n    "namespaceid": "/subjectdata/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/00186c9ae3329e2a43e95ba05acfdbb6",\n    "namespacecode": "/subjectdata/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/at000005501",\n    "orgid": "prod.r&d.center",\n    "starttime": "2023-07-13t08:26:55.000+0000",\n    "status": "01",\n    "creater": "system",\n    "pageview": 330,\n    "ownervercode": "da_v0.0.2",\n    "verid": "",\n    "verdate": "",\n    "lucenceflushdate": "",\n    "mdhash": "cb399b0bbe3312871809ddcdf81511f2",\n    "syscode": "dap6",\n    "sysname": "",\n    "dbcode": "dap6",\n    "dbname": "",\n    "schcode": "dap6",\n    "tabcode": "",\n    "tabname": "",\n    "corpid": "1",\n    "rsvstr1": "",\n    "rsvstr2": "",\n    "rsvstr3": "",\n    "rsvstr4": "",\n    "rsvstr5": "",\n    "rsvstr6": "dap6",\n    "rsvstr7": "dap6",\n    "rsvstr8": "dap6",\n    "rsvstr9": "",\n    "rsvstr10": "23333",\n    "rsvstr11": "",\n    "rsvstr12": "",\n    "rsvstr13": "",\n    "rsvstr14": "",\n    "rsvstr15": "",\n    "rsvstr16": "",\n    "rsvstr17": "",\n    "rsvstr18": "",\n    "rsvstr19": "",\n    "rsvstr20": "",\n    "rsvstr21": "",\n    "rsvstr22": "",\n    "rsvstr23": "",\n    "rsvstr24": "",\n    "rsvstr25": "",\n    "rsvstr26": "",\n    "rsvstr27": "",\n    "rsvstr28": "",\n    "rsvstr29": "",\n    "rsvstr30": "",\n    "rsvstr31": "",\n    "rsvstr32": "",\n    "rsvstr33": "",\n    "rsvstr34": "",\n    "rsvstr35": "",\n    "rsvstr36": "",\n    "rsvstr37": "",\n    "rsvstr38": "",\n    "rsvstr39": "",\n    "rsvstr40": "",\n    "filterlist": "",\n    "fetrlist": [\n      {\n        "rsvstr7": "dap6",\n        "instcnname": "元数据变更登记表",\n        "rsvstr8": "dap6",\n        "instenname": "t_dev_md_check",\n        "instcode": "at000005501",\n        "rsvstr10": "23333",\n        "orgid": "产品研发部"\n      }\n    ],\n    "namespaces": [\n      "/金融市场/运营管理/网点管理"\n    ],\n    "fullpath": "/主题数据/公共汇总层/协议/金融账户",\n    "leaf": false\n  }\n}\n\n\n\n# 字段级[dataassetregistrationservice.getlistitembypidandtype]\n\n{\n  "code": 200,\n  "message": "操作成功",\n  "data": {\n    "total": 14,\n    "list": [\n      {\n        "instid": "056fc76a48401e18cd7dc5636cffb2ef",\n        "instcode": "sys_code",\n        "instcnname": "系统编号",\n        "instenname": "sys_code",\n        "classid": "subjectdataitem",\n        "fromclassid": "ddcolumn",\n        "parentid": "00186c9ae3329e2a43e95ba05acfdbb6",\n        "namespaceid": "/subjectdata/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/00186c9ae3329e2a43e95ba05acfdbb6/056fc76a48401e18cd7dc5636cffb2ef",\n        "namespacecode": "/subjectdata/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/at000005501/sys_code",\n        "orgid": "",\n        "starttime": "2023-07-13t08:26:55.000+0000",\n        "creater": "system",\n        "mdhash": "a3d2fbbfe03e6bc9b4e51d0ca119e483",\n        "syscode": "dap6",\n        "sysname": "",\n        "dbcode": "",\n        "dbname": "",\n        "schcode": "",\n        "tabcode": "",\n        "tabname": "",\n        "corpid": "",\n        "rsvstr1": "varchar(50)",\n        "rsvstr2": "n",\n        "rsvstr3": "",\n        "rsvstr4": "2",\n        "rsvstr5": "10",\n        "rsvstr6": "2",\n        "rsvstr7": "",\n        "rsvstr8": "",\n        "rsvstr9": "",\n        "rsvstr10": "",\n        "rsvstr11": "",\n        "rsvstr12": "",\n        "rsvstr13": "",\n        "rsvstr14": "",\n        "rsvstr15": "",\n        "rsvstr16": "",\n        "rsvstr17": "",\n        "rsvstr18": "",\n        "rsvstr19": "",\n        "rsvstr20": "",\n        "rsvstr21": "",\n        "rsvstr22": "",\n        "rsvstr23": "",\n        "rsvstr24": "",\n        "rsvstr25": "",\n        "rsvstr26": "",\n        "rsvstr27": "",\n        "rsvstr28": "",\n        "rsvstr29": "",\n        "rsvstr30": "",\n        "rsvstr31": "",\n        "rsvstr32": "",\n        "rsvstr33": "",\n        "rsvstr34": "",\n        "rsvstr35": "",\n        "rsvstr36": "",\n        "rsvstr37": "",\n        "rsvstr38": "",\n        "rsvstr39": "",\n        "rsvstr40": "",\n        "pagesize": "",\n        "pagenum": "",\n        "apprstatus": "",\n        "altertype": "",\n        "fetrlist": [\n          {\n            "rsvstr6": "c2",\n            "rsvstr4": "2",\n            "rsvstr5": "配偶及子女情况",\n            "instcnname": "系统编号",\n            "instenname": "sys_code",\n            "rsvstr2": "否",\n            "rsvstr1": "varchar(50)"\n          }\n        ]\n      },\n      {\n        "instid": "11f9cec7cd06e168b811ba605b6acb8a",\n        "instcode": "sys_name",\n        "instcnname": "系统名称",\n        "instenname": "sys_name",\n        "classid": "subjectdataitem",\n        "fromclassid": "ddcolumn",\n        "parentid": "00186c9ae3329e2a43e95ba05acfdbb6",\n        "namespaceid": "/subjectdata/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/00186c9ae3329e2a43e95ba05acfdbb6/11f9cec7cd06e168b811ba605b6acb8a",\n        "namespacecode": "/subjectdata/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/at000005501/sys_name",\n        "orgid": "",\n        "starttime": "2023-07-13t08:26:55.000+0000",\n        "creater": "system",\n        "mdhash": "5fd0ba46e4f2c02cfd0dbf9f1aa12351",\n        "syscode": "dap6",\n        "sysname": "",\n        "dbcode": "",\n        "dbname": "",\n        "schcode": "",\n        "tabcode": "",\n        "tabname": "",\n        "corpid": "",\n        "rsvstr1": "varchar(255)",\n        "rsvstr2": "n",\n        "rsvstr3": "",\n        "rsvstr4": "2",\n        "rsvstr5": "14",\n        "rsvstr6": "3",\n        "rsvstr7": "",\n        "rsvstr8": "",\n        "rsvstr9": "",\n        "rsvstr10": "",\n        "rsvstr11": "",\n        "rsvstr12": "",\n        "rsvstr13": "",\n        "rsvstr14": "",\n        "rsvstr15": "",\n        "rsvstr16": "",\n        "rsvstr17": "",\n        "rsvstr18": "",\n        "rsvstr19": "",\n        "rsvstr20": "",\n        "rsvstr21": "",\n        "rsvstr22": "",\n        "rsvstr23": "",\n        "rsvstr24": "",\n        "rsvstr25": "",\n        "rsvstr26": "",\n        "rsvstr27": "",\n        "rsvstr28": "",\n        "rsvstr29": "",\n        "rsvstr30": "",\n        "rsvstr31": "",\n        "rsvstr32": "",\n        "rsvstr33": "",\n        "rsvstr34": "",\n        "rsvstr35": "",\n        "rsvstr36": "",\n        "rsvstr37": "",\n        "rsvstr38": "",\n        "rsvstr39": "",\n        "rsvstr40": "",\n        "pagesize": "",\n        "pagenum": "",\n        "apprstatus": "",\n        "altertype": "",\n        "fetrlist": [\n          {\n            "rsvstr6": "c3",\n            "rsvstr4": "2",\n            "rsvstr5": "企业（个人）信用等级",\n            "instcnname": "系统名称",\n            "instenname": "sys_name",\n            "rsvstr2": "否",\n            "rsvstr1": "varchar(255)"\n          }\n        ]\n      },\n      {\n        "instid": "191115812190db6112c231c31aa356a2",\n        "instcode": "ver_no",\n        "instcnname": "版本号",\n        "instenname": "ver_no",\n        "classid": "subjectdataitem",\n        "fromclassid": "ddcolumn",\n        "parentid": "00186c9ae3329e2a43e95ba05acfdbb6",\n        "namespaceid": "/subjectdata/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/00186c9ae3329e2a43e95ba05acfdbb6/191115812190db6112c231c31aa356a2",\n        "namespacecode": "/subjectdata/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/at000005501/ver_no",\n        "orgid": "",\n        "starttime": "2023-07-13t08:26:55.000+0000",\n        "creater": "system",\n        "mdhash": "143aa441acc79edd8060c92df05b9182",\n        "syscode": "dap6",\n        "sysname": "",\n        "dbcode": "",\n        "dbname": "",\n        "schcode": "",\n        "tabcode": "",\n        "tabname": "",\n        "corpid": "",\n        "rsvstr1": "varchar(50)",\n        "rsvstr2": "n",\n        "rsvstr3": "",\n        "rsvstr4": "3",\n        "rsvstr5": "",\n        "rsvstr6": "3",\n        "rsvstr7": "",\n        "rsvstr8": "",\n        "rsvstr9": "",\n        "rsvstr10": "",\n        "rsvstr11": "",\n        "rsvstr12": "",\n        "rsvstr13": "",\n        "rsvstr14": "",\n        "rsvstr15": "",\n        "rsvstr16": "",\n        "rsvstr17": "",\n        "rsvstr18": "",\n        "rsvstr19": "",\n        "rsvstr20": "",\n        "rsvstr21": "",\n        "rsvstr22": "",\n        "rsvstr23": "",\n        "rsvstr24": "",\n        "rsvstr25": "",\n        "rsvstr26": "",\n        "rsvstr27": "",\n        "rsvstr28": "",\n        "rsvstr29": "",\n        "rsvstr30": "",\n        "rsvstr31": "",\n        "rsvstr32": "",\n        "rsvstr33": "",\n        "rsvstr34": "",\n        "rsvstr35": "",\n        "rsvstr36": "",\n        "rsvstr37": "",\n        "rsvstr38": "",\n        "rsvstr39": "",\n        "rsvstr40": "",\n        "pagesize": "",\n        "pagenum": "",\n        "apprstatus": "",\n        "altertype": "",\n        "fetrlist": [\n          {\n            "rsvstr6": "c3",\n            "rsvstr4": "3",\n            "instcnname": "版本号",\n            "instenname": "ver_no",\n            "rsvstr2": "否",\n            "rsvstr1": "varchar(50)"\n          }\n        ]\n      },\n      {\n        "instid": "4303589b5131d6450b44024891639d3b",\n        "instcode": "check_id",\n        "instcnname": "登记编号",\n        "instenname": "check_id",\n        "classid": "subjectdataitem",\n        "fromclassid": "ddcolumn",\n        "parentid": "00186c9ae3329e2a43e95ba05acfdbb6",\n        "namespaceid": "/subjectdata/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/00186c9ae3329e2a43e95ba05acfdbb6/4303589b5131d6450b44024891639d3b",\n        "namespacecode": "/subjectdata/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/at000005501/check_id",\n        "orgid": "",\n        "starttime": "2023-07-13t08:26:55.000+0000",\n        "creater": "system",\n        "mdhash": "9c43195ed115dfda9cd464d43c5d256a",\n        "syscode": "dap6",\n        "sysname": "",\n        "dbcode": "",\n        "dbname": "",\n        "schcode": "",\n        "tabcode": "",\n        "tabname": "",\n        "corpid": "",\n        "rsvstr1": "varchar(50)",\n        "rsvstr2": "y",\n        "rsvstr3": "",\n        "rsvstr4": "3",\n        "rsvstr5": "",\n        "rsvstr6": "3",\n        "rsvstr7": "",\n        "rsvstr8": "",\n        "rsvstr9": "",\n        "rsvstr10": "",\n        "rsvstr11": "",\n        "rsvstr12": "",\n        "rsvstr13": "",\n        "rsvstr14": "",\n        "rsvstr15": "",\n        "rsvstr16": "",\n        "rsvstr17": "",\n        "rsvstr18": "",\n        "rsvstr19": "",\n        "rsvstr20": "",\n        "rsvstr21": "",\n        "rsvstr22": "",\n        "rsvstr23": "",\n        "rsvstr24": "",\n        "rsvstr25": "",\n        "rsvstr26": "",\n        "rsvstr27": "",\n        "rsvstr28": "",\n        "rsvstr29": "",\n        "rsvstr30": "",\n        "rsvstr31": "",\n        "rsvstr32": "",\n        "rsvstr33": "",\n        "rsvstr34": "",\n        "rsvstr35": "",\n        "rsvstr36": "",\n        "rsvstr37": "",\n        "rsvstr38": "",\n        "rsvstr39": "",\n        "rsvstr40": "",\n        "pagesize": "",\n        "pagenum": "",\n        "apprstatus": "",\n        "altertype": "",\n        "fetrlist": [\n          {\n            "rsvstr6": "c3",\n            "rsvstr4": "3",\n            "instcnname": "登记编号",\n            "instenname": "check_id",\n            "rsvstr2": "是",\n            "rsvstr1": "varchar(50)"\n          }\n        ]\n      },\n      {\n        "instid": "51bd518bc8686605daa461ca2016b2c0",\n        "instcode": "reg_user",\n        "instcnname": "变更人",\n        "instenname": "reg_user",\n        "classid": "subjectdataitem",\n        "fromclassid": "ddcolumn",\n        "parentid": "00186c9ae3329e2a43e95ba05acfdbb6",\n        "namespaceid": "/subjectdata/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/00186c9ae3329e2a43e95ba05acfdbb6/51bd518bc8686605daa461ca2016b2c0",\n        "namespacecode": "/subjectdata/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/at000005501/reg_user",\n        "orgid": "",\n        "starttime": "2023-07-13t08:26:55.000+0000",\n        "creater": "system",\n        "mdhash": "26a4c88cb4c9fd7bb57852218f39ce4f",\n        "syscode": "dap6",\n        "sysname": "",\n        "dbcode": "",\n        "dbname": "",\n        "schcode": "",\n        "tabcode": "",\n        "tabname": "",\n        "corpid": "",\n        "rsvstr1": "varchar(50)",\n        "rsvstr2": "n",\n        "rsvstr3": "",\n        "rsvstr4": "3",\n        "rsvstr5": "",\n        "rsvstr6": "3",\n        "rsvstr7": "",\n        "rsvstr8": "",\n        "rsvstr9": "",\n        "rsvstr10": "",\n        "rsvstr11": "",\n        "rsvstr12": "",\n        "rsvstr13": "",\n        "rsvstr14": "",\n        "rsvstr15": "",\n        "rsvstr16": "",\n        "rsvstr17": "",\n        "rsvstr18": "",\n        "rsvstr19": "",\n        "rsvstr20": "",\n        "rsvstr21": "",\n        "rsvstr22": "",\n        "rsvstr23": "",\n        "rsvstr24": "",\n        "rsvstr25": "",\n        "rsvstr26": "",\n        "rsvstr27": "",\n        "rsvstr28": "",\n        "rsvstr29": "",\n        "rsvstr30": "",\n        "rsvstr31": "",\n        "rsvstr32": "",\n        "rsvstr33": "",\n        "rsvstr34": "",\n        "rsvstr35": "",\n        "rsvstr36": "",\n        "rsvstr37": "",\n        "rsvstr38": "",\n        "rsvstr39": "",\n        "rsvstr40": "",\n        "pagesize": "",\n        "pagenum": "",\n        "apprstatus": "",\n        "altertype": "",\n        "fetrlist": [\n          {\n            "rsvstr6": "c3",\n            "rsvstr4": "3",\n            "instcnname": "变更人",\n            "instenname": "reg_user",\n            "rsvstr2": "否",\n            "rsvstr1": "varchar(50)"\n          }\n        ]\n      },\n      {\n        "instid": "7b19ddcb782d0638145fadea79b562f2",\n        "instcode": "des_email",\n        "instcnname": "邮件通知已卸数表 0:未发送 1:已发送成功过  发送失败原因",\n        "instenname": "des_email",\n        "classid": "subjectdataitem",\n        "fromclassid": "ddcolumn",\n        "parentid": "00186c9ae3329e2a43e95ba05acfdbb6",\n        "namespaceid": "/subjectdata/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/00186c9ae3329e2a43e95ba05acfdbb6/7b19ddcb782d0638145fadea79b562f2",\n        "namespacecode": "/subjectdata/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/at000005501/des_email",\n        "orgid": "",\n        "starttime": "2023-07-13t08:26:55.000+0000",\n        "creater": "system",\n        "mdhash": "2c770ac1adb3a6c1def49583e6d5fcfd",\n        "syscode": "dap6",\n        "sysname": "",\n        "dbcode": "",\n        "dbname": "",\n        "schcode": "",\n        "tabcode": "",\n        "tabname": "",\n        "corpid": "",\n        "rsvstr1": "varchar(255)",\n        "rsvstr2": "n",\n        "rsvstr3": "",\n        "rsvstr4": "2",\n        "rsvstr5": "11",\n        "rsvstr6": "3",\n        "rsvstr7": "",\n        "rsvstr8": "",\n        "rsvstr9": "",\n        "rsvstr10": "",\n        "rsvstr11": "",\n        "rsvstr12": "",\n        "rsvstr13": "",\n        "rsvstr14": "",\n        "rsvstr15": "",\n        "rsvstr16": "",\n        "rsvstr17": "",\n        "rsvstr18": "",\n        "rsvstr19": "",\n        "rsvstr20": "",\n        "rsvstr21": "",\n        "rsvstr22": "",\n        "rsvstr23": "",\n        "rsvstr24": "",\n        "rsvstr25": "",\n        "rsvstr26": "",\n        "rsvstr27": "",\n        "rsvstr28": "",\n        "rsvstr29": "",\n        "rsvstr30": "",\n        "rsvstr31": "",\n        "rsvstr32": "",\n        "rsvstr33": "",\n        "rsvstr34": "",\n        "rsvstr35": "",\n        "rsvstr36": "",\n        "rsvstr37": "",\n        "rsvstr38": "",\n        "rsvstr39": "",\n        "rsvstr40": "",\n        "pagesize": "",\n        "pagenum": "",\n        "apprstatus": "",\n        "altertype": "",\n        "fetrlist": [\n          {\n            "rsvstr6": "c3",\n            "rsvstr4": "2",\n            "rsvstr5": "系统密钥",\n            "instcnname": "邮件通知已卸数表 0:未发送 1:已发送成功过  发送失败原因",\n            "instenname": "des_email",\n            "rsvstr2": "否",\n            "rsvstr1": "varchar(255)"\n          }\n        ]\n      },\n      {\n        "instid": "9182ba444eaa052a68289f3d534a4a1e",\n        "instcode": "reg_date",\n        "instcnname": "变更时间",\n        "instenname": "reg_date",\n        "classid": "subjectdataitem",\n        "fromclassid": "ddcolumn",\n        "parentid": "00186c9ae3329e2a43e95ba05acfdbb6",\n        "namespaceid": "/subjectdata/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/00186c9ae3329e2a43e95ba05acfdbb6/9182ba444eaa052a68289f3d534a4a1e",\n        "namespacecode": "/subjectdata/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/at000005501/reg_date",\n        "orgid": "",\n        "starttime": "2023-07-13t08:26:55.000+0000",\n        "creater": "system",\n        "mdhash": "b9924e95fde0397138391a8282bd3e8c",\n        "syscode": "dap6",\n        "sysname": "",\n        "dbcode": "",\n        "dbname": "",\n        "schcode": "",\n        "tabcode": "",\n        "tabname": "",\n        "corpid": "",\n        "rsvstr1": "varchar(50)",\n        "rsvstr2": "n",\n        "rsvstr3": "",\n        "rsvstr4": "3",\n        "rsvstr5": "",\n        "rsvstr6": "3",\n        "rsvstr7": "",\n        "rsvstr8": "",\n        "rsvstr9": "",\n        "rsvstr10": "",\n        "rsvstr11": "",\n        "rsvstr12": "",\n        "rsvstr13": "",\n        "rsvstr14": "",\n        "rsvstr15": "",\n        "rsvstr16": "",\n        "rsvstr17": "",\n        "rsvstr18": "",\n        "rsvstr19": "",\n        "rsvstr20": "",\n        "rsvstr21": "",\n        "rsvstr22": "",\n        "rsvstr23": "",\n        "rsvstr24": "",\n        "rsvstr25": "",\n        "rsvstr26": "",\n        "rsvstr27": "",\n        "rsvstr28": "",\n        "rsvstr29": "",\n        "rsvstr30": "",\n        "rsvstr31": "",\n        "rsvstr32": "",\n        "rsvstr33": "",\n        "rsvstr34": "",\n        "rsvstr35": "",\n        "rsvstr36": "",\n        "rsvstr37": "",\n        "rsvstr38": "",\n        "rsvstr39": "",\n        "rsvstr40": "",\n        "pagesize": "",\n        "pagenum": "",\n        "apprstatus": "",\n        "altertype": "",\n        "fetrlist": [\n          {\n            "rsvstr6": "c3",\n            "rsvstr4": "3",\n            "instcnname": "变更时间",\n            "instenname": "reg_date",\n            "rsvstr2": "否",\n            "rsvstr1": "varchar(50)"\n          }\n        ]\n      },\n      {\n        "instid": "92c124123b7f9cc3f31b36271f6e0455",\n        "instcode": "status",\n        "instcnname": "状态",\n        "instenname": "status",\n        "classid": "subjectdataitem",\n        "fromclassid": "ddcolumn",\n        "parentid": "00186c9ae3329e2a43e95ba05acfdbb6",\n        "namespaceid": "/subjectdata/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/00186c9ae3329e2a43e95ba05acfdbb6/92c124123b7f9cc3f31b36271f6e0455",\n        "namespacecode": "/subjectdata/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/at000005501/status",\n        "orgid": "",\n        "starttime": "2023-07-13t08:26:55.000+0000",\n        "creater": "system",\n        "mdhash": "b1e7adfbbedc301c7b3dd58e9cbbba8c",\n        "syscode": "dap6",\n        "sysname": "",\n        "dbcode": "",\n        "dbname": "",\n        "schcode": "",\n        "tabcode": "",\n        "tabname": "",\n        "corpid": "",\n        "rsvstr1": "varchar(32)",\n        "rsvstr2": "n",\n        "rsvstr3": "",\n        "rsvstr4": "2",\n        "rsvstr5": "",\n        "rsvstr6": "1",\n        "rsvstr7": "",\n        "rsvstr8": "",\n        "rsvstr9": "",\n        "rsvstr10": "",\n        "rsvstr11": "",\n        "rsvstr12": "",\n        "rsvstr13": "",\n        "rsvstr14": "",\n        "rsvstr15": "",\n        "rsvstr16": "",\n        "rsvstr17": "",\n        "rsvstr18": "",\n        "rsvstr19": "",\n        "rsvstr20": "",\n        "rsvstr21": "",\n        "rsvstr22": "",\n        "rsvstr23": "",\n        "rsvstr24": "",\n        "rsvstr25": "",\n        "rsvstr26": "",\n        "rsvstr27": "",\n        "rsvstr28": "",\n        "rsvstr29": "",\n        "rsvstr30": "",\n        "rsvstr31": "",\n        "rsvstr32": "",\n        "rsvstr33": "",\n        "rsvstr34": "",\n        "rsvstr35": "",\n        "rsvstr36": "",\n        "rsvstr37": "",\n        "rsvstr38": "",\n        "rsvstr39": "",\n        "rsvstr40": "",\n        "pagesize": "",\n        "pagenum": "",\n        "apprstatus": "",\n        "altertype": "",\n        "fetrlist": [\n          {\n            "rsvstr6": "c1",\n            "rsvstr4": "2",\n            "instcnname": "状态",\n            "instenname": "status",\n            "rsvstr2": "否",\n            "rsvstr1": "varchar(32)"\n          }\n        ]\n      },\n      {\n        "instid": "a221079cfc18d09fba02e3c0d207107b",\n        "instcode": "reg_info",\n        "instcnname": "变更内容",\n        "instenname": "reg_info",\n        "classid": "subjectdataitem",\n        "fromclassid": "ddcolumn",\n        "parentid": "00186c9ae3329e2a43e95ba05acfdbb6",\n        "namespaceid": "/subjectdata/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/00186c9ae3329e2a43e95ba05acfdbb6/a221079cfc18d09fba02e3c0d207107b",\n        "namespacecode": "/subjectdata/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/at000005501/reg_info",\n        "orgid": "",\n        "starttime": "2023-07-13t08:26:55.000+0000",\n        "creater": "system",\n        "mdhash": "793418f290dda0d2fad48df1bdd9465e",\n        "syscode": "dap6",\n        "sysname": "",\n        "dbcode": "",\n        "dbname": "",\n        "schcode": "",\n        "tabcode": "",\n        "tabname": "",\n        "corpid": "",\n        "rsvstr1": "varchar(500)",\n        "rsvstr2": "n",\n        "rsvstr3": "",\n        "rsvstr4": "2",\n        "rsvstr5": "",\n        "rsvstr6": "1",\n        "rsvstr7": "",\n        "rsvstr8": "",\n        "rsvstr9": "",\n        "rsvstr10": "",\n        "rsvstr11": "",\n        "rsvstr12": "",\n        "rsvstr13": "",\n        "rsvstr14": "",\n        "rsvstr15": "",\n        "rsvstr16": "",\n        "rsvstr17": "",\n        "rsvstr18": "",\n        "rsvstr19": "",\n        "rsvstr20": "",\n        "rsvstr21": "",\n        "rsvstr22": "",\n        "rsvstr23": "",\n        "rsvstr24": "",\n        "rsvstr25": "",\n        "rsvstr26": "",\n        "rsvstr27": "",\n        "rsvstr28": "",\n        "rsvstr29": "",\n        "rsvstr30": "",\n        "rsvstr31": "",\n        "rsvstr32": "",\n        "rsvstr33": "",\n        "rsvstr34": "",\n        "rsvstr35": "",\n        "rsvstr36": "",\n        "rsvstr37": "",\n        "rsvstr38": "",\n        "rsvstr39": "",\n        "rsvstr40": "",\n        "pagesize": "",\n        "pagenum": "",\n        "apprstatus": "",\n        "altertype": "",\n        "fetrlist": [\n          {\n            "rsvstr6": "c1",\n            "rsvstr4": "2",\n            "instcnname": "变更内容",\n            "instenname": "reg_info",\n            "rsvstr2": "否",\n            "rsvstr1": "varchar(500)"\n          }\n        ]\n      },\n      {\n        "instid": "b0aba53993d4b6aad99e4e3fcb4778ed",\n        "instcode": "compare_status",\n        "instcnname": "对比结果  0：未对比  1：已对比无差异  2：对比有差异，3对比失败",\n        "instenname": "compare_status",\n        "classid": "subjectdataitem",\n        "fromclassid": "ddcolumn",\n        "parentid": "00186c9ae3329e2a43e95ba05acfdbb6",\n        "namespaceid": "/subjectdata/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/00186c9ae3329e2a43e95ba05acfdbb6/b0aba53993d4b6aad99e4e3fcb4778ed",\n        "namespacecode": "/subjectdata/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/at000005501/compare_status",\n        "orgid": "",\n        "starttime": "2023-07-13t08:26:55.000+0000",\n        "creater": "system",\n        "mdhash": "9d3c6e98f66a5b11ecba564b5e85b06e",\n        "syscode": "dap6",\n        "sysname": "",\n        "dbcode": "",\n        "dbname": "",\n        "schcode": "",\n        "tabcode": "",\n        "tabname": "",\n        "corpid": "",\n        "rsvstr1": "varchar(255)",\n        "rsvstr2": "n",\n        "rsvstr3": "",\n        "rsvstr4": "3",\n        "rsvstr5": "",\n        "rsvstr6": "3",\n        "rsvstr7": "",\n        "rsvstr8": "",\n        "rsvstr9": "",\n        "rsvstr10": "",\n        "rsvstr11": "",\n        "rsvstr12": "",\n        "rsvstr13": "",\n        "rsvstr14": "",\n        "rsvstr15": "",\n        "rsvstr16": "",\n        "rsvstr17": "",\n        "rsvstr18": "",\n        "rsvstr19": "",\n        "rsvstr20": "",\n        "rsvstr21": "",\n        "rsvstr22": "",\n        "rsvstr23": "",\n        "rsvstr24": "",\n        "rsvstr25": "",\n        "rsvstr26": "",\n        "rsvstr27": "",\n        "rsvstr28": "",\n        "rsvstr29": "",\n        "rsvstr30": "",\n        "rsvstr31": "",\n        "rsvstr32": "",\n        "rsvstr33": "",\n        "rsvstr34": "",\n        "rsvstr35": "",\n        "rsvstr36": "",\n        "rsvstr37": "",\n        "rsvstr38": "",\n        "rsvstr39": "",\n        "rsvstr40": "",\n        "pagesize": "",\n        "pagenum": "",\n        "apprstatus": "",\n        "altertype": "",\n        "fetrlist": [\n          {\n            "rsvstr6": "c3",\n            "rsvstr4": "3",\n            "instcnname": "对比结果  0：未对比  1：已对比无差异  2：对比有差异，3对比失败",\n            "instenname": "compare_status",\n            "rsvstr2": "否",\n            "rsvstr1": "varchar(255)"\n          }\n        ]\n      },\n      {\n        "instid": "c18017de0ad6d9a707a6c80cc77080c5",\n        "instcode": "syn_status",\n        "instcnname": "同步结果  0：未同步  1、同步成功 同步失败原因",\n        "instenname": "syn_status",\n        "classid": "subjectdataitem",\n        "fromclassid": "ddcolumn",\n        "parentid": "00186c9ae3329e2a43e95ba05acfdbb6",\n        "namespaceid": "/subjectdata/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/00186c9ae3329e2a43e95ba05acfdbb6/c18017de0ad6d9a707a6c80cc77080c5",\n        "namespacecode": "/subjectdata/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/at000005501/syn_status",\n        "orgid": "",\n        "starttime": "2023-07-13t08:26:55.000+0000",\n        "creater": "system",\n        "mdhash": "13d886db37a34402e350351f40d84c15",\n        "syscode": "dap6",\n        "sysname": "",\n        "dbcode": "",\n        "dbname": "",\n        "schcode": "",\n        "tabcode": "",\n        "tabname": "",\n        "corpid": "",\n        "rsvstr1": "varchar(255)",\n        "rsvstr2": "n",\n        "rsvstr3": "",\n        "rsvstr4": "3",\n        "rsvstr5": "",\n        "rsvstr6": "3",\n        "rsvstr7": "",\n        "rsvstr8": "",\n        "rsvstr9": "",\n        "rsvstr10": "",\n        "rsvstr11": "",\n        "rsvstr12": "",\n        "rsvstr13": "",\n        "rsvstr14": "",\n        "rsvstr15": "",\n        "rsvstr16": "",\n        "rsvstr17": "",\n        "rsvstr18": "",\n        "rsvstr19": "",\n        "rsvstr20": "",\n        "rsvstr21": "",\n        "rsvstr22": "",\n        "rsvstr23": "",\n        "rsvstr24": "",\n        "rsvstr25": "",\n        "rsvstr26": "",\n        "rsvstr27": "",\n        "rsvstr28": "",\n        "rsvstr29": "",\n        "rsvstr30": "",\n        "rsvstr31": "",\n        "rsvstr32": "",\n        "rsvstr33": "",\n        "rsvstr34": "",\n        "rsvstr35": "",\n        "rsvstr36": "",\n        "rsvstr37": "",\n        "rsvstr38": "",\n        "rsvstr39": "",\n        "rsvstr40": "",\n        "pagesize": "",\n        "pagenum": "",\n        "apprstatus": "",\n        "altertype": "",\n        "fetrlist": [\n          {\n            "rsvstr6": "c3",\n            "rsvstr4": "3",\n            "instcnname": "同步结果  0：未同步  1、同步成功 同步失败原因",\n            "instenname": "syn_status",\n            "rsvstr2": "否",\n            "rsvstr1": "varchar(255)"\n          }\n        ]\n      },\n      {\n        "instid": "c89685e9ff561879bcdf489a06959c29",\n        "instcode": "tc_date",\n        "instcnname": "投产日期",\n        "instenname": "tc_date",\n        "classid": "subjectdataitem",\n        "fromclassid": "ddcolumn",\n        "parentid": "00186c9ae3329e2a43e95ba05acfdbb6",\n        "namespaceid": "/subjectdata/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/00186c9ae3329e2a43e95ba05acfdbb6/c89685e9ff561879bcdf489a06959c29",\n        "namespacecode": "/subjectdata/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/at000005501/tc_date",\n        "orgid": "",\n        "starttime": "2023-07-13t08:26:55.000+0000",\n        "creater": "system",\n        "mdhash": "e57e7a296a166136dc117528bdae2e6a",\n        "syscode": "dap6",\n        "sysname": "",\n        "dbcode": "",\n        "dbname": "",\n        "schcode": "",\n        "tabcode": "",\n        "tabname": "",\n        "corpid": "",\n        "rsvstr1": "varchar(32)",\n        "rsvstr2": "n",\n        "rsvstr3": "",\n        "rsvstr4": "2",\n        "rsvstr5": "",\n        "rsvstr6": "1",\n        "rsvstr7": "",\n        "rsvstr8": "",\n        "rsvstr9": "",\n        "rsvstr10": "",\n        "rsvstr11": "",\n        "rsvstr12": "",\n        "rsvstr13": "",\n        "rsvstr14": "",\n        "rsvstr15": "",\n        "rsvstr16": "",\n        "rsvstr17": "",\n        "rsvstr18": "",\n        "rsvstr19": "",\n        "rsvstr20": "",\n        "rsvstr21": "",\n        "rsvstr22": "",\n        "rsvstr23": "",\n        "rsvstr24": "",\n        "rsvstr25": "",\n        "rsvstr26": "",\n        "rsvstr27": "",\n        "rsvstr28": "",\n        "rsvstr29": "",\n        "rsvstr30": "",\n        "rsvstr31": "",\n        "rsvstr32": "",\n        "rsvstr33": "",\n        "rsvstr34": "",\n        "rsvstr35": "",\n        "rsvstr36": "",\n        "rsvstr37": "",\n        "rsvstr38": "",\n        "rsvstr39": "",\n        "rsvstr40": "",\n        "pagesize": "",\n        "pagenum": "",\n        "apprstatus": "",\n        "altertype": "",\n        "fetrlist": [\n          {\n            "rsvstr6": "c1",\n            "rsvstr4": "2",\n            "instcnname": "投产日期",\n            "instenname": "tc_date",\n            "rsvstr2": "否",\n            "rsvstr1": "varchar(32)"\n          }\n        ]\n      },\n      {\n        "instid": "d0e06a6d72929d0a46432e3fb298b5d2",\n        "instcode": "form_id",\n        "instcnname": "流程编号",\n        "instenname": "form_id",\n        "classid": "subjectdataitem",\n        "fromclassid": "ddcolumn",\n        "parentid": "00186c9ae3329e2a43e95ba05acfdbb6",\n        "namespaceid": "/subjectdata/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/00186c9ae3329e2a43e95ba05acfdbb6/d0e06a6d72929d0a46432e3fb298b5d2",\n        "namespacecode": "/subjectdata/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/at000005501/form_id",\n        "orgid": "",\n        "starttime": "2023-07-13t08:26:55.000+0000",\n        "creater": "system",\n        "mdhash": "6d6cad8476be2f1e47a3a5fc00471c86",\n        "syscode": "dap6",\n        "sysname": "",\n        "dbcode": "",\n        "dbname": "",\n        "schcode": "",\n        "tabcode": "",\n        "tabname": "",\n        "corpid": "",\n        "rsvstr1": "varchar(50)",\n        "rsvstr2": "n",\n        "rsvstr3": "",\n        "rsvstr4": "3",\n        "rsvstr5": "",\n        "rsvstr6": "3",\n        "rsvstr7": "",\n        "rsvstr8": "",\n        "rsvstr9": "",\n        "rsvstr10": "",\n        "rsvstr11": "",\n        "rsvstr12": "",\n        "rsvstr13": "",\n        "rsvstr14": "",\n        "rsvstr15": "",\n        "rsvstr16": "",\n        "rsvstr17": "",\n        "rsvstr18": "",\n        "rsvstr19": "",\n        "rsvstr20": "",\n        "rsvstr21": "",\n        "rsvstr22": "",\n        "rsvstr23": "",\n        "rsvstr24": "",\n        "rsvstr25": "",\n        "rsvstr26": "",\n        "rsvstr27": "",\n        "rsvstr28": "",\n        "rsvstr29": "",\n        "rsvstr30": "",\n        "rsvstr31": "",\n        "rsvstr32": "",\n        "rsvstr33": "",\n        "rsvstr34": "",\n        "rsvstr35": "",\n        "rsvstr36": "",\n        "rsvstr37": "",\n        "rsvstr38": "",\n        "rsvstr39": "",\n        "rsvstr40": "",\n        "pagesize": "",\n        "pagenum": "",\n        "apprstatus": "",\n        "altertype": "",\n        "fetrlist": [\n          {\n            "rsvstr6": "c3",\n            "rsvstr4": "3",\n            "instcnname": "流程编号",\n            "instenname": "form_id",\n            "rsvstr2": "否",\n            "rsvstr1": "varchar(50)"\n          }\n        ]\n      },\n      {\n        "instid": "dd1c584f6743d3f4c8a36a837db59a8e",\n        "instcode": "remind_email",\n        "instcnname": "投产当天通知 0：未发送 1:已发送成功 发送失败原因",\n        "instenname": "remind_email",\n        "classid": "subjectdataitem",\n        "fromclassid": "ddcolumn",\n        "parentid": "00186c9ae3329e2a43e95ba05acfdbb6",\n        "namespaceid": "/subjectdata/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/00186c9ae3329e2a43e95ba05acfdbb6/dd1c584f6743d3f4c8a36a837db59a8e",\n        "namespacecode": "/subjectdata/2b5f65d8caa141d8a0ded3598397dc01/6f831520e05c404d9afe520e607fbacf/3d86419dec054006b1cb8dd88ae6855a/at000005501/remind_email",\n        "orgid": "",\n        "starttime": "2023-07-13t08:26:55.000+0000",\n        "creater": "system",\n        "mdhash": "babab10a89cfc60afed0c82d6213c9b9",\n        "syscode": "dap6",\n        "sysname": "",\n        "dbcode": "",\n        "dbname": "",\n        "schcode": "",\n        "tabcode": "",\n        "tabname": "",\n        "corpid": "",\n        "rsvstr1": "varchar(255)",\n        "rsvstr2": "n",\n        "rsvstr3": "",\n        "rsvstr4": "3",\n        "rsvstr5": "",\n        "rsvstr6": "3",\n        "rsvstr7": "",\n        "rsvstr8": "",\n        "rsvstr9": "",\n        "rsvstr10": "",\n        "rsvstr11": "",\n        "rsvstr12": "",\n        "rsvstr13": "",\n        "rsvstr14": "",\n        "rsvstr15": "",\n        "rsvstr16": "",\n        "rsvstr17": "",\n        "rsvstr18": "",\n        "rsvstr19": "",\n        "rsvstr20": "",\n        "rsvstr21": "",\n        "rsvstr22": "",\n        "rsvstr23": "",\n        "rsvstr24": "",\n        "rsvstr25": "",\n        "rsvstr26": "",\n        "rsvstr27": "",\n        "rsvstr28": "",\n        "rsvstr29": "",\n        "rsvstr30": "",\n        "rsvstr31": "",\n        "rsvstr32": "",\n        "rsvstr33": "",\n        "rsvstr34": "",\n        "rsvstr35": "",\n        "rsvstr36": "",\n        "rsvstr37": "",\n        "rsvstr38": "",\n        "rsvstr39": "",\n        "rsvstr40": "",\n        "pagesize": "",\n        "pagenum": "",\n        "apprstatus": "",\n        "altertype": "",\n        "fetrlist": [\n          {\n            "rsvstr6": "c3",\n            "rsvstr4": "3",\n            "instcnname": "投产当天通知 0：未发送 1:已发送成功 发送失败原因",\n            "instenname": "remind_email",\n            "rsvstr2": "否",\n            "rsvstr1": "varchar(255)"\n          }\n        ]\n      }\n    ],\n    "pagenum": 1,\n    "pagesize": 14,\n    "size": 14,\n    "startrow": 0,\n    "endrow": 13,\n    "pages": 1,\n    "prepage": 0,\n    "nextpage": 0,\n    "isfirstpage": true,\n    "islastpage": true,\n    "haspreviouspage": false,\n    "hasnextpage": false,\n    "navigatepages": 8,\n    "navigatepagenums": [\n      1\n    ],\n    "navigatefirstpage": 1,\n    "navigatelastpage": 1,\n    "firstpage": 1,\n    "lastpage": 1\n  }\n}\n\n\n\n# metaanalysisservice.getanalysetoasset获取的数据\n\n{\n  "code": 200,\n  "message": "操作成功",\n  "data": {\n    "blood": {\n      "blood": "",\n      "impact": "",\n      "sessionid": "6a12a8134dd54d2682f629556a8a188e",\n      "layer": "3",\n      "type": "02",\n      "origininstid": "4ae1ce8f388d5b4b02db92dba007ea36",\n      "instid": "4ae1ce8f388d5b4b02db92dba007ea36",\n      "classid": "ddtable",\n      "relations": {},\n      "nodes": [\n        {\n          "instid": "4ae1ce8f388d5b4b02db92dba007ea36",\n          "instcode": "t_dev_md_check",\n          "instname": "元数据变更登记表",\n          "classid": "ddtable",\n          "parentid": "a684856d6e40965138cf24c59672e2d0",\n          "namespaceid": "/datadict_pde/pde_dd7833fb44274e0c9f49d89c1aff151f/bcce37af9d2b493517594f972c536f02/a684856d6e40965138cf24c59672e2d0/4ae1ce8f388d5b4b02db92dba007ea36",\n          "namespacecode": "/datadict_pde/dap6/dap6/dap6/t_dev_md_check",\n          "verid": "6632c106daab47b9a21e54e6b0ce392f",\n          "starttime": "2023-07-10 14:51:18",\n          "isroot": "",\n          "apptype": "md",\n          "status": "",\n          "pageview": 0,\n          "creater": "",\n          "corpid": "default",\n          "rsvstr1": "",\n          "rsvstr2": "",\n          "rsvstr3": "0",\n          "rsvstr4": "",\n          "rsvstr5": "",\n          "rsvstr6": "16384",\n          "rsvstr7": "2022-06-15 10:38:28",\n          "rsvstr8": "",\n          "rsvstr9": "t",\n          "rsvstr10": "",\n          "rsvstr11": "",\n          "rsvstr12": "",\n          "rsvstr13": "",\n          "rsvstr14": "",\n          "rsvstr15": "",\n          "rsvstr16": "",\n          "rsvstr17": "",\n          "rsvstr18": "",\n          "rsvstr19": "",\n          "rsvstr20": "",\n          "rsvstr21": "",\n          "rsvstr22": "",\n          "rsvstr23": "",\n          "rsvstr24": "",\n          "rsvstr25": "",\n          "rsvstr26": "",\n          "rsvstr27": "",\n          "rsvstr28": "",\n          "rsvstr29": "",\n          "rsvstr30": "",\n          "rsvstr31": "",\n          "rsvstr32": "",\n          "rsvstr33": "",\n          "rsvstr34": "",\n          "rsvstr35": "",\n          "rsvstr36": "",\n          "rsvstr37": "",\n          "rsvstr38": "",\n          "rsvstr39": "",\n          "rsvstr40": "",\n          "versiondate": "2023-07-10 14:51:18",\n          "lucnecfalgdate": "",\n          "mdhash": "",\n          "syscode": "dap6",\n          "sysname": "dap6数据库",\n          "dbcode": "dap6",\n          "dbname": "dap6",\n          "schcode": "dap6",\n          "schname": "dap6",\n          "tabcode": "",\n          "tabname": "",\n          "sysinstid": "",\n          "sysinstname": "",\n          "sysclassid": "",\n          "sysparentid": "",\n          "dbinstid": "",\n          "dbinstname": "",\n          "dbclassid": "",\n          "dbparentid": "",\n          "theme": "",\n          "collflag": "",\n          "colluserid": "",\n          "parent": "",\n          "optiontype": "",\n          "corpvalue": ""\n        }\n      ]\n    },\n    "impact": {\n      "blood": "",\n      "impact": "",\n      "sessionid": "d3292d53d9c347e184917b7d7a21879c",\n      "layer": "3",\n      "type": "01",\n      "origininstid": "4ae1ce8f388d5b4b02db92dba007ea36",\n      "instid": "4ae1ce8f388d5b4b02db92dba007ea36",\n      "classid": "ddtable",\n      "relations": {},\n      "nodes": [\n        {\n          "instid": "4ae1ce8f388d5b4b02db92dba007ea36",\n          "instcode": "t_dev_md_check",\n          "instname": "元数据变更登记表",\n          "classid": "ddtable",\n          "parentid": "a684856d6e40965138cf24c59672e2d0",\n          "namespaceid": "/datadict_pde/pde_dd7833fb44274e0c9f49d89c1aff151f/bcce37af9d2b493517594f972c536f02/a684856d6e40965138cf24c59672e2d0/4ae1ce8f388d5b4b02db92dba007ea36",\n          "namespacecode": "/datadict_pde/dap6/dap6/dap6/t_dev_md_check",\n          "verid": "6632c106daab47b9a21e54e6b0ce392f",\n          "starttime": "2023-07-10 14:51:18",\n          "isroot": "",\n          "apptype": "md",\n          "status": "",\n          "pageview": 0,\n          "creater": "",\n          "corpid": "default",\n          "rsvstr1": "",\n          "rsvstr2": "",\n          "rsvstr3": "0",\n          "rsvstr4": "",\n          "rsvstr5": "",\n          "rsvstr6": "16384",\n          "rsvstr7": "2022-06-15 10:38:28",\n          "rsvstr8": "",\n          "rsvstr9": "t",\n          "rsvstr10": "",\n          "rsvstr11": "",\n          "rsvstr12": "",\n          "rsvstr13": "",\n          "rsvstr14": "",\n          "rsvstr15": "",\n          "rsvstr16": "",\n          "rsvstr17": "",\n          "rsvstr18": "",\n          "rsvstr19": "",\n          "rsvstr20": "",\n          "rsvstr21": "",\n          "rsvstr22": "",\n          "rsvstr23": "",\n          "rsvstr24": "",\n          "rsvstr25": "",\n          "rsvstr26": "",\n          "rsvstr27": "",\n          "rsvstr28": "",\n          "rsvstr29": "",\n          "rsvstr30": "",\n          "rsvstr31": "",\n          "rsvstr32": "",\n          "rsvstr33": "",\n          "rsvstr34": "",\n          "rsvstr35": "",\n          "rsvstr36": "",\n          "rsvstr37": "",\n          "rsvstr38": "",\n          "rsvstr39": "",\n          "rsvstr40": "",\n          "versiondate": "2023-07-10 14:51:18",\n          "lucnecfalgdate": "",\n          "mdhash": "",\n          "syscode": "dap6",\n          "sysname": "dap6数据库",\n          "dbcode": "dap6",\n          "dbname": "dap6",\n          "schcode": "dap6",\n          "schname": "dap6",\n          "tabcode": "",\n          "tabname": "",\n          "sysinstid": "",\n          "sysinstname": "",\n          "sysclassid": "",\n          "sysparentid": "",\n          "dbinstid": "",\n          "dbinstname": "",\n          "dbclassid": "",\n          "dbparentid": "",\n          "theme": "",\n          "collflag": "",\n          "colluserid": "",\n          "parent": "",\n          "optiontype": "",\n          "corpvalue": ""\n        }\n      ]\n    },\n    "sessionid": "",\n    "layer": "3",\n    "type": "",\n    "origininstid": "",\n    "instid": "",\n    "classid": "",\n    "relations": {},\n    "nodes": []\n  }\n}\n',charsets:{cjk:!0}},{title:"INDEX",frontmatter:{},regularPath:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/excel.html",relativePath:"插件小技巧/excel.md",key:"v-8efb47ee",path:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/excel.html",headers:[{level:3,title:"INDEX",slug:"index",normalizedTitle:"index",charIndex:2},{level:3,title:"INDIRECT",slug:"indirect",normalizedTitle:"indirect",charIndex:27},{level:3,title:"CELL",slug:"cell",normalizedTitle:"cell",charIndex:141},{level:3,title:"带有工作日志的日历",slug:"带有工作日志的日历",normalizedTitle:"带有工作日志的日历",charIndex:1595}],headersStr:"INDEX INDIRECT CELL 带有工作日志的日历",content:'# INDEX\n\nINDEX(区域,行序,列序)\n\n=INDIRECT(ADDRESS(101,1)) 表示取第1列，第101行的数值。\n\n\n# INDIRECT\n\n某单元格的列和行\n\n=INDIRECT("A"&ROW()-10)+INDIRECT("A"&ROW())\n\n\n# CELL\n\n=IF (CELL ("type"，A1) ="v"，A1*2，0)\n\nINFO_TYPE       返回结果\n“address”       引用中第一个单元格的引用，文本类型。\n“col”           引用中单元格的列标。\n“color”         如果单元格中的负值以不同颜色显示，则为值 1；否则，返回 0（零）。注意: Excel 网页版 、Excel\n                Mobile 和 Excel Starter 中不支持此值。\n"contents"      引用中左上角单元格的值：不是公式。\n"filename"      包含引用的文件名（包括全部路径），文本类型。 如果包含目标引用的工作表尚未保存，则返回空文本 ("")。注意:\n                Excel 网页版 、Excel Mobile 和 Excel Starter 中不支持此值。\n“format”        对应于单元格数字格式的文本值。 下表显示了各种格式的文本值。 如果单元格为负值设置颜色格式，则返回文本值末尾的"-"。\n                如果单元格 () 正值或所有值的括号，则返回文本值末尾的" () "。注意: Excel 网页版 、Excel\n                Mobile 和 Excel Starter 中不支持此值。\n“parentheses”   如果单元格中为正值或所有单元格均加括号，则为值 1；否则返回 0。注意: Excel 网页版 、Excel Mobile\n                和 Excel Starter 中不支持此值。\n“prefix”        与单元格中的“前置标签”相对应的文本值。 如果单元格文本左对齐，则返回单引号 (\')；如果单元格文本右对齐，则返回双引号\n                (")；如果单元格文本居中，则返回插入字符 (^)；如果单元格文本两端对齐，则返回反斜线\n                ()；如果是其他情况，则返回空文本 ("")。注意: Excel 网页版 、Excel Mobile 和 Excel\n                Starter 中不支持此值。\n“protect”       如果单元格没有锁定，则为值 0；如果单元格锁定，则返回 1。注意: Excel 网页版 、Excel Mobile 和\n                Excel Starter 中不支持此值。\n“row”           引用中单元格的行号。\n“type”          对应于单元格中数据类型的文本值。\n                如果单元格为空，则返回"b"表示空白;如果单元格包含文本常量，则返回"l"表示标签;如果单元格包含任何其他内容，则返回"v"作为值。\n“width”         返回包含 2 个项的数组。数组的第一项是单元格的列宽，四舍五入为整数。\n                列宽以默认字号的一个字符的宽度为单位。数组的第二项是布尔值，如果列宽为默认值，则值为\n                TRUE;如果用户显式设置了宽度，则值为 FALSE。 注意: Excel 网页版 、Excel Mobile 和\n                Excel Starter 中不支持此值。\n\n\n# 带有工作日志的日历\n\nhttp://www.360doc.com/content/18/0514/07/22637415_753739514.shtml',normalizedContent:'# index\n\nindex(区域,行序,列序)\n\n=indirect(address(101,1)) 表示取第1列，第101行的数值。\n\n\n# indirect\n\n某单元格的列和行\n\n=indirect("a"&row()-10)+indirect("a"&row())\n\n\n# cell\n\n=if (cell ("type"，a1) ="v"，a1*2，0)\n\ninfo_type       返回结果\n“address”       引用中第一个单元格的引用，文本类型。\n“col”           引用中单元格的列标。\n“color”         如果单元格中的负值以不同颜色显示，则为值 1；否则，返回 0（零）。注意: excel 网页版 、excel\n                mobile 和 excel starter 中不支持此值。\n"contents"      引用中左上角单元格的值：不是公式。\n"filename"      包含引用的文件名（包括全部路径），文本类型。 如果包含目标引用的工作表尚未保存，则返回空文本 ("")。注意:\n                excel 网页版 、excel mobile 和 excel starter 中不支持此值。\n“format”        对应于单元格数字格式的文本值。 下表显示了各种格式的文本值。 如果单元格为负值设置颜色格式，则返回文本值末尾的"-"。\n                如果单元格 () 正值或所有值的括号，则返回文本值末尾的" () "。注意: excel 网页版 、excel\n                mobile 和 excel starter 中不支持此值。\n“parentheses”   如果单元格中为正值或所有单元格均加括号，则为值 1；否则返回 0。注意: excel 网页版 、excel mobile\n                和 excel starter 中不支持此值。\n“prefix”        与单元格中的“前置标签”相对应的文本值。 如果单元格文本左对齐，则返回单引号 (\')；如果单元格文本右对齐，则返回双引号\n                (")；如果单元格文本居中，则返回插入字符 (^)；如果单元格文本两端对齐，则返回反斜线\n                ()；如果是其他情况，则返回空文本 ("")。注意: excel 网页版 、excel mobile 和 excel\n                starter 中不支持此值。\n“protect”       如果单元格没有锁定，则为值 0；如果单元格锁定，则返回 1。注意: excel 网页版 、excel mobile 和\n                excel starter 中不支持此值。\n“row”           引用中单元格的行号。\n“type”          对应于单元格中数据类型的文本值。\n                如果单元格为空，则返回"b"表示空白;如果单元格包含文本常量，则返回"l"表示标签;如果单元格包含任何其他内容，则返回"v"作为值。\n“width”         返回包含 2 个项的数组。数组的第一项是单元格的列宽，四舍五入为整数。\n                列宽以默认字号的一个字符的宽度为单位。数组的第二项是布尔值，如果列宽为默认值，则值为\n                true;如果用户显式设置了宽度，则值为 false。 注意: excel 网页版 、excel mobile 和\n                excel starter 中不支持此值。\n\n\n# 带有工作日志的日历\n\nhttp://www.360doc.com/content/18/0514/07/22637415_753739514.shtml',charsets:{cjk:!0}},{title:"wangEditor 5",frontmatter:{},regularPath:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/wangeditor.html",relativePath:"插件小技巧/wangeditor.md",key:"v-1eabf2d6",path:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/wangeditor.html",headers:[{level:2,title:"editor-for-vue的使用",slug:"editor-for-vue的使用",normalizedTitle:"editor-for-vue的使用",charIndex:263},{level:3,title:"安装 editor",slug:"安装-editor",normalizedTitle:"安装 editor",charIndex:285},{level:3,title:"安装 Vue2 组件",slug:"安装-vue2-组件",normalizedTitle:"安装 vue2 组件",charIndex:372},{level:3,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:205},{level:3,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:2106},{level:3,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:2232}],headersStr:"editor-for-vue的使用 安装 editor 安装 Vue2 组件 使用 配置 案例",content:'# wangEditor 5\n\n官网：https://www.wangeditor.com\n\n禁用（无效）：\n\nhttps://www.csdn.net/tags/MtTaMg3sMTM3MzQzLWJsb2cO0O0O.html\n\n菜单自定义：\n\nhttps://blog.csdn.net/weixin_44872995/article/details/123799759\n\nwangEditor结合vue使用方法示例:\n\nhttps://www.gxlcms.com/JavaScript-60375.html\n\n\n# editor-for-vue的使用\n\n\n# 安装 editor\n\nyarn add @wangeditor/editor\n# 或者 npm install @wangeditor/editor --save\n\n\n\n# 安装 Vue2 组件\n\nyarn add @wangeditor/editor-for-vue\n# 或者 npm install @wangeditor/editor-for-vue --save\n\n\n\n# 使用\n\n模板\n\n<template>\n    <div style="border: 1px solid #ccc;">\n        <Toolbar\n                 style="border-bottom: 1px solid #ccc"\n                 :editor="editor"\n                 :defaultConfig="toolbarConfig"\n                 :mode="mode"\n                 />\n        <Editor\n                style="height: 500px; overflow-y: hidden;"\n                v-model="html"\n                :defaultConfig="editorConfig"\n                :mode="mode"\n                @onCreated="onCreated"\n                />\n    </div>\n</template>\n\n\nscript\n\n<script>\n    import Vue from \'vue\'\n    import { Editor, Toolbar } from \'@wangeditor/editor-for-vue\'\n\n    export default Vue.extend({\n        components: { Editor, Toolbar },\n        data() {\n            return {\n                editor: null,\n                html: \'<p>hello</p>\',\n                toolbarConfig: { },\n                editorConfig: { placeholder: \'请输入内容...\' },\n                mode: \'default\', // or \'simple\'\n            }\n        },\n        methods: {\n            onCreated(editor) {\n                this.editor = Object.seal(editor) // 一定要用 Object.seal() ，否则会报错\n            },\n        },\n        mounted() {\n            // 模拟 ajax 请求，异步渲染编辑器\n            setTimeout(() => {\n                this.html = \'<p>模拟 Ajax 异步设置内容 HTML</p>\'\n            }, 1500)\n        },\n        beforeDestroy() {\n            const editor = this.editor\n            if (editor == null) return\n            editor.destroy() // 组件销毁时，及时销毁编辑器\n        }\n    })\n<\/script>\n\n\n提示\n\n * 赋值 this.editor 时要用 Object.seal()\n * 组件销毁时，要及时销毁编辑器\n\n记得引入 style\n\n<style src="@wangeditor/editor/dist/css/style.css"></style>\n\n\n\n# 配置\n\n可通过 toolbarConfig 和 editorConfig 来修改菜单栏和编辑器的配置，详细文档参考\n\n注意\n\n编辑器配置中 onXxx 格式的生命周期函数，必须通过 Vue 事件来传递，不可以放在 editorConfig 中\n\n\n# 案例\n\n例子代码：\n\n<template>\n    <div>\n        <Toolbar\n                 style="border-bottom: 1px solid #ccc"\n                 :editor="editor"\n                 :defaultConfig="toolbarConfig"\n                 :mode="mode"\n                 />\n        <Editor\n                style="overflow-y: hidden; min-height: 300px"\n                v-model="myValue"\n                :defaultConfig="editorConfig"\n                :mode="mode"\n                @onCreated="onCreated"\n                @onChange="onChange"\n                @onDestroyed="onDestroyed"\n                @onMaxLength="onMaxLength"\n                @onFocus="onFocus"\n                @onBlur="onBlur"\n                @customAlert="customAlert"\n                @customPaste="customPaste"\n                />\n    </div>\n</template>\n\n<script>\n    import { DomEditor } from "@wangeditor/editor";\n    import { Editor, Toolbar } from "@wangeditor/editor-for-vue";\n    export default {\n        components: { Editor, Toolbar },\n        props: {\n            value: {\n                type: String,\n                default: "",\n            },\n        },\n        data() {\n            return {\n                myValue: this.value,\n                editor: null,\n                toolbarConfig: {\n                    toolbarKeys: [\n                        "headerSelect",\n                        // "header1",\n                        // "header2",\n                        // "header3",\n                        // "header4",\n                        // "header5",\n                        // "blockquote", // 引用\n                        "|",\n                        "bold",\n                        "underline",\n                        "italic",\n                        "through",\n                        "code",\n                        "sub",\n                        "sup",\n                        "clearStyle",\n                        "color",\n                        "bgColor",\n                        "|",\n                        "fontSize",\n                        // "fontFamily",\n                        "lineHeight",\n                        "|",\n                        "bulletedList",\n                        "numberedList",\n                        "todo",\n                        "|",\n                        "indent",\n                        "delIndent",\n                        "justifyLeft",\n                        "justifyRight",\n                        "justifyCenter",\n                        "justifyJustify",\n                        "|",\n                        "emotion",\n                        // 插入链接\n                        "insertLink",\n                        // "editLink",\n                        // "unLink",\n                        // "viewLink",\n                        // 表格\n                        "insertTable",\n                        // "deleteTable",\n                        // "insertTableRow",\n                        // "deleteTableRow",\n                        // "insertTableCol",\n                        // "deleteTableCol",\n                        // "tableHeader",\n                        // "tableFullWidth",\n                        "|",\n                        // 图片\n                        // "insertImage",\n                        // "deleteImage",\n                        // "editImage",\n                        // "viewImageLink",\n                        // "imageWidth30",\n                        // "imageWidth50",\n                        // "imageWidth100",\n                        // "|",\n                        // 视频\n                        // "insertVideo",\n                        // "uploadVideo",\n                        // "uploadImage",\n                        // "codeSelectLang",\n                        // "|",\n                        "codeBlock",\n                        "divider",\n                        "|",\n                        "redo",\n                        "undo",\n                        "|",\n                        "fullScreen",\n                    ],\n                    excludeKeys: [],\n                },\n                editorConfig: {\n                    placeholder: "请输入内容...",\n                },\n                mode: "default", // \'default\' or \'simple\'\n            };\n        },\n        watch: {\n            value: {\n                immediate: true,\n                deep: true,\n                handler(newValue, oldValue) {\n                    this.myValue = newValue;\n                },\n            },\n            myValue: {\n                immediate: true,\n                deep: true,\n                handler(newValue, oldValue) {\n                    this.$emit("input", newValue);\n                },\n            },\n        },\n        mounted() {\n            // 模拟 ajax 请求，异步渲染编辑器\n            // setTimeout(() => {\n            //   this.html = "<p>模拟 Ajax 异步设置内容 HTML</p>";\n            // }, 1500);\n        },\n        methods: {\n            onCreated(editor) {\n                this.editor = Object.seal(editor); // 一定要用 Object.seal() ，否则会报错\n                console.log("onCreated", editor);\n            },\n            onChange(editor) {\n                console.log("onChange", editor.children);\n            },\n            onDestroyed(editor) {\n                console.log("onDestroyed", editor);\n            },\n            onMaxLength(editor) {\n                console.log("onMaxLength", editor);\n            },\n            onFocus(editor) {\n                console.log("onFocus", editor);\n            },\n            onBlur(editor) {\n                console.log("onBlur", editor);\n            },\n            // customAlert(info: string, type: string) { window.alert(`customAlert in Vue demo\\n${type}:\\n${info}`) },\n            customPaste(editor, event, callback) {\n                console.log("ClipboardEvent 粘贴事件对象", event);\n                // const html = event.clipboardData.getData(\'text/html\') // 获取粘贴的 html\n                // const text = event.clipboardData.getData(\'text/plain\') // 获取粘贴的纯文本\n                // const rtf = event.clipboardData.getData(\'text/rtf\') // 获取 rtf 数据（如从 word wsp 复制粘贴）\n\n                // 自定义插入内容\n                editor.insertText("xxx");\n\n                // 返回 false ，阻止默认粘贴行为\n                event.preventDefault();\n                // callback(false) // 返回值（注意，vue 事件的返回值，不能用 return）\n\n                // 返回 true ，继续默认的粘贴行为\n                // callback(true)\n            },\n        },\n        beforeDestroy() {\n            const editor = this.editor;\n            if (editor == null) return;\n            editor.destroy(); // 组件销毁时，及时销毁编辑器\n        },\n    };\n<\/script>\n\n<style src="@wangeditor/editor/dist/css/style.css"></style>\n\n',normalizedContent:'# wangeditor 5\n\n官网：https://www.wangeditor.com\n\n禁用（无效）：\n\nhttps://www.csdn.net/tags/mttamg3smtm3mzqzlwjsb2co0o0o.html\n\n菜单自定义：\n\nhttps://blog.csdn.net/weixin_44872995/article/details/123799759\n\nwangeditor结合vue使用方法示例:\n\nhttps://www.gxlcms.com/javascript-60375.html\n\n\n# editor-for-vue的使用\n\n\n# 安装 editor\n\nyarn add @wangeditor/editor\n# 或者 npm install @wangeditor/editor --save\n\n\n\n# 安装 vue2 组件\n\nyarn add @wangeditor/editor-for-vue\n# 或者 npm install @wangeditor/editor-for-vue --save\n\n\n\n# 使用\n\n模板\n\n<template>\n    <div style="border: 1px solid #ccc;">\n        <toolbar\n                 style="border-bottom: 1px solid #ccc"\n                 :editor="editor"\n                 :defaultconfig="toolbarconfig"\n                 :mode="mode"\n                 />\n        <editor\n                style="height: 500px; overflow-y: hidden;"\n                v-model="html"\n                :defaultconfig="editorconfig"\n                :mode="mode"\n                @oncreated="oncreated"\n                />\n    </div>\n</template>\n\n\nscript\n\n<script>\n    import vue from \'vue\'\n    import { editor, toolbar } from \'@wangeditor/editor-for-vue\'\n\n    export default vue.extend({\n        components: { editor, toolbar },\n        data() {\n            return {\n                editor: null,\n                html: \'<p>hello</p>\',\n                toolbarconfig: { },\n                editorconfig: { placeholder: \'请输入内容...\' },\n                mode: \'default\', // or \'simple\'\n            }\n        },\n        methods: {\n            oncreated(editor) {\n                this.editor = object.seal(editor) // 一定要用 object.seal() ，否则会报错\n            },\n        },\n        mounted() {\n            // 模拟 ajax 请求，异步渲染编辑器\n            settimeout(() => {\n                this.html = \'<p>模拟 ajax 异步设置内容 html</p>\'\n            }, 1500)\n        },\n        beforedestroy() {\n            const editor = this.editor\n            if (editor == null) return\n            editor.destroy() // 组件销毁时，及时销毁编辑器\n        }\n    })\n<\/script>\n\n\n提示\n\n * 赋值 this.editor 时要用 object.seal()\n * 组件销毁时，要及时销毁编辑器\n\n记得引入 style\n\n<style src="@wangeditor/editor/dist/css/style.css"></style>\n\n\n\n# 配置\n\n可通过 toolbarconfig 和 editorconfig 来修改菜单栏和编辑器的配置，详细文档参考\n\n注意\n\n编辑器配置中 onxxx 格式的生命周期函数，必须通过 vue 事件来传递，不可以放在 editorconfig 中\n\n\n# 案例\n\n例子代码：\n\n<template>\n    <div>\n        <toolbar\n                 style="border-bottom: 1px solid #ccc"\n                 :editor="editor"\n                 :defaultconfig="toolbarconfig"\n                 :mode="mode"\n                 />\n        <editor\n                style="overflow-y: hidden; min-height: 300px"\n                v-model="myvalue"\n                :defaultconfig="editorconfig"\n                :mode="mode"\n                @oncreated="oncreated"\n                @onchange="onchange"\n                @ondestroyed="ondestroyed"\n                @onmaxlength="onmaxlength"\n                @onfocus="onfocus"\n                @onblur="onblur"\n                @customalert="customalert"\n                @custompaste="custompaste"\n                />\n    </div>\n</template>\n\n<script>\n    import { domeditor } from "@wangeditor/editor";\n    import { editor, toolbar } from "@wangeditor/editor-for-vue";\n    export default {\n        components: { editor, toolbar },\n        props: {\n            value: {\n                type: string,\n                default: "",\n            },\n        },\n        data() {\n            return {\n                myvalue: this.value,\n                editor: null,\n                toolbarconfig: {\n                    toolbarkeys: [\n                        "headerselect",\n                        // "header1",\n                        // "header2",\n                        // "header3",\n                        // "header4",\n                        // "header5",\n                        // "blockquote", // 引用\n                        "|",\n                        "bold",\n                        "underline",\n                        "italic",\n                        "through",\n                        "code",\n                        "sub",\n                        "sup",\n                        "clearstyle",\n                        "color",\n                        "bgcolor",\n                        "|",\n                        "fontsize",\n                        // "fontfamily",\n                        "lineheight",\n                        "|",\n                        "bulletedlist",\n                        "numberedlist",\n                        "todo",\n                        "|",\n                        "indent",\n                        "delindent",\n                        "justifyleft",\n                        "justifyright",\n                        "justifycenter",\n                        "justifyjustify",\n                        "|",\n                        "emotion",\n                        // 插入链接\n                        "insertlink",\n                        // "editlink",\n                        // "unlink",\n                        // "viewlink",\n                        // 表格\n                        "inserttable",\n                        // "deletetable",\n                        // "inserttablerow",\n                        // "deletetablerow",\n                        // "inserttablecol",\n                        // "deletetablecol",\n                        // "tableheader",\n                        // "tablefullwidth",\n                        "|",\n                        // 图片\n                        // "insertimage",\n                        // "deleteimage",\n                        // "editimage",\n                        // "viewimagelink",\n                        // "imagewidth30",\n                        // "imagewidth50",\n                        // "imagewidth100",\n                        // "|",\n                        // 视频\n                        // "insertvideo",\n                        // "uploadvideo",\n                        // "uploadimage",\n                        // "codeselectlang",\n                        // "|",\n                        "codeblock",\n                        "divider",\n                        "|",\n                        "redo",\n                        "undo",\n                        "|",\n                        "fullscreen",\n                    ],\n                    excludekeys: [],\n                },\n                editorconfig: {\n                    placeholder: "请输入内容...",\n                },\n                mode: "default", // \'default\' or \'simple\'\n            };\n        },\n        watch: {\n            value: {\n                immediate: true,\n                deep: true,\n                handler(newvalue, oldvalue) {\n                    this.myvalue = newvalue;\n                },\n            },\n            myvalue: {\n                immediate: true,\n                deep: true,\n                handler(newvalue, oldvalue) {\n                    this.$emit("input", newvalue);\n                },\n            },\n        },\n        mounted() {\n            // 模拟 ajax 请求，异步渲染编辑器\n            // settimeout(() => {\n            //   this.html = "<p>模拟 ajax 异步设置内容 html</p>";\n            // }, 1500);\n        },\n        methods: {\n            oncreated(editor) {\n                this.editor = object.seal(editor); // 一定要用 object.seal() ，否则会报错\n                console.log("oncreated", editor);\n            },\n            onchange(editor) {\n                console.log("onchange", editor.children);\n            },\n            ondestroyed(editor) {\n                console.log("ondestroyed", editor);\n            },\n            onmaxlength(editor) {\n                console.log("onmaxlength", editor);\n            },\n            onfocus(editor) {\n                console.log("onfocus", editor);\n            },\n            onblur(editor) {\n                console.log("onblur", editor);\n            },\n            // customalert(info: string, type: string) { window.alert(`customalert in vue demo\\n${type}:\\n${info}`) },\n            custompaste(editor, event, callback) {\n                console.log("clipboardevent 粘贴事件对象", event);\n                // const html = event.clipboarddata.getdata(\'text/html\') // 获取粘贴的 html\n                // const text = event.clipboarddata.getdata(\'text/plain\') // 获取粘贴的纯文本\n                // const rtf = event.clipboarddata.getdata(\'text/rtf\') // 获取 rtf 数据（如从 word wsp 复制粘贴）\n\n                // 自定义插入内容\n                editor.inserttext("xxx");\n\n                // 返回 false ，阻止默认粘贴行为\n                event.preventdefault();\n                // callback(false) // 返回值（注意，vue 事件的返回值，不能用 return）\n\n                // 返回 true ，继续默认的粘贴行为\n                // callback(true)\n            },\n        },\n        beforedestroy() {\n            const editor = this.editor;\n            if (editor == null) return;\n            editor.destroy(); // 组件销毁时，及时销毁编辑器\n        },\n    };\n<\/script>\n\n<style src="@wangeditor/editor/dist/css/style.css"></style>\n\n',charsets:{cjk:!0}},{title:"element",frontmatter:{},regularPath:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/element.html",relativePath:"插件小技巧/element.md",key:"v-3c6a7dae",path:"/%E6%8F%92%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/element.html",headers:[{level:2,title:"el-table",slug:"el-table",normalizedTitle:"el-table",charIndex:85},{level:3,title:"type=“seletion“ 设置表格行时候可以选择",slug:"type-seletion-设置表格行时候可以选择",normalizedTitle:"type=“seletion“ 设置表格行时候可以选择",charIndex:98},{level:3,title:"table的sortable使用",slug:"table的sortable使用",normalizedTitle:"table的sortable使用",charIndex:684},{level:3,title:"table横向滚动条一直在可视范围内",slug:"table横向滚动条一直在可视范围内",normalizedTitle:"table横向滚动条一直在可视范围内",charIndex:4207},{level:3,title:"elementui的el-table根据内容长度自适应调整列",slug:"elementui的el-table根据内容长度自适应调整列",normalizedTitle:"elementui的el-table根据内容长度自适应调整列",charIndex:12738},{level:3,title:"element的table如何在多页数据下勾选多行",slug:"element的table如何在多页数据下勾选多行",normalizedTitle:"element的table如何在多页数据下勾选多行",charIndex:15331},{level:3,title:"element的el-table的合并",slug:"element的el-table的合并",normalizedTitle:"element的el-table的合并",charIndex:18996},{level:3,title:"基于ElementUI-Table的表头吸顶(黏性布局)效果实现",slug:"基于elementui-table的表头吸顶-黏性布局-效果实现",normalizedTitle:"基于elementui-table的表头吸顶(黏性布局)效果实现",charIndex:25792},{level:2,title:"el-form",slug:"el-form",normalizedTitle:"el-form",charIndex:35938},{level:3,title:"关于ElementUi中select框在页面滚动时el-option超出元素区域的问题",slug:"关于elementui中select框在页面滚动时el-option超出元素区域的问题",normalizedTitle:"关于elementui中select框在页面滚动时el-option超出元素区域的问题",charIndex:35950},{level:3,title:"element ui表单el-form的label自适应宽度",slug:"element-ui表单el-form的label自适应宽度",normalizedTitle:"element ui表单el-form的label自适应宽度",charIndex:40986},{level:3,title:"element表单内只有一个input回车刷新页面",slug:"element表单内只有一个input回车刷新页面",normalizedTitle:"element表单内只有一个input回车刷新页面",charIndex:41425},{level:3,title:"element-ui 表单form 回车 enter 触发查询",slug:"element-ui-表单form-回车-enter-触发查询",normalizedTitle:"element-ui 表单form 回车 enter 触发查询",charIndex:41633},{level:3,title:"ElementUI中MessageBox弹框的取消键盘触发事件(enter,esc)关闭弹窗(执行事件)的解决方法",slug:"elementui中messagebox弹框的取消键盘触发事件-enter-esc-关闭弹窗-执行事件-的解决方法",normalizedTitle:"elementui中messagebox弹框的取消键盘触发事件(enter,esc)关闭弹窗(执行事件)的解决方法",charIndex:41766},{level:3,title:"element中下拉框select在长页面滚动时，下拉弹框没有跟随下拉框跑路",slug:"element中下拉框select在长页面滚动时-下拉弹框没有跟随下拉框跑路",normalizedTitle:"element中下拉框select在长页面滚动时，下拉弹框没有跟随下拉框跑路",charIndex:42375},{level:3,title:"DateTimePicker日期范围封装组件[日期范围/月份范围/年份范围]",slug:"datetimepicker日期范围封装组件-日期范围-月份范围-年份范围",normalizedTitle:"datetimepicker日期范围封装组件[日期范围/月份范围/年份范围]",charIndex:42937},{level:3,title:"element日期组件时间范围选择限制",slug:"element日期组件时间范围选择限制",normalizedTitle:"element日期组件时间范围选择限制",charIndex:47944},{level:2,title:"el-tree",slug:"el-tree",normalizedTitle:"el-tree",charIndex:49204},{level:3,title:"element的el-tree组件宽度超出父元素滚动条不生效问题",slug:"element的el-tree组件宽度超出父元素滚动条不生效问题",normalizedTitle:"element的el-tree组件宽度超出父元素滚动条不生效问题",charIndex:49216}],headersStr:"el-table type=“seletion“ 设置表格行时候可以选择 table的sortable使用 table横向滚动条一直在可视范围内 elementui的el-table根据内容长度自适应调整列 element的table如何在多页数据下勾选多行 element的el-table的合并 基于ElementUI-Table的表头吸顶(黏性布局)效果实现 el-form 关于ElementUi中select框在页面滚动时el-option超出元素区域的问题 element ui表单el-form的label自适应宽度 element表单内只有一个input回车刷新页面 element-ui 表单form 回车 enter 触发查询 ElementUI中MessageBox弹框的取消键盘触发事件(enter,esc)关闭弹窗(执行事件)的解决方法 element中下拉框select在长页面滚动时，下拉弹框没有跟随下拉框跑路 DateTimePicker日期范围封装组件[日期范围/月份范围/年份范围] element日期组件时间范围选择限制 el-tree element的el-tree组件宽度超出父元素滚动条不生效问题",content:'# element\n\nelement 官网：https://element.eleme.cn/2.14/#/zh-CN/component/quickstart\n\n\n# el-table\n\n\n# type=“seletion“ 设置表格行时候可以选择\n\n项目需求：有的行可被选择，有的行不可被选择\n\n参数           说明                                                          类型\nselectable   仅对 type=selection 的列有效，类型为 Function，Function 的返回值用来决定这一行的   Function(row, index)\n             CheckBox 是否可以勾选\n\n添加:selectable属性即可,设置方法checkboxSelect\n\n<el-table-column type="selection" align="center" fixed width="50" :selectable=\'checkboxSelect\'/>\n\n\n设置自己的逻辑\n\ncheckboxSelect(row,index){ \n  //控制表格的选择\n  // 通过return true or false 控制表格是否选择 true 可选 false 不可选\n  //如下仅供参考，写自己的逻辑交互\n  if(index ===3 ){\n    return true\n  }else{\n    return false\n  }\n},\n\n\n\n# table的sortable使用\n\n1、业务分析\n\n效果：默认升序，点击排序的icon，上箭头升序，下箭头降序\n\n2、实现\n\n在列中设置sortable属性即可实现以该列为基准的排序，接受一个Boolean，默认为false。可以通过 Table 的default-sort属性设置默认的排序列和排序顺序。可以使用sort-method或者sort-by使用自定义的排序规则。如果需要后端排序，需将sortable设置为custom，同时在 Table 上监听sort-change事件，在事件回调中可以获取当前排序的字段名和排序顺序，从而向接口请求排序后的表格数据。在本例中，我们还使用了formatter属性，它用于格式化指定列的值，接受一个Function，会传入两个参数：row和column，可以根据自己的需求进行处理。\n\n3、实例\n\nTIP\n\n在需要排序的字段上增加sortable=“custom”,el-table增加@sort-change事件监听排序\n\n<template>\n<div style="padding:20px;height:100%" class="resolve">\n    <el-table\n              :data="tableData"\n              stripe\n              border\n              @sort-change="changeTableSort"\n              style="width:100%;"\n              >\n        <el-table-column type="selection" width="55"> </el-table-column>\n        <el-table-column type="index" width="50" label="序号"></el-table-column>\n        <el-table-column prop="name" label="姓名"></el-table-column>\n        <el-table-column\n                         prop="address"\n                         label="地址"\n                         width="200"\n                         ></el-table-column>\n        <el-table-column prop="payDate" label="payDate"></el-table-column>\n        <el-table-column\n                         prop="come"\n                         label="come"\n                         sortable="custom"\n                         ></el-table-column>\n        <el-table-column prop="pay" label="pay"></el-table-column>\n        <el-table-column prop="money" label="money"></el-table-column>\n    </el-table>\n    <div class="block">\n        <el-pagination\n                       background\n                       layout="prev, pager, next"\n                       :total="50"\n                       :page-size="5"\n                       :current-page="currentPage"\n                       @current-change="handlePageCurrentChange"\n                       >\n    </el-pagination>\n    </div>\n    </div>\n</template>\n\n<script>\n    import { getHomeData } from "@/api/index";\n    export default {\n        name: "",\n        data() {\n            return {\n                tableData: [],\n                currentPage: 1,\n                fieldName: "",\n                sortMethod: "",\n            };\n        },\n        mounted() {\n            this.getData();\n        },\n        methods: {\n            getData() {\n                var data = {\n                    pageIndex: this.currentPage,\n                    pageSize: 10,\n                    come: this.sortMethod, // 排序的字段：排序的方式(升序/降序)\n                };\n                getHomeData(data).then((res) => {\n                    console.log(res);\n                    console.log("table", res.data.content);\n                    if (res.code == 0) {\n                        this.tableData = res.data.content;\n                    }\n                });\n            },\n            handlePageCurrentChange(value) {\n                console.log("value", value);\n                this.currentPage = value;\n                this.getData();\n            },\n            // 排序\n            changeTableSort(column) {\n                console.log("column", column);\n                // this.fieldName = column.prop;\n                var sortingType = column.order;\n                sortingType == "ascending"\n                    ? (this.sortMethod = "ASC")\n                : (this.sortMethod = "DESC");\n                this.getData(this.sortMethod);\n            },\n        },\n    };\n<\/script>\n\n<style scoped>\n    .resolve {\n        overflow-y: auto;\n    }\n    .block {\n        margin-top: 20px;\n    }\n</style>\n\n\n\n\n# table横向滚动条一直在可视范围内\n\nhttps://www.cnblogs.com/LunuZ/articles/13932622.html\n\n当数据过多，table的X轴滚动条不在可视区域时，给table的父级容器添加一个滚动条perfectScrollbar，然后将perfectScrollbar的scroll值赋值给table自己的滚动条\n\ntableDemo.vue\n\n<template>\n<div>\n    <el-row type="flex" justify="end">\n        <el-col :span="6">\n            <el-button type="primary" @click="getData">获取数据</el-button>\n    </el-col>\n    </el-row>\n    <div class="tableC" style="position: relative; ">\n        \x3c!--绑定v-perfect-scrollbar 指令--\x3e\n        <el-table\n                  v-perfect-scrollbar\n                  border\n                  resizable\n                  :data="tableData">\n            <el-table-column sortable="custom" prop="column_1" label="行1" show-overflow-tooltip="" width="120">\n                <template slot-scope="scope">\n                    <span>{{ scope.row.column_1 }}</span>\n</template>\n</el-table-column>\n<el-table-column sortable="" prop="column_2" label="行2" show-overflow-tooltip="" width="120">\n    <template slot-scope="scope">\n<span>{{ scope.row.column_2 }}</span>\n    </template>\n</el-table-column>\n<el-table-column sortable="" prop="column_3" label="行3" show-overflow-tooltip="" width="140">\n    <template slot-scope="scope">\n<span>{{ scope.row.column_3 }}</span>\n    </template>\n</el-table-column>\n<el-table-column sortable="" prop="column_4" label="行4" show-overflow-tooltip="" width="160">\n    <template slot-scope="scope">\n<span>{{ scope.row.column_4 }}</span></template>\n</el-table-column>\n<el-table-column sortable="" prop="column_5" label="行5" show-overflow-tooltip="" width="180">\n    <template slot-scope="scope">\n<span>{{ scope.row.column_5 }}</span>\n    </template>\n</el-table-column>\n<el-table-column sortable="" prop="column_6" label="行6" show-overflow-tooltip="" width="200">\n    <template slot-scope="scope">\n<span>{{ scope.row.column_6 }}</span>\n    </template>\n</el-table-column>\n<el-table-column sortable="" prop="column_7" label="行7" show-overflow-tooltip="" width="220">\n    <template slot-scope="scope">\n<span>{{ scope.row.column_7 }}</span>\n    </template>\n</el-table-column>\n<el-table-column sortable="" prop="column_8" label="行8" show-overflow-tooltip="" width="200">\n    <template slot-scope="scope">\n<span>{{ scope.row.column_8 }}</span>\n    </template>\n</el-table-column>\n<el-table-column sortable="" prop="column_9" label="行9" show-overflow-tooltip="" width="200">\n    <template slot-scope="scope">\n<span>{{ scope.row.column_9 }}</span>\n    </template>\n</el-table-column>\n<el-table-column sortable="" prop="column_10" label="行10" show-overflow-tooltip="" width="200">\n    <template slot-scope="scope">\n<span>{{ scope.row.column_10 }}</span>\n    </template>\n</el-table-column>\n<el-table-column sortable="" prop="column_11" label="行11" show-overflow-tooltip="" width="200">\n    <template slot-scope="scope">\n<span>{{ scope.row.column_11 }}</span>\n    </template>\n</el-table-column>\n<el-table-column sortable="" prop="column_12" label="行12" show-overflow-tooltip="" width="200">\n    <template slot-scope="scope">\n<span>{{ scope.row.column_12 }}</span>\n    </template>\n</el-table-column>\n</el-table>\n</div>\n\x3c!--用来占位--\x3e\n<el-pagination background="" layout="prev, pager, next" :total="1000"></el-pagination>\n</div>\n</template>\n<script>\n    export\n    default {\n        data() {\n            return {\n                tableData:[]\n            }\n        },\n        methods: {\n            getData() {\n                var len = this.tableData.length\n                var i = 0;\n                while (i < 50) {\n                    var bz = len + i;\n                    this.tableData.push({\n                        column_1: "第1-" + bz + "行的数据",\n                        column_2: "第2-" + bz + "行的数据",\n                        column_3: "第3-" + bz + "行的数据",\n                        column_4: "第4-" + bz + "行的数据",\n                        column_5: "第5-" + bz + "行的数据",\n                        column_6: "第6-" + bz + "行的数据",\n                        column_7: "第7-" + bz + "行的数据",\n                        column_8: "第8-" + bz + "行的数据",\n                        column_9: "第9-" + bz + "行的数据",\n                        column_10: "第10-" + bz + "行的数据",\n                        column_11: "第11" + bz + "行的数据",\n                        column_12: "第12-" + bz + "行的数据",\n                    });\n                    i++;\n                }\n            },\n        },\n\n    };\n<\/script>\n<style scoped>\n    .el-row{ margin-bottom: 15px; }\n    .el-pagination{ margin-top: 20px; }\n</style>\n\x3c!--需设置为全局css样式--\x3e\n<style>\n    .tableC{ position:relative;}\n    .el-table th{ height: 60px; }\n    .el-table td{ padding:0; height: 50px; font-size: 14px; }\n    .el-table.hide-scrollBar{\n        /*隐藏滚动条 设置底部padding20px*/\n        scrollbar-width: none; /* Firefox */\n        -ms-overflow-style: none; /* IE 10+ */\n        padding-bottom: 20px;\n    }\n    .el-table.hide-scrollBar ::-webkit-scrollbar { display: none; /* Chrome Safari */ }\n</style>\n\x3c!--tableDemo.vue--end--\x3e\n\n\napp.vue里面id="app"的div绑定v-app-scroll 指令，设置style="height: 100vh;overflow-y: scroll"\n\ndirective.js\n\n// 自定义table水平滚动条始终显示在可视区域\nVue.directive(\'perfectScrollbar\', {\n    componentUpdated:function (el, binding,vnode) {\n        let trCount=vnode.context.tableData.length;// tr的个数\n        fixTabScrollbar(el,null,trCount)\n    }\n})\n//自定义app滚动事件\nVue.directive(\'appScroll\', {\n    bind: function(el, binding, vNode) {\n        let start = (e) =>{\n            fixTabScrollbar(null,el)\n        }\n        // 添加事件监听器\n        el.addEventListener("scroll", start);\n    }\n})\n//app滚动->定位table的水平滚动条\nfunction fixTabScrollbar(tabEle,appEle,trCount) {\n    var tabEle=tabEle||document.getElementsByClassName(\'el-table\')[0] // table 元素\n    var appEle=appEle||document.getElementById("app") // 滚动条所在容器\n    if(!(tabEle&&appEle)) return;\n    var tabContainer=tabEle.parentNode; // table 的父级容器\n    let thead = tabEle.getElementsByClassName(\'el-table__header-wrapper\')[0];\n    let tbody = tabEle.getElementsByClassName(\'el-table__body-wrapper\')[0];\n    var trCount=trCount||tbody.getElementsByTagName("tr").length //tr的个数\n    let trHeight=50.4 //tr的高度（自己设置的,这里el-table-column需要设置为 show-overflow-tooltip，不然换行会影响tr的高度） elementui这个框架，不知道0.4哪里来的\n    let theadHeight=thead.clientHeight?thead.clientHeight:60; // 表头的高度，60是默认的高度(自己设置的)\n    let tabHeight=theadHeight+trHeight*trCount+18 //table的高度 （18是el-table水平滚动条的高度）\n    let tabWinWidth=thead.clientWidth //table视口的宽度\n    let tabWidth=thead.getElementsByTagName(\'table\')[0].offsetWidth;//table的宽度\n    let appHeight=appEle.offsetHeight- getOffsetTop(appEle) // 窗口的高度\n    let tabOffsetTop=getOffsetTop(tabContainer) //table 距离顶部距离\n    let appScrollTop=appEle.scrollTop  // 容器向上滚动的距离\n    let bottom=tabOffsetTop+tabHeight-appScrollTop-appHeight;\n    if(bottom>0&&tabWidth>tabWinWidth){ //底部大于0并且table的宽度大于el-table视口的宽度--\x3e显示滚动条，并隐藏自己的滚动条\n        let scrollBarEle=null\n        let childEle=null\n        tabEle.classList.add("hide-scrollBar")  //隐藏tableC自己的滚动条\n        if(document.getElementById(\'perfectScrollbar-div\')==null){\n            scrollBarEle = document.createElement(\'div\');\n            scrollBarEle.id = \'perfectScrollbar-div\';\n            childEle=document.createElement(\'p\');\n            childEle.id = \'perfectScrollbar-child\';\n            tabContainer.appendChild(scrollBarEle);\n            scrollBarEle.appendChild(childEle);\n            scrollBarEle.style.display="block";\n            childEle.style.width=tabWidth+"px";\n            childEle.style.height="1px";\n            childEle.style.padding="0";\n            childEle.style.margin="0";\n            scrollBarEle.style.position="absolute";\n            scrollBarEle.style.overflowX="auto";\n            scrollBarEle.style.left="0px";\n            scrollBarEle.style.right="0px";\n            scrollBarEle.style.margin="auto";\n        }else{\n            scrollBarEle = document.getElementById(\'perfectScrollbar-div\');\n        }\n        scrollBarEle.style.bottom=bottom+"px";\n        scrollBarEle.onscroll = function(){\n            let target=event.target;\n            let scrollLeft=target.scrollLeft\n            tbody.scrollLeft=scrollLeft;\n        }\n    }else{\n        tabEle.classList.remove("hide-scrollBar") //显示tableC自己的滚动条\n        var scrollBarEle=document.getElementById(\'perfectScrollbar-div\');\n        if(scrollBarEle)scrollBarEle.parentNode.removeChild(scrollBarEle);\n    }\n}\nfunction getOffsetTop(obj) {\n    if (!!window.ActiveXObject || "ActiveXObject" in window) {\n        var y = obj.offsetTop;\n        while (obj = obj.offsetParent) y += obj.offsetTop;\n        return y;\n    }else{\n        return obj.offsetTop\n    }\n}\n\n\n\n# elementui的el-table根据内容长度自适应调整列\n\n 1. 添加\n    \n    <el-table-column prop="name" :width="flexColumnWidth(\'name\',tableData)" label="名称" align="center" />\n    \n\n 2. 函数\n    \n    // 自适应表格列宽\n    flexColumnWidth(str, tableData, flag = \'max\',flewMinWidth) {\n        // str为该列的字段名(传字符串);tableData为该表格的数据源(传变量);\n        // flag为可选值，可不传该参数,传参时可选\'max\'或\'equal\',默认为\'max\'\n        // flag为\'max\'则设置列宽适配该列中最长的内容,flag为\'equal\'则设置列宽适配该列中第一行内容的长度。\n        str = str + \'\'\n        let columnContent = \'\'\n        if (!tableData || !tableData.length || tableData.length === 0 || tableData === undefined) {\n            if(flewMinWidth){\n                return flewMinWidth\n            }\n            return\n        }\n        if (!str || !str.length || str.length === 0 || str === undefined) {\n            return\n        }\n        if (flag === \'equal\') {\n            // 获取该列中第一个不为空的数据(内容)\n            for (let i = 0; i < tableData.length; i++) {\n                if (tableData[i][str].length > 0) {\n                    // console.log(\'该列数据[0]:\', tableData[0][str])\n                    columnContent = tableData[i][str]\n                    break\n                }\n            }\n        } else {\n            // 获取该列中最长的数据(内容)\n            let index = 0\n            for (let i = 0; i < tableData.length; i++) {\n                if (tableData[i][str] === null) {\n                    if(flewMinWidth){\n                        return flewMinWidth\n                    }\n                    return\n                }\n                const now_temp = tableData[i][str] + \'\'\n                const max_temp = tableData[index][str] + \'\'\n                if (now_temp.length > max_temp.length) {\n                    index = i\n                }\n            }\n            columnContent = tableData[index][str]\n        }\n        // console.log(\'该列数据[i]:\', columnContent)\n        // 以下分配的单位长度可根据实际需求进行调整\n        let flexWidth = 0\n        // 这个循环可以使用js的计算长度进行获取width   \n        for (const char of columnContent) {\n            if ((char >= \'A\' && char <= \'Z\') || (char >= \'a\' && char <= \'z\')) {\n                // 如果是英文字符，为字符分配8个单位宽度\n                flexWidth += 8\n            } else if (char >= \'\\u4e00\' && char <= \'\\u9fa5\') {\n                // 如果是中文字符，为字符分配15个单位宽度\n                flexWidth += 15\n            } else {\n                // 其他种类字符，为字符分配8个单位宽度\n                flexWidth += 8\n            }\n        }\n        if (flexWidth < 80) {\n            // 设置最小宽度\n            flexWidth = 80\n        }\n        // if (flexWidth > 250) {\n        //   // 设置最大宽度\n        //   flexWidth = 250\n        // }\n        return flexWidth + \'px\'\n    }\n    \n\n\n# element的table如何在多页数据下勾选多行\n\n业务中，表格数据往往不只一页。多页数据情况下，表格勾选某些行，就会遇到返回上一页，勾选消失的情况。这种情况，需要一些技巧和处理。具体代码如下：\n\n<template>\n    <div class="demo-example">\n        <el-table\n                  ref="table"\n                  v-loading="loading"\n                  :data="list"\n                  height="650"\n                  border\n                  @select="onSelect"\n                  @select-all="onSelectAll"\n                  @selection-change="onSelectionChange"\n                  >\n            <el-table-column type="selection" width="55"></el-table-column>\n            <el-table-column prop="u_createTime" label="注册时间"></el-table-column>\n            <el-table-column prop="u_id" label="用户ID"></el-table-column>\n            <el-table-column prop="u_nickname" label="用户名称"></el-table-column>\n            <el-table-column prop="u_phone" label="用户账户"></el-table-column>\n            <el-table-column prop="u_gender" label="性别"></el-table-column>\n            <el-table-column label="角色">\n                <template slot-scope="scope">\n                    <span>{{scope.row.u_role === 1 ? \'团队长\' : \'保险人\'}}</span>\n                </template>\n            </el-table-column>\n            <el-table-column prop="u_companyNum" label="所属企业数量"></el-table-column>\n            <el-table-column prop="ha_addPeople" label="所属群组">\n                <template slot-scope="scope">\n                    <el-button @click="onChakan(scope.row)" type="text" style="color:#67c23a" size="small">查看</el-button>\n                </template>\n            </el-table-column>\n            <el-table-column prop="u_lastLoginTime" label="最近登录时间"></el-table-column>\n        </el-table>\n\n        <div class="block pag" v-if="total">\n            <el-pagination\n                           @current-change="onChangePage"\n                           :current-page="currentPage"\n                           :page-size="10"\n                           layout="total, prev, pager, next, jumper"\n                           :total="total"\n                           ></el-pagination>\n        </div>\n        \n    </div>\n</template>\n\n<script>\n    export default {\n        data() {\n            return {\n                selections: {}, // 保存已选择过的row\n                list: [],\n                total: 0,\n                curPage: 1,\n            };\n        },\n        //方法事件\n        methods: {\n            // 勾选时候，记录[{u_id: row}, ...]\n            onSelect(selection, row) {\n                if (this.selections[row.u_id]) {\n                    delete this.selections[row.u_id];\n                } else {\n                    this.selections[row.u_id] = row;\n                }\n            },\n\n            // 全选情况\n            onSelectAll(selection) {\n                // 全选\n                if (selection.length) {\n                    selection.forEach(row => {\n                        this.selections[row.u_id] = row;\n                    })\n                } else {\n                    // 取消全选\n                    this.list.forEach(row => {\n                        delete this.selections[row.u_id];\n                    })\n                }\n\n            },\n\n            // 对已选择过的row勾选，返回到上一页时候\n            checkRows() {\n                const keys = Object.keys(this.selections);\n                const rows = this.list.filter(row => {\n                    return keys.includes(String(row.u_id));\n                });\n\n                rows.map(row => {\n                    this.$refs.table.toggleRowSelection(row);\n                });\n            },\n\n            // 省略...\n\n            // 获取数据列表\n            getData() {\n                // ...\n            },\n\n        },\n\n        created() {\n            this.getData();\n        }\n    };\n<\/script>\n\n\n\n# element的el-table的合并\n\n属性：span-method="objectSpanMethod"\n\n# 纵向合并单元格（单列）\n\n封装-mergeColspan.js\n\n// 纵向合并单元格（单列）\n\nexport default class mergeColspan {\n  static cellList = [] // (一行或者一列)每个单元格计算后所占各自的数组\n\n  static doCompute(tableBody, paramName) {\n    this.cellList = [] // 单元格数组初始化\n    let count = 0// 第几个合并\n    // f循环遍历表体数据\n    for (let i = 0; i < tableBody.length; i++) {\n      if (i === 0) {\n        // 先设置第一项\n        this.cellList.push(1)\n      } else {\n        if (tableBody[i][paramName] === tableBody[i - 1][paramName]) {\n          this.cellList[count] += 1\n          this.cellList.push(0)\n        } else {\n          this.cellList.push(1)\n          count = i\n        }\n\n      }\n\n    }\n    return false\n  }\n\n  // 第二步，将计算好的结果返回给el-table\n  static doMerge(rowIndex, columnIndex, paramIndex) {\n    // 给选定列做单元格合并\n    if (columnIndex === paramIndex) {\n      const roeCell = this.cellList[rowIndex]\n      if (roeCell > 0) {\n        return {\n          rowspan: roeCell,\n          colspan: 1\n        }\n      } else {\n        return {\n          rowspan: 0,\n          colspan: 0\n        }\n      }\n    } else {\n      return {\n        rowspan: 1,\n        colspan: 1\n      }\n    }\n  }\n\n}\n\n\n引用\n\n<template>\n  <el-table\n    :data="tableData"\n    :span-method="objectSpanMethod"\n    border\n    style="width: 100%; margin-top: 20px"\n  >\n    <el-table-column prop="id" label="ID" width="180"> </el-table-column>\n    <el-table-column prop="name" label="姓名"> </el-table-column>\n    <el-table-column prop="amount1" label="数值 1（元）"> </el-table-column>\n    <el-table-column prop="amount2" label="数值 2（元）"> </el-table-column>\n    <el-table-column prop="amount3" label="数值 3（元）"> </el-table-column>\n  </el-table>\n</template>\n\n<script>\nimport mergeColspan from \'./mergeColspan\';\nexport default {\n  data() {\n    return {\n      tableData: [\n        {\n          id: "12987122",\n          name: "王小虎",\n          amount1: "234",\n          amount2: "3.2",\n          amount3: 10,\n        },\n        {\n          id: "12987123",\n          name: "王小虎",\n          amount1: "165",\n          amount2: "4.43",\n          amount3: 12,\n        },\n        {\n          id: "12987124",\n          name: "王小虎",\n          amount1: "324",\n          amount2: "1.9",\n          amount3: 9,\n        },\n        {\n          id: "12987125",\n          name: "王小虎",\n          amount1: "621",\n          amount2: "2.2",\n          amount3: 17,\n        },\n        {\n          id: "12987126",\n          name: "王小虎",\n          amount1: "539",\n          amount2: "4.1",\n          amount3: 15,\n        },\n      ],\n    };\n  },\n  mounted() {\n    mergeColspan.doCompute(this.tableData, "name");\n  },\n  methods: {\n    objectSpanMethod({ row, column, rowIndex, columnIndex }) {\n      return mergeColspan.doMerge(rowIndex, columnIndex, 1);\n    },\n  },\n};\n<\/script>\n\n<style>\n</style>\n\n\n# 纵向合并单元格（多列）\n\n封装-mergeColspans.js\n\n// 纵向合并单元格（多列）\n\nexport default class mergeColspans {\n  static needMergeArr = [] // 需要合并列的项目的集合\n  static rowMergeArrs = [] // 需要存放合并项信息的对象\n\n  static rowMerrgeHandle(arr, data) {\n    if (!Array.isArray(arr) && !arr.length) return false\n    if (!Array.isArray(data) && !data.length) return false\n    this.needMergeArr = arr\n    let needMerge = {}\n\n    arr.forEach((i, idx) => {\n      needMerge[i] = {\n        rowArr: [],\n        rowMergeNum: 0\n      }\n\n      if (idx === 0) {\n        data.forEach((item, index) => {\n          if (index === 0) {\n            needMerge[i].rowArr.push(1)\n            needMerge[i].rowMergeNum = 0\n          } else {\n            if (item[i] === data[index - 1][i]) {\n              needMerge[i].rowArr.push(0)\n              needMerge[i].rowArr[needMerge[i].rowMergeNum] += 1\n            } else {\n              needMerge[i].rowArr.push(1)\n              needMerge[i].rowMergeNum = index\n            }\n          }\n        })\n      } else {\n        let firstRowArr = needMerge[arr[0]].rowArr\n        let firstRowArrDeal = []\n        firstRowArr.forEach((ietm, index) => {\n          if (index > 0) {\n            firstRowArrDeal.push(index)\n          }\n        })\n        data.forEach((item, index) => {\n          let sign = false\n          if (firstRowArrDeal.indexOf(index) > 0) {\n            needMerge[i].rowMergeNum = index\n            sign = true\n          }\n          // 表格首个数据单独处理\n          if (index === 0) {\n            needMerge[i].rowArr.push(1)\n            needMerge[i].rowMergeNum = 0\n          } else {\n            if (item[i] === data[index - 1][i]) {\n              if (sign) {\n                needMerge[i].rowArr.push(1)\n              } else {\n                needMerge[i].rowArr.push(0)\n                needMerge[i].rowArr[needMerge[i].rowMergeNum] += 1\n              }\n            } else {\n              needMerge[i].rowArr.push(1)\n              needMerge[i].rowMergeNum = index\n            }\n          }\n        })\n      }\n      this.rowMergeArrs = needMerge\n    });\n  }\n\n\n  static mergeAction(column, rowIndex) {\n    for (const res in this.needMergeArr) {\n      if (this.needMergeArr[res] === column.property) {\n        let _row = this.rowMergeArrs[column.property].rowArr[rowIndex]\n        let _col = _row > 0 ? 1 : 0\n        return [_row, _col]\n      }\n\n    }\n  }\n\n}\n\n\n引用\n\n<template>\n  <el-table\n    :data="tableData"\n    :span-method="objectSpanMethod"\n    border\n    style="width: 100%; margin-top: 20px"\n  >\n    <el-table-column prop="id" label="ID" width="180"> </el-table-column>\n    <el-table-column prop="name" label="姓名"> </el-table-column>\n    <el-table-column prop="amount1" label="数值 1（元）"> </el-table-column>\n    <el-table-column prop="amount2" label="数值 2（元）"> </el-table-column>\n    <el-table-column prop="amount3" label="数值 3（元）"> </el-table-column>\n  </el-table>\n</template>\n\n<script>\nimport mergeColspans from \'./mergeColspans\';\nexport default {\n  data() {\n    return {\n      tableData: [\n        {\n          id: "12987122",\n          name: "王小虎",\n          amount1: "234",\n          amount2: "3.2",\n          amount3: 10,\n        },\n        {\n          id: "12987123",\n          name: "王小虎",\n          amount1: "165",\n          amount2: "4.43",\n          amount3: 12,\n        },\n        {\n          id: "12987124",\n          name: "王小虎",\n          amount1: "324",\n          amount2: "1.9",\n          amount3: 9,\n        },\n        {\n          id: "12987125",\n          name: "王小虎",\n          amount1: "621",\n          amount2: "2.2",\n          amount3: 17,\n        },\n        {\n          id: "12987126",\n          name: "王小虎",\n          amount1: "539",\n          amount2: "4.1",\n          amount3: 15,\n        },\n      ],\n    };\n  },\n  mounted() {\n    mergeColspans.rowMerrgeHandle(["name"], this.tableData);\n  },\n  methods: {\n    objectSpanMethod({ row, column, rowIndex, columnIndex }) {\n      return mergeColspans.mergeAction(column, rowIndex);\n    },\n  },\n};\n<\/script>\n\n<style>\n</style>\n\n\n\n# 基于ElementUI-Table的表头吸顶(黏性布局)效果实现\n\n# 1.使用自定义指令\n\n我们给每一想要固定头部的table都加一个自定义指令v-sticky，而且，我们需要传入自定义指令两个参数，top:指定距离顶部的高度，parent:指定滚动容器,如果滚动容器是#document，则不传入parent；\n\nv-sticky="{\n    top:0,\n    parent:\'#table_box\' \n}"\n\n\n 1. 开始编写自定义指令\n\n * 代码逻辑写在注释中\n\nimport Vue from \'vue\'\n// 给固定头设置样式\nfunction doFix(dom, top) {\n    dom.style.position = \'fixed\'\n    dom.style.zIndex = \'2001\'\n    dom.style.top = top + \'px\'\n    dom.parentNode.style.paddingTop = top + \'px\'\n}\n// 给固定头取消样式\nfunction removeFix(dom) {\n    dom.parentNode.style.paddingTop = 0\n    dom.style.position = \'static\'\n    dom.style.top = \'0\'\n    dom.style.zIndex = \'0\'\n}\n// 给固定头添加class\nfunction addClass(dom, fixtop) {\n    const old = dom.className\n    if (!old.includes(\'fixed\')) {\n        dom.setAttribute(\'class\', old + \' fixed\')\n        doFix(dom, fixtop)\n    }\n}\n// 给固定头移除class\nfunction removeClass(dom) {\n    const old = dom.className\n    const idx = old.indexOf(\'fixed\')\n    if (idx !== -1) {\n        const newClass = old.substr(0, idx - 1)\n        dom.setAttribute(\'class\', newClass)\n        removeFix(dom)\n    }\n}\n// 具体判断是否固定头的主函数\nfunction fixHead(parent, el, top) {\n    /**\n   * myTop 当前元素距离滚动父容器的高度，\n   * fixtop 当前元素需要设置的绝对定位的高度\n   * parentHeight 滚动父容器的高度\n   */\n    let myTop, fixtop, parentHeight\n    // 表头DOM节点\n    const dom = el.children[1]\n\n    if (parent.tagName) {\n        // 如果是DOM内局部滚动\n        // 当前元素距离滚动父容器的高度= 当前元素距离父元素的高度-父容器的滚动距离-表头的高度\n        myTop = el.offsetTop - parent.scrollTop - dom.offsetHeight\n        // 父元素高度\n        const height = getComputedStyle(parent).height\n        parentHeight = Number(height.slice(0, height.length - 2))\n        // 绝对定位高度 = 滚动父容器相对于视口的高度 + 传入的吸顶高度\n        fixtop = top + parent.getBoundingClientRect().top\n        // 如果自己距离顶部距离大于父元素的高度，也就是自己还没在父元素滚动出来，直接return\n        if (myTop > parentHeight) {\n            return\n        }\n    } else {\n        // document节点滚动\n        // 当前元素距离滚动父容器的高度 = 当前元素距离视口顶端的距离\n        myTop = el.getBoundingClientRect().top\n        // 父元素高度 = 视口的高度\n        parentHeight = window.innerHeight\n        //  绝对定位高度 = 传入的吸顶高度\n        fixtop = top\n        // 如果自己距离顶部距离大于父元素的高度，也就是自己还没在父元素滚动出来，直接return\n        if (myTop > document.documentElement.scrollTop + parentHeight) {\n            return\n        }\n    }\n    // 如果 已经滚动的上去不在父容器显示了。直接return \n    if (Math.abs(myTop) > el.offsetHeight + 100) {\n        return\n    }\n    if (myTop < 0 && Math.abs(myTop) > el.offsetHeight) {\n        // 如果当前表格已经完全滚动到父元素上面，也就是不在父元素显示了。则需要去除fixed定位\n        removeClass(dom)\n    } else if (myTop <= 0) {\n        // 如果表头滚动到 父容器顶部了。fixed定位\n        addClass(dom, fixtop)\n    } else if (myTop > 0) {\n        // 如果表格向上滚动 又滚动到父容器里。取消fixed定位\n        removeClass(dom)\n    } else if (Math.abs(myTop) < el.offsetHeight) {\n        // 如果滚动的距离的绝对值小于自身的高度，也就是说表格向上滚动，刚刚显示出表格的尾部是需要将表头fixed定位\n        addClass(dom, fixtop)\n    }\n}\n// 设置头部固定时表头外容器的宽度写死为表格body的宽度\nfunction setHeadWidth(el) {\n    // 获取到当前表格个表格body的宽度\n    const width = getComputedStyle(\n        el.getElementsByClassName(\'el-table__body-wrapper\')[0]\n    ).width\n    // 给表格设置宽度。这里默认一个页面中的多个表格宽度是一样的。所以直接遍历赋值，也可以根据自己需求，单独设置\n    const tableParent = el.getElementsByClassName(\'el-table__header-wrapper\')\n    for (let i = 0; i < tableParent.length; i++) {\n        tableParent[i].style.width = width\n    }\n}\n/**\n * 这里有三个全局对象。用于存放监听事件。方便组件销毁后移除监听事件\n */\nconst fixFunObj = {}      // 用于存放滚动容器的监听scroll事件\nconst setWidthFunObj = {}   // 用于存放页面resize后重新计算head宽度事件\nconst autoMoveFunObj ={}    // 用户存放如果是DOM元素内局部滚动时，document滚动时，fix布局的表头也需要跟着document一起向上滚动\n\n// 全局注册 自定义事件\nVue.directive(\'sticky\', {\n    // 当被绑定的元素插入到 DOM 中时……\n    inserted(el, binding, vnode) {\n        // 首先设置表头宽度\n        setHeadWidth(el)\n        // 获取当前vueComponent的ID。作为存放各种监听事件的key\n        const uid = vnode.componentInstance._uid\n        // 当window resize时 重新计算设置表头宽度，并将监听函数存入 监听函数对象中，方便移除监听事件\n        window.addEventListener(\n            \'resize\',\n            (setWidthFunObj[uid] = () => {\n                setHeadWidth(el)\n            })\n        )\n        // 获取当前滚动的容器是什么。如果是document滚动。则可默认不传入parent参数\n        const scrollParent =\n              document.querySelector(binding.value.parent) || document\n        // 给滚动容器加scroll监听事件。并将监听函数存入 监听函数对象中，方便移除监听事件\n        scrollParent.addEventListener(\n            \'scroll\',\n            (fixFunObj[uid] = () => {\n                fixHead(scrollParent, el, binding.value.top)\n            })\n        )\n        // 如果是局部DOM元素内滚动。则需要监听document滚动，document滚动是同步让表头一起滚动。并将监听函数存入 监听函数对象中，方便移除监听事件\n        if (binding.value.parent) {\n            document.addEventListener(\'scroll\', autoMoveFunObj[uid] = ()=> {\n                // 获取到表头DOM节点\n                const dom = el.children[1]\n                // 如果当前表头是fixed定位。则跟着document滚动一起滚\n                if(getComputedStyle(dom).position=== \'fixed\'){\n                    // 滚动的距离是： 滚动父容器距离视口顶端高度 + 传入的吸顶固定距离 \n                    const fixtop =\n                          binding.value.top + scrollParent.getBoundingClientRect().top\n                    doFix(dom, fixtop, \'fixed\')\n                }\n            })\n        }\n    },\n    // component 更新后。重新计算表头宽度\n    componentUpdated(el) {\n        setHeadWidth(el)\n    },\n    // 节点取消绑定时 移除各项监听事件。\n    unbind(el, binding, vnode) {\n        const uid = vnode.componentInstance._uid\n        window.removeEventListener(\'resize\', setWidthFunObj[uid])\n        const scrollParent =\n              document.querySelector(binding.value.parent) || document\n        scrollParent.removeEventListener(\'scroll\', fixFunObj[uid])\n        if (binding.value.parent) {\n            document.removeEventListener(\'scroll\', autoMoveFunObj[uid])\n        }\n    }\n})\n\n\n# 1.1添加测试代码\n\n * 首先是html代码\n\n<div class="table">\n    <div id="table_box" class="table_box">\n        <el-table\n                  v-for="item in [1, 2]"\n                  :key="item"\n                  ref="stickyTable"\n                  v-sticky="{\n                            top: 0,\n                            parent: \'#table_box\'\n                            }"\n                  :data="tableData"\n                  style="width: 100%"\n                  border\n                  >\n            <el-table-column prop="date" :label="`日期${item}`" width="180">\n            </el-table-column>\n            <el-table-column prop="name" :label="`姓名${item}`" width="180">\n            </el-table-column>\n            <el-table-column prop="address" :label="`地址${item}`">\n            </el-table-column>\n        </el-table>\n    </div>\n    <el-table\n              v-for="item in [3, 4]"\n              :key="item"\n              ref="stickyTable"\n              v-sticky="{\n                        top: 0\n                        }"\n              :data="tableData"\n              style="width: 100%"\n              border\n              >\n        <el-table-column prop="date" :label="`日期${item}`" width="180">\n        </el-table-column>\n        <el-table-column prop="name" :label="`姓名${item}`" width="180">\n        </el-table-column>\n        <el-table-column prop="address" :label="`地址${item}`"> </el-table-column>\n    </el-table>\n</div>\n\n\n页面中定义了四个表格，前两个在一个父容器div#table_box中滚动，后两个则随document滚动\n\n * 再给表格加一下样式，方便区分每个表格和表头\n\n.table {\n    width: 100%;\n    border: 1px solid #ddd;\n    padding: 10px 20px;\n    .table_box {\n        border: 1px solid red;\n        margin-bottom: 20px;\n        height: 200px;\n        overflow-x: hidden;\n        overflow-y: auto;\n    }\n    .el-table {\n        margin-bottom: 50px;\n        border: 1px solid transparent;\n    }\n    /deep/ .el-table__header-wrapper {\n        th {\n            background: rgba(244, 244, 244, 1);\n        }\n    }\n}\n\n\n * 加一些js，给表格添加数据。使用setTimeOut模拟异步请求数据\n\nexport default {\n    data() {\n        return {\n            tableData: []\n        }\n    },\n    mounted() {\n        this.setTableData()\n    },\n    methods: {\n        setTableData() {\n            const result = []\n            for (let i = 0; i < 20; i++) {\n                result.push({\n                    date: \'2016-05-03\',\n                    name: \'王小虎\' + i,\n                    address: \'上海市普陀区金沙江路 1516 弄\' + i\n                })\n            }\n            setTimeout(() => {\n                this.tableData = result\n            }, 500)\n        }\n    }\n}\n\n\n该demo仅支持ElementUI中简单的table。如table中存在左右固定的布局的，样式可能会错乱。感兴趣的同学再深入研究下~\n\n# 2.直接css实现（吸顶功能）\n\n// css吸顶功能 \n#mainContainer {\n    >div,\n    .ceiling,\n    .ceilingTab {\n        >.el-table {\n            .el-table__header-wrapper {\n                position: sticky;\n                top: 0px;\n                left: 0px;\n                background: #fff;\n                z-index: 4;\n            }\n\n        }\n\n        // 左右布局表格的吸顶\n        .ceiling {\n            >.el-table {\n                .el-table__header-wrapper {\n                    top: 0px;\n                }\n            }\n        }\n\n        // 左右布局Tab标签页内部表格的吸顶\n        .ceilingTab {\n            >.el-table {\n                .el-table__header-wrapper {\n                    top: 2px;\n                }\n            }\n        }\n\n        >.el-tabs {\n            .el-table {\n                .el-table__header-wrapper {\n                    position: sticky;\n                    top: -16px;\n                    left: 0px;\n                    background: #fff;\n                    z-index: 2;\n                }\n            }\n        }\n\n        //分页功能顶部吸住\n        .el-pagination,\n        .elpagination {\n            position: sticky;\n            bottom: 0px;\n            left: 0px;\n            background: #fff;\n            text-align: right;\n            width: 100%;\n            z-index: 3;\n            margin-top: 5px;\n            padding: 6px 0;\n        }\n    }\n}\n\n\n# position: sticky\n\nposition的含义是指定位类型，取值类型可以有：static、relative、absolute、fixed、inherit和sticky，这里sticky是CSS3新发布的一个属性。我今天重点要说的就是sticky属性\n\nposition:sticky用法\n\n * position:sticky 被称为粘性定位元素（stickily positioned element）是计算后位置属性为 sticky 的元素。\n * 简单的理解就是：在目标区域以内，它的行为就像 position:relative;在滑动过程中，某个元素距离其父元素的距离达到sticky粘性定位的要求时(比如top：100px)；position:sticky这时的效果相当于fixed定位，固定到适当位置。\n * 可以说是相对定位relative和固定定位fixed的结合\n * 元素固定的相对偏移是相对于离它最近的具有滚动框的祖先元素，如果祖先元素都不可以滚动，那么是相对于viewport来计算元素的偏移量。\n\nposition:sticky 使用条件\n\n1.父元素不能overflow:hidden或者overflow:auto属性。 2.必须指定top、bottom、left、right4个值之一，否则只会处于相对定位 3.父元素的高度不能低于sticky元素的高度 4、sticky元素仅在其父元素内生效\n\n\n# el-form\n\n\n# 关于ElementUi中select框在页面滚动时el-option超出元素区域的问题\n\n问题：在项目开发中发现elementUi中的select组件在页面滚动时会随着页面滚动并遮盖页面\n\n1、创建js文件\n\nfackClickOutSide.js\n\nlet lock = true;\nlet el = null;\nconst MousedownEvent = new Event(\'mousedown\', {bubbles:true});\nconst MouseupEvent = new Event(\'mouseup\', {bubbles:true});\nconst fakeClickOutSide = () => {\n    document.dispatchEvent(MousedownEvent);\n    document.dispatchEvent(MouseupEvent);\n    lock = true; // console.log(\'dispatchEvent\');\n};\nconst mousedownHandle = e => {\n    let classList = e.target.classList;\n    if(classList.contains(\'el-select__caret\') || classList.contains(\'el-input__inner\')) {\n        lock = false;\n        return;\n    }\n    if(lock) return;\n    fakeClickOutSide();\n};\nconst mousewheelHandle = e => {\n    if(lock || e.target.classList.contains(\'el-select-dropdown__item\') || e.target.parentNode.classList.contains(\'el-select-dropdown__item\')) return;\n    fakeClickOutSide();\n};\nconst eventListener = (type) => {\n    el[type + \'EventListener\'](\'mousedown\', mousedownHandle);\n    window[type + \'EventListener\'](\'mousewheel\', mousewheelHandle);\n    window[type + \'EventListener\'](\'DOMMouseScroll\', mousewheelHandle); // fireFox 3.5+ \n}\nexport default {\n    mounted() {\n        el = this.$root.$el;\n        el.addFakeClickOutSideEventCount = el.addFakeClickOutSideEventCount || 0;\n        (! el.addFakeClickOutSideEventCount) && this.$nextTick(() => {\n            eventListener(\'add\');\n        });\n        el.addFakeClickOutSideEventCount += 1;\n    },\n    destroyed() {\n        eventListener(\'remove\');\n        el.addFakeClickOutSideEventCount -= 1;\n    },\n}\n\n\n2、使用\n\n// App.vue\n\nimport fackClickOutSide from \'./util/fackClickOutSide\';\n\nnew Vue({\n    name: "App"\n    router,\n    mixins: [fackClickOutSide],\n})\n\n\n// 鼠标滚动的事件()\n\nfackClickOutSide.js\n\nexport default {\n    data() {\n        return {\n            name: \'mixin\',\n            el: "",\n            lock: true,\n            MousedownEvent: {},\n            MouseupEvent: {}\n        }\n    },\n    mounted() {\n        this.MousedownEvent = new Event(\'mousedown\', { bubbles: true });\n        this.MouseupEvent = new Event(\'mouseup\', { bubbles: true });\n        this.el = this.$root.$el;\n        this.el.addFakeClickOutSideEventCount = this.el.addFakeClickOutSideEventCount || 0;\n        (!this.el.addFakeClickOutSideEventCount) && this.$nextTick(() => {\n            this.eventListener(\'add\');\n        });\n        this.el.addFakeClickOutSideEventCount += 1;\n    },\n    destroyed() {\n        this.eventListener(\'remove\');\n        this.el.addFakeClickOutSideEventCount -= 1;\n    },\n    methods: {\n        fakeClickOutSide(e) {\n            document.dispatchEvent(this.MousedownEvent);\n            document.dispatchEvent(this.MouseupEvent);\n            this.lock = true; // console.log(\'dispatchEvent\');\n        },\n        mousedownHandle(e) {\n            let classList = e.target.classList;\n            if (classList.contains(\'el-select__caret\') || classList.contains(\'el-input__inner\')) {\n                this.lock = false;\n                return;\n            }\n            if (this.lock) return;\n            this.fakeClickOutSide();\n        },\n        mousewheelHandle(e) {\n            if (this.lock || e.target.classList.contains(\'el-select-dropdown__item\') || e.target.parentNode.classList.contains(\'el-select-dropdown__item\') ||\n                e.target.classList.contains(\'el-time-spinner__item\') || e.target.parentNode.classList.contains(\'el-time-spinner__item\') ||\n                e.target.classList.contains(\'el-picker-panel__item\') || e.target.parentNode.classList.contains(\'el-picker-panel__item\') ||\n                e.target.classList.contains(\'el-date-picker__item\') || e.target.parentNode.classList.contains(\'el-date-picker__item\')) {\n                // console.log(e.srcElement.className);\n                if (typeof e.srcElement.className === \'string\') {\n                    if ((e.srcElement.className.indexOf(\'el-select-dropdown\') == -1 &&\n                         e.srcElement.className.indexOf(\'el-picker-panel\') == -1 &&\n                         e.srcElement.className.indexOf(\'el-date-picker\') == -1 &&\n                         e.srcElement.className.indexOf(\'el-date-picker\') == -1 &&\n                         e.srcElement.className.indexOf(\'el-time-spinner\') == -1\n                        ) && e.srcElement.className !== \'\') {\n                        if (document.getElementsByClassName(\'el-select-dropdown\').length !== 0) {\n                            document.getElementsByClassName(\'el-select-dropdown\')[0].style.display = "none"\n                        }\n                    } else {\n                        return\n                    }\n                }\n            }\n            this.fakeClickOutSide();\n        },\n        eventListener(type) {\n            this.el[type + \'EventListener\'](\'mousedown\', this.mousedownHandle);\n            window[type + \'EventListener\'](\'mousewheel\', this.mousewheelHandle);\n            window[type + \'EventListener\'](\'DOMMouseScroll\', this.mousewheelHandle); // fireFox 3.5+ \n        }\n    }\n}\n\n\n\n# element ui表单el-form的label自适应宽度\n\n在ElementUI官方文档中el-form提供了一个参数 label-width：\n\n\n\n可以在form表单中设置label-width宽度（作为 Form 直接子元素的 form-item 会继承该值），但问题来了，如果不确定标签的长度，给固定值容易造成过长标签的换行，导致页面布局错乱。\n\n所以把label-width设置为auto，如下\n\n<el-form ref="form" :model="form" label-width="auto" size="small" > </el-form>\n\n\n注意\n\n如果给固定值，则还可以设置label标签的对齐方式 label-position="left" 可以通过设置label-width=150px;label-position="left出来的效果，遇到标签过长的字段名称只能在单独的el-form-item标签中设置label-width\n\n\n# element表单内只有一个input回车刷新页面\n\n在表单中如果只有一个el-input的话，按回车会刷新页面。 原因：出发了表单提交事件； 解决方法： 1.在 <el-form></el-form> 中添加@submit.native.prevent\n\n<el-form @submit.native.prevent></el-form>\n\n\n2.多加一个表单控件并且添加display:none;样式\n\n\n# element-ui 表单form 回车 enter 触发查询\n\n在 el-form 上添加 @keyup.enter.native="onQuery"\n\n<el-form @keyup.enter.native="onQuery"></el-form>\n\n\n\n# ElementUI中MessageBox弹框的取消键盘触发事件(enter,esc)关闭弹窗(执行事件)的解决方法\n\n第一次点击确定按钮的时候,在beforeClose中仅仅只是做了对确定按钮绑定点击事件,以及取消回车响应事件,但是并没有调用.抱着这个想法我认为可以在第一次点击的时候就触发绑定的点击事件.完整代码如下：\n\nbeforeClose: (action, instance, done) => { // 取消回车确认事件\n    // console.log(\'进入beforeClose事件22222\');\n    if (action === \'confirm\') {\n        // console.log(\'进入 action === confirm 条件\');\n        instance.$refs[\'confirm\'].$el.onclick = (function(e) {\n            // console.log(\'进入点击事件\');\n            e = e || window.event;\n            if (e.detail !== 0) {\n                done();\n            }\n        }());\n    } else {\n        done();\n    }\n}\n\n\n\n# element中下拉框select在长页面滚动时，下拉弹框没有跟随下拉框跑路\n\n设置这个属性即可 :popper-append-to-body=“false”\n\n<el-select v-model="formData.proTypeCode" placeholder="请选择经营性质" filterable clearable style="width: 100%;" @change="prodTypeChange" :popper-append-to-body="false">\n    <el-option v-for="item in proTypeList" :label="item.baseName" :value="item.baseCode" :key="item.baseCode"></el-option>\n    <el-option value="" class="click-bottom"><el-button type="text" @click="addbasePage(\'proTypeList\', \'6010\')">新增</el-button></el-option>\n</el-select>\n\n\n注意\n\n该属性只能用于整个body页面上的表单，局域上的区域无法达到要求\n\n\n# DateTimePicker日期范围封装组件[日期范围/月份范围/年份范围]\n\n引用\n\n<template>\n<div>\n    <timeFrame\n               :dataType="[\'daterange\', \'monthrange\', \'yearrange\'][userActiveShow]"\n               @changeTime="changeTime"\n               >\n    </timeFrame>\n    </div>\n</template>\n\n<script>\n    export default {\n        data() {\n            return {\n                userActiveShow:0,\n                formInline: [],\n            };\n        },\n        methods: {\n            changeTime(time) {\n                console.log(time, "====");// [\'\',\'\']\n                this.formInline = time;\n            },\n        };\n<\/script>\n\n<style>\n</style>\n\n\n新建组件文件timeFrame.vue\n\n<template>\n  <div>\n    <el-date-picker\n      v-if="dataType == \'daterange\' || dataType == \'monthrange\'"\n      v-model="dateOrMonthTime"\n      :type="dataType"\n      range-separator="-"\n      :value-format="valueFormat"\n      @change="changeTime"\n      :start-placeholder="$i18ns(startPlaceholder)"\n      :end-placeholder="$i18ns(endPlaceholder)"\n    >\n    </el-date-picker>\n    <span v-else-if="dataType == \'yearrange\'">\n      <el-date-picker\n        v-model="yeartsStart"\n        :picker-options="startDatePicker"\n        :value-format="valueFormat"\n        type="year"\n        @change="changeYearTime"\n        :placeholder="$i18ns(startPlaceholder)"\n      >\n      </el-date-picker>\n      ~\n      <el-date-picker\n        v-model="yeartsEnd"\n        :value-format="valueFormat"\n        @change="changeYearTime"\n        :picker-options="endDatePicker"\n        type="year"\n        :placeholder="$i18ns(endPlaceholder)"\n      >\n      </el-date-picker>\n    </span>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    // daterange -日期范围； monthrange -月份范围； yearrange -年份范围\n    dataType: {\n      type: String,\n      default: "daterange",\n    },\n    // 时间的格式\n    valueFormat: {\n      type: String,\n      default: "yyyy-MM-dd",\n    },\n    // 开始提示语\n    startPlaceholder: {\n      type: String,\n      default: "Startdate",\n    },\n    // 结束提示语\n    endPlaceholder: {\n      type: String,\n      default: "Enddate",\n    },\n  },\n  data() {\n    return {\n      dateOrMonthTime: [],\n      // 年份的时间\n      yeartsStart: "",\n      yeartsEnd: "",\n      // 提出开始时间必须小于提出结束时间\n      startDatePicker: {\n        //开始时间限制\n        disabledDate: (time) => {\n          let beginVal = this.yeartsEnd;\n          if (beginVal) {\n            return time.getTime() >= new Date(beginVal).getTime();\n          }\n        },\n      },\n      // 提出结束时间必须大于提出开始时间\n      endDatePicker: {\n        disabledDate: (time) => {\n          let beginVal = this.yeartsStart;\n          if (beginVal) {\n            return time.getTime() < new Date(beginVal).getTime() - 86399999;\n          }\n        },\n      },\n    };\n  },\n  methods: {\n    changeTime(val) {\n      // console.log(val, "====val");\n      if (val && val instanceof Array && this.dataType == "monthrange") {\n        // 月份的时候\n        const date = new Date(val[1]);\n        date.setDate(28);\n        date.setMonth(date.getMonth() + 1);\n        let currentDate = this.getTimeDate(date.setDate(0), "month", "endTime");\n        // console.log(currentDate, "===currentDate");\n        // // 日期设置为0号, 0表示1号的前一天\n        this.dateOrMonthTime[1] = currentDate;\n      }\n      this.$emit("changeTime", this.dateOrMonthTime);\n    },\n    // 更改年份\n    changeYearTime() {\n      let startTime = this.getTimeDate(this.yeartsStart, "year", "startTime");\n      let endTime = this.getTimeDate(this.yeartsEnd, "year", "endTime");\n      this.$emit("changeTime", [startTime, endTime]);\n    },\n    // 获取当月/当年的数据\n    getTimeDate(taggledate, type, time) {\n      console.log(taggledate, "=====taggledate");\n      if (taggledate) {\n        let data = new Date(taggledate);\n        let year, month, date;\n        if (time == "startTime") {\n          // 开始的时候\n          if (type == "month") {\n            year = data.getFullYear();\n            month = data.getMonth() + 1;\n            date = 1;\n          } else if (type == "year") {\n            year = data.getFullYear();\n            month = 1;\n            date = 1;\n          } else {\n            year = data.getFullYear();\n            month = data.getMonth() + 1;\n            date = data.getDate();\n          }\n        } else if (time == "endTime") {\n          // 结束的时候\n          if (type == "month") {\n            year = data.getFullYear();\n            month = data.getMonth() + 1;\n            date = new Date(year, month, 0).getDate(); //获取当月最后一日\n          } else if (type == "year") {\n            year = data.getFullYear();\n            month = 12;\n            date = new Date(year, month, 0).getDate(); //获取当月最后一日\n          } else {\n            year = data.getFullYear();\n            month = data.getMonth() + 1;\n            date = data.getDate();\n          }\n        }\n        month = Number(month) < 10 ? "0" + month : month; //月份补 0\n        date = Number(date) < 10 ? "0" + date : date; //日期补 0\n        return [year, month, date].join("-");\n      } else {\n        return "";\n      }\n    },\n  },\n};\n<\/script>\n\n<style>\n</style>\n\n\n\n# element日期组件时间范围选择限制\n\n# 1.只能选择今天及今天之后的日期\n\n<template>\n  <div>\n    <el-date-picker v-model="timeDate" type="daterange" range-separator="至" start-placeholder="开始日期"\n      end-placeholder="结束日期" value-format="yyyy-MM-dd" :picker-options="pickerOptions">\n    </el-date-picker>\n  </div>\n</template>\n\n<script>\n  export default {\n    data() {\n      return {\n        timeDate: "",\n        pickerOptions: {\n          disabledDate(time) {\n            return time.getTime() < Date.now() - 8.64e7; //只能选择今天及今天之后的日期\n            //return time.getTime() < Date.now() - 8.64e6; //只能选择今天之后的日期，今天的日期也不能选\n          }\n        },\n      }\n    },\n  }\n<\/script>\n\n\n# 2.只能选择今天及今天之前的日期\n\n<template>\n  <div>\n    <el-date-picker v-model="timeDate" type="daterange" range-separator="至" start-placeholder="开始日期"\n      end-placeholder="结束日期" value-format="yyyy-MM-dd" :picker-options="pickerOptions">\n    </el-date-picker>\n  </div>\n</template>\n\n<script>\n  export default {\n    data() {\n      return {\n        timeDate: "",\n        pickerOptions: {\n          disabledDate(time) {\n            return time.getTime() > Date.now() - 8.64e6; //只能选择今天及今天之前的日期\n            // return time.getTime() > Date.now() - 8.64e7; //只能选择今天之前的日期，连今天的日期也不能选\n          }\n        },\n      }\n    },\n  }\n<\/script>\n\n\n\n# el-tree\n\n\n# element的el-tree组件宽度超出父元素滚动条不生效问题\n\n.el-tree>.el-tree-node{\n    min-width:100%;\n    display: inline-block;\n}\n',normalizedContent:'# element\n\nelement 官网：https://element.eleme.cn/2.14/#/zh-cn/component/quickstart\n\n\n# el-table\n\n\n# type=“seletion“ 设置表格行时候可以选择\n\n项目需求：有的行可被选择，有的行不可被选择\n\n参数           说明                                                          类型\nselectable   仅对 type=selection 的列有效，类型为 function，function 的返回值用来决定这一行的   function(row, index)\n             checkbox 是否可以勾选\n\n添加:selectable属性即可,设置方法checkboxselect\n\n<el-table-column type="selection" align="center" fixed width="50" :selectable=\'checkboxselect\'/>\n\n\n设置自己的逻辑\n\ncheckboxselect(row,index){ \n  //控制表格的选择\n  // 通过return true or false 控制表格是否选择 true 可选 false 不可选\n  //如下仅供参考，写自己的逻辑交互\n  if(index ===3 ){\n    return true\n  }else{\n    return false\n  }\n},\n\n\n\n# table的sortable使用\n\n1、业务分析\n\n效果：默认升序，点击排序的icon，上箭头升序，下箭头降序\n\n2、实现\n\n在列中设置sortable属性即可实现以该列为基准的排序，接受一个boolean，默认为false。可以通过 table 的default-sort属性设置默认的排序列和排序顺序。可以使用sort-method或者sort-by使用自定义的排序规则。如果需要后端排序，需将sortable设置为custom，同时在 table 上监听sort-change事件，在事件回调中可以获取当前排序的字段名和排序顺序，从而向接口请求排序后的表格数据。在本例中，我们还使用了formatter属性，它用于格式化指定列的值，接受一个function，会传入两个参数：row和column，可以根据自己的需求进行处理。\n\n3、实例\n\ntip\n\n在需要排序的字段上增加sortable=“custom”,el-table增加@sort-change事件监听排序\n\n<template>\n<div style="padding:20px;height:100%" class="resolve">\n    <el-table\n              :data="tabledata"\n              stripe\n              border\n              @sort-change="changetablesort"\n              style="width:100%;"\n              >\n        <el-table-column type="selection" width="55"> </el-table-column>\n        <el-table-column type="index" width="50" label="序号"></el-table-column>\n        <el-table-column prop="name" label="姓名"></el-table-column>\n        <el-table-column\n                         prop="address"\n                         label="地址"\n                         width="200"\n                         ></el-table-column>\n        <el-table-column prop="paydate" label="paydate"></el-table-column>\n        <el-table-column\n                         prop="come"\n                         label="come"\n                         sortable="custom"\n                         ></el-table-column>\n        <el-table-column prop="pay" label="pay"></el-table-column>\n        <el-table-column prop="money" label="money"></el-table-column>\n    </el-table>\n    <div class="block">\n        <el-pagination\n                       background\n                       layout="prev, pager, next"\n                       :total="50"\n                       :page-size="5"\n                       :current-page="currentpage"\n                       @current-change="handlepagecurrentchange"\n                       >\n    </el-pagination>\n    </div>\n    </div>\n</template>\n\n<script>\n    import { gethomedata } from "@/api/index";\n    export default {\n        name: "",\n        data() {\n            return {\n                tabledata: [],\n                currentpage: 1,\n                fieldname: "",\n                sortmethod: "",\n            };\n        },\n        mounted() {\n            this.getdata();\n        },\n        methods: {\n            getdata() {\n                var data = {\n                    pageindex: this.currentpage,\n                    pagesize: 10,\n                    come: this.sortmethod, // 排序的字段：排序的方式(升序/降序)\n                };\n                gethomedata(data).then((res) => {\n                    console.log(res);\n                    console.log("table", res.data.content);\n                    if (res.code == 0) {\n                        this.tabledata = res.data.content;\n                    }\n                });\n            },\n            handlepagecurrentchange(value) {\n                console.log("value", value);\n                this.currentpage = value;\n                this.getdata();\n            },\n            // 排序\n            changetablesort(column) {\n                console.log("column", column);\n                // this.fieldname = column.prop;\n                var sortingtype = column.order;\n                sortingtype == "ascending"\n                    ? (this.sortmethod = "asc")\n                : (this.sortmethod = "desc");\n                this.getdata(this.sortmethod);\n            },\n        },\n    };\n<\/script>\n\n<style scoped>\n    .resolve {\n        overflow-y: auto;\n    }\n    .block {\n        margin-top: 20px;\n    }\n</style>\n\n\n\n\n# table横向滚动条一直在可视范围内\n\nhttps://www.cnblogs.com/lunuz/articles/13932622.html\n\n当数据过多，table的x轴滚动条不在可视区域时，给table的父级容器添加一个滚动条perfectscrollbar，然后将perfectscrollbar的scroll值赋值给table自己的滚动条\n\ntabledemo.vue\n\n<template>\n<div>\n    <el-row type="flex" justify="end">\n        <el-col :span="6">\n            <el-button type="primary" @click="getdata">获取数据</el-button>\n    </el-col>\n    </el-row>\n    <div class="tablec" style="position: relative; ">\n        \x3c!--绑定v-perfect-scrollbar 指令--\x3e\n        <el-table\n                  v-perfect-scrollbar\n                  border\n                  resizable\n                  :data="tabledata">\n            <el-table-column sortable="custom" prop="column_1" label="行1" show-overflow-tooltip="" width="120">\n                <template slot-scope="scope">\n                    <span>{{ scope.row.column_1 }}</span>\n</template>\n</el-table-column>\n<el-table-column sortable="" prop="column_2" label="行2" show-overflow-tooltip="" width="120">\n    <template slot-scope="scope">\n<span>{{ scope.row.column_2 }}</span>\n    </template>\n</el-table-column>\n<el-table-column sortable="" prop="column_3" label="行3" show-overflow-tooltip="" width="140">\n    <template slot-scope="scope">\n<span>{{ scope.row.column_3 }}</span>\n    </template>\n</el-table-column>\n<el-table-column sortable="" prop="column_4" label="行4" show-overflow-tooltip="" width="160">\n    <template slot-scope="scope">\n<span>{{ scope.row.column_4 }}</span></template>\n</el-table-column>\n<el-table-column sortable="" prop="column_5" label="行5" show-overflow-tooltip="" width="180">\n    <template slot-scope="scope">\n<span>{{ scope.row.column_5 }}</span>\n    </template>\n</el-table-column>\n<el-table-column sortable="" prop="column_6" label="行6" show-overflow-tooltip="" width="200">\n    <template slot-scope="scope">\n<span>{{ scope.row.column_6 }}</span>\n    </template>\n</el-table-column>\n<el-table-column sortable="" prop="column_7" label="行7" show-overflow-tooltip="" width="220">\n    <template slot-scope="scope">\n<span>{{ scope.row.column_7 }}</span>\n    </template>\n</el-table-column>\n<el-table-column sortable="" prop="column_8" label="行8" show-overflow-tooltip="" width="200">\n    <template slot-scope="scope">\n<span>{{ scope.row.column_8 }}</span>\n    </template>\n</el-table-column>\n<el-table-column sortable="" prop="column_9" label="行9" show-overflow-tooltip="" width="200">\n    <template slot-scope="scope">\n<span>{{ scope.row.column_9 }}</span>\n    </template>\n</el-table-column>\n<el-table-column sortable="" prop="column_10" label="行10" show-overflow-tooltip="" width="200">\n    <template slot-scope="scope">\n<span>{{ scope.row.column_10 }}</span>\n    </template>\n</el-table-column>\n<el-table-column sortable="" prop="column_11" label="行11" show-overflow-tooltip="" width="200">\n    <template slot-scope="scope">\n<span>{{ scope.row.column_11 }}</span>\n    </template>\n</el-table-column>\n<el-table-column sortable="" prop="column_12" label="行12" show-overflow-tooltip="" width="200">\n    <template slot-scope="scope">\n<span>{{ scope.row.column_12 }}</span>\n    </template>\n</el-table-column>\n</el-table>\n</div>\n\x3c!--用来占位--\x3e\n<el-pagination background="" layout="prev, pager, next" :total="1000"></el-pagination>\n</div>\n</template>\n<script>\n    export\n    default {\n        data() {\n            return {\n                tabledata:[]\n            }\n        },\n        methods: {\n            getdata() {\n                var len = this.tabledata.length\n                var i = 0;\n                while (i < 50) {\n                    var bz = len + i;\n                    this.tabledata.push({\n                        column_1: "第1-" + bz + "行的数据",\n                        column_2: "第2-" + bz + "行的数据",\n                        column_3: "第3-" + bz + "行的数据",\n                        column_4: "第4-" + bz + "行的数据",\n                        column_5: "第5-" + bz + "行的数据",\n                        column_6: "第6-" + bz + "行的数据",\n                        column_7: "第7-" + bz + "行的数据",\n                        column_8: "第8-" + bz + "行的数据",\n                        column_9: "第9-" + bz + "行的数据",\n                        column_10: "第10-" + bz + "行的数据",\n                        column_11: "第11" + bz + "行的数据",\n                        column_12: "第12-" + bz + "行的数据",\n                    });\n                    i++;\n                }\n            },\n        },\n\n    };\n<\/script>\n<style scoped>\n    .el-row{ margin-bottom: 15px; }\n    .el-pagination{ margin-top: 20px; }\n</style>\n\x3c!--需设置为全局css样式--\x3e\n<style>\n    .tablec{ position:relative;}\n    .el-table th{ height: 60px; }\n    .el-table td{ padding:0; height: 50px; font-size: 14px; }\n    .el-table.hide-scrollbar{\n        /*隐藏滚动条 设置底部padding20px*/\n        scrollbar-width: none; /* firefox */\n        -ms-overflow-style: none; /* ie 10+ */\n        padding-bottom: 20px;\n    }\n    .el-table.hide-scrollbar ::-webkit-scrollbar { display: none; /* chrome safari */ }\n</style>\n\x3c!--tabledemo.vue--end--\x3e\n\n\napp.vue里面id="app"的div绑定v-app-scroll 指令，设置style="height: 100vh;overflow-y: scroll"\n\ndirective.js\n\n// 自定义table水平滚动条始终显示在可视区域\nvue.directive(\'perfectscrollbar\', {\n    componentupdated:function (el, binding,vnode) {\n        let trcount=vnode.context.tabledata.length;// tr的个数\n        fixtabscrollbar(el,null,trcount)\n    }\n})\n//自定义app滚动事件\nvue.directive(\'appscroll\', {\n    bind: function(el, binding, vnode) {\n        let start = (e) =>{\n            fixtabscrollbar(null,el)\n        }\n        // 添加事件监听器\n        el.addeventlistener("scroll", start);\n    }\n})\n//app滚动->定位table的水平滚动条\nfunction fixtabscrollbar(tabele,appele,trcount) {\n    var tabele=tabele||document.getelementsbyclassname(\'el-table\')[0] // table 元素\n    var appele=appele||document.getelementbyid("app") // 滚动条所在容器\n    if(!(tabele&&appele)) return;\n    var tabcontainer=tabele.parentnode; // table 的父级容器\n    let thead = tabele.getelementsbyclassname(\'el-table__header-wrapper\')[0];\n    let tbody = tabele.getelementsbyclassname(\'el-table__body-wrapper\')[0];\n    var trcount=trcount||tbody.getelementsbytagname("tr").length //tr的个数\n    let trheight=50.4 //tr的高度（自己设置的,这里el-table-column需要设置为 show-overflow-tooltip，不然换行会影响tr的高度） elementui这个框架，不知道0.4哪里来的\n    let theadheight=thead.clientheight?thead.clientheight:60; // 表头的高度，60是默认的高度(自己设置的)\n    let tabheight=theadheight+trheight*trcount+18 //table的高度 （18是el-table水平滚动条的高度）\n    let tabwinwidth=thead.clientwidth //table视口的宽度\n    let tabwidth=thead.getelementsbytagname(\'table\')[0].offsetwidth;//table的宽度\n    let appheight=appele.offsetheight- getoffsettop(appele) // 窗口的高度\n    let taboffsettop=getoffsettop(tabcontainer) //table 距离顶部距离\n    let appscrolltop=appele.scrolltop  // 容器向上滚动的距离\n    let bottom=taboffsettop+tabheight-appscrolltop-appheight;\n    if(bottom>0&&tabwidth>tabwinwidth){ //底部大于0并且table的宽度大于el-table视口的宽度--\x3e显示滚动条，并隐藏自己的滚动条\n        let scrollbarele=null\n        let childele=null\n        tabele.classlist.add("hide-scrollbar")  //隐藏tablec自己的滚动条\n        if(document.getelementbyid(\'perfectscrollbar-div\')==null){\n            scrollbarele = document.createelement(\'div\');\n            scrollbarele.id = \'perfectscrollbar-div\';\n            childele=document.createelement(\'p\');\n            childele.id = \'perfectscrollbar-child\';\n            tabcontainer.appendchild(scrollbarele);\n            scrollbarele.appendchild(childele);\n            scrollbarele.style.display="block";\n            childele.style.width=tabwidth+"px";\n            childele.style.height="1px";\n            childele.style.padding="0";\n            childele.style.margin="0";\n            scrollbarele.style.position="absolute";\n            scrollbarele.style.overflowx="auto";\n            scrollbarele.style.left="0px";\n            scrollbarele.style.right="0px";\n            scrollbarele.style.margin="auto";\n        }else{\n            scrollbarele = document.getelementbyid(\'perfectscrollbar-div\');\n        }\n        scrollbarele.style.bottom=bottom+"px";\n        scrollbarele.onscroll = function(){\n            let target=event.target;\n            let scrollleft=target.scrollleft\n            tbody.scrollleft=scrollleft;\n        }\n    }else{\n        tabele.classlist.remove("hide-scrollbar") //显示tablec自己的滚动条\n        var scrollbarele=document.getelementbyid(\'perfectscrollbar-div\');\n        if(scrollbarele)scrollbarele.parentnode.removechild(scrollbarele);\n    }\n}\nfunction getoffsettop(obj) {\n    if (!!window.activexobject || "activexobject" in window) {\n        var y = obj.offsettop;\n        while (obj = obj.offsetparent) y += obj.offsettop;\n        return y;\n    }else{\n        return obj.offsettop\n    }\n}\n\n\n\n# elementui的el-table根据内容长度自适应调整列\n\n 1. 添加\n    \n    <el-table-column prop="name" :width="flexcolumnwidth(\'name\',tabledata)" label="名称" align="center" />\n    \n\n 2. 函数\n    \n    // 自适应表格列宽\n    flexcolumnwidth(str, tabledata, flag = \'max\',flewminwidth) {\n        // str为该列的字段名(传字符串);tabledata为该表格的数据源(传变量);\n        // flag为可选值，可不传该参数,传参时可选\'max\'或\'equal\',默认为\'max\'\n        // flag为\'max\'则设置列宽适配该列中最长的内容,flag为\'equal\'则设置列宽适配该列中第一行内容的长度。\n        str = str + \'\'\n        let columncontent = \'\'\n        if (!tabledata || !tabledata.length || tabledata.length === 0 || tabledata === undefined) {\n            if(flewminwidth){\n                return flewminwidth\n            }\n            return\n        }\n        if (!str || !str.length || str.length === 0 || str === undefined) {\n            return\n        }\n        if (flag === \'equal\') {\n            // 获取该列中第一个不为空的数据(内容)\n            for (let i = 0; i < tabledata.length; i++) {\n                if (tabledata[i][str].length > 0) {\n                    // console.log(\'该列数据[0]:\', tabledata[0][str])\n                    columncontent = tabledata[i][str]\n                    break\n                }\n            }\n        } else {\n            // 获取该列中最长的数据(内容)\n            let index = 0\n            for (let i = 0; i < tabledata.length; i++) {\n                if (tabledata[i][str] === null) {\n                    if(flewminwidth){\n                        return flewminwidth\n                    }\n                    return\n                }\n                const now_temp = tabledata[i][str] + \'\'\n                const max_temp = tabledata[index][str] + \'\'\n                if (now_temp.length > max_temp.length) {\n                    index = i\n                }\n            }\n            columncontent = tabledata[index][str]\n        }\n        // console.log(\'该列数据[i]:\', columncontent)\n        // 以下分配的单位长度可根据实际需求进行调整\n        let flexwidth = 0\n        // 这个循环可以使用js的计算长度进行获取width   \n        for (const char of columncontent) {\n            if ((char >= \'a\' && char <= \'z\') || (char >= \'a\' && char <= \'z\')) {\n                // 如果是英文字符，为字符分配8个单位宽度\n                flexwidth += 8\n            } else if (char >= \'\\u4e00\' && char <= \'\\u9fa5\') {\n                // 如果是中文字符，为字符分配15个单位宽度\n                flexwidth += 15\n            } else {\n                // 其他种类字符，为字符分配8个单位宽度\n                flexwidth += 8\n            }\n        }\n        if (flexwidth < 80) {\n            // 设置最小宽度\n            flexwidth = 80\n        }\n        // if (flexwidth > 250) {\n        //   // 设置最大宽度\n        //   flexwidth = 250\n        // }\n        return flexwidth + \'px\'\n    }\n    \n\n\n# element的table如何在多页数据下勾选多行\n\n业务中，表格数据往往不只一页。多页数据情况下，表格勾选某些行，就会遇到返回上一页，勾选消失的情况。这种情况，需要一些技巧和处理。具体代码如下：\n\n<template>\n    <div class="demo-example">\n        <el-table\n                  ref="table"\n                  v-loading="loading"\n                  :data="list"\n                  height="650"\n                  border\n                  @select="onselect"\n                  @select-all="onselectall"\n                  @selection-change="onselectionchange"\n                  >\n            <el-table-column type="selection" width="55"></el-table-column>\n            <el-table-column prop="u_createtime" label="注册时间"></el-table-column>\n            <el-table-column prop="u_id" label="用户id"></el-table-column>\n            <el-table-column prop="u_nickname" label="用户名称"></el-table-column>\n            <el-table-column prop="u_phone" label="用户账户"></el-table-column>\n            <el-table-column prop="u_gender" label="性别"></el-table-column>\n            <el-table-column label="角色">\n                <template slot-scope="scope">\n                    <span>{{scope.row.u_role === 1 ? \'团队长\' : \'保险人\'}}</span>\n                </template>\n            </el-table-column>\n            <el-table-column prop="u_companynum" label="所属企业数量"></el-table-column>\n            <el-table-column prop="ha_addpeople" label="所属群组">\n                <template slot-scope="scope">\n                    <el-button @click="onchakan(scope.row)" type="text" style="color:#67c23a" size="small">查看</el-button>\n                </template>\n            </el-table-column>\n            <el-table-column prop="u_lastlogintime" label="最近登录时间"></el-table-column>\n        </el-table>\n\n        <div class="block pag" v-if="total">\n            <el-pagination\n                           @current-change="onchangepage"\n                           :current-page="currentpage"\n                           :page-size="10"\n                           layout="total, prev, pager, next, jumper"\n                           :total="total"\n                           ></el-pagination>\n        </div>\n        \n    </div>\n</template>\n\n<script>\n    export default {\n        data() {\n            return {\n                selections: {}, // 保存已选择过的row\n                list: [],\n                total: 0,\n                curpage: 1,\n            };\n        },\n        //方法事件\n        methods: {\n            // 勾选时候，记录[{u_id: row}, ...]\n            onselect(selection, row) {\n                if (this.selections[row.u_id]) {\n                    delete this.selections[row.u_id];\n                } else {\n                    this.selections[row.u_id] = row;\n                }\n            },\n\n            // 全选情况\n            onselectall(selection) {\n                // 全选\n                if (selection.length) {\n                    selection.foreach(row => {\n                        this.selections[row.u_id] = row;\n                    })\n                } else {\n                    // 取消全选\n                    this.list.foreach(row => {\n                        delete this.selections[row.u_id];\n                    })\n                }\n\n            },\n\n            // 对已选择过的row勾选，返回到上一页时候\n            checkrows() {\n                const keys = object.keys(this.selections);\n                const rows = this.list.filter(row => {\n                    return keys.includes(string(row.u_id));\n                });\n\n                rows.map(row => {\n                    this.$refs.table.togglerowselection(row);\n                });\n            },\n\n            // 省略...\n\n            // 获取数据列表\n            getdata() {\n                // ...\n            },\n\n        },\n\n        created() {\n            this.getdata();\n        }\n    };\n<\/script>\n\n\n\n# element的el-table的合并\n\n属性：span-method="objectspanmethod"\n\n# 纵向合并单元格（单列）\n\n封装-mergecolspan.js\n\n// 纵向合并单元格（单列）\n\nexport default class mergecolspan {\n  static celllist = [] // (一行或者一列)每个单元格计算后所占各自的数组\n\n  static docompute(tablebody, paramname) {\n    this.celllist = [] // 单元格数组初始化\n    let count = 0// 第几个合并\n    // f循环遍历表体数据\n    for (let i = 0; i < tablebody.length; i++) {\n      if (i === 0) {\n        // 先设置第一项\n        this.celllist.push(1)\n      } else {\n        if (tablebody[i][paramname] === tablebody[i - 1][paramname]) {\n          this.celllist[count] += 1\n          this.celllist.push(0)\n        } else {\n          this.celllist.push(1)\n          count = i\n        }\n\n      }\n\n    }\n    return false\n  }\n\n  // 第二步，将计算好的结果返回给el-table\n  static domerge(rowindex, columnindex, paramindex) {\n    // 给选定列做单元格合并\n    if (columnindex === paramindex) {\n      const roecell = this.celllist[rowindex]\n      if (roecell > 0) {\n        return {\n          rowspan: roecell,\n          colspan: 1\n        }\n      } else {\n        return {\n          rowspan: 0,\n          colspan: 0\n        }\n      }\n    } else {\n      return {\n        rowspan: 1,\n        colspan: 1\n      }\n    }\n  }\n\n}\n\n\n引用\n\n<template>\n  <el-table\n    :data="tabledata"\n    :span-method="objectspanmethod"\n    border\n    style="width: 100%; margin-top: 20px"\n  >\n    <el-table-column prop="id" label="id" width="180"> </el-table-column>\n    <el-table-column prop="name" label="姓名"> </el-table-column>\n    <el-table-column prop="amount1" label="数值 1（元）"> </el-table-column>\n    <el-table-column prop="amount2" label="数值 2（元）"> </el-table-column>\n    <el-table-column prop="amount3" label="数值 3（元）"> </el-table-column>\n  </el-table>\n</template>\n\n<script>\nimport mergecolspan from \'./mergecolspan\';\nexport default {\n  data() {\n    return {\n      tabledata: [\n        {\n          id: "12987122",\n          name: "王小虎",\n          amount1: "234",\n          amount2: "3.2",\n          amount3: 10,\n        },\n        {\n          id: "12987123",\n          name: "王小虎",\n          amount1: "165",\n          amount2: "4.43",\n          amount3: 12,\n        },\n        {\n          id: "12987124",\n          name: "王小虎",\n          amount1: "324",\n          amount2: "1.9",\n          amount3: 9,\n        },\n        {\n          id: "12987125",\n          name: "王小虎",\n          amount1: "621",\n          amount2: "2.2",\n          amount3: 17,\n        },\n        {\n          id: "12987126",\n          name: "王小虎",\n          amount1: "539",\n          amount2: "4.1",\n          amount3: 15,\n        },\n      ],\n    };\n  },\n  mounted() {\n    mergecolspan.docompute(this.tabledata, "name");\n  },\n  methods: {\n    objectspanmethod({ row, column, rowindex, columnindex }) {\n      return mergecolspan.domerge(rowindex, columnindex, 1);\n    },\n  },\n};\n<\/script>\n\n<style>\n</style>\n\n\n# 纵向合并单元格（多列）\n\n封装-mergecolspans.js\n\n// 纵向合并单元格（多列）\n\nexport default class mergecolspans {\n  static needmergearr = [] // 需要合并列的项目的集合\n  static rowmergearrs = [] // 需要存放合并项信息的对象\n\n  static rowmerrgehandle(arr, data) {\n    if (!array.isarray(arr) && !arr.length) return false\n    if (!array.isarray(data) && !data.length) return false\n    this.needmergearr = arr\n    let needmerge = {}\n\n    arr.foreach((i, idx) => {\n      needmerge[i] = {\n        rowarr: [],\n        rowmergenum: 0\n      }\n\n      if (idx === 0) {\n        data.foreach((item, index) => {\n          if (index === 0) {\n            needmerge[i].rowarr.push(1)\n            needmerge[i].rowmergenum = 0\n          } else {\n            if (item[i] === data[index - 1][i]) {\n              needmerge[i].rowarr.push(0)\n              needmerge[i].rowarr[needmerge[i].rowmergenum] += 1\n            } else {\n              needmerge[i].rowarr.push(1)\n              needmerge[i].rowmergenum = index\n            }\n          }\n        })\n      } else {\n        let firstrowarr = needmerge[arr[0]].rowarr\n        let firstrowarrdeal = []\n        firstrowarr.foreach((ietm, index) => {\n          if (index > 0) {\n            firstrowarrdeal.push(index)\n          }\n        })\n        data.foreach((item, index) => {\n          let sign = false\n          if (firstrowarrdeal.indexof(index) > 0) {\n            needmerge[i].rowmergenum = index\n            sign = true\n          }\n          // 表格首个数据单独处理\n          if (index === 0) {\n            needmerge[i].rowarr.push(1)\n            needmerge[i].rowmergenum = 0\n          } else {\n            if (item[i] === data[index - 1][i]) {\n              if (sign) {\n                needmerge[i].rowarr.push(1)\n              } else {\n                needmerge[i].rowarr.push(0)\n                needmerge[i].rowarr[needmerge[i].rowmergenum] += 1\n              }\n            } else {\n              needmerge[i].rowarr.push(1)\n              needmerge[i].rowmergenum = index\n            }\n          }\n        })\n      }\n      this.rowmergearrs = needmerge\n    });\n  }\n\n\n  static mergeaction(column, rowindex) {\n    for (const res in this.needmergearr) {\n      if (this.needmergearr[res] === column.property) {\n        let _row = this.rowmergearrs[column.property].rowarr[rowindex]\n        let _col = _row > 0 ? 1 : 0\n        return [_row, _col]\n      }\n\n    }\n  }\n\n}\n\n\n引用\n\n<template>\n  <el-table\n    :data="tabledata"\n    :span-method="objectspanmethod"\n    border\n    style="width: 100%; margin-top: 20px"\n  >\n    <el-table-column prop="id" label="id" width="180"> </el-table-column>\n    <el-table-column prop="name" label="姓名"> </el-table-column>\n    <el-table-column prop="amount1" label="数值 1（元）"> </el-table-column>\n    <el-table-column prop="amount2" label="数值 2（元）"> </el-table-column>\n    <el-table-column prop="amount3" label="数值 3（元）"> </el-table-column>\n  </el-table>\n</template>\n\n<script>\nimport mergecolspans from \'./mergecolspans\';\nexport default {\n  data() {\n    return {\n      tabledata: [\n        {\n          id: "12987122",\n          name: "王小虎",\n          amount1: "234",\n          amount2: "3.2",\n          amount3: 10,\n        },\n        {\n          id: "12987123",\n          name: "王小虎",\n          amount1: "165",\n          amount2: "4.43",\n          amount3: 12,\n        },\n        {\n          id: "12987124",\n          name: "王小虎",\n          amount1: "324",\n          amount2: "1.9",\n          amount3: 9,\n        },\n        {\n          id: "12987125",\n          name: "王小虎",\n          amount1: "621",\n          amount2: "2.2",\n          amount3: 17,\n        },\n        {\n          id: "12987126",\n          name: "王小虎",\n          amount1: "539",\n          amount2: "4.1",\n          amount3: 15,\n        },\n      ],\n    };\n  },\n  mounted() {\n    mergecolspans.rowmerrgehandle(["name"], this.tabledata);\n  },\n  methods: {\n    objectspanmethod({ row, column, rowindex, columnindex }) {\n      return mergecolspans.mergeaction(column, rowindex);\n    },\n  },\n};\n<\/script>\n\n<style>\n</style>\n\n\n\n# 基于elementui-table的表头吸顶(黏性布局)效果实现\n\n# 1.使用自定义指令\n\n我们给每一想要固定头部的table都加一个自定义指令v-sticky，而且，我们需要传入自定义指令两个参数，top:指定距离顶部的高度，parent:指定滚动容器,如果滚动容器是#document，则不传入parent；\n\nv-sticky="{\n    top:0,\n    parent:\'#table_box\' \n}"\n\n\n 1. 开始编写自定义指令\n\n * 代码逻辑写在注释中\n\nimport vue from \'vue\'\n// 给固定头设置样式\nfunction dofix(dom, top) {\n    dom.style.position = \'fixed\'\n    dom.style.zindex = \'2001\'\n    dom.style.top = top + \'px\'\n    dom.parentnode.style.paddingtop = top + \'px\'\n}\n// 给固定头取消样式\nfunction removefix(dom) {\n    dom.parentnode.style.paddingtop = 0\n    dom.style.position = \'static\'\n    dom.style.top = \'0\'\n    dom.style.zindex = \'0\'\n}\n// 给固定头添加class\nfunction addclass(dom, fixtop) {\n    const old = dom.classname\n    if (!old.includes(\'fixed\')) {\n        dom.setattribute(\'class\', old + \' fixed\')\n        dofix(dom, fixtop)\n    }\n}\n// 给固定头移除class\nfunction removeclass(dom) {\n    const old = dom.classname\n    const idx = old.indexof(\'fixed\')\n    if (idx !== -1) {\n        const newclass = old.substr(0, idx - 1)\n        dom.setattribute(\'class\', newclass)\n        removefix(dom)\n    }\n}\n// 具体判断是否固定头的主函数\nfunction fixhead(parent, el, top) {\n    /**\n   * mytop 当前元素距离滚动父容器的高度，\n   * fixtop 当前元素需要设置的绝对定位的高度\n   * parentheight 滚动父容器的高度\n   */\n    let mytop, fixtop, parentheight\n    // 表头dom节点\n    const dom = el.children[1]\n\n    if (parent.tagname) {\n        // 如果是dom内局部滚动\n        // 当前元素距离滚动父容器的高度= 当前元素距离父元素的高度-父容器的滚动距离-表头的高度\n        mytop = el.offsettop - parent.scrolltop - dom.offsetheight\n        // 父元素高度\n        const height = getcomputedstyle(parent).height\n        parentheight = number(height.slice(0, height.length - 2))\n        // 绝对定位高度 = 滚动父容器相对于视口的高度 + 传入的吸顶高度\n        fixtop = top + parent.getboundingclientrect().top\n        // 如果自己距离顶部距离大于父元素的高度，也就是自己还没在父元素滚动出来，直接return\n        if (mytop > parentheight) {\n            return\n        }\n    } else {\n        // document节点滚动\n        // 当前元素距离滚动父容器的高度 = 当前元素距离视口顶端的距离\n        mytop = el.getboundingclientrect().top\n        // 父元素高度 = 视口的高度\n        parentheight = window.innerheight\n        //  绝对定位高度 = 传入的吸顶高度\n        fixtop = top\n        // 如果自己距离顶部距离大于父元素的高度，也就是自己还没在父元素滚动出来，直接return\n        if (mytop > document.documentelement.scrolltop + parentheight) {\n            return\n        }\n    }\n    // 如果 已经滚动的上去不在父容器显示了。直接return \n    if (math.abs(mytop) > el.offsetheight + 100) {\n        return\n    }\n    if (mytop < 0 && math.abs(mytop) > el.offsetheight) {\n        // 如果当前表格已经完全滚动到父元素上面，也就是不在父元素显示了。则需要去除fixed定位\n        removeclass(dom)\n    } else if (mytop <= 0) {\n        // 如果表头滚动到 父容器顶部了。fixed定位\n        addclass(dom, fixtop)\n    } else if (mytop > 0) {\n        // 如果表格向上滚动 又滚动到父容器里。取消fixed定位\n        removeclass(dom)\n    } else if (math.abs(mytop) < el.offsetheight) {\n        // 如果滚动的距离的绝对值小于自身的高度，也就是说表格向上滚动，刚刚显示出表格的尾部是需要将表头fixed定位\n        addclass(dom, fixtop)\n    }\n}\n// 设置头部固定时表头外容器的宽度写死为表格body的宽度\nfunction setheadwidth(el) {\n    // 获取到当前表格个表格body的宽度\n    const width = getcomputedstyle(\n        el.getelementsbyclassname(\'el-table__body-wrapper\')[0]\n    ).width\n    // 给表格设置宽度。这里默认一个页面中的多个表格宽度是一样的。所以直接遍历赋值，也可以根据自己需求，单独设置\n    const tableparent = el.getelementsbyclassname(\'el-table__header-wrapper\')\n    for (let i = 0; i < tableparent.length; i++) {\n        tableparent[i].style.width = width\n    }\n}\n/**\n * 这里有三个全局对象。用于存放监听事件。方便组件销毁后移除监听事件\n */\nconst fixfunobj = {}      // 用于存放滚动容器的监听scroll事件\nconst setwidthfunobj = {}   // 用于存放页面resize后重新计算head宽度事件\nconst automovefunobj ={}    // 用户存放如果是dom元素内局部滚动时，document滚动时，fix布局的表头也需要跟着document一起向上滚动\n\n// 全局注册 自定义事件\nvue.directive(\'sticky\', {\n    // 当被绑定的元素插入到 dom 中时……\n    inserted(el, binding, vnode) {\n        // 首先设置表头宽度\n        setheadwidth(el)\n        // 获取当前vuecomponent的id。作为存放各种监听事件的key\n        const uid = vnode.componentinstance._uid\n        // 当window resize时 重新计算设置表头宽度，并将监听函数存入 监听函数对象中，方便移除监听事件\n        window.addeventlistener(\n            \'resize\',\n            (setwidthfunobj[uid] = () => {\n                setheadwidth(el)\n            })\n        )\n        // 获取当前滚动的容器是什么。如果是document滚动。则可默认不传入parent参数\n        const scrollparent =\n              document.queryselector(binding.value.parent) || document\n        // 给滚动容器加scroll监听事件。并将监听函数存入 监听函数对象中，方便移除监听事件\n        scrollparent.addeventlistener(\n            \'scroll\',\n            (fixfunobj[uid] = () => {\n                fixhead(scrollparent, el, binding.value.top)\n            })\n        )\n        // 如果是局部dom元素内滚动。则需要监听document滚动，document滚动是同步让表头一起滚动。并将监听函数存入 监听函数对象中，方便移除监听事件\n        if (binding.value.parent) {\n            document.addeventlistener(\'scroll\', automovefunobj[uid] = ()=> {\n                // 获取到表头dom节点\n                const dom = el.children[1]\n                // 如果当前表头是fixed定位。则跟着document滚动一起滚\n                if(getcomputedstyle(dom).position=== \'fixed\'){\n                    // 滚动的距离是： 滚动父容器距离视口顶端高度 + 传入的吸顶固定距离 \n                    const fixtop =\n                          binding.value.top + scrollparent.getboundingclientrect().top\n                    dofix(dom, fixtop, \'fixed\')\n                }\n            })\n        }\n    },\n    // component 更新后。重新计算表头宽度\n    componentupdated(el) {\n        setheadwidth(el)\n    },\n    // 节点取消绑定时 移除各项监听事件。\n    unbind(el, binding, vnode) {\n        const uid = vnode.componentinstance._uid\n        window.removeeventlistener(\'resize\', setwidthfunobj[uid])\n        const scrollparent =\n              document.queryselector(binding.value.parent) || document\n        scrollparent.removeeventlistener(\'scroll\', fixfunobj[uid])\n        if (binding.value.parent) {\n            document.removeeventlistener(\'scroll\', automovefunobj[uid])\n        }\n    }\n})\n\n\n# 1.1添加测试代码\n\n * 首先是html代码\n\n<div class="table">\n    <div id="table_box" class="table_box">\n        <el-table\n                  v-for="item in [1, 2]"\n                  :key="item"\n                  ref="stickytable"\n                  v-sticky="{\n                            top: 0,\n                            parent: \'#table_box\'\n                            }"\n                  :data="tabledata"\n                  style="width: 100%"\n                  border\n                  >\n            <el-table-column prop="date" :label="`日期${item}`" width="180">\n            </el-table-column>\n            <el-table-column prop="name" :label="`姓名${item}`" width="180">\n            </el-table-column>\n            <el-table-column prop="address" :label="`地址${item}`">\n            </el-table-column>\n        </el-table>\n    </div>\n    <el-table\n              v-for="item in [3, 4]"\n              :key="item"\n              ref="stickytable"\n              v-sticky="{\n                        top: 0\n                        }"\n              :data="tabledata"\n              style="width: 100%"\n              border\n              >\n        <el-table-column prop="date" :label="`日期${item}`" width="180">\n        </el-table-column>\n        <el-table-column prop="name" :label="`姓名${item}`" width="180">\n        </el-table-column>\n        <el-table-column prop="address" :label="`地址${item}`"> </el-table-column>\n    </el-table>\n</div>\n\n\n页面中定义了四个表格，前两个在一个父容器div#table_box中滚动，后两个则随document滚动\n\n * 再给表格加一下样式，方便区分每个表格和表头\n\n.table {\n    width: 100%;\n    border: 1px solid #ddd;\n    padding: 10px 20px;\n    .table_box {\n        border: 1px solid red;\n        margin-bottom: 20px;\n        height: 200px;\n        overflow-x: hidden;\n        overflow-y: auto;\n    }\n    .el-table {\n        margin-bottom: 50px;\n        border: 1px solid transparent;\n    }\n    /deep/ .el-table__header-wrapper {\n        th {\n            background: rgba(244, 244, 244, 1);\n        }\n    }\n}\n\n\n * 加一些js，给表格添加数据。使用settimeout模拟异步请求数据\n\nexport default {\n    data() {\n        return {\n            tabledata: []\n        }\n    },\n    mounted() {\n        this.settabledata()\n    },\n    methods: {\n        settabledata() {\n            const result = []\n            for (let i = 0; i < 20; i++) {\n                result.push({\n                    date: \'2016-05-03\',\n                    name: \'王小虎\' + i,\n                    address: \'上海市普陀区金沙江路 1516 弄\' + i\n                })\n            }\n            settimeout(() => {\n                this.tabledata = result\n            }, 500)\n        }\n    }\n}\n\n\n该demo仅支持elementui中简单的table。如table中存在左右固定的布局的，样式可能会错乱。感兴趣的同学再深入研究下~\n\n# 2.直接css实现（吸顶功能）\n\n// css吸顶功能 \n#maincontainer {\n    >div,\n    .ceiling,\n    .ceilingtab {\n        >.el-table {\n            .el-table__header-wrapper {\n                position: sticky;\n                top: 0px;\n                left: 0px;\n                background: #fff;\n                z-index: 4;\n            }\n\n        }\n\n        // 左右布局表格的吸顶\n        .ceiling {\n            >.el-table {\n                .el-table__header-wrapper {\n                    top: 0px;\n                }\n            }\n        }\n\n        // 左右布局tab标签页内部表格的吸顶\n        .ceilingtab {\n            >.el-table {\n                .el-table__header-wrapper {\n                    top: 2px;\n                }\n            }\n        }\n\n        >.el-tabs {\n            .el-table {\n                .el-table__header-wrapper {\n                    position: sticky;\n                    top: -16px;\n                    left: 0px;\n                    background: #fff;\n                    z-index: 2;\n                }\n            }\n        }\n\n        //分页功能顶部吸住\n        .el-pagination,\n        .elpagination {\n            position: sticky;\n            bottom: 0px;\n            left: 0px;\n            background: #fff;\n            text-align: right;\n            width: 100%;\n            z-index: 3;\n            margin-top: 5px;\n            padding: 6px 0;\n        }\n    }\n}\n\n\n# position: sticky\n\nposition的含义是指定位类型，取值类型可以有：static、relative、absolute、fixed、inherit和sticky，这里sticky是css3新发布的一个属性。我今天重点要说的就是sticky属性\n\nposition:sticky用法\n\n * position:sticky 被称为粘性定位元素（stickily positioned element）是计算后位置属性为 sticky 的元素。\n * 简单的理解就是：在目标区域以内，它的行为就像 position:relative;在滑动过程中，某个元素距离其父元素的距离达到sticky粘性定位的要求时(比如top：100px)；position:sticky这时的效果相当于fixed定位，固定到适当位置。\n * 可以说是相对定位relative和固定定位fixed的结合\n * 元素固定的相对偏移是相对于离它最近的具有滚动框的祖先元素，如果祖先元素都不可以滚动，那么是相对于viewport来计算元素的偏移量。\n\nposition:sticky 使用条件\n\n1.父元素不能overflow:hidden或者overflow:auto属性。 2.必须指定top、bottom、left、right4个值之一，否则只会处于相对定位 3.父元素的高度不能低于sticky元素的高度 4、sticky元素仅在其父元素内生效\n\n\n# el-form\n\n\n# 关于elementui中select框在页面滚动时el-option超出元素区域的问题\n\n问题：在项目开发中发现elementui中的select组件在页面滚动时会随着页面滚动并遮盖页面\n\n1、创建js文件\n\nfackclickoutside.js\n\nlet lock = true;\nlet el = null;\nconst mousedownevent = new event(\'mousedown\', {bubbles:true});\nconst mouseupevent = new event(\'mouseup\', {bubbles:true});\nconst fakeclickoutside = () => {\n    document.dispatchevent(mousedownevent);\n    document.dispatchevent(mouseupevent);\n    lock = true; // console.log(\'dispatchevent\');\n};\nconst mousedownhandle = e => {\n    let classlist = e.target.classlist;\n    if(classlist.contains(\'el-select__caret\') || classlist.contains(\'el-input__inner\')) {\n        lock = false;\n        return;\n    }\n    if(lock) return;\n    fakeclickoutside();\n};\nconst mousewheelhandle = e => {\n    if(lock || e.target.classlist.contains(\'el-select-dropdown__item\') || e.target.parentnode.classlist.contains(\'el-select-dropdown__item\')) return;\n    fakeclickoutside();\n};\nconst eventlistener = (type) => {\n    el[type + \'eventlistener\'](\'mousedown\', mousedownhandle);\n    window[type + \'eventlistener\'](\'mousewheel\', mousewheelhandle);\n    window[type + \'eventlistener\'](\'dommousescroll\', mousewheelhandle); // firefox 3.5+ \n}\nexport default {\n    mounted() {\n        el = this.$root.$el;\n        el.addfakeclickoutsideeventcount = el.addfakeclickoutsideeventcount || 0;\n        (! el.addfakeclickoutsideeventcount) && this.$nexttick(() => {\n            eventlistener(\'add\');\n        });\n        el.addfakeclickoutsideeventcount += 1;\n    },\n    destroyed() {\n        eventlistener(\'remove\');\n        el.addfakeclickoutsideeventcount -= 1;\n    },\n}\n\n\n2、使用\n\n// app.vue\n\nimport fackclickoutside from \'./util/fackclickoutside\';\n\nnew vue({\n    name: "app"\n    router,\n    mixins: [fackclickoutside],\n})\n\n\n// 鼠标滚动的事件()\n\nfackclickoutside.js\n\nexport default {\n    data() {\n        return {\n            name: \'mixin\',\n            el: "",\n            lock: true,\n            mousedownevent: {},\n            mouseupevent: {}\n        }\n    },\n    mounted() {\n        this.mousedownevent = new event(\'mousedown\', { bubbles: true });\n        this.mouseupevent = new event(\'mouseup\', { bubbles: true });\n        this.el = this.$root.$el;\n        this.el.addfakeclickoutsideeventcount = this.el.addfakeclickoutsideeventcount || 0;\n        (!this.el.addfakeclickoutsideeventcount) && this.$nexttick(() => {\n            this.eventlistener(\'add\');\n        });\n        this.el.addfakeclickoutsideeventcount += 1;\n    },\n    destroyed() {\n        this.eventlistener(\'remove\');\n        this.el.addfakeclickoutsideeventcount -= 1;\n    },\n    methods: {\n        fakeclickoutside(e) {\n            document.dispatchevent(this.mousedownevent);\n            document.dispatchevent(this.mouseupevent);\n            this.lock = true; // console.log(\'dispatchevent\');\n        },\n        mousedownhandle(e) {\n            let classlist = e.target.classlist;\n            if (classlist.contains(\'el-select__caret\') || classlist.contains(\'el-input__inner\')) {\n                this.lock = false;\n                return;\n            }\n            if (this.lock) return;\n            this.fakeclickoutside();\n        },\n        mousewheelhandle(e) {\n            if (this.lock || e.target.classlist.contains(\'el-select-dropdown__item\') || e.target.parentnode.classlist.contains(\'el-select-dropdown__item\') ||\n                e.target.classlist.contains(\'el-time-spinner__item\') || e.target.parentnode.classlist.contains(\'el-time-spinner__item\') ||\n                e.target.classlist.contains(\'el-picker-panel__item\') || e.target.parentnode.classlist.contains(\'el-picker-panel__item\') ||\n                e.target.classlist.contains(\'el-date-picker__item\') || e.target.parentnode.classlist.contains(\'el-date-picker__item\')) {\n                // console.log(e.srcelement.classname);\n                if (typeof e.srcelement.classname === \'string\') {\n                    if ((e.srcelement.classname.indexof(\'el-select-dropdown\') == -1 &&\n                         e.srcelement.classname.indexof(\'el-picker-panel\') == -1 &&\n                         e.srcelement.classname.indexof(\'el-date-picker\') == -1 &&\n                         e.srcelement.classname.indexof(\'el-date-picker\') == -1 &&\n                         e.srcelement.classname.indexof(\'el-time-spinner\') == -1\n                        ) && e.srcelement.classname !== \'\') {\n                        if (document.getelementsbyclassname(\'el-select-dropdown\').length !== 0) {\n                            document.getelementsbyclassname(\'el-select-dropdown\')[0].style.display = "none"\n                        }\n                    } else {\n                        return\n                    }\n                }\n            }\n            this.fakeclickoutside();\n        },\n        eventlistener(type) {\n            this.el[type + \'eventlistener\'](\'mousedown\', this.mousedownhandle);\n            window[type + \'eventlistener\'](\'mousewheel\', this.mousewheelhandle);\n            window[type + \'eventlistener\'](\'dommousescroll\', this.mousewheelhandle); // firefox 3.5+ \n        }\n    }\n}\n\n\n\n# element ui表单el-form的label自适应宽度\n\n在elementui官方文档中el-form提供了一个参数 label-width：\n\n\n\n可以在form表单中设置label-width宽度（作为 form 直接子元素的 form-item 会继承该值），但问题来了，如果不确定标签的长度，给固定值容易造成过长标签的换行，导致页面布局错乱。\n\n所以把label-width设置为auto，如下\n\n<el-form ref="form" :model="form" label-width="auto" size="small" > </el-form>\n\n\n注意\n\n如果给固定值，则还可以设置label标签的对齐方式 label-position="left" 可以通过设置label-width=150px;label-position="left出来的效果，遇到标签过长的字段名称只能在单独的el-form-item标签中设置label-width\n\n\n# element表单内只有一个input回车刷新页面\n\n在表单中如果只有一个el-input的话，按回车会刷新页面。 原因：出发了表单提交事件； 解决方法： 1.在 <el-form></el-form> 中添加@submit.native.prevent\n\n<el-form @submit.native.prevent></el-form>\n\n\n2.多加一个表单控件并且添加display:none;样式\n\n\n# element-ui 表单form 回车 enter 触发查询\n\n在 el-form 上添加 @keyup.enter.native="onquery"\n\n<el-form @keyup.enter.native="onquery"></el-form>\n\n\n\n# elementui中messagebox弹框的取消键盘触发事件(enter,esc)关闭弹窗(执行事件)的解决方法\n\n第一次点击确定按钮的时候,在beforeclose中仅仅只是做了对确定按钮绑定点击事件,以及取消回车响应事件,但是并没有调用.抱着这个想法我认为可以在第一次点击的时候就触发绑定的点击事件.完整代码如下：\n\nbeforeclose: (action, instance, done) => { // 取消回车确认事件\n    // console.log(\'进入beforeclose事件22222\');\n    if (action === \'confirm\') {\n        // console.log(\'进入 action === confirm 条件\');\n        instance.$refs[\'confirm\'].$el.onclick = (function(e) {\n            // console.log(\'进入点击事件\');\n            e = e || window.event;\n            if (e.detail !== 0) {\n                done();\n            }\n        }());\n    } else {\n        done();\n    }\n}\n\n\n\n# element中下拉框select在长页面滚动时，下拉弹框没有跟随下拉框跑路\n\n设置这个属性即可 :popper-append-to-body=“false”\n\n<el-select v-model="formdata.protypecode" placeholder="请选择经营性质" filterable clearable style="width: 100%;" @change="prodtypechange" :popper-append-to-body="false">\n    <el-option v-for="item in protypelist" :label="item.basename" :value="item.basecode" :key="item.basecode"></el-option>\n    <el-option value="" class="click-bottom"><el-button type="text" @click="addbasepage(\'protypelist\', \'6010\')">新增</el-button></el-option>\n</el-select>\n\n\n注意\n\n该属性只能用于整个body页面上的表单，局域上的区域无法达到要求\n\n\n# datetimepicker日期范围封装组件[日期范围/月份范围/年份范围]\n\n引用\n\n<template>\n<div>\n    <timeframe\n               :datatype="[\'daterange\', \'monthrange\', \'yearrange\'][useractiveshow]"\n               @changetime="changetime"\n               >\n    </timeframe>\n    </div>\n</template>\n\n<script>\n    export default {\n        data() {\n            return {\n                useractiveshow:0,\n                forminline: [],\n            };\n        },\n        methods: {\n            changetime(time) {\n                console.log(time, "====");// [\'\',\'\']\n                this.forminline = time;\n            },\n        };\n<\/script>\n\n<style>\n</style>\n\n\n新建组件文件timeframe.vue\n\n<template>\n  <div>\n    <el-date-picker\n      v-if="datatype == \'daterange\' || datatype == \'monthrange\'"\n      v-model="dateormonthtime"\n      :type="datatype"\n      range-separator="-"\n      :value-format="valueformat"\n      @change="changetime"\n      :start-placeholder="$i18ns(startplaceholder)"\n      :end-placeholder="$i18ns(endplaceholder)"\n    >\n    </el-date-picker>\n    <span v-else-if="datatype == \'yearrange\'">\n      <el-date-picker\n        v-model="yeartsstart"\n        :picker-options="startdatepicker"\n        :value-format="valueformat"\n        type="year"\n        @change="changeyeartime"\n        :placeholder="$i18ns(startplaceholder)"\n      >\n      </el-date-picker>\n      ~\n      <el-date-picker\n        v-model="yeartsend"\n        :value-format="valueformat"\n        @change="changeyeartime"\n        :picker-options="enddatepicker"\n        type="year"\n        :placeholder="$i18ns(endplaceholder)"\n      >\n      </el-date-picker>\n    </span>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    // daterange -日期范围； monthrange -月份范围； yearrange -年份范围\n    datatype: {\n      type: string,\n      default: "daterange",\n    },\n    // 时间的格式\n    valueformat: {\n      type: string,\n      default: "yyyy-mm-dd",\n    },\n    // 开始提示语\n    startplaceholder: {\n      type: string,\n      default: "startdate",\n    },\n    // 结束提示语\n    endplaceholder: {\n      type: string,\n      default: "enddate",\n    },\n  },\n  data() {\n    return {\n      dateormonthtime: [],\n      // 年份的时间\n      yeartsstart: "",\n      yeartsend: "",\n      // 提出开始时间必须小于提出结束时间\n      startdatepicker: {\n        //开始时间限制\n        disableddate: (time) => {\n          let beginval = this.yeartsend;\n          if (beginval) {\n            return time.gettime() >= new date(beginval).gettime();\n          }\n        },\n      },\n      // 提出结束时间必须大于提出开始时间\n      enddatepicker: {\n        disableddate: (time) => {\n          let beginval = this.yeartsstart;\n          if (beginval) {\n            return time.gettime() < new date(beginval).gettime() - 86399999;\n          }\n        },\n      },\n    };\n  },\n  methods: {\n    changetime(val) {\n      // console.log(val, "====val");\n      if (val && val instanceof array && this.datatype == "monthrange") {\n        // 月份的时候\n        const date = new date(val[1]);\n        date.setdate(28);\n        date.setmonth(date.getmonth() + 1);\n        let currentdate = this.gettimedate(date.setdate(0), "month", "endtime");\n        // console.log(currentdate, "===currentdate");\n        // // 日期设置为0号, 0表示1号的前一天\n        this.dateormonthtime[1] = currentdate;\n      }\n      this.$emit("changetime", this.dateormonthtime);\n    },\n    // 更改年份\n    changeyeartime() {\n      let starttime = this.gettimedate(this.yeartsstart, "year", "starttime");\n      let endtime = this.gettimedate(this.yeartsend, "year", "endtime");\n      this.$emit("changetime", [starttime, endtime]);\n    },\n    // 获取当月/当年的数据\n    gettimedate(taggledate, type, time) {\n      console.log(taggledate, "=====taggledate");\n      if (taggledate) {\n        let data = new date(taggledate);\n        let year, month, date;\n        if (time == "starttime") {\n          // 开始的时候\n          if (type == "month") {\n            year = data.getfullyear();\n            month = data.getmonth() + 1;\n            date = 1;\n          } else if (type == "year") {\n            year = data.getfullyear();\n            month = 1;\n            date = 1;\n          } else {\n            year = data.getfullyear();\n            month = data.getmonth() + 1;\n            date = data.getdate();\n          }\n        } else if (time == "endtime") {\n          // 结束的时候\n          if (type == "month") {\n            year = data.getfullyear();\n            month = data.getmonth() + 1;\n            date = new date(year, month, 0).getdate(); //获取当月最后一日\n          } else if (type == "year") {\n            year = data.getfullyear();\n            month = 12;\n            date = new date(year, month, 0).getdate(); //获取当月最后一日\n          } else {\n            year = data.getfullyear();\n            month = data.getmonth() + 1;\n            date = data.getdate();\n          }\n        }\n        month = number(month) < 10 ? "0" + month : month; //月份补 0\n        date = number(date) < 10 ? "0" + date : date; //日期补 0\n        return [year, month, date].join("-");\n      } else {\n        return "";\n      }\n    },\n  },\n};\n<\/script>\n\n<style>\n</style>\n\n\n\n# element日期组件时间范围选择限制\n\n# 1.只能选择今天及今天之后的日期\n\n<template>\n  <div>\n    <el-date-picker v-model="timedate" type="daterange" range-separator="至" start-placeholder="开始日期"\n      end-placeholder="结束日期" value-format="yyyy-mm-dd" :picker-options="pickeroptions">\n    </el-date-picker>\n  </div>\n</template>\n\n<script>\n  export default {\n    data() {\n      return {\n        timedate: "",\n        pickeroptions: {\n          disableddate(time) {\n            return time.gettime() < date.now() - 8.64e7; //只能选择今天及今天之后的日期\n            //return time.gettime() < date.now() - 8.64e6; //只能选择今天之后的日期，今天的日期也不能选\n          }\n        },\n      }\n    },\n  }\n<\/script>\n\n\n# 2.只能选择今天及今天之前的日期\n\n<template>\n  <div>\n    <el-date-picker v-model="timedate" type="daterange" range-separator="至" start-placeholder="开始日期"\n      end-placeholder="结束日期" value-format="yyyy-mm-dd" :picker-options="pickeroptions">\n    </el-date-picker>\n  </div>\n</template>\n\n<script>\n  export default {\n    data() {\n      return {\n        timedate: "",\n        pickeroptions: {\n          disableddate(time) {\n            return time.gettime() > date.now() - 8.64e6; //只能选择今天及今天之前的日期\n            // return time.gettime() > date.now() - 8.64e7; //只能选择今天之前的日期，连今天的日期也不能选\n          }\n        },\n      }\n    },\n  }\n<\/script>\n\n\n\n# el-tree\n\n\n# element的el-tree组件宽度超出父元素滚动条不生效问题\n\n.el-tree>.el-tree-node{\n    min-width:100%;\n    display: inline-block;\n}\n',charsets:{cjk:!0}}],themeConfig:{nav:[{text:"vuepress",link:"/guide/"},{text:"前端知识",items:[{text:"插件小技巧",link:"/插件小技巧/"},{text:"前端问题",link:"/前端问题/"},{text:"vue问题",link:"/vue/"},{text:"react问题",link:"/react/"},{text:"优化问题",link:"/优化问题/"},{text:"node",link:"/node/"},{text:"webpack",link:"/webpack/"},{text:"正则&git",link:"/regular&git/regular/"}]},{text:"画图小软件",items:[{text:"three.js",link:"/three.js/"},{text:"eChart",link:"/eChart/"}]},{text:"微前端",items:[{text:"qiankun",link:"/qiankun/"}]},{text:"其他",items:[{text:"记录问题",link:"/progress/"},{text:"小案例",link:"/小案例/"}]},{text:"Gitee",link:"https://gitee.com/Lchu3/lchushan"}],sidebarDepth:2,displayAllHeaders:!1,sidebar:{"/guide/":[{title:"vuepress",collapsable:!1,children:[["/guide/introduce.md","介绍"],["/guide/quickStart.md","快速入门"],["/guide/directory.md","目录结构"],["/guide/basicConfiguration.md","基本配置"],["/guide/markdown.md","Markdown 拓展"],["/guide/deploy.md","部署"]]}],"/插件小技巧/":[{title:"插件小技巧",collapsable:!1,children:[["/插件小技巧/element.md","element"],["/插件小技巧/G6.md","G6"],["/插件小技巧/Ant_Design_Vue.md","Ant Design of Vue"],["/插件小技巧/wangeditor.md","wangeditor"],["/插件小技巧/d3.md","d3"],["/插件小技巧/codemirror.md","codemirror"]]}],"/前端问题/":[{title:"前端问题",collapsable:!1,children:[["/前端问题/","前端问题"],["/前端问题/前端基础/jsBase.md","js基础"],["/前端问题/前端基础/htmlBase.md","html基础"],["/前端问题/前端基础/cssBase.md","css基础"],["/前端问题/前端基础/canvas.md","canvas"],["/前端问题/前端请求接口的几种方式总结.md","前端请求接口的几种方式总结"],["/前端问题/ArrObjStr.md","数组/对象/字符串"],["/前端问题/递归.md","递归"],["/前端问题/跳转相关.md","跳转相关"],["/前端问题/模拟数据.md","模拟数据"],["/前端问题/刷新页面.md","刷新页面"],["/前端问题/瀑布流.md","瀑布流"],["/前端问题/悬浮小图标.md","悬浮小图标"]]}],"/vue/":[{title:"vue",collapsable:!1,children:[["/vue/vuex.md","vuex"],["/vue/vue-router.md","vue-router"],["/vue/vue+svg.md","vue引入svg图标"],["/vue/vue.md","vue"],["/vue/","vue问题总结"]]}],"/react/":[{title:"react",collapsable:!1,children:[["/react/react.md","react"],["/react/","react问题总结"]]}],"/优化问题/":[{title:"优化",collapsable:!1,children:[["/优化问题/","优化"],["/优化问题/tips.md","小技巧"],["/优化问题/deploy.md","相关问题"]]}],"/node/":[{title:"node.js",collapsable:!1,children:[["/node/","介绍"],["/node/node.md","node使用"],["/node/express.md","express"],["/node/database.md","数据库"],["/node/nvm.md","nvm"]]}],"/webpack/":[{title:"webpack配置",collapsable:!1,children:[["/webpack/","webpack"]]}],"/regular&git/":[{title:"正则&git",collapsable:!1,children:[["/regular&git/regular/","正则表达式"],["/regular&git/regular/commonUse.md","常用正则表达式"],["/regular&git/regular/case.md","使用正则案例"],["/regular&git/git/","git 命令"]]}],"/progress/":[{title:"记录问题",collapsable:!1,children:[["/progress/","未分类"],["/progress/interview1.md","面试题1"],["/progress/interview2.md","面试题2"],["/progress/interview3.md","32个手撕JS，彻底摆脱初级前端（面试高频）"],["/progress/interview4.md","前端笔试题"]]}],"/小案例/":[{title:"小案例",collapsable:!1,children:[["/小案例/","小案例"],["/小案例/区域随机生成圆/","区域随机生成圆"],["/小案例/随机点餐/","随机点餐"],["/小案例/通用大数据可视化展示平台html模板/","通用大数据可视化展示平台html模板"],["/小案例/css案例.md","css案例"]]}],"/模块联邦/":[{title:"模块联邦",collapsable:!1,children:[["/模块联邦/","模块联邦"]]}],"/three.js/":[{title:"three.js",collapsable:!1,children:[["/three.js/","介绍"],["/three.js/SimpleModel.md","简单模型"],["/three.js/SimpleDynamicEffect.md","简单动效"],["/three.js/SimpleInteraction.md","简单互动"],["/three.js/SimpleFont.md","简单字体"],["/three.js/SpaceModel.md","空间模型"],["/three.js/SpecialEffects.md","特效效果"],["/three.js/three.js.md","three.js"]]}],"/eChart/":[{title:"eChart",collapsable:!1,children:[["/eChart/","介绍"],["/eChart/eChart.md","eChart"]]}],"/qiankun/":[{title:"qiankun",collapsable:!1,children:[["/qiankun/","介绍"],["/qiankun/qiankun1.md","入门、上手、实战（构建大型 web 应用）"]]}]}}};t(234);Wt.component("Badge",()=>Promise.all([t.e(0),t.e(17)]).then(t.bind(null,640))),Wt.component("CodeBlock",()=>Promise.all([t.e(0),t.e(18)]).then(t.bind(null,559))),Wt.component("CodeGroup",()=>Promise.all([t.e(0),t.e(19)]).then(t.bind(null,560)));t(235);var zs=[({Vue:n,options:e,router:t,siteData:r,isServer:a})=>{},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{}],_s=[];class Is extends class{constructor(){this.store=new Wt({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Wt.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(Is.prototype,{getPageAsyncComponent:is,getLayoutAsyncComponent:ss,getAsyncComponent:ls,getVueComponent:cs});var Ps={install(n){const e=new Is;n.$vuepress=e,n.prototype.$vuepress=e}};function Hs(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var Ds={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return ds("pageKey",e),Wt.component(e)||Wt.component(e,is(e)),Wt.component(e)?n(e):n("")}},Bs={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},$s={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Ls=(t(236),t(237),Object(Cs.a)($s,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),Fs={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Wt.config.productionTip=!1,Wt.use(Gi),Wt.use(Ps),Wt.mixin(function(n,e,t=Wt){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const r=new(n(t.$vuepress.$get("siteData"))),a=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(r)),o={};return Object.keys(a).reduce((n,e)=>(e.startsWith("$")&&(n[e]=a[e].get),n),o),{computed:o}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const r in n)"/"===r?t=n[r]:0===this.$page.path.indexOf(r)&&(e=n[r]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?r?r+" | "+t:t:r||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(r.path.toLowerCase()===e.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},As)),Wt.component("Content",Ds),Wt.component("ContentSlotsDistributor",Bs),Wt.component("OutboundLink",Ls),Wt.component("ClientOnly",Fs),Wt.component("Layout",ss("Layout")),Wt.component("NotFound",ss("NotFound")),Wt.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.9",hash:"ca39063"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:As.routerBase||As.base,t=new Gi({base:e,mode:"history",fallback:!1,routes:Ms,scrollBehavior:(n,e,t)=>t||(n.hash?!Wt.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,r)=>{if(Hs(n,e.path))r();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";Hs(n,t)?r(t):r()}else r();else{const t=e.path+"/",a=e.path+".html";Hs(n,a)?r(a):Hs(n,t)?r(t):r()}})}(t);const r={};try{await Promise.all(zs.filter(n=>"function"==typeof n).map(e=>e({Vue:Wt,options:r,router:t,siteData:As,isServer:n})))}catch(n){console.error(n)}return{app:new Wt(Object.assign(r,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},_s.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);